(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,s,i=e[0],l=e[1],c=e[2],h=0,m=[];h<i.length;h++)s=i[h],Object.prototype.hasOwnProperty.call(a,s)&&a[s]&&m.push(a[s][0]),a[s]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(d&&d(e);m.length;)m.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,i=1;i<t.length;i++){var l=t[i];0!==a[l]&&(r=!1)}r&&(o.splice(e--,1),n=s(s.s=t[0]))}return n}var r={},a={1:0},o=[];function s(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,i=document.createElement("script");i.charset="utf-8",i.timeout=120,s.nc&&i.setAttribute("nonce",s.nc),i.src=function(n){return s.p+"assets/js/"+({}[n]||n)+"."+{2:"1326d5c5",3:"a08ead12",4:"a809b5fd",5:"286eb3ef",6:"faa26ecb",7:"a5935444",8:"00353dc6",9:"781d1be5",10:"2392af32",11:"53e72c14",12:"a02fc4f3",13:"4de47a72",14:"f86ac00d",15:"c63a5ffb",16:"4531808d",17:"99f64d3d",18:"b2093194",19:"4d58eb23",20:"437919f2",21:"31db3915",22:"bb3d37f2",23:"3355e829",24:"2f8633b1",25:"121358b4",26:"dc092b64",27:"f4bc91ef",28:"6fb31055",29:"6832d321",30:"07b35d96",31:"994f40ae",32:"9ff5f511",33:"3e844136",34:"bd7a755a",35:"f3bf4c42",36:"8aa344d6",37:"7211d7b7",38:"35d12ac6",39:"20845c14",40:"c1debdb8",41:"45f7183e",42:"68c50dc3",43:"91dcf874",44:"9910d305",45:"3283dd8e",46:"d4d05e05",47:"dc207994",48:"9ca55df9",49:"e39817cc",50:"ace431a8",51:"0a3a440f",52:"e34dd628",53:"42297942",54:"d6fdc312",55:"0109d0f8",56:"adeef516",57:"45af8c25",58:"3b8d0df8",59:"7a537950",60:"17d0416d",61:"1d03f9c2",62:"eb893ee3",63:"6ff3cebc",64:"e75fca19",65:"b794b424",66:"52d22c61",67:"f014acc6",68:"dd470c7e",69:"3779aed4",70:"3cc3e76d",71:"52f9b192",72:"febfa0e4",73:"2671a109",74:"7e66ee6d",75:"0c6db353",76:"2bc0c070",77:"c59bcd6f",78:"d681b6e4",79:"3d708452",80:"c4543982",81:"1c77b483",82:"2ce6945a",83:"029b0ef5",84:"a06bfb49",85:"293ed33d",86:"b02fc823",87:"4d82f310",88:"8825f0a2",89:"8595a2e9",90:"5e4e54a8",91:"cce3a406",92:"54911d96",93:"6c5d37be",94:"7cd08dcc",95:"e61688d0",96:"e7745f34",97:"379da6d5",98:"9fa85dd7",99:"ea09738f",100:"c168041f",101:"f77ebb59",102:"69a5cd61",103:"39c5e5c5",104:"0c253c70",105:"67d4c2f3",106:"eb52002a",107:"76ca9ab7",108:"63a4ea2e",109:"62f86bf6",110:"9df79747",111:"a7b85493",112:"b0dce9fd",113:"94038541",114:"f3b74d6f",115:"e3244362",116:"b13eee2d",117:"137caa9f",118:"544ff712",119:"ab46c0f7",120:"016d0949",121:"42945c65",122:"fb3e2227",123:"59edc8b1",124:"9fd9b09a",125:"b4a84148",126:"0c5c96f6",127:"b2e7a72b",128:"f49a3f18",129:"9d3839d9",130:"4f7baa41",131:"1cd033b8",132:"518443c6",133:"a8a6a8c1",134:"e6f5b93e",135:"af4f4fe8",136:"c0c03bcc",137:"1dcce972",138:"79c4c181",139:"a4ffc262",140:"95f0369d",141:"e0cbe054",142:"f847b0f5",143:"b3149d3c",144:"bd5e10bc",145:"df5aa20a",146:"b6e8455e",147:"0eb4fe13",148:"13e7abdf",149:"aaddc5c7",150:"02215db5",151:"e4ae19a7",152:"dc59cb1b",153:"dfe45f4a",154:"fdc2ffb9",155:"e48c76af",156:"0ca06e58",157:"79af1797",158:"c69403ad",159:"a058e84e",160:"0c66884f",161:"20220390",162:"abcd0651",163:"fc044695",164:"274deb95",165:"95226fd8",166:"ad3645c7",167:"7228c2d4",168:"4fcef869",169:"db61befd",170:"9fd9a0ce",171:"08bb6335",172:"66864725",173:"86da2e94",174:"f2f33fc8",175:"6016233a",176:"96ea176f",177:"5164255f",178:"e1096c58",179:"212ed982",180:"38a25675",181:"deb09247",182:"a8b235a9",183:"db458df3",184:"e35ae4e8",185:"96b07065",186:"829ac4d0",187:"3d8e34e9",188:"a82a5dd7",189:"bb542d8e",190:"2bff3b61",191:"b19d663a",192:"b1e49ad2",193:"ef77b996",194:"fc3a36ff",195:"896be253",196:"9b5d7cbf",197:"17bee67f",198:"a889f469",199:"0d4a40d9",200:"542d5364",201:"6dd9df0c",202:"d9fdbe9b",203:"5aab2d29",204:"43cd4d67",205:"9182176c",206:"070a200c",207:"b0e141bb",208:"8d8f8f41",209:"021e89f3",210:"1b2672c1",211:"3a1f56dd",212:"7b976037",213:"a576a588",214:"6d12cf59",215:"95584a42",216:"3e9f6e11",217:"22187254",218:"5f14f2b2",219:"d72ebfae",220:"0c69ced5",221:"721a0f0f",222:"3a56b326",223:"8d2ac8b5",224:"cd28d8dd",225:"670515e4",226:"78d4b60e",227:"014100a5",228:"79fd0c4f",229:"4599a2e3",230:"26a9ad11",231:"2dca13bb",232:"8c9fb908",233:"3d2e754c",234:"882ad867",235:"74925e82",236:"c2b08116",237:"f474898b",238:"14ce215a",239:"07613097",240:"3d3e21e2",241:"77d31ce8",242:"2919cfd9",243:"1c40613f",244:"07ed923c",245:"a2f8cf1e",246:"07901351",247:"d241ae58",248:"bdcbc370",249:"3ccbef5b",250:"8cf507e3",251:"385a73ec",252:"b05014aa",253:"a0dd73c3",254:"e9e96303",255:"7e5b008d",256:"6d906d53",257:"5d69a988",258:"5b78c7cd",259:"60dacc8b",260:"a9ffa8be",261:"bb28a47d",262:"06c6850e",263:"2373e12f",264:"821d2ae4",265:"bd716645",266:"f97241d2",267:"8ea52fbd",268:"73e20954",269:"b6b2063e",270:"78c91339",271:"37d7a9b1",272:"d4c9ca89",273:"a653c8fc",274:"9ab5f05e",275:"dfcf4136",276:"afaba8ab",277:"cefaed06",278:"1db36194",279:"a2c2d6e3",280:"c4d82e9b",281:"9d278ec3",282:"7e908036",283:"7bf80035",284:"9421c453",285:"9c5d7352",286:"6557aae5",287:"01475f53",288:"bcb4a6b5",289:"9b4b3dfb",290:"ee90a843",291:"14ac2aa7",292:"5a375367",293:"55668c4d",294:"acf8afba",295:"5db4cf6d",296:"9af29a0e"}[n]+".js"}(n);var l=new Error;o=function(e){i.onerror=i.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:i})}),12e4);i.onerror=i.onload=o,document.head.appendChild(i)}return Promise.all(e)},s.m=n,s.c=r,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)s.d(t,r,function(e){return n[e]}.bind(null,r));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/",s.oe=function(n){throw console.error(n),n};var i=window.webpackJsonp=window.webpackJsonp||[],l=i.push.bind(i);i.push=e,i=i.slice();for(var c=0;c<i.length;c++)e(i[c]);var d=l;o.push([103,0]),t()}([function(n,e,t){var r=t(55),a=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===a}:function(n){return"function"==typeof n}},function(n,e,t){var r=t(27),a=Function.prototype,o=a.call,s=r&&a.bind.bind(o,o);n.exports=r?s:function(n){return function(){return o.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||this||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(69),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e,t){"use strict";function r(n,e,t,r,a,o,s,i){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=l):a&&(l=i?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var h=c.beforeCreate;c.beforeCreate=h?[].concat(h,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(1),a=t(32),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(a(n),e)}},function(n,e,t){var r=t(0),a=t(55),o=a.all;n.exports=a.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===o}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(163),a=t(166);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return s})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return h})),t.d(e,"f",(function(){return m})),t.d(e,"l",(function(){return p})),t.d(e,"m",(function(){return u})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return y}));t(16);const r=/#.*$/,a=/\.(md|html)$/,o=/\/$/,s=/^[a-z]+:/i;function i(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return s.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function h(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",a=i(n);return o.test(a)?n:a+".html"+t}function m(n,e){const t=n.hash,a=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(a&&t!==a)return!1;return i(n.path)===i(e)}function p(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const a=e.split("/");t&&a[a.length-1]||a.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?a.pop():"."!==e&&a.push(e)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));const r=i(e);for(let e=0;e<n.length;e++)if(i(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:h(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function u(n,e,t,r){const{pages:a,themeConfig:o}=t,s=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||s.sidebar||o.sidebar))return g(n);const i=s.sidebar||o.sidebar;if(i){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,i);return"auto"===r?g(n):r?r.map(n=>function n(e,t,r,a=1){if("string"==typeof e)return p(t,e,r);if(Array.isArray(e))return Object.assign(p(t,e[0],r),{title:e[1]});{a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(p(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map(e=>n(e,t,r,a+1)),collapsable:!1!==e.collapsable}}}(n,a,t)):[]}return[]}function g(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function E(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return E(e)-E(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(15),a=t(148),o=t(149),s=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(4),a=t(17),o=t(35);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(6).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(26),a=t(32),o=t(33),s=t(127),i=t(129);r({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=a(this),t=o(e),r=arguments.length;i(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return s(e,t),t}})},function(n,e,t){var r=t(4),a=t(64),o=t(98),s=t(25),i=t(54),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=r?o?function(n,e,t){if(s(n),e=i(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=d(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(s(n),e=i(e),s(t),a)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(1),a=r({}.toString),o=r("".slice);n.exports=function(n){return o(a(n),8,-1)}},function(n,e,t){var r=t(153),a=t(154),o=t(155),s=t(156),i=t(157);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var r=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(175);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(45);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),d=r.speed,h=r.easing;return l.offsetWidth,s((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),i(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,d,h)),1===n?(i(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){i(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,s=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),d=document.querySelector(r.parent);return i(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&m(a),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&m(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),i=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:h(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=h(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function d(n,e){var t,r=h(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function h(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function m(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){var r=t(9),a=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not an object")}},function(n,e,t){var r=t(2),a=t(51).f,o=t(14),s=t(111),i=t(37),l=t(65),c=t(123);n.exports=function(n,e){var t,d,h,m,p,u=n.target,g=n.global,f=n.stat;if(t=g?r:f?r[u]||i(u,{}):(r[u]||{}).prototype)for(d in e){if(m=e[d],h=n.dontCallGetSet?(p=a(t,d))&&p.value:t[d],!c(g?d:u+(f?".":"#")+d,n.forced)&&void 0!==h){if(typeof m==typeof h)continue;l(m,h)}(n.sham||h&&h.sham)&&o(m,"sham",!0),s(t,d,m,n)}}},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(47),a=t(52);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(2),a=t(0),o=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(0),a=t(109),o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not a function")}},function(n,e,t){var r=t(2),a=t(61),o=t(8),s=t(63),i=t(59),l=t(58),c=r.Symbol,d=a("wks"),h=l?c.for||c:c&&c.withoutSetter||s;n.exports=function(n){return o(d,n)||(d[n]=i&&o(c,n)?c[n]:h("Symbol."+n)),d[n]}},function(n,e,t){var r=t(52),a=Object;n.exports=function(n){return a(r(n))}},function(n,e,t){var r=t(121);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(27),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(2),a=t(37),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(2),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(147),a=t(12),o=Object.prototype,s=o.hasOwnProperty,i=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&s.call(n,"callee")&&!i.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(6),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(167),a=t(174),o=t(176),s=t(177),i=t(178);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(5),a=t(45),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(s.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(13),a=t(12);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(1),a=t(3),o=t(18),s=Object,i=r("".split);n.exports=a((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?i(n,""):s(n)}:s},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,s=parseInt,i="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=i||l||Function("return this")(),d=Object.prototype.toString,h=Math.max,m=Math.min,p=function(){return c.Date.now()};function u(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(u(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=u(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var i=a.test(n);return i||o.test(n)?s(n.slice(2),i?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,s,i,l,c=0,d=!1,f=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,o=a;return r=a=void 0,c=e,s=n.apply(o,t)}function E(n){return c=n,i=setTimeout(x,e),d?b(n):s}function y(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-c>=o}function x(){var n=p();if(y(n))return w(n);i=setTimeout(x,function(n){var t=e-(n-l);return f?m(t,o-(n-c)):t}(n))}function w(n){return i=void 0,v&&r?b(n):(r=a=void 0,s)}function j(){var n=p(),t=y(n);if(r=arguments,a=this,l=n,t){if(void 0===i)return E(l);if(f)return i=setTimeout(x,e),b(l)}return void 0===i&&(i=setTimeout(x,e)),s}return e=g(e)||0,u(t)&&(d=!!t.leading,o=(f="maxWait"in t)?h(g(t.maxWait)||0,e):o,v="trailing"in t?!!t.trailing:v),j.cancel=function(){void 0!==i&&clearTimeout(i),c=0,r=l=a=i=void 0},j.flush=function(){return void 0===i?s:w(p())},j}},function(n,e,t){var r=t(4),a=t(34),o=t(105),s=t(35),i=t(28),l=t(54),c=t(8),d=t(64),h=Object.getOwnPropertyDescriptor;e.f=r?h:function(n,e){if(n=i(n),e=l(e),d)try{return h(n,e)}catch(n){}if(c(n,e))return s(!a(o.f,n,e),n[e])}},function(n,e,t){var r=t(53),a=TypeError;n.exports=function(n){if(r(n))throw a("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(106),a=t(56);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(29),a=t(0),o=t(57),s=t(58),i=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&o(e.prototype,i(n))}},function(n,e,t){var r=t(1);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(59);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(60),a=t(3),o=t(2).String;n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!o(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,o=t(2),s=t(107),i=o.process,l=o.Deno,c=i&&i.versions||l&&l.version,d=c&&c.v8;d&&(a=(r=d.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&s&&(!(r=s.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=s.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(62),a=t(36);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.30.2",mode:r?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(1),a=0,o=Math.random(),s=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++a+o,36)}},function(n,e,t){var r=t(4),a=t(3),o=t(97);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(8),a=t(116),o=t(51),s=t(17);n.exports=function(n,e,t){for(var i=a(e),l=s.f,c=o.f,d=0;d<i.length;d++){var h=i[d];r(n,h)||t&&r(t,h)||l(n,h,c(e,h))}}},function(n,e,t){var r=t(120);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(133),a=t(25),o=t(134);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),o(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(19),a=t(158),o=t(159),s=t(160),i=t(161),l=t(162);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=s,c.prototype.has=i,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(13),a=t(40);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(179),a=t(12);n.exports=function n(e,t,o,s,i){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,s,n,i))}},function(n,e,t){var r=t(76),a=t(182),o=t(77);n.exports=function(n,e,t,s,i,l){var c=1&t,d=n.length,h=e.length;if(d!=h&&!(c&&h>d))return!1;var m=l.get(n),p=l.get(e);if(m&&p)return m==e&&p==n;var u=-1,g=!0,f=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++u<d;){var v=n[u],b=e[u];if(s)var E=c?s(b,v,u,e,n,l):s(v,b,u,n,e,l);if(void 0!==E){if(E)continue;g=!1;break}if(f){if(!a(e,(function(n,e){if(!o(f,e)&&(v===n||i(v,n,t,s,l)))return f.push(e)}))){g=!1;break}}else if(v!==b&&!i(v,b,t,s,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var r=t(41),a=t(180),o=t(181);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=a,s.prototype.has=o,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(192),a=t(198),o=t(82);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(6),a=t(194),o=e&&!e.nodeType&&e,s=o&&"object"==typeof n&&n&&!n.nodeType&&n,i=s&&s.exports===o?r.Buffer:void 0,l=(i?i.isBuffer:void 0)||a;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(195),a=t(196),o=t(197),s=o&&o.isTypedArray,i=s?a(s):r;n.exports=i},function(n,e,t){var r=t(72),a=t(43);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(6),"Set");n.exports=r},function(n,e,t){var r=t(40);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(87),a=t(23);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(5),a=t(44),o=t(209),s=t(212);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(s(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(145),a=t(150),o=t(221),s=t(229),i=t(238),l=t(102),c=o((function(n){var e=l(n);return i(e)&&(e=void 0),s(r(n,1,i,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var o="",s=0,i=0;for(s=a.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}i!==s&&(o+=t.substring(i,s)),i=s+1,o+=e}return i!==s?o+t.substring(i,s):o}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(241),t(7)),o=Object(a.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},a=(t(242),t(7)),o=Object(a.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(2),a=t(9),o=r.document,s=a(o)&&a(o.createElement);n.exports=function(n){return s?o.createElement(n):{}}},function(n,e,t){var r=t(4),a=t(3);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(1),a=t(3),o=t(0),s=t(8),i=t(4),l=t(112).CONFIGURABLE,c=t(113),d=t(114),h=d.enforce,m=d.get,p=String,u=Object.defineProperty,g=r("".slice),f=r("".replace),v=r([].join),b=i&&!a((function(){return 8!==u((function(){}),"length",{value:8}).length})),E=String(String).split("String"),y=n.exports=function(n,e,t){"Symbol("===g(p(e),0,7)&&(e="["+f(p(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!s(n,"name")||l&&n.name!==e)&&(i?u(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&s(t,"arity")&&n.length!==t.arity&&u(n,"length",{value:t.arity});try{t&&s(t,"constructor")&&t.constructor?i&&u(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=h(n);return s(r,"source")||(r.source=v(E,"string"==typeof e?e:"")),n};Function.prototype.toString=y((function(){return o(this)&&m(this).source||c(this)}),"toString")},function(n,e,t){var r=t(61),a=t(63),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){var r=t(1),a=t(8),o=t(28),s=t(118).indexOf,i=t(48),l=r([].push);n.exports=function(n,e){var t,r=o(n),c=0,d=[];for(t in r)!a(i,t)&&a(r,t)&&l(d,t);for(;e.length>c;)a(r,t=e[c++])&&(~s(d,t)||l(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(247)},function(n,e,t){"use strict";var r=t(26),a=t(124).left,o=t(125),s=t(60);r({target:"Array",proto:!0,forced:!t(126)&&s>79&&s<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(34),a=t(9),o=t(56),s=t(108),i=t(110),l=t(31),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,l=s(n,d);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!a(t)||o(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),i(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var r=t(30),a=t(53);n.exports=function(n,e){var t=n[e];return a(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(34),a=t(0),o=t(9),s=TypeError;n.exports=function(n,e){var t,i;if("string"===e&&a(t=n.toString)&&!o(i=r(t,n)))return i;if(a(t=n.valueOf)&&!o(i=r(t,n)))return i;if("string"!==e&&a(t=n.toString)&&!o(i=r(t,n)))return i;throw s("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),a=t(17),o=t(99),s=t(37);n.exports=function(n,e,t,i){i||(i={});var l=i.enumerable,c=void 0!==i.name?i.name:e;if(r(t)&&o(t,c,i),i.global)l?n[e]=t:s(e,t);else{try{i.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!i.nonConfigurable,writable:!i.nonWritable})}return n}},function(n,e,t){var r=t(4),a=t(8),o=Function.prototype,s=r&&Object.getOwnPropertyDescriptor,i=a(o,"name"),l=i&&"something"===function(){}.name,c=i&&(!r||r&&s(o,"name").configurable);n.exports={EXISTS:i,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(1),a=t(0),o=t(36),s=r(Function.toString);a(o.inspectSource)||(o.inspectSource=function(n){return s(n)}),n.exports=o.inspectSource},function(n,e,t){var r,a,o,s=t(115),i=t(2),l=t(9),c=t(14),d=t(8),h=t(36),m=t(100),p=t(48),u=i.TypeError,g=i.WeakMap;if(s||h.state){var f=h.state||(h.state=new g);f.get=f.get,f.has=f.has,f.set=f.set,r=function(n,e){if(f.has(n))throw u("Object already initialized");return e.facade=n,f.set(n,e),e},a=function(n){return f.get(n)||{}},o=function(n){return f.has(n)}}else{var v=m("state");p[v]=!0,r=function(n,e){if(d(n,v))throw u("Object already initialized");return e.facade=n,c(n,v,e),e},a=function(n){return d(n,v)?n[v]:{}},o=function(n){return d(n,v)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw u("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(2),a=t(0),o=r.WeakMap;n.exports=a(o)&&/native code/.test(String(o))},function(n,e,t){var r=t(29),a=t(1),o=t(117),s=t(122),i=t(25),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=o.f(i(n)),t=s.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(101),a=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(28),a=t(119),o=t(33),s=function(n){return function(e,t,s){var i,l=r(e),c=o(l),d=a(s,c);if(n&&t!=t){for(;c>d;)if((i=l[d++])!=i)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){var r=t(66),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(66),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(3),a=t(0),o=/#|\.prototype\./,s=function(n,e){var t=l[i(n)];return t==d||t!=c&&(a(e)?r(e):!!e)},i=s.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=s.data={},c=s.NATIVE="N",d=s.POLYFILL="P";n.exports=s},function(n,e,t){var r=t(30),a=t(32),o=t(47),s=t(33),i=TypeError,l=function(n){return function(e,t,l,c){r(t);var d=a(e),h=o(d),m=s(d),p=n?m-1:0,u=n?-1:1;if(l<2)for(;;){if(p in h){c=h[p],p+=u;break}if(p+=u,n?p<0:m<=p)throw i("Reduce of empty array with no initial value")}for(;n?p>=0:m>p;p+=u)p in h&&(c=t(c,h[p],p,d));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(18);n.exports="undefined"!=typeof process&&"process"==r(process)},function(n,e,t){"use strict";var r=t(4),a=t(128),o=TypeError,s=Object.getOwnPropertyDescriptor,i=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=i?function(n,e){if(a(n)&&!s(n,"length").writable)throw o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(18);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(26),a=t(2),o=t(131),s=t(132),i=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=s(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(i&&i[n]){var t={};t[n]=s("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){var r=t(27),a=Function.prototype,o=a.apply,s=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?s.bind(o):function(){return s.apply(o,arguments)})},function(n,e,t){"use strict";var r=t(29),a=t(8),o=t(14),s=t(57),i=t(67),l=t(65),c=t(135),d=t(136),h=t(137),m=t(141),p=t(142),u=t(4),g=t(62);n.exports=function(n,e,t,f){var v=f?2:1,b=n.split("."),E=b[b.length-1],y=r.apply(null,b);if(y){var x=y.prototype;if(!g&&a(x,"cause")&&delete x.cause,!t)return y;var w=r("Error"),j=e((function(n,e){var t=h(f?e:n,void 0),r=f?new y(n):new y;return void 0!==t&&o(r,"message",t),p(r,j,r.stack,2),this&&s(x,this)&&d(r,this,j),arguments.length>v&&m(r,arguments[v]),r}));if(j.prototype=x,"Error"!==E?i?i(j,w):l(j,w,{name:!0}):u&&"stackTraceLimit"in y&&(c(j,y,"stackTraceLimit"),c(j,y,"prepareStackTrace")),l(j,y),!g)try{x.name!==E&&o(x,"name",E),x.constructor=j}catch(n){}return j}}},function(n,e,t){var r=t(1),a=t(30);n.exports=function(n,e,t){try{return r(a(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var r=t(0),a=String,o=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var r=t(17).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(0),a=t(9),o=t(67);n.exports=function(n,e,t){var s,i;return o&&r(s=e.constructor)&&s!==t&&a(i=s.prototype)&&i!==t.prototype&&o(n,i),n}},function(n,e,t){var r=t(138);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(139),a=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(140),a=t(0),o=t(18),s=t(31)("toStringTag"),i=Object,l="Arguments"==o(function(){return arguments}());n.exports=r?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=i(n),s))?t:l?o(e):"Object"==(r=o(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(31)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),a=t(14);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(14),a=t(143),o=t(144),s=Error.captureStackTrace;n.exports=function(n,e,t,i){o&&(s?s(n,e):r(n,"stack",a(t,i)))}},function(n,e,t){var r=t(1),a=Error,o=r("".replace),s=String(a("zxcasd").stack),i=/\n\s*at [^:]*:[^\n]*/,l=i.test(s);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=o(n,i,"");return n}},function(n,e,t){var r=t(3),a=t(35);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(68),a=t(146);n.exports=function n(e,t,o,s,i){var l=-1,c=e.length;for(o||(o=a),i||(i=[]);++l<c;){var d=e[l];t>0&&o(d)?t>1?n(d,t-1,o,s,i):r(i,d):s||(i[i.length]=d)}return i}},function(n,e,t){var r=t(15),a=t(38),o=t(5),s=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(s&&n&&n[s])}},function(n,e,t){var r=t(13),a=t(12);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(15),a=Object.prototype,o=a.hasOwnProperty,s=a.toString,i=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,i),t=n[i];try{n[i]=void 0;var r=!0}catch(n){}var a=s.call(n);return r&&(e?n[i]=t:delete n[i]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(151),a=t(207),o=t(46),s=t(5),i=t(218);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?s(n)?a(n[0],n[1]):r(n):i(n)}},function(n,e,t){var r=t(152),a=t(206),o=t(85);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(70),a=t(74);n.exports=function(n,e,t,o){var s=t.length,i=s,l=!o;if(null==n)return!i;for(n=Object(n);s--;){var c=t[s];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++s<i;){var d=(c=t[s])[0],h=n[d],m=c[1];if(l&&c[2]){if(void 0===h&&!(d in n))return!1}else{var p=new r;if(o)var u=o(h,m,d,n,e,p);if(!(void 0===u?a(m,h,3,o,p):u))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(20),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(20);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(20);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(19);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(19),a=t(39),o=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var s=t.__data__;if(!a||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(72),a=t(164),o=t(40),s=t(73),i=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,h=c.hasOwnProperty,m=RegExp("^"+d.call(h).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?m:i).test(s(n))}},function(n,e,t){var r,a=t(165),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(6)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(168),a=t(19),o=t(39);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(169),a=t(170),o=t(171),s=t(172),i=t(173);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var r=t(21);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(22);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(70),a=t(75),o=t(183),s=t(186),i=t(202),l=t(5),c=t(79),d=t(81),h="[object Object]",m=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,p,u,g){var f=l(n),v=l(e),b=f?"[object Array]":i(n),E=v?"[object Array]":i(e),y=(b="[object Arguments]"==b?h:b)==h,x=(E="[object Arguments]"==E?h:E)==h,w=b==E;if(w&&c(n)){if(!c(e))return!1;f=!0,y=!1}if(w&&!y)return g||(g=new r),f||d(n)?a(n,e,t,p,u,g):o(n,e,b,t,p,u,g);if(!(1&t)){var j=y&&m.call(n,"__wrapped__"),T=x&&m.call(e,"__wrapped__");if(j||T){var B=j?n.value():n,A=T?e.value():e;return g||(g=new r),u(B,A,t,p,g)}}return!!w&&(g||(g=new r),s(n,e,t,p,u,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(15),a=t(184),o=t(71),s=t(75),i=t(185),l=t(42),c=r?r.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,h,m){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!h(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var p=i;case"[object Set]":var u=1&r;if(p||(p=l),n.size!=e.size&&!u)return!1;var g=m.get(n);if(g)return g==e;r|=2,m.set(n,e);var f=s(p(n),p(e),r,c,h,m);return m.delete(n),f;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var r=t(6).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(187),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,s,i){var l=1&t,c=r(n),d=c.length;if(d!=r(e).length&&!l)return!1;for(var h=d;h--;){var m=c[h];if(!(l?m in e:a.call(e,m)))return!1}var p=i.get(n),u=i.get(e);if(p&&u)return p==e&&u==n;var g=!0;i.set(n,e),i.set(e,n);for(var f=l;++h<d;){var v=n[m=c[h]],b=e[m];if(o)var E=l?o(b,v,m,e,n,i):o(v,b,m,n,e,i);if(!(void 0===E?v===b||s(v,b,t,o,i):E)){g=!1;break}f||(f="constructor"==m)}if(g&&!f){var y=n.constructor,x=e.constructor;y==x||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof x&&x instanceof x||(g=!1)}return i.delete(n),i.delete(e),g}},function(n,e,t){var r=t(188),a=t(189),o=t(78);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(68),a=t(5);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(190),a=t(191),o=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,i=s?function(n){return null==n?[]:(n=Object(n),r(s(n),(function(e){return o.call(n,e)})))}:a;n.exports=i},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var s=n[t];e(s,t,n)&&(o[a++]=s)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(193),a=t(38),o=t(5),s=t(79),i=t(80),l=t(81),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),d=!t&&a(n),h=!t&&!d&&s(n),m=!t&&!d&&!h&&l(n),p=t||d||h||m,u=p?r(n.length,String):[],g=u.length;for(var f in n)!e&&!c.call(n,f)||p&&("length"==f||h&&("offset"==f||"parent"==f)||m&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||i(f,g))||u.push(f);return u}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(13),a=t(43),o=t(12),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!s[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(69),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a&&r.process,i=function(){try{var n=o&&o.require&&o.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=i}).call(this,t(49)(n))},function(n,e,t){var r=t(199),a=t(200),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(201)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(203),a=t(39),o=t(204),s=t(83),i=t(205),l=t(13),c=t(73),d=c(r),h=c(a),m=c(o),p=c(s),u=c(i),g=l;(r&&"[object DataView]"!=g(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=g(new a)||o&&"[object Promise]"!=g(o.resolve())||s&&"[object Set]"!=g(new s)||i&&"[object WeakMap]"!=g(new i))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case d:return"[object DataView]";case h:return"[object Map]";case m:return"[object Promise]";case p:return"[object Set]";case u:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var r=t(10)(t(6),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(6),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(6),"WeakMap");n.exports=r},function(n,e,t){var r=t(84),a=t(78);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],s=n[o];e[t]=[o,s,r(s)]}return e}},function(n,e,t){var r=t(74),a=t(208),o=t(215),s=t(44),i=t(84),l=t(85),c=t(23);n.exports=function(n,e){return s(n)&&i(e)?l(c(n),e):function(t){var s=a(t,n);return void 0===s&&s===e?o(t,n):r(e,s,3)}}},function(n,e,t){var r=t(86);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(210),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,s=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var r=t(211);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(41);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var s=n.apply(this,r);return t.cache=o.set(a,s)||o,s};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(213);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(15),a=t(214),o=t(5),s=t(45),i=r?r.prototype:void 0,l=i?i.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(216),a=t(217);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(87),a=t(38),o=t(5),s=t(80),i=t(43),l=t(23);n.exports=function(n,e,t){for(var c=-1,d=(e=r(e,n)).length,h=!1;++c<d;){var m=l(e[c]);if(!(h=null!=n&&t(n,m)))break;n=n[m]}return h||++c!=d?h:!!(d=null==n?0:n.length)&&i(d)&&s(m,d)&&(o(n)||a(n))}},function(n,e,t){var r=t(219),a=t(220),o=t(44),s=t(23);n.exports=function(n){return o(n)?r(s(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(86);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(46),a=t(222),o=t(224);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(223),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,s=-1,i=a(o.length-e,0),l=Array(i);++s<i;)l[s]=o[e+s];s=-1;for(var c=Array(e+1);++s<e;)c[s]=o[s];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(225),a=t(228)(r);n.exports=a},function(n,e,t){var r=t(226),a=t(227),o=t(46),s=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(76),a=t(230),o=t(235),s=t(77),i=t(236),l=t(42);n.exports=function(n,e,t){var c=-1,d=a,h=n.length,m=!0,p=[],u=p;if(t)m=!1,d=o;else if(h>=200){var g=e?null:i(n);if(g)return l(g);m=!1,d=s,u=new r}else u=e?[]:p;n:for(;++c<h;){var f=n[c],v=e?e(f):f;if(f=t||0!==f?f:0,m&&v==v){for(var b=u.length;b--;)if(u[b]===v)continue n;e&&u.push(v),p.push(f)}else d(u,v,t)||(u!==p&&u.push(v),p.push(f))}return p}},function(n,e,t){var r=t(231);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(232),a=t(233),o=t(234);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(83),a=t(237),o=t(42),s=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(82),a=t(12);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function o(n){return null==n}function s(n){return null!=n}function i(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var h=Object.prototype.toString;function m(n){return"[object Object]"===h.call(n)}function p(n){return"[object RegExp]"===h.call(n)}function u(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||m(n)&&n.toString===h?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var E=b("key,ref,slot,slot-scope,is");function y(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function j(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var T=/-(\w)/g,B=j((function(n){return n.replace(T,(function(n,e){return e?e.toUpperCase():""}))})),A=j((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),S=/\B([A-Z])/g,z=j((function(n){return n.replace(S,"-$1").toLowerCase()}));var C=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function P(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function k(n,e){for(var t in e)n[t]=e[t];return n}function I(n){for(var e={},t=0;t<n.length;t++)n[t]&&k(e,n[t]);return e}function M(n,e,t){}var R=function(n,e,t){return!1},L=function(n){return n};function H(n,e){if(n===e)return!0;var t=d(n),r=d(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return H(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var s=Object.keys(n),i=Object.keys(e);return s.length===i.length&&s.every((function(t){return H(n[t],e[t])}))}catch(n){return!1}}function _(n,e){for(var t=0;t<n.length;t++)if(H(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function G(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],O=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],W={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:R,isReservedAttr:R,isUnknownElement:R,getTagNamespace:M,parsePlatformTagName:L,mustUseProp:R,async:!0,_lifecycleHooks:O},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function V(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function q(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var N=new RegExp("[^".concat(U.source,".$_\\d]"));var Z="__proto__"in{},$="undefined"!=typeof window,Y=$&&window.navigator.userAgent.toLowerCase(),X=Y&&/msie|trident/.test(Y),J=Y&&Y.indexOf("msie 9.0")>0,K=Y&&Y.indexOf("edge/")>0;Y&&Y.indexOf("android");var Q=Y&&/iphone|ipad|ipod|ios/.test(Y);Y&&/chrome\/\d+/.test(Y),Y&&/phantomjs/.test(Y);var nn,en=Y&&Y.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if($)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!$&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=$&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var hn=null;function mn(n){void 0===n&&(n=null),n||hn&&hn._scope.off(),hn=n,n&&n._scope.on()}var pn=function(){function n(n,e,t,r,a,o,s,i){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=i,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),un=function(n){void 0===n&&(n="");var e=new pn;return e.text=n,e.isComment=!0,e};function gn(n){return new pn(void 0,void 0,void 0,String(n))}function fn(n){var e=new pn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=[],En=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();En.target=null;var yn=[];function xn(n){yn.push(n),En.target=n}function wn(){yn.pop(),En.target=yn[yn.length-1]}var jn=Array.prototype,Tn=Object.create(jn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=jn[n];q(Tn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,o=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&s.observeArray(a),s.dep.notify(),o}))}));var Bn=Object.getOwnPropertyNames(Tn),An={},Sn=!0;function zn(n){Sn=n}var Cn={notify:M,depend:M,addSub:M,removeSub:M},Pn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Cn:new En,this.vmCount=0,q(n,"__ob__",this),a(n)){if(!t)if(Z)n.__proto__=Tn;else for(var r=0,o=Bn.length;r<o;r++){q(n,i=Bn[r],Tn[i])}e||this.observeArray(n)}else{var s=Object.keys(n);for(r=0;r<s.length;r++){var i;In(n,i=s[r],An,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)kn(n[e],!1,this.mock)},n}();function kn(n,e,t){return n&&w(n,"__ob__")&&n.__ob__ instanceof Pn?n.__ob__:!Sn||!t&&on()||!a(n)&&!m(n)||!Object.isExtensible(n)||n.__v_skip||Gn(n)||n instanceof pn?void 0:new Pn(n,e,t)}function In(n,e,t,r,o,s){var i=new En,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,d=l&&l.set;c&&!d||t!==An&&2!==arguments.length||(t=n[e]);var h=!o&&kn(t,!1,s);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return En.target&&(i.depend(),h&&(h.dep.depend(),a(e)&&Ln(e))),Gn(e)&&!o?e.value:e},set:function(e){var r=c?c.call(n):t;if(G(r,e)){if(d)d.call(n,e);else{if(c)return;if(!o&&Gn(r)&&!Gn(e))return void(r.value=e);t=e}h=!o&&kn(e,!1,s),i.notify()}}}),i}}function Mn(n,e,t){if(!Dn(n)){var r=n.__ob__;return a(n)&&u(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&kn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(In(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function Rn(n,e){if(a(n)&&u(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Dn(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function Ln(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&Ln(e)}function Hn(n){return _n(n,!0),q(n,"__v_isShallow",!0),n}function _n(n,e){if(!Dn(n)){kn(n,e,on());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Gn(n){return!(!n||!0!==n.__v_isRef)}function Fn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Gn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Gn(r)&&!Gn(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var On;var Wn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=On,!n&&On&&(this.index=(On.scopes||(On.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=On;try{return On=this,n()}finally{On=e}}else 0},n.prototype.on=function(){On=this},n.prototype.off=function(){On=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Un(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Vn=j((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function qn(n,e){function t(){var n=t.fns;if(!a(n))return Se(n,null,arguments,e,"v-on handler");for(var r=n.slice(),o=0;o<r.length;o++)Se(r[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Nn(n,e,t,r,a,s){var l,c,d,h;for(l in n)c=n[l],d=e[l],h=Vn(l),o(c)||(o(d)?(o(c.fns)&&(c=n[l]=qn(c,s)),i(h.once)&&(c=n[l]=a(h.name,c,h.capture)),t(h.name,c,h.capture,h.passive,h.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)o(n[l])&&r((h=Vn(l)).name,e[l],h.capture)}function Zn(n,e,t){var r;n instanceof pn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),y(r.fns,l)}o(a)?r=qn([l]):s(a.fns)&&i(a.merged)?(r=a).fns.push(l):r=qn([a,l]),r.merged=!0,n[e]=r}function $n(n,e,t,r,a){if(s(e)){if(w(e,t))return n[t]=e[t],a||delete e[t],!0;if(w(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Yn(n){return l(n)?[gn(n)]:a(n)?function n(e,t){var r,c,d,h,m=[];for(r=0;r<e.length;r++)o(c=e[r])||"boolean"==typeof c||(d=m.length-1,h=m[d],a(c)?c.length>0&&(Xn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Xn(h)&&(m[d]=gn(h.text+c[0].text),c.shift()),m.push.apply(m,c)):l(c)?Xn(h)?m[d]=gn(h.text+c):""!==c&&m.push(gn(c)):Xn(c)&&Xn(h)?m[d]=gn(h.text+c.text):(i(e._isVList)&&s(c.tag)&&o(c.key)&&s(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),m.push(c)));return m}(n):void 0}function Xn(n){return s(n)&&s(n.text)&&!1===n.isComment}function Jn(n,e){var t,r,o,i,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),h=c.next();!h.done;)l.push(e(h.value,l.length)),h=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,r=o.length;t<r;t++)i=o[t],l[t]=e(n[i],i,t);return s(l)||(l=[]),l._isVList=!0,l}function Kn(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=k(k({},r),t)),a=o(t)||(c(e)?e():e)):a=this.$slots[n]||(c(e)?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},a):a}function Qn(n){return Pt(this.$options,"filters",n,!0)||L}function ne(n,e){return a(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,r,a){var o=W.keyCodes[e]||t;return a&&r&&!W.keyCodes[e]?ne(a,r):o?ne(o,n):r?z(r)!==e:void 0===n}function te(n,e,t,r,o){if(t)if(d(t)){a(t)&&(t=I(t));var s=void 0,i=function(a){if("class"===a||"style"===a||E(a))s=n;else{var i=n.attrs&&n.attrs.type;s=r||W.mustUseProp(e,i,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=B(a),c=z(a);l in s||c in s||(s[a]=t[a],o&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)i(l)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||oe(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&se(n[r],"".concat(e,"_").concat(r),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function ie(n,e){if(e)if(m(e)){var t=n.on=n.on?k({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function le(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var s=n[o];a(s)?le(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function he(n){n._o=ae,n._n=v,n._s=f,n._l=Jn,n._t=Kn,n._q=H,n._i=_,n._m=re,n._f=Qn,n._k=ee,n._b=te,n._v=gn,n._e=un,n._u=le,n._g=ie,n._d=ce,n._p=de}function me(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],s=o.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,o.context!==e&&o.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(o);else{var i=s.slot,l=t[i]||(t[i]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(pe)&&delete t[c];return t}function pe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ue(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,a){var o,s=Object.keys(t).length>0,i=e?!!e.$stable:!s,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(i&&a&&a!==r&&l===a.$key&&!s&&!a.$hasNormal)return a;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=fe(n,t,c,e[c]))}else o={};for(var d in t)d in o||(o[d]=ve(t,d));return e&&Object.isExtensible(e)&&(e._normalized=o),q(o,"$stable",i),q(o,"$key",l),q(o,"$hasNormal",s),o}function fe(n,e,t,r){var o=function(){var e=hn;mn(n);var t=arguments.length?r.apply(null,arguments):r({}),o=(t=t&&"object"==typeof t&&!a(t)?[t]:Yn(t))&&t[0];return mn(e),t&&(!o||1===t.length&&o.isComment&&!ue(o))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function ve(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};q(e,"_v_attr_proxy",!0),Ee(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||Ee(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||xe(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:C(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Fn(n,e,t)}))}}}function Ee(n,e,t,r,a){var o=!1;for(var s in e)s in n?e[s]!==t[s]&&(o=!0):(o=!0,ye(n,s,r,a));for(var s in n)s in e||(o=!0,delete n[s]);return o}function ye(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function xe(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var we=null;function je(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Te(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||ue(t)))return t}}function Be(n,e,t,r,h,m){return(a(t)||l(t))&&(h=r,r=t,t=void 0),i(m)&&(h=2),function(n,e,t,r,l){if(s(t)&&s(t.__ob__))return un();s(t)&&s(t.is)&&(e=t.is);if(!e)return un();0;a(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Yn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var h,m;if("string"==typeof e){var p=void 0;m=n.$vnode&&n.$vnode.ns||W.getTagNamespace(e),h=W.isReservedTag(e)?new pn(W.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!s(p=Pt(n.$options,"components",e))?new pn(e,t,r,void 0,void 0,n):yt(p,t,n,r,e)}else h=yt(e,t,n,r);return a(h)?h:s(h)?(s(m)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(s(e.children))for(var a=0,l=e.children.length;a<l;a++){var c=e.children[a];s(c.tag)&&(o(c.ns)||i(r)&&"svg"!==c.tag)&&n(c,t,r)}}(h,m),s(t)&&function(n){d(n.style)&&We(n.style);d(n.class)&&We(n.class)}(t),h):un()}(n,e,t,r,h)}function Ae(n,e,t){xn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){ze(n,r,"errorCaptured hook")}}ze(n,e,t)}finally{wn()}}function Se(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&g(o)&&!o._handled&&(o.catch((function(n){return Ae(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){Ae(n,r,a)}return o}function ze(n,e,t){if(W.errorHandler)try{return W.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ce(e,null,"config.errorHandler")}Ce(n,e,t)}function Ce(n,e,t){if(!$||"undefined"==typeof console)throw n;console.error(n)}var Pe,ke=!1,Ie=[],Me=!1;function Re(){Me=!1;var n=Ie.slice(0);Ie.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Le=Promise.resolve();Pe=function(){Le.then(Re),Q&&setTimeout(M)},ke=!0}else if(X||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Pe="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Re)}:function(){setTimeout(Re,0)};else{var He=1,_e=new MutationObserver(Re),De=document.createTextNode(String(He));_e.observe(De,{characterData:!0}),Pe=function(){He=(He+1)%2,De.data=String(He)},ke=!0}function Ge(n,e){var t;if(Ie.push((function(){if(n)try{n.call(e)}catch(n){Ae(n,e,"nextTick")}else t&&t(e)})),Me||(Me=!0,Pe()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Fe(n){return function(e,t){if(void 0===t&&(t=hn),t)return function(n,e,t){var r=n.$options;r[e]=At(r[e],t)}(t,n,e)}}Fe("beforeMount"),Fe("mounted"),Fe("beforeUpdate"),Fe("updated"),Fe("beforeDestroy"),Fe("destroyed"),Fe("activated"),Fe("deactivated"),Fe("serverPrefetch"),Fe("renderTracked"),Fe("renderTriggered"),Fe("errorCaptured");var Oe=new cn;function We(n){return function n(e,t){var r,o,s=a(e);if(!s&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof pn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(s)for(r=e.length;r--;)n(e[r],t);else if(Gn(e))n(e.value,t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,Oe),Oe.clear(),n}var Ue,Ve=0,qe=function(){function n(n,e,t,r,a){var o,s;o=this,void 0===(s=On&&!On._vm?On:n?n._scope:void 0)&&(s=On),s&&s.active&&s.effects.push(o),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ve,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!N.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=M)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ae(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&We(n),wn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Se(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&y(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ne(n,e){Ue.$on(n,e)}function Ze(n,e){Ue.$off(n,e)}function $e(n,e){var t=Ue;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Ye(n,e,t){Ue=n,Nn(e,t||{},Ne,Ze,$e,n),Ue=void 0}var Xe=null;function Je(n){var e=Xe;return Xe=n,function(){Xe=e}}function Ke(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Qe(n,e){if(e){if(n._directInactive=!1,Ke(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Qe(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,r){void 0===r&&(r=!0),xn();var a=hn;r&&mn(n);var o=n.$options[e],s="".concat(e," hook");if(o)for(var i=0,l=o.length;i<l;i++)Se(o[i],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),r&&mn(a),wn()}var et=[],tt=[],rt={},at=!1,ot=!1,st=0;var it=0,lt=Date.now;if($&&!X){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ht(){var n,e;for(it=lt(),ot=!0,et.sort(dt),st=0;st<et.length;st++)(n=et[st]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();st=et.length=tt.length=0,rt={},at=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Qe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&W.devtools&&sn.emit("flush")}function mt(n){var e=n.id;if(null==rt[e]&&(n!==En.target||!n.noRecurse)){if(rt[e]=!0,ot){for(var t=et.length-1;t>st&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);at||(at=!0,Ge(ht))}}function pt(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){var s=n[o].from;if(s in e._provided)t[o]=e._provided[s];else if("default"in n[o]){var i=n[o].default;t[o]=c(i)?i.call(e):i}else 0}}return t}}function ut(n,e,t,o,s){var l,c=this,d=s.options;w(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var h=i(d._compiled),m=!h;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||r,this.injections=pt(d.inject,o),this.slots=function(){return c.$slots||ge(o,n.scopedSlots,c.$slots=me(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(o,n.scopedSlots,this.slots())}}),h&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=ge(o,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,r){var s=Be(l,n,e,t,r,m);return s&&!a(s)&&(s.fnScopeId=d._scopeId,s.fnContext=o),s}:this._c=function(n,e,t,r){return Be(l,n,e,t,r,m)}}function gt(n,e,t,r,a){var o=fn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function ft(n,e){for(var t in e)n[B(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}he(ut.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;s(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,o){var s=a.data.scopedSlots,i=n.$scopedSlots,l=!!(s&&!s.$stable||i!==r&&!i.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=o;var h=a.data.attrs||r;n._attrsProxy&&Ee(n._attrsProxy,h,d.data&&d.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=h,t=t||r;var m=n.$options._parentListeners;if(n._listenersProxy&&Ee(n._listenersProxy,t,m||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ye(n,t,m),e&&n.$options.props){zn(!1);for(var p=n._props,u=n.$options._propKeys||[],g=0;g<u.length;g++){var f=u[g],v=n.$options.props;p[f]=kt(f,v,e,n)}zn(!0),n.$options.propsData=e}c&&(n.$slots=me(o,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Qe(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ke(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},Et=Object.keys(bt);function yt(n,e,t,l,c){if(!o(n)){var h=t.$options._base;if(d(n)&&(n=h.extend(n)),"function"==typeof n){var m;if(o(n.cid)&&void 0===(n=function(n,e){if(i(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=we;if(t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),i(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var r=n.owners=[t],a=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var h=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},m=D((function(t){n.resolved=je(t,e),a?r.length=0:h(!0)})),p=D((function(e){s(n.errorComp)&&(n.error=!0,h(!0))})),u=n(m,p);return d(u)&&(g(u)?o(n.resolved)&&u.then(m,p):g(u.component)&&(u.component.then(m,p),s(u.error)&&(n.errorComp=je(u.error,e)),s(u.loading)&&(n.loadingComp=je(u.loading,e),0===u.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,h(!1))}),u.delay||200)),s(u.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&p(null)}),u.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(m=n,h)))return function(n,e,t,r,a){var o=un();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(m,e,t,l,c);e=e||{},qt(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),i=o[r],l=e.model.callback;s(i)?(a(i)?-1===i.indexOf(l):i!==l)&&(o[r]=[l].concat(i)):o[r]=l}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!o(r)){var a={},i=n.attrs,l=n.props;if(s(i)||s(l))for(var c in r){var d=z(c);$n(a,l,c,d,!0)||$n(a,i,c,d,!1)}return a}}(e,n);if(i(n.options.functional))return function(n,e,t,o,i){var l=n.options,c={},d=l.props;if(s(d))for(var h in d)c[h]=kt(h,d,e||r);else s(t.attrs)&&ft(c,t.attrs),s(t.props)&&ft(c,t.props);var m=new ut(t,c,i,o,n),p=l.render.call(null,m._c,m);if(p instanceof pn)return gt(p,t,m.parent,l,m);if(a(p)){for(var u=Yn(p)||[],g=new Array(u.length),f=0;f<u.length;f++)g[f]=gt(u[f],t,m.parent,l,m);return g}}(n,p,e,t,l);var u=e.on;if(e.on=e.nativeOn,i(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Et.length;t++){var r=Et[t],a=e[r],o=bt[r];a===o||a&&a._merged||(e[r]=a?xt(o,a):o)}}(e);var v=vt(n.options)||c;return new pn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:u,tag:c,children:l},m)}}}function xt(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var wt=M,jt=W.optionMergeStrategies;function Tt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,a,o,s=dn?Reflect.ownKeys(e):Object.keys(e),i=0;i<s.length;i++)"__ob__"!==(r=s[i])&&(a=n[r],o=e[r],t&&w(n,r)?a!==o&&m(a)&&m(o)&&Tt(a,o):Mn(n,r,o));return n}function Bt(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,a=c(n)?n.call(t,t):n;return r?Tt(r,a):a}:e?n?function(){return Tt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function At(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function St(n,e,t,r){var a=Object.create(n||null);return e?k(a,e):a}jt.data=function(n,e,t){return t?Bt(n,e,t):e&&"function"!=typeof e?n:Bt(n,e)},O.forEach((function(n){jt[n]=At})),F.forEach((function(n){jt[n+"s"]=St})),jt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var s in k(o,n),e){var i=o[s],l=e[s];i&&!a(i)&&(i=[i]),o[s]=i?i.concat(l):a(l)?l:[l]}return o},jt.props=jt.methods=jt.inject=jt.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return k(a,n),e&&k(a,e),a},jt.provide=function(n,e){return n?function(){var t=Object.create(null);return Tt(t,c(n)?n.call(this):n),e&&Tt(t,c(e)?e.call(this):e,!1),t}:e};var zt=function(n,e){return void 0===e?n:e};function Ct(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,s={};if(a(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(s[B(o)]={type:null});else if(m(t))for(var i in t)o=t[i],s[B(i)]=m(o)?o:{type:o};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(m(t))for(var s in t){var i=t[s];r[s]=m(i)?k({from:s},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Ct(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=Ct(n,e.mixins[r],t);var s,i={};for(s in n)l(s);for(s in e)w(n,s)||l(s);function l(r){var a=jt[r]||zt;i[r]=a(n[r],e[r],t,r)}return i}function Pt(n,e,t,r){if("string"==typeof t){var a=n[e];if(w(a,t))return a[t];var o=B(t);if(w(a,o))return a[o];var s=A(o);return w(a,s)?a[s]:a[t]||a[o]||a[s]}}function kt(n,e,t,r){var a=e[n],o=!w(t,n),s=t[n],i=Lt(Boolean,a.type);if(i>-1)if(o&&!w(a,"default"))s=!1;else if(""===s||s===z(n)){var l=Lt(String,a.type);(l<0||i<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!w(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Mt(e.type)?r.call(n):r}(r,a,n);var d=Sn;zn(!0),kn(s),zn(d)}return s}var It=/^\s*function (\w+)/;function Mt(n){var e=n&&n.toString().match(It);return e?e[1]:""}function Rt(n,e){return Mt(n)===Mt(e)}function Lt(n,e){if(!a(e))return Rt(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Rt(e[t],n))return t;return-1}var Ht={enumerable:!0,configurable:!0,get:M,set:M};function _t(n,e,t){Ht.get=function(){return this[e][t]},Ht.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ht)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Hn({}),a=n.$options._propKeys=[];n.$parent&&zn(!1);var o=function(o){a.push(o);var s=kt(o,e,t,n);In(r,o,s),o in n||_t(n,"_props",o)};for(var s in e)o(s);zn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=be(n);mn(n),xn();var a=Se(t,null,[n._props||Hn({}),r],n,"setup");if(wn(),mn(),c(a))e.render=a;else if(d(a))if(n._setupState=a,a.__sfc){var o=n._setupProxy={};for(var s in a)"__sfc"!==s&&Fn(o,a,s)}else for(var s in a)V(s)||Fn(n,a,s);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?M:C(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;m(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return Ae(n,e,"data()"),{}}finally{wn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&w(r,o)||V(o)||_t(n,"_data",o)}var s=kn(e);s&&s.vmCount++}(n);else{var t=kn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var o=e[a],s=c(o)?o:o.get;0,r||(t[a]=new qe(n,s||M,M,Gt)),a in n||Ft(n,a,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var o=0;o<r.length;o++)Ut(n,t,r[o]);else Ut(n,t,r)}}(n,e.watch)}var Gt={lazy:!0};function Ft(n,e,t){var r=!on();c(t)?(Ht.get=r?Ot(e):Wt(t),Ht.set=M):(Ht.get=t.get?r&&!1!==t.cache?Ot(e):Wt(t.get):M,Ht.set=t.set||M),Object.defineProperty(n,e,Ht)}function Ot(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),En.target&&e.depend(),e.value}}function Wt(n){return function(){return n.call(this,this)}}function Ut(n,e,t,r){return m(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Vt=0;function qt(n){var e=n.options;if(n.super){var t=qt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&k(n.extendOptions,r),(e=n.options=Ct(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Nt(n){this._init(n)}function Zt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=vt(n)||vt(t.options);var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=Ct(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)_t(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ft(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,F.forEach((function(n){s[n]=t[n]})),o&&(s.options.components[o]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=k({},s.options),a[r]=s,s}}function $t(n){return n&&(vt(n.Ctor.options)||n.tag)}function Yt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function Xt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var s=t[o];if(s){var i=s.name;i&&!e(i)&&Jt(t,o,r,a)}}}function Jt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Vt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Wn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ct(qt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ye(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=me(e._renderChildren,a),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,a){return Be(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Be(n,e,t,r,a,!0)};var o=t&&t.data;In(n,"$attrs",o&&o.attrs||r,null,!0),In(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=pt(n.$options.inject,n);e&&(zn(!1),Object.keys(e).forEach((function(t){In(n,t,e[t])})),zn(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var r=Un(n),a=dn?Reflect.ownKeys(t):Object.keys(t),o=0;o<a.length;o++){var s=a[o];Object.defineProperty(r,s,Object.getOwnPropertyDescriptor(t,s))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Nt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Mn,n.prototype.$delete=Rn,n.prototype.$watch=function(n,e,t){if(m(e))return Ut(this,n,e,t);(t=t||{}).user=!0;var r=new qe(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');xn(),Se(e,this,[r.value],this,a),wn()}return function(){r.teardown()}}}(Nt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var o=0,s=n.length;o<s;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var s,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var l=i.length;l--;)if((s=i[l])===e||s.fn===e){i.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?P(t):t;for(var r=P(arguments,1),a='event handler for "'.concat(n,'"'),o=0,s=t.length;o<s;o++)Se(t[o],e,r,e,a)}return e}}(Nt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Je(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var s=t;s&&s.$vnode&&s.$parent&&s.$vnode===s.$parent._vnode;)s.$parent.$el=s.$el,s=s.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Nt),function(n){he(n.prototype),n.prototype.$nextTick=function(n){return Ge(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,o=t._parentVnode;o&&e._isMounted&&(e.$scopedSlots=ge(e.$parent,o.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&xe(e._slotsProxy,e.$scopedSlots)),e.$vnode=o;try{mn(e),we=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Ae(t,e,"render"),n=e._vnode}finally{we=null,mn()}return a(n)&&1===n.length&&(n=n[0]),n instanceof pn||(n=un()),n.parent=o,n}}(Nt);var Kt=[String,RegExp,Array],Qt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Kt,exclude:Kt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,o=t.componentInstance,s=t.componentOptions;n[r]={name:$t(s),tag:a,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&Jt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Jt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Xt(n,(function(n){return Yt(e,n)}))})),this.$watch("exclude",(function(e){Xt(n,(function(n){return!Yt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Te(n),t=e&&e.componentOptions;if(t){var r=$t(t),a=this.include,o=this.exclude;if(a&&(!r||!Yt(a,r))||o&&r&&Yt(o,r))return e;var s=this.cache,i=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,y(i,l),i.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return W}};Object.defineProperty(n,"config",e),n.util={warn:wt,extend:k,mergeOptions:Ct,defineReactive:In},n.set=Mn,n.delete=Rn,n.nextTick=Ge,n.observable=function(n){return kn(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,k(n.options.components,Qt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=P(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ct(this.options,n),this}}(n),Zt(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&m(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Nt),Object.defineProperty(Nt.prototype,"$isServer",{get:on}),Object.defineProperty(Nt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Nt,"FunctionalRenderContext",{value:ut}),Nt.version="2.7.14";var nr=b("style,class"),er=b("input,textarea,option,select,progress"),tr=b("contenteditable,draggable,spellcheck"),rr=b("events,caret,typing,plaintext-only"),ar=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),or="http://www.w3.org/1999/xlink",sr=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},ir=function(n){return sr(n)?n.slice(6,n.length):""},lr=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;s(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=dr(r.data,e));for(;s(t=t.parent);)t&&t.data&&(e=dr(e,t.data));return function(n,e){if(s(n)||s(e))return hr(n,mr(e));return""}(e.staticClass,e.class)}function dr(n,e){return{staticClass:hr(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function hr(n,e){return n?e?n+" "+e:n:e||""}function mr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)s(e=mr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var pr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ur=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fr=function(n){return ur(n)||gr(n)};var vr=Object.create(null);var br=b("text,number,password,search,email,tel,url");var Er=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(pr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),yr={create:function(n,e){xr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(xr(n,!0),xr(e))},destroy:function(n){xr(n,!0)}};function xr(n,e){var t=n.data.ref;if(s(t)){var r=n.context,o=n.componentInstance||n.elm,i=e?null:o,l=e?void 0:o;if(c(t))Se(t,r,[i],r,"template ref function");else{var d=n.data.refInFor,h="string"==typeof t||"number"==typeof t,m=Gn(t),p=r.$refs;if(h||m)if(d){var u=h?p[t]:t.value;e?a(u)&&y(u,o):a(u)?u.includes(o)||u.push(o):h?(p[t]=[o],wr(r,t,p[t])):t.value=[o]}else if(h){if(e&&p[t]!==o)return;p[t]=l,wr(r,t,i)}else if(m){if(e&&t.value!==o)return;t.value=i}else 0}}}function wr(n,e,t){var r=n._setupState;r&&w(r,e)&&(Gn(r[e])?r[e].value=t:r[e]=t)}var jr=new pn("",{},[]),Tr=["create","activate","update","remove","destroy"];function Br(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=s(t=n.data)&&s(t=t.attrs)&&t.type,a=s(t=e.data)&&s(t=t.attrs)&&t.type;return r===a||br(r)&&br(a)}(n,e)||i(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function Ar(n,e,t){var r,a,o={};for(r=e;r<=t;++r)s(a=n[r].key)&&(o[a]=r);return o}var Sr={create:zr,update:zr,destroy:function(n){zr(n,jr)}};function zr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===jr,s=e===jr,i=Pr(n.data.directives,n.context),l=Pr(e.data.directives,e.context),c=[],d=[];for(t in l)r=i[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,Ir(a,"update",e,n),a.def&&a.def.componentUpdated&&d.push(a)):(Ir(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var h=function(){for(var t=0;t<c.length;t++)Ir(c[t],"inserted",e,n)};o?Zn(e,"insert",h):h()}d.length&&Zn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)Ir(d[t],"componentUpdated",e,n)}));if(!o)for(t in i)l[t]||Ir(i[t],"unbind",n,n,s)}(n,e)}var Cr=Object.create(null);function Pr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=Cr),a[kr(r)]=r,e._setupState&&e._setupState.__sfc){var o=r.def||Pt(e,"_setupState","v-"+r.name);r.def="function"==typeof o?{bind:o,update:o}:o}r.def=r.def||Pt(e.$options,"directives",r.name)}return a}function kr(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ir(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){Ae(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Mr=[yr,Sr];function Rr(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,a,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(r in(s(d.__ob__)||i(d._v_attr_proxy))&&(d=e.data.attrs=k({},d)),d)a=d[r],c[r]!==a&&Lr(l,r,a,e.data.pre);for(r in(X||K)&&d.value!==c.value&&Lr(l,"value",d.value),c)o(d[r])&&(sr(r)?l.removeAttributeNS(or,ir(r)):tr(r)||l.removeAttribute(r))}}function Lr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Hr(n,e,t):ar(e)?lr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):tr(e)?n.setAttribute(e,function(n,e){return lr(e)||"false"===e?"false":"contenteditable"===n&&rr(e)?e:"true"}(e,t)):sr(e)?lr(t)?n.removeAttributeNS(or,ir(e)):n.setAttributeNS(or,e,t):Hr(n,e,t)}function Hr(n,e,t){if(lr(t))n.removeAttribute(e);else{if(X&&!J&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var _r={create:Rr,update:Rr};function Dr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(a)||o(a.staticClass)&&o(a.class)))){var i=cr(e),l=t._transitionClasses;s(l)&&(i=hr(i,mr(l))),i!==t._prevClass&&(t.setAttribute("class",i),t._prevClass=i)}}var Gr,Fr={create:Dr,update:Dr};function Or(n,e,t){var r=Gr;return function a(){var o=e.apply(null,arguments);null!==o&&Vr(n,a,t,r)}}var Wr=ke&&!(en&&Number(en[1])<=53);function Ur(n,e,t,r){if(Wr){var a=it,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Gr.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Vr(n,e,t,r){(r||Gr).removeEventListener(n,e._wrapper||e,t)}function qr(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Gr=e.elm||n.elm,function(n){if(s(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Nn(t,r,Ur,Vr,Or,e.context),Gr=void 0}}var Nr,Zr={create:qr,update:qr,destroy:function(n){return qr(n,jr)}};function $r(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(s(c.__ob__)||i(c._v_attr_proxy))&&(c=e.data.domProps=k({},c)),l)t in c||(a[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var d=o(r)?"":String(r);Yr(a,d)&&(a.value=d)}else if("innerHTML"===t&&gr(a.tagName)&&o(a.innerHTML)){(Nr=Nr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var h=Nr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;h.firstChild;)a.appendChild(h.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Yr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(s(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Xr={create:$r,update:$r},Jr=j((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Kr(n){var e=Qr(n.style);return n.staticStyle?k(n.staticStyle,e):e}function Qr(n){return Array.isArray(n)?I(n):"string"==typeof n?Jr(n):n}var na,ea=/^--/,ta=/\s*!important$/,ra=function(n,e,t){if(ea.test(e))n.style.setProperty(e,t);else if(ta.test(t))n.style.setProperty(z(e),t.replace(ta,""),"important");else{var r=oa(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},aa=["Webkit","Moz","ms"],oa=j((function(n){if(na=na||document.createElement("div").style,"filter"!==(n=B(n))&&n in na)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<aa.length;t++){var r=aa[t]+e;if(r in na)return r}}));function sa(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var a,i,l=e.elm,c=r.staticStyle,d=r.normalizedStyle||r.style||{},h=c||d,m=Qr(e.data.style)||{};e.data.normalizedStyle=s(m.__ob__)?k({},m):m;var p=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Kr(a.data))&&k(r,t);(t=Kr(n.data))&&k(r,t);for(var o=n;o=o.parent;)o.data&&(t=Kr(o.data))&&k(r,t);return r}(e,!0);for(i in h)o(p[i])&&ra(l,i,"");for(i in p)(a=p[i])!==h[i]&&ra(l,i,null==a?"":a)}}var ia={create:sa,update:sa},la=/\s+/;function ca(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function da(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ha(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&k(e,ma(n.name||"v")),k(e,n),e}return"string"==typeof n?ma(n):void 0}}var ma=j((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),pa=$&&!J,ua="transition",ga="transitionend",fa="animation",va="animationend";pa&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ua="WebkitTransition",ga="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fa="WebkitAnimation",va="webkitAnimationEnd"));var ba=$?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Ea(n){ba((function(){ba(n)}))}function ya(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ca(n,e))}function xa(n,e){n._transitionClasses&&y(n._transitionClasses,e),da(n,e)}function wa(n,e,t){var r=Ta(n,e),a=r.type,o=r.timeout,s=r.propCount;if(!a)return t();var i="transition"===a?ga:va,l=0,c=function(){n.removeEventListener(i,d),t()},d=function(e){e.target===n&&++l>=s&&c()};setTimeout((function(){l<s&&c()}),o+1),n.addEventListener(i,d)}var ja=/\b(transform|all)(,|$)/;function Ta(n,e){var t,r=window.getComputedStyle(n),a=(r[ua+"Delay"]||"").split(", "),o=(r[ua+"Duration"]||"").split(", "),s=Ba(a,o),i=(r[fa+"Delay"]||"").split(", "),l=(r[fa+"Duration"]||"").split(", "),c=Ba(i,l),d=0,h=0;return"transition"===e?s>0&&(t="transition",d=s,h=o.length):"animation"===e?c>0&&(t="animation",d=c,h=l.length):h=(t=(d=Math.max(s,c))>0?s>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:d,propCount:h,hasTransform:"transition"===t&&ja.test(r[ua+"Property"])}}function Ba(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Aa(e)+Aa(n[t])})))}function Aa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Sa(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ha(n.data.transition);if(!o(r)&&!s(t._enterCb)&&1===t.nodeType){for(var a=r.css,i=r.type,l=r.enterClass,h=r.enterToClass,m=r.enterActiveClass,p=r.appearClass,u=r.appearToClass,g=r.appearActiveClass,f=r.beforeEnter,b=r.enter,E=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,w=r.appear,j=r.afterAppear,T=r.appearCancelled,B=r.duration,A=Xe,S=Xe.$vnode;S&&S.parent;)A=S.context,S=S.parent;var z=!A._isMounted||!n.isRootInsert;if(!z||w||""===w){var C=z&&p?p:l,P=z&&g?g:m,k=z&&u?u:h,I=z&&x||f,M=z&&c(w)?w:b,R=z&&j||E,L=z&&T||y,H=v(d(B)?B.enter:B);0;var _=!1!==a&&!J,G=Pa(M),F=t._enterCb=D((function(){_&&(xa(t,k),xa(t,P)),F.cancelled?(_&&xa(t,C),L&&L(t)):R&&R(t),t._enterCb=null}));n.data.show||Zn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),M&&M(t,F)})),I&&I(t),_&&(ya(t,C),ya(t,P),Ea((function(){xa(t,C),F.cancelled||(ya(t,k),G||(Ca(H)?setTimeout(F,H):wa(t,i,F)))}))),n.data.show&&(e&&e(),M&&M(t,F)),_||G||F()}}}function za(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ha(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var a=r.css,i=r.type,l=r.leaveClass,c=r.leaveToClass,h=r.leaveActiveClass,m=r.beforeLeave,p=r.leave,u=r.afterLeave,g=r.leaveCancelled,f=r.delayLeave,b=r.duration,E=!1!==a&&!J,y=Pa(p),x=v(d(b)?b.leave:b);0;var w=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),E&&(xa(t,c),xa(t,h)),w.cancelled?(E&&xa(t,l),g&&g(t)):(e(),u&&u(t)),t._leaveCb=null}));f?f(j):j()}function j(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),m&&m(t),E&&(ya(t,l),ya(t,h),Ea((function(){xa(t,l),w.cancelled||(ya(t,c),y||(Ca(x)?setTimeout(w,x):wa(t,i,w)))}))),p&&p(t,w),E||y||w())}}function Ca(n){return"number"==typeof n&&!isNaN(n)}function Pa(n){if(o(n))return!1;var e=n.fns;return s(e)?Pa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ka(n,e){!0!==e.data.show&&Sa(e)}var Ia=function(n){var e,t,r={},c=n.modules,d=n.nodeOps;for(e=0;e<Tr.length;++e)for(r[Tr[e]]=[],t=0;t<c.length;++t)s(c[t][Tr[e]])&&r[Tr[e]].push(c[t][Tr[e]]);function h(n){var e=d.parentNode(n);s(e)&&d.removeChild(e,n)}function m(n,e,t,a,o,l,c){if(s(n.elm)&&s(l)&&(n=l[c]=fn(n)),n.isRootInsert=!o,!function(n,e,t,a){var o=n.data;if(s(o)){var l=s(n.componentInstance)&&o.keepAlive;if(s(o=o.hook)&&s(o=o.init)&&o(n,!1),s(n.componentInstance))return p(n,e),u(t,n.elm,a),i(l)&&function(n,e,t,a){var o,i=n;for(;i.componentInstance;)if(i=i.componentInstance._vnode,s(o=i.data)&&s(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](jr,i);e.push(i);break}u(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var h=n.data,m=n.children,f=n.tag;s(f)?(n.elm=n.ns?d.createElementNS(n.ns,f):d.createElement(f,n),E(n),g(n,m,e),s(h)&&v(n,e),u(t,n.elm,a)):i(n.isComment)?(n.elm=d.createComment(n.text),u(t,n.elm,a)):(n.elm=d.createTextNode(n.text),u(t,n.elm,a))}}function p(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(v(n,e),E(n)):(xr(n),e.push(n))}function u(n,e,t){s(n)&&(s(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function g(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)m(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function v(n,t){for(var a=0;a<r.create.length;++a)r.create[a](jr,n);s(e=n.data.hook)&&(s(e.create)&&e.create(jr,n),s(e.insert)&&t.push(n))}function E(n){var e;if(s(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;s(e=Xe)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function y(n,e,t,r,a,o){for(;r<=a;++r)m(t[r],o,n,e,!1,t,r)}function x(n){var e,t,a=n.data;if(s(a))for(s(e=a.hook)&&s(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];s(r)&&(s(r.tag)?(j(r),x(r)):h(r.elm))}}function j(n,e){if(s(e)||s(n.data)){var t,a=r.remove.length+1;for(s(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&h(n)}return t.listeners=e,t}(n.elm,a),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&j(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else h(n.elm)}function T(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(s(o)&&Br(n,o))return a}}function B(n,e,t,a,l,c){if(n!==e){s(e.elm)&&s(a)&&(e=a[l]=fn(e));var h=e.elm=n.elm;if(i(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?z(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(i(e.isStatic)&&i(n.isStatic)&&e.key===n.key&&(i(e.isCloned)||i(e.isOnce)))e.componentInstance=n.componentInstance;else{var p,u=e.data;s(u)&&s(p=u.hook)&&s(p=p.prepatch)&&p(n,e);var g=n.children,v=e.children;if(s(u)&&f(e)){for(p=0;p<r.update.length;++p)r.update[p](n,e);s(p=u.hook)&&s(p=p.update)&&p(n,e)}o(e.text)?s(g)&&s(v)?g!==v&&function(n,e,t,r,a){var i,l,c,h=0,p=0,u=e.length-1,g=e[0],f=e[u],v=t.length-1,b=t[0],E=t[v],x=!a;for(0;h<=u&&p<=v;)o(g)?g=e[++h]:o(f)?f=e[--u]:Br(g,b)?(B(g,b,r,t,p),g=e[++h],b=t[++p]):Br(f,E)?(B(f,E,r,t,v),f=e[--u],E=t[--v]):Br(g,E)?(B(g,E,r,t,v),x&&d.insertBefore(n,g.elm,d.nextSibling(f.elm)),g=e[++h],E=t[--v]):Br(f,b)?(B(f,b,r,t,p),x&&d.insertBefore(n,f.elm,g.elm),f=e[--u],b=t[++p]):(o(i)&&(i=Ar(e,h,u)),o(l=s(b.key)?i[b.key]:T(b,e,h,u))?m(b,r,n,g.elm,!1,t,p):Br(c=e[l],b)?(B(c,b,r,t,p),e[l]=void 0,x&&d.insertBefore(n,c.elm,g.elm)):m(b,r,n,g.elm,!1,t,p),b=t[++p]);h>u?y(n,o(t[v+1])?null:t[v+1].elm,t,p,v,r):p>v&&w(e,h,u)}(h,g,v,t,c):s(v)?(s(n.text)&&d.setTextContent(h,""),y(h,null,v,0,v.length-1,t)):s(g)?w(g,0,g.length-1):s(n.text)&&d.setTextContent(h,""):n.text!==e.text&&d.setTextContent(h,e.text),s(u)&&s(p=u.hook)&&s(p=p.postpatch)&&p(n,e)}}}function A(n,e,t){if(i(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var S=b("attrs,class,staticClass,staticStyle,key");function z(n,e,t,r){var a,o=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,i(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(l)&&(s(a=l.hook)&&s(a=a.init)&&a(e,!0),s(a=e.componentInstance)))return p(e,t),!0;if(s(o)){if(s(c))if(n.hasChildNodes())if(s(a=l)&&s(a=a.domProps)&&s(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var d=!0,h=n.firstChild,m=0;m<c.length;m++){if(!h||!z(h,c[m],t,r)){d=!1;break}h=h.nextSibling}if(!d||h)return!1}else g(e,c,t);if(s(l)){var u=!1;for(var f in l)if(!S(f)){u=!0,v(e,t);break}!u&&l.class&&We(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!o(e)){var l,c=!1,h=[];if(o(n))c=!0,m(e,h);else{var p=s(n.nodeType);if(!p&&Br(n,e))B(n,e,h,null,null,a);else{if(p){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),i(t)&&z(n,e,h))return A(e,h,!0),n;l=n,n=new pn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var u=n.elm,g=d.parentNode(u);if(m(e,h,u._leaveCb?null:g,d.nextSibling(u)),s(e.parent))for(var v=e.parent,b=f(e);v;){for(var E=0;E<r.destroy.length;++E)r.destroy[E](v);if(v.elm=e.elm,b){for(var y=0;y<r.create.length;++y)r.create[y](jr,v);var j=v.data.hook.insert;if(j.merged)for(var T=1;T<j.fns.length;T++)j.fns[T]()}else xr(v);v=v.parent}s(g)?w([n],0,0):s(n.tag)&&x(n)}}return A(e,h,c),e.elm}s(n)&&x(n)}}({nodeOps:Er,modules:[_r,Fr,Zr,Xr,ia,$?{create:ka,activate:ka,remove:function(n,e){!0!==n.data.show?za(n,e):e()}}:{}].concat(Mr)});J&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Fa(n,"input")}));var Ma={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Zn(t,"postpatch",(function(){Ma.componentUpdated(n,e,t)})):Ra(n,e,t.context),n._vOptions=[].map.call(n.options,_a)):("textarea"===t.tag||br(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Da),n.addEventListener("compositionend",Ga),n.addEventListener("change",Ga),J&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ra(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,_a);if(a.some((function(n,e){return!H(n,r[e])})))(n.multiple?e.value.some((function(n){return Ha(n,a)})):e.value!==e.oldValue&&Ha(e.value,a))&&Fa(n,"change")}}};function Ra(n,e,t){La(n,e,t),(X||K)&&setTimeout((function(){La(n,e,t)}),0)}function La(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,s,i=0,l=n.options.length;i<l;i++)if(s=n.options[i],a)o=_(r,_a(s))>-1,s.selected!==o&&(s.selected=o);else if(H(_a(s),r))return void(n.selectedIndex!==i&&(n.selectedIndex=i));a||(n.selectedIndex=-1)}}function Ha(n,e){return e.every((function(e){return!H(e,n)}))}function _a(n){return"_value"in n?n._value:n.value}function Da(n){n.target.composing=!0}function Ga(n){n.target.composing&&(n.target.composing=!1,Fa(n.target,"input"))}function Fa(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Oa(n){return!n.componentInstance||n.data&&n.data.transition?n:Oa(n.componentInstance._vnode)}var Wa={model:Ma,show:{bind:function(n,e,t){var r=e.value,a=(t=Oa(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,Sa(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Oa(t)).data&&t.data.transition?(t.data.show=!0,r?Sa(t,(function(){n.style.display=n.__vOriginalDisplay})):za(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Ua={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Va(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Va(Te(e.children)):n}function qa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[B(r)]=a[r];return e}function Na(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Za=function(n){return n.tag||ue(n)},$a=function(n){return"show"===n.name},Ya={name:"transition",props:Ua,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Za)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=Va(a);if(!o)return a;if(this._leaving)return Na(n,a);var s="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?s+"comment":s+o.tag:l(o.key)?0===String(o.key).indexOf(s)?o.key:s+o.key:o.key;var i=(o.data||(o.data={})).transition=qa(this),c=this._vnode,d=Va(c);if(o.data.directives&&o.data.directives.some($a)&&(o.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,d)&&!ue(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var h=d.data.transition=k({},i);if("out-in"===r)return this._leaving=!0,Zn(h,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Na(n,a);if("in-out"===r){if(ue(o))return c;var m,p=function(){m()};Zn(i,"afterEnter",p),Zn(i,"enterCancelled",p),Zn(h,"delayLeave",(function(n){m=n}))}}return a}}},Xa=k({tag:String,moveClass:String},Ua);function Ja(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ka(n){n.data.newPos=n.elm.getBoundingClientRect()}function Qa(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),o.transitionDuration="0s"}}delete Xa.mode;var no={Transition:Ya,TransitionGroup:{props:Xa,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Je(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],s=qa(this),i=0;i<a.length;i++){if((d=a[i]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))o.push(d),t[d.key]=d,(d.data||(d.data={})).transition=s;else;}if(r){var l=[],c=[];for(i=0;i<r.length;i++){var d;(d=r[i]).data.transition=s,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ja),n.forEach(Ka),n.forEach(Qa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;ya(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(ga,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(ga,n),t._moveCb=null,xa(t,e))})}})))},methods:{hasMove:function(n,e){if(!pa)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){da(t,n)})),ca(t,e),t.style.display="none",this.$el.appendChild(t);var r=Ta(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function eo(n,e){for(var t in e)n[t]=e[t];return n}Nt.config.mustUseProp=function(n,e,t){return"value"===t&&er(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Nt.config.isReservedTag=fr,Nt.config.isReservedAttr=nr,Nt.config.getTagNamespace=function(n){return gr(n)?"svg":"math"===n?"math":void 0},Nt.config.isUnknownElement=function(n){if(!$)return!0;if(fr(n))return!1;if(n=n.toLowerCase(),null!=vr[n])return vr[n];var e=document.createElement(n);return n.indexOf("-")>-1?vr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:vr[n]=/HTMLUnknownElement/.test(e.toString())},k(Nt.options.directives,Wa),k(Nt.options.components,no),Nt.prototype.__patch__=$?Ia:M,Nt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=un),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new qe(n,r,M,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var o=0;o<a.length;o++)a[o].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&$?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},$&&setTimeout((function(){W.devtools&&sn&&sn.emit("init",Nt)}),0);var to=/[!'()*]/g,ro=function(n){return"%"+n.charCodeAt(0).toString(16)},ao=/%2C/g,oo=function(n){return encodeURIComponent(n).replace(to,ro).replace(ao,",")};function so(n){try{return decodeURIComponent(n)}catch(n){0}return n}var io=function(n){return null==n||"object"==typeof n?n:String(n)};function lo(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=so(t.shift()),a=t.length>0?so(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function co(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oo(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(oo(e)):r.push(oo(e)+"="+oo(n)))})),r.join("&")}return oo(e)+"="+oo(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ho=/\/?$/;function mo(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=po(o)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:fo(e,a),matched:n?go(n):[]};return t&&(s.redirectedFrom=fo(t,a)),Object.freeze(s)}function po(n){if(Array.isArray(n))return n.map(po);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=po(n[t]);return e}return n}var uo=mo(null,{path:"/"});function go(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function fo(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||co)(r)+a}function vo(n,e,t){return e===uo?n===e:!!e&&(n.path&&e.path?n.path.replace(ho,"")===e.path.replace(ho,"")&&(t||n.hash===e.hash&&bo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&bo(n.query,e.query)&&bo(n.params,e.params))))}function bo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var s=e[t];return null==o||null==s?o===s:"object"==typeof o&&"object"==typeof s?bo(o,s):String(o)===String(s)}))}function Eo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var s=0;s<o.length;s++)a._isBeingDestroyed||o[s](a)}}}}var yo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var s=a.$createElement,i=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),d=0,h=!1;a&&a._routerRoot!==a;){var m=a.$vnode?a.$vnode.data:{};m.routerView&&d++,m.keepAlive&&a._directInactive&&a._inactive&&(h=!0),a=a.$parent}if(o.routerViewDepth=d,h){var p=c[i],u=p&&p.component;return u?(p.configProps&&xo(u,o,p.route,p.configProps),s(u,o,r)):s()}var g=l.matched[d],f=g&&g.components[i];if(!g||!f)return c[i]=null,s();c[i]={component:f},o.registerRouteInstance=function(n,e){var t=g.instances[i];(e&&t!==n||!e&&t===n)&&(g.instances[i]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){g.instances[i]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[i]&&(g.instances[i]=n.componentInstance),Eo(l)};var v=g.props&&g.props[i];return v&&(eo(c[i],{route:l,configProps:v}),xo(f,o,l,v)),s(f,o,r)}};function xo(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=eo({},a);var o=e.attrs=e.attrs||{};for(var s in a)n.props&&s in n.props||(o[s]=a[s],delete a[s])}}function wo(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),s=0;s<o.length;s++){var i=o[s];".."===i?a.pop():"."!==i&&a.push(i)}return""!==a[0]&&a.unshift(""),a.join("/")}function jo(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var To=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Bo=Go,Ao=ko,So=function(n,e){return Mo(ko(n,e),e)},zo=Mo,Co=Do,Po=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ko(n,e){for(var t,r=[],a=0,o=0,s="",i=e&&e.delimiter||"/";null!=(t=Po.exec(n));){var l=t[0],c=t[1],d=t.index;if(s+=n.slice(o,d),o=d+l.length,c)s+=c[1];else{var h=n[o],m=t[2],p=t[3],u=t[4],g=t[5],f=t[6],v=t[7];s&&(r.push(s),s="");var b=null!=m&&null!=h&&h!==m,E="+"===f||"*"===f,y="?"===f||"*"===f,x=t[2]||i,w=u||g;r.push({name:p||a++,prefix:m||"",delimiter:x,optional:y,repeat:E,partial:b,asterisk:!!v,pattern:w?Lo(w):v?".*":"[^"+Ro(x)+"]+?"})}}return o<n.length&&(s+=n.substr(o)),s&&r.push(s),r}function Io(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Mo(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",_o(e)));return function(e,r){for(var a="",o=e||{},s=(r||{}).pretty?Io:encodeURIComponent,i=0;i<n.length;i++){var l=n[i];if("string"!=typeof l){var c,d=o[l.name];if(null==d){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(To(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var h=0;h<d.length;h++){if(c=s(d[h]),!t[i].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===h?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(d),!t[i].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function Ro(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Lo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Ho(n,e){return n.keys=e,n}function _o(n){return n&&n.sensitive?"":"i"}function Do(n,e,t){To(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",s=0;s<n.length;s++){var i=n[s];if("string"==typeof i)o+=Ro(i);else{var l=Ro(i.prefix),c="(?:"+i.pattern+")";e.push(i),i.repeat&&(c+="(?:"+l+c+")*"),o+=c=i.optional?i.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=Ro(t.delimiter||"/"),h=o.slice(-d.length)===d;return r||(o=(h?o.slice(0,-d.length):o)+"(?:"+d+"(?=$))?"),o+=a?"$":r&&h?"":"(?="+d+"|$)",Ho(new RegExp("^"+o,_o(t)),e)}function Go(n,e,t){return To(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Ho(n,e)}(n,e):To(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(Go(n[a],e,t).source);return Ho(new RegExp("(?:"+r.join("|")+")",_o(t)),e)}(n,e,t):function(n,e,t){return Do(ko(n,t),e,t)}(n,e,t)}Bo.parse=Ao,Bo.compile=So,Bo.tokensToFunction=zo,Bo.tokensToRegExp=Co;var Fo=Object.create(null);function Oo(n,e,t){e=e||{};try{var r=Fo[n]||(Fo[n]=Bo.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Wo(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var o=(a=eo({},n)).params;return o&&"object"==typeof o&&(a.params=eo({},o)),a}if(!a.path&&a.params&&e){(a=eo({},a))._normalized=!0;var s=eo(eo({},e.params),a.params);if(e.name)a.name=e.name,a.params=s;else if(e.matched.length){var i=e.matched[e.matched.length-1].path;a.path=Oo(i,s,e.path)}else 0;return a}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",d=l.path?wo(l.path,c,t||a.append):c,h=function(n,e,t){void 0===e&&(e={});var r,a=t||lo;try{r=a(n||"")}catch(n){r={}}for(var o in e){var s=e[o];r[o]=Array.isArray(s)?s.map(io):io(s)}return r}(l.query,a.query,r&&r.options.parseQuery),m=a.hash||l.hash;return m&&"#"!==m.charAt(0)&&(m="#"+m),{_normalized:!0,path:d,query:h,hash:m}}var Uo,Vo=function(){},qo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),o=a.location,s=a.route,i=a.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,h=null==c?"router-link-active":c,m=null==d?"router-link-exact-active":d,p=null==this.activeClass?h:this.activeClass,u=null==this.exactActiveClass?m:this.exactActiveClass,g=s.redirectedFrom?mo(null,Wo(s.redirectedFrom),null,t):s;l[u]=vo(r,g,this.exactPath),l[p]=this.exact||this.exactPath?l[u]:function(n,e){return 0===n.path.replace(ho,"/").indexOf(e.path.replace(ho,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,g);var f=l[u]?this.ariaCurrentValue:null,v=function(n){No(n)&&(e.replace?t.replace(o,Vo):t.push(o,Vo))},b={click:No};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var E={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:i,route:s,navigate:v,isActive:l[p],isExactActive:l[u]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)E.on=b,E.attrs={href:i,"aria-current":f};else{var x=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var w=x.data=eo({},x.data);for(var j in w.on=w.on||{},w.on){var T=w.on[j];j in b&&(w.on[j]=Array.isArray(T)?T:[T])}for(var B in b)B in w.on?w.on[B].push(b[B]):w.on[B]=v;var A=x.data.attrs=eo({},x.data.attrs);A.href=i,A["aria-current"]=f}else E.on=b}return n(this.tag,E,this.$slots.default)}};function No(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Zo="undefined"!=typeof window;function $o(n,e,t,r,a){var o=e||[],s=t||Object.create(null),i=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,s){var i=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return jo(e.path+"/"+n)}(i,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var h={path:d,regex:Yo(d,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=s?jo(s+"/"+a.path):void 0;n(e,t,r,a,h,o)}));t[h.path]||(e.push(h.path),t[h.path]=h);if(void 0!==a.alias)for(var m=Array.isArray(a.alias)?a.alias:[a.alias],p=0;p<m.length;++p){0;var u={path:m[p],children:a.children};n(e,t,r,u,o,h.path||"/")}l&&(r[l]||(r[l]=h))}(o,s,i,n,a)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:s,nameMap:i}}function Yo(n,e){return Bo(n,[],e)}function Xo(n,e){var t=$o(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function s(n,t,s){var i=Wo(n,t,!1,e),c=i.name;if(c){var d=o[c];if(!d)return l(null,i);var h=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof i.params&&(i.params={}),t&&"object"==typeof t.params)for(var m in t.params)!(m in i.params)&&h.indexOf(m)>-1&&(i.params[m]=t.params[m]);return i.path=Oo(d.path,i.params),l(d,i,s)}if(i.path){i.params={};for(var p=0;p<r.length;p++){var u=r[p],g=a[u];if(Jo(g.regex,i.path,i.params))return l(g,i,s)}}return l(null,i)}function i(n,t){var r=n.redirect,a="function"==typeof r?r(mo(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var i=a,c=i.name,d=i.path,h=t.query,m=t.hash,p=t.params;if(h=i.hasOwnProperty("query")?i.query:h,m=i.hasOwnProperty("hash")?i.hash:m,p=i.hasOwnProperty("params")?i.params:p,c){o[c];return s({_normalized:!0,name:c,query:h,hash:m,params:p},void 0,t)}if(d){var u=function(n,e){return wo(n,e.parent?e.parent.path:"/",!0)}(d,n);return s({_normalized:!0,path:Oo(u,p),query:h,hash:m},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?i(n,r||t):n&&n.matchAs?function(n,e,t){var r=s({_normalized:!0,path:Oo(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):mo(n,t,r,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;$o([e||n],r,a,o,t),t&&t.alias.length&&$o(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,o,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){$o(n,r,a,o)}}}function Jo(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var s=n.keys[a-1];s&&(t[s.name||"pathMatch"]="string"==typeof r[a]?so(r[a]):r[a])}return!0}var Ko=Zo&&window.performance&&window.performance.now?window.performance:Date;function Qo(){return Ko.now().toFixed(3)}var ns=Qo();function es(){return ns}function ts(n){return ns=n}var rs=Object.create(null);function as(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=eo({},window.history.state);return t.key=es(),window.history.replaceState(t,"",e),window.addEventListener("popstate",is),function(){window.removeEventListener("popstate",is)}}function os(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=es();if(n)return rs[n]}(),s=a.call(n,e,t,r?o:null);s&&("function"==typeof s.then?s.then((function(n){ms(n,o)})).catch((function(n){0})):ms(s,o))}))}}function ss(){var n=es();n&&(rs[n]={x:window.pageXOffset,y:window.pageYOffset})}function is(n){ss(),n.state&&n.state.key&&ts(n.state.key)}function ls(n){return ds(n.x)||ds(n.y)}function cs(n){return{x:ds(n.x)?n.x:window.pageXOffset,y:ds(n.y)?n.y:window.pageYOffset}}function ds(n){return"number"==typeof n}var hs=/^#\d/;function ms(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=hs.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:ds((t=o).x)?t.x:0,y:ds(t.y)?t.y:0})}else ls(n)&&(e=cs(n))}else r&&ls(n)&&(e=cs(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ps,us=Zo&&((-1===(ps=window.navigator.userAgent).indexOf("Android 2.")&&-1===ps.indexOf("Android 4.0")||-1===ps.indexOf("Mobile Safari")||-1!==ps.indexOf("Chrome")||-1!==ps.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function gs(n,e){ss();var t=window.history;try{if(e){var r=eo({},t.state);r.key=es(),t.replaceState(r,"",n)}else t.pushState({key:ts(Qo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function fs(n){gs(n,!0)}var vs={redirected:2,aborted:4,cancelled:8,duplicated:16};function bs(n,e){return ys(n,e,vs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return xs.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Es(n,e){return ys(n,e,vs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ys(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var xs=["params","query","hash"];function ws(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function js(n,e){return ws(n)&&n._isRouter&&(null==e||n.type===e)}function Ts(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}function Bs(n){return function(e,t,r){var a=!1,o=0,s=null;As(n,(function(n,e,t,i){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=Cs((function(e){var a;((a=e).__esModule||zs&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Uo.extend(e),t.components[i]=e,--o<=0&&r()})),d=Cs((function(n){var e="Failed to resolve async component "+i+": "+n;s||(s=ws(n)?n:new Error(e),r(s))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var h=l.component;h&&"function"==typeof h.then&&h.then(c,d)}}})),a||r()}}function As(n,e){return Ss(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ss(n){return Array.prototype.concat.apply([],n)}var zs="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Cs(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Ps=function(n,e){this.router=n,this.base=function(n){if(!n)if(Zo){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=uo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ks(n,e,t,r){var a=As(n,(function(n,r,a,o){var s=function(n,e){"function"!=typeof n&&(n=Uo.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,r,a,o)})):t(s,r,a,o)}));return Ss(r?a.reverse():a)}function Is(n,e){if(e)return function(){return n.apply(e,arguments)}}Ps.prototype.listen=function(n){this.cb=n},Ps.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ps.prototype.onError=function(n){this.errorCbs.push(n)},Ps.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(js(n,vs.redirected)&&o===uo||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ps.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o,s,i=function(n){!js(n)&&ws(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(vo(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&os(this.router,a,n,!1),i(((s=ys(o=a,n,vs.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",s));var d=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),h=d.updated,m=d.deactivated,p=d.activated,u=[].concat(function(n){return ks(n,"beforeRouteLeave",Is,!0)}(m),this.router.beforeHooks,function(n){return ks(n,"beforeRouteUpdate",Is)}(h),p.map((function(n){return n.beforeEnter})),Bs(p)),g=function(e,t){if(r.pending!==n)return i(Es(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),i(function(n,e){return ys(n,e,vs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):ws(e)?(r.ensureURL(!0),i(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(i(bs(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){i(n)}};Ts(u,g,(function(){Ts(function(n){return ks(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(p).concat(r.router.resolveHooks),g,(function(){if(r.pending!==n)return i(Es(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Eo(n)}))}))}))},Ps.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ps.prototype.setupListeners=function(){},Ps.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=uo,this.pending=null};var Ms=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Rs(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=us&&t;r&&this.listeners.push(as());var a=function(){var t=n.current,a=Rs(n.base);n.current===uo&&a===n._startLocation||n.transitionTo(a,(function(n){r&&os(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){gs(jo(r.base+n.fullPath)),os(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){fs(jo(r.base+n.fullPath)),os(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Rs(this.base)!==this.current.fullPath){var e=jo(this.base+this.current.fullPath);n?gs(e):fs(e)}},e.prototype.getCurrentLocation=function(){return Rs(this.base)},e}(Ps);function Rs(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(jo(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ls=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Rs(n);if(!/^\/#/.test(e))return window.location.replace(jo(n+"/#"+e)),!0}(this.base)||Hs()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=us&&e;t&&this.listeners.push(as());var r=function(){var e=n.current;Hs()&&n.transitionTo(_s(),(function(r){t&&os(n.router,r,e,!0),us||Fs(r.fullPath)}))},a=us?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Gs(n.fullPath),os(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Fs(n.fullPath),os(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;_s()!==e&&(n?Gs(e):Fs(e))},e.prototype.getCurrentLocation=function(){return _s()},e}(Ps);function Hs(){var n=_s();return"/"===n.charAt(0)||(Fs("/"+n),!1)}function _s(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ds(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Gs(n){us?gs(Ds(n)):window.location.hash=n}function Fs(n){us?fs(Ds(n)):window.location.replace(Ds(n))}var Os=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){js(n,vs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ps),Ws=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Xo(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!us&&!1!==n.fallback,this.fallback&&(e="hash"),Zo||(e="abstract"),this.mode=e,e){case"history":this.history=new Ms(this,n.base);break;case"hash":this.history=new Ls(this,n.base,this.fallback);break;case"abstract":this.history=new Os(this,n.base);break;default:0}},Us={currentRoute:{configurable:!0}};Ws.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Us.currentRoute.get=function(){return this.history&&this.history.current},Ws.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Ms||t instanceof Ls){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;us&&a&&"fullPath"in n&&os(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ws.prototype.beforeEach=function(n){return qs(this.beforeHooks,n)},Ws.prototype.beforeResolve=function(n){return qs(this.resolveHooks,n)},Ws.prototype.afterEach=function(n){return qs(this.afterHooks,n)},Ws.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ws.prototype.onError=function(n){this.history.onError(n)},Ws.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Ws.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ws.prototype.go=function(n){this.history.go(n)},Ws.prototype.back=function(){this.go(-1)},Ws.prototype.forward=function(){this.go(1)},Ws.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ws.prototype.resolve=function(n,e,t){var r=Wo(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?jo(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},Ws.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ws.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==uo&&this.history.transitionTo(this.history.getCurrentLocation())},Ws.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==uo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ws.prototype,Us);var Vs=Ws;function qs(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ws.install=function n(e){if(!n.installed||Uo!==e){n.installed=!0,Uo=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yo),e.component("RouterLink",qo);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Ws.version="3.6.5",Ws.isNavigationFailure=js,Ws.NavigationFailureType=vs,Ws.START_LOCATION=uo,Zo&&window.Vue&&window.Vue.use(Ws);t(104);t(16),t(130);var Ns={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,332)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,331))},Zs={"v-59a1b962":()=>t.e(6).then(t.bind(null,333)),"v-00662320":()=>t.e(8).then(t.bind(null,334)),"v-08114dcc":()=>t.e(10).then(t.bind(null,335)),"v-1de226ea":()=>t.e(9).then(t.bind(null,336)),"v-6d6dd174":()=>t.e(12).then(t.bind(null,337)),"v-739ad686":()=>t.e(13).then(t.bind(null,338)),"v-f61c8362":()=>t.e(14).then(t.bind(null,339)),"v-6d376c5c":()=>t.e(11).then(t.bind(null,340)),"v-18d00a90":()=>t.e(15).then(t.bind(null,341)),"v-7deb3ce7":()=>t.e(17).then(t.bind(null,342)),"v-19f32a6c":()=>t.e(16).then(t.bind(null,343)),"v-2abb3539":()=>t.e(18).then(t.bind(null,344)),"v-5588bc62":()=>t.e(19).then(t.bind(null,345)),"v-e64fd4e6":()=>t.e(21).then(t.bind(null,346)),"v-0ab12fef":()=>t.e(23).then(t.bind(null,347)),"v-53d6f011":()=>t.e(22).then(t.bind(null,348)),"v-88d78922":()=>t.e(24).then(t.bind(null,349)),"v-67300f90":()=>t.e(25).then(t.bind(null,350)),"v-c9691bd2":()=>t.e(20).then(t.bind(null,351)),"v-5298ab40":()=>t.e(26).then(t.bind(null,352)),"v-1fdb2764":()=>t.e(27).then(t.bind(null,353)),"v-0ee268b4":()=>t.e(29).then(t.bind(null,354)),"v-b5d04e02":()=>t.e(28).then(t.bind(null,355)),"v-7210a980":()=>t.e(30).then(t.bind(null,356)),"v-71604a53":()=>t.e(31).then(t.bind(null,357)),"v-80a6d188":()=>t.e(32).then(t.bind(null,358)),"v-9b5795f0":()=>t.e(33).then(t.bind(null,359)),"v-57a088ec":()=>t.e(34).then(t.bind(null,360)),"v-683c0a08":()=>t.e(35).then(t.bind(null,361)),"v-29e07cd8":()=>t.e(36).then(t.bind(null,362)),"v-86a14178":()=>t.e(37).then(t.bind(null,363)),"v-3e8fbd2b":()=>t.e(7).then(t.bind(null,364)),"v-57fafbfe":()=>t.e(38).then(t.bind(null,365)),"v-202ce318":()=>t.e(39).then(t.bind(null,366)),"v-10922bc2":()=>t.e(40).then(t.bind(null,367)),"v-721d6ab3":()=>t.e(42).then(t.bind(null,368)),"v-bd1646ee":()=>t.e(43).then(t.bind(null,369)),"v-17c7c929":()=>t.e(41).then(t.bind(null,370)),"v-0c3f3d1c":()=>t.e(44).then(t.bind(null,371)),"v-580f06fa":()=>t.e(45).then(t.bind(null,372)),"v-2d2ee09c":()=>t.e(46).then(t.bind(null,373)),"v-f3679942":()=>t.e(47).then(t.bind(null,374)),"v-20bef0e8":()=>t.e(48).then(t.bind(null,375)),"v-8030b53e":()=>t.e(49).then(t.bind(null,376)),"v-50155d20":()=>t.e(50).then(t.bind(null,377)),"v-64ed261a":()=>t.e(51).then(t.bind(null,378)),"v-7dc03fae":()=>t.e(52).then(t.bind(null,379)),"v-6aa1157e":()=>t.e(53).then(t.bind(null,380)),"v-797cc37a":()=>t.e(54).then(t.bind(null,381)),"v-031f2e1d":()=>t.e(55).then(t.bind(null,382)),"v-250291f2":()=>t.e(56).then(t.bind(null,383)),"v-0672af9c":()=>t.e(57).then(t.bind(null,384)),"v-6e3447f4":()=>t.e(58).then(t.bind(null,385)),"v-3cd97688":()=>t.e(59).then(t.bind(null,386)),"v-4c46d3c6":()=>t.e(60).then(t.bind(null,387)),"v-54146766":()=>t.e(61).then(t.bind(null,388)),"v-c0905f02":()=>t.e(62).then(t.bind(null,389)),"v-0d2bc02d":()=>t.e(63).then(t.bind(null,390)),"v-5c2c5da4":()=>t.e(64).then(t.bind(null,391)),"v-54d533e0":()=>t.e(65).then(t.bind(null,392)),"v-3411a9fe":()=>t.e(66).then(t.bind(null,393)),"v-88d3b7ec":()=>t.e(67).then(t.bind(null,394)),"v-7ca9b8a2":()=>t.e(68).then(t.bind(null,395)),"v-7b3457a0":()=>t.e(69).then(t.bind(null,396)),"v-fe4e97a4":()=>t.e(70).then(t.bind(null,397)),"v-ab57bc80":()=>t.e(71).then(t.bind(null,398)),"v-11dd13bf":()=>t.e(72).then(t.bind(null,399)),"v-054810aa":()=>t.e(74).then(t.bind(null,400)),"v-6cc27f7d":()=>t.e(75).then(t.bind(null,401)),"v-e4723f4c":()=>t.e(73).then(t.bind(null,402)),"v-1df7f180":()=>t.e(76).then(t.bind(null,403)),"v-39711157":()=>t.e(77).then(t.bind(null,404)),"v-698761d4":()=>t.e(78).then(t.bind(null,405)),"v-4e79869f":()=>t.e(79).then(t.bind(null,406)),"v-7f3230f8":()=>t.e(80).then(t.bind(null,407)),"v-d5d385d8":()=>t.e(81).then(t.bind(null,408)),"v-544a2f3c":()=>t.e(82).then(t.bind(null,409)),"v-d79514d0":()=>t.e(83).then(t.bind(null,410)),"v-5f9a68e8":()=>t.e(84).then(t.bind(null,411)),"v-4c63bba6":()=>t.e(85).then(t.bind(null,412)),"v-04bb1726":()=>t.e(86).then(t.bind(null,413)),"v-f58673ce":()=>t.e(87).then(t.bind(null,414)),"v-ab1a91e8":()=>t.e(88).then(t.bind(null,415)),"v-4505f054":()=>t.e(89).then(t.bind(null,416)),"v-56bb56bc":()=>t.e(90).then(t.bind(null,417)),"v-c60820fa":()=>t.e(91).then(t.bind(null,418)),"v-7ab36901":()=>t.e(93).then(t.bind(null,419)),"v-7f63d78b":()=>t.e(92).then(t.bind(null,420)),"v-0d6eb080":()=>t.e(94).then(t.bind(null,421)),"v-b870ab44":()=>t.e(95).then(t.bind(null,422)),"v-09e41a95":()=>t.e(96).then(t.bind(null,423)),"v-19d3bbba":()=>t.e(97).then(t.bind(null,424)),"v-50cd75e2":()=>t.e(98).then(t.bind(null,425)),"v-2eff5cbc":()=>t.e(99).then(t.bind(null,426)),"v-40cdcbcf":()=>t.e(100).then(t.bind(null,427)),"v-63702f6b":()=>t.e(101).then(t.bind(null,428)),"v-a9c900fe":()=>t.e(102).then(t.bind(null,429)),"v-5e7950d8":()=>t.e(103).then(t.bind(null,430)),"v-083e2755":()=>t.e(104).then(t.bind(null,431)),"v-d8c63b20":()=>t.e(105).then(t.bind(null,432)),"v-cfd35e92":()=>t.e(106).then(t.bind(null,433)),"v-28edb3fc":()=>t.e(107).then(t.bind(null,434)),"v-48577124":()=>t.e(108).then(t.bind(null,435)),"v-33f176a4":()=>t.e(109).then(t.bind(null,436)),"v-6d7a8eb7":()=>t.e(110).then(t.bind(null,437)),"v-18a3e02e":()=>t.e(111).then(t.bind(null,438)),"v-0732c0e2":()=>t.e(112).then(t.bind(null,439)),"v-8afc710a":()=>t.e(113).then(t.bind(null,440)),"v-0ab635d8":()=>t.e(114).then(t.bind(null,441)),"v-26ffe15a":()=>t.e(115).then(t.bind(null,442)),"v-347f5f9f":()=>t.e(116).then(t.bind(null,443)),"v-5c3633ad":()=>t.e(117).then(t.bind(null,444)),"v-a5dd4774":()=>t.e(118).then(t.bind(null,445)),"v-f6b64df4":()=>t.e(119).then(t.bind(null,446)),"v-2a39b6e4":()=>t.e(121).then(t.bind(null,447)),"v-36a594f2":()=>t.e(120).then(t.bind(null,448)),"v-5a5e0b82":()=>t.e(122).then(t.bind(null,449)),"v-4f8bdade":()=>t.e(123).then(t.bind(null,450)),"v-44f45938":()=>t.e(125).then(t.bind(null,451)),"v-3a585300":()=>t.e(126).then(t.bind(null,452)),"v-41dffdd4":()=>t.e(124).then(t.bind(null,453)),"v-f21ec9e0":()=>t.e(127).then(t.bind(null,454)),"v-7fcce397":()=>t.e(129).then(t.bind(null,455)),"v-0853d625":()=>t.e(128).then(t.bind(null,456)),"v-6e8891b6":()=>t.e(130).then(t.bind(null,457)),"v-1529c538":()=>t.e(131).then(t.bind(null,458)),"v-58d55029":()=>t.e(132).then(t.bind(null,459)),"v-36e902b0":()=>t.e(133).then(t.bind(null,460)),"v-0b069e57":()=>t.e(134).then(t.bind(null,461)),"v-281b710e":()=>t.e(135).then(t.bind(null,462)),"v-48b62e34":()=>t.e(137).then(t.bind(null,463)),"v-b8bc7f42":()=>t.e(138).then(t.bind(null,464)),"v-7a6b5bc6":()=>t.e(136).then(t.bind(null,465)),"v-5c5e9bdc":()=>t.e(139).then(t.bind(null,466)),"v-a691e0fc":()=>t.e(141).then(t.bind(null,467)),"v-505a04dd":()=>t.e(142).then(t.bind(null,468)),"v-20360617":()=>t.e(144).then(t.bind(null,469)),"v-a5230b16":()=>t.e(140).then(t.bind(null,470)),"v-bb92678c":()=>t.e(143).then(t.bind(null,471)),"v-4b104e94":()=>t.e(146).then(t.bind(null,472)),"v-596ce778":()=>t.e(145).then(t.bind(null,473)),"v-af3ef6e0":()=>t.e(147).then(t.bind(null,474)),"v-442556e6":()=>t.e(148).then(t.bind(null,475)),"v-a0685c18":()=>t.e(150).then(t.bind(null,476)),"v-23d9bdae":()=>t.e(151).then(t.bind(null,477)),"v-444b2197":()=>t.e(149).then(t.bind(null,478)),"v-04884aa9":()=>t.e(152).then(t.bind(null,479)),"v-4a7931ea":()=>t.e(154).then(t.bind(null,480)),"v-30f87000":()=>t.e(153).then(t.bind(null,481)),"v-a449bf94":()=>t.e(155).then(t.bind(null,482)),"v-2bbec22a":()=>t.e(156).then(t.bind(null,483)),"v-64040a28":()=>t.e(157).then(t.bind(null,484)),"v-04470b50":()=>t.e(158).then(t.bind(null,485)),"v-26245688":()=>t.e(160).then(t.bind(null,486)),"v-37c2a0b8":()=>t.e(159).then(t.bind(null,487)),"v-4bf5cab4":()=>t.e(162).then(t.bind(null,488)),"v-3eb105a6":()=>t.e(161).then(t.bind(null,489)),"v-6028f147":()=>t.e(163).then(t.bind(null,490)),"v-1d2a71f8":()=>t.e(164).then(t.bind(null,491)),"v-b55eba40":()=>t.e(165).then(t.bind(null,492)),"v-4e113527":()=>t.e(166).then(t.bind(null,493)),"v-0ab7f00c":()=>t.e(167).then(t.bind(null,494)),"v-384d9b66":()=>t.e(169).then(t.bind(null,495)),"v-773576a7":()=>t.e(170).then(t.bind(null,496)),"v-3996c29d":()=>t.e(168).then(t.bind(null,497)),"v-551bde42":()=>t.e(171).then(t.bind(null,498)),"v-a8f143e2":()=>t.e(172).then(t.bind(null,499)),"v-b17d2f24":()=>t.e(173).then(t.bind(null,500)),"v-1db0392e":()=>t.e(175).then(t.bind(null,501)),"v-9c41d56c":()=>t.e(174).then(t.bind(null,502)),"v-8b41caee":()=>t.e(176).then(t.bind(null,503)),"v-41afb39f":()=>t.e(177).then(t.bind(null,504)),"v-57df0166":()=>t.e(178).then(t.bind(null,505)),"v-7d387f1c":()=>t.e(179).then(t.bind(null,506)),"v-6333d9f8":()=>t.e(180).then(t.bind(null,507)),"v-0a966bc7":()=>t.e(181).then(t.bind(null,508)),"v-0e2ab762":()=>t.e(182).then(t.bind(null,509)),"v-2287542e":()=>t.e(183).then(t.bind(null,510)),"v-f13a2722":()=>t.e(184).then(t.bind(null,511)),"v-1672bc36":()=>t.e(186).then(t.bind(null,512)),"v-18951d86":()=>t.e(185).then(t.bind(null,513)),"v-54519bd0":()=>t.e(188).then(t.bind(null,514)),"v-763b4e35":()=>t.e(189).then(t.bind(null,515)),"v-740abe3c":()=>t.e(187).then(t.bind(null,516)),"v-4217aa3d":()=>t.e(190).then(t.bind(null,517)),"v-5195a875":()=>t.e(191).then(t.bind(null,518)),"v-22a792ce":()=>t.e(193).then(t.bind(null,519)),"v-0717c793":()=>t.e(194).then(t.bind(null,520)),"v-1f67061d":()=>t.e(192).then(t.bind(null,521)),"v-a2b567ae":()=>t.e(195).then(t.bind(null,522)),"v-64b14f88":()=>t.e(196).then(t.bind(null,523)),"v-5c0fecb8":()=>t.e(197).then(t.bind(null,524)),"v-63de3e24":()=>t.e(198).then(t.bind(null,525)),"v-8eb408b8":()=>t.e(199).then(t.bind(null,526)),"v-4332b628":()=>t.e(201).then(t.bind(null,527)),"v-05494578":()=>t.e(200).then(t.bind(null,528)),"v-803ffe94":()=>t.e(202).then(t.bind(null,529)),"v-57df0643":()=>t.e(203).then(t.bind(null,530)),"v-7c9b722a":()=>t.e(204).then(t.bind(null,531)),"v-2f97d739":()=>t.e(205).then(t.bind(null,532)),"v-3ca61054":()=>t.e(206).then(t.bind(null,533)),"v-e00e8ad8":()=>t.e(207).then(t.bind(null,534)),"v-625ca383":()=>t.e(208).then(t.bind(null,535)),"v-c98105f0":()=>t.e(209).then(t.bind(null,536)),"v-744c40be":()=>t.e(210).then(t.bind(null,537)),"v-18333ca2":()=>t.e(211).then(t.bind(null,538)),"v-9709b4ce":()=>t.e(212).then(t.bind(null,539)),"v-49244fca":()=>t.e(213).then(t.bind(null,540)),"v-bdf3a312":()=>t.e(214).then(t.bind(null,541)),"v-c22b68d6":()=>t.e(215).then(t.bind(null,542)),"v-0d5aab1a":()=>t.e(216).then(t.bind(null,543)),"v-2e90a37d":()=>t.e(217).then(t.bind(null,544)),"v-ec6f9786":()=>t.e(218).then(t.bind(null,545)),"v-f5e61cc8":()=>t.e(220).then(t.bind(null,546)),"v-1e2bcf16":()=>t.e(219).then(t.bind(null,547)),"v-76f03d60":()=>t.e(223).then(t.bind(null,548)),"v-580c898f":()=>t.e(224).then(t.bind(null,549)),"v-0c4a5c5c":()=>t.e(225).then(t.bind(null,550)),"v-25637300":()=>t.e(222).then(t.bind(null,551)),"v-0f889bbc":()=>t.e(226).then(t.bind(null,552)),"v-949d0b96":()=>t.e(227).then(t.bind(null,553)),"v-2c6a8a39":()=>t.e(221).then(t.bind(null,554)),"v-692d0a85":()=>t.e(228).then(t.bind(null,555)),"v-a8d65390":()=>t.e(229).then(t.bind(null,556)),"v-c1efc94c":()=>t.e(230).then(t.bind(null,557)),"v-7cebfb4f":()=>t.e(231).then(t.bind(null,558)),"v-1e96b2cc":()=>t.e(233).then(t.bind(null,559)),"v-3c4463d4":()=>t.e(232).then(t.bind(null,560)),"v-58412606":()=>t.e(234).then(t.bind(null,561)),"v-31b2dbbf":()=>t.e(235).then(t.bind(null,562)),"v-555d9eed":()=>t.e(237).then(t.bind(null,563)),"v-047aa23a":()=>t.e(236).then(t.bind(null,564)),"v-5c0d32fb":()=>t.e(238).then(t.bind(null,565)),"v-301a465c":()=>t.e(239).then(t.bind(null,566)),"v-6da97d6b":()=>t.e(240).then(t.bind(null,567)),"v-75e4b124":()=>t.e(241).then(t.bind(null,568)),"v-c11250be":()=>t.e(242).then(t.bind(null,569)),"v-26882685":()=>t.e(243).then(t.bind(null,570)),"v-4871c65a":()=>t.e(244).then(t.bind(null,571)),"v-a7e2a9c6":()=>t.e(246).then(t.bind(null,572)),"v-0b4ab0f6":()=>t.e(245).then(t.bind(null,573)),"v-6908b822":()=>t.e(248).then(t.bind(null,574)),"v-21a84a04":()=>t.e(247).then(t.bind(null,575)),"v-0dd532f8":()=>t.e(249).then(t.bind(null,576)),"v-a994a3e0":()=>t.e(250).then(t.bind(null,577)),"v-6fda0888":()=>t.e(251).then(t.bind(null,578)),"v-947d9400":()=>t.e(252).then(t.bind(null,579)),"v-139fa962":()=>t.e(254).then(t.bind(null,580)),"v-71cb85e4":()=>t.e(253).then(t.bind(null,581)),"v-b72d140e":()=>t.e(255).then(t.bind(null,582)),"v-4ebeb0e4":()=>t.e(256).then(t.bind(null,583)),"v-27b0f8bf":()=>t.e(257).then(t.bind(null,584)),"v-177bce0e":()=>t.e(258).then(t.bind(null,585)),"v-6c478b4f":()=>t.e(259).then(t.bind(null,586)),"v-1c8eca98":()=>t.e(260).then(t.bind(null,587)),"v-4b050e8e":()=>t.e(261).then(t.bind(null,588)),"v-d98b1d80":()=>t.e(262).then(t.bind(null,589)),"v-483f6004":()=>t.e(263).then(t.bind(null,590)),"v-735dd117":()=>t.e(264).then(t.bind(null,591)),"v-d0089e5a":()=>t.e(265).then(t.bind(null,592)),"v-57c2ccdc":()=>t.e(266).then(t.bind(null,593)),"v-3f8b08d1":()=>t.e(267).then(t.bind(null,594)),"v-e9796ed4":()=>t.e(269).then(t.bind(null,595)),"v-5febe29d":()=>t.e(268).then(t.bind(null,596)),"v-5c2b4d06":()=>t.e(270).then(t.bind(null,597)),"v-2f525902":()=>t.e(271).then(t.bind(null,598)),"v-650e89cc":()=>t.e(273).then(t.bind(null,599)),"v-13085dfb":()=>t.e(272).then(t.bind(null,600)),"v-2dac77a6":()=>t.e(274).then(t.bind(null,601)),"v-3f3ba29a":()=>t.e(278).then(t.bind(null,602)),"v-42bac2c6":()=>t.e(277).then(t.bind(null,603)),"v-4e577efe":()=>t.e(279).then(t.bind(null,604)),"v-50c7990a":()=>t.e(276).then(t.bind(null,605)),"v-07a4d46e":()=>t.e(280).then(t.bind(null,606)),"v-79c7025f":()=>t.e(281).then(t.bind(null,607)),"v-09c2f018":()=>t.e(282).then(t.bind(null,608)),"v-b352d932":()=>t.e(284).then(t.bind(null,609)),"v-42ec0e6e":()=>t.e(283).then(t.bind(null,610)),"v-0d1e30f7":()=>t.e(275).then(t.bind(null,611)),"v-18ffc03d":()=>t.e(285).then(t.bind(null,612)),"v-63e0f928":()=>t.e(286).then(t.bind(null,613)),"v-d9f794c4":()=>t.e(287).then(t.bind(null,614)),"v-53fb374d":()=>t.e(288).then(t.bind(null,615)),"v-b35f1826":()=>t.e(289).then(t.bind(null,616)),"v-25fafc76":()=>t.e(290).then(t.bind(null,617)),"v-37e75448":()=>t.e(291).then(t.bind(null,618)),"v-5e46ee5e":()=>t.e(292).then(t.bind(null,619)),"v-720cbfa2":()=>t.e(293).then(t.bind(null,620)),"v-6e1e280a":()=>t.e(294).then(t.bind(null,621)),"v-0d65b539":()=>t.e(295).then(t.bind(null,622)),"v-1bed40a5":()=>t.e(296).then(t.bind(null,623)),"v-0e429eca":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,624))};function $s(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ys=/-(\w)/g,Xs=$s(n=>n.replace(Ys,(n,e)=>e?e.toUpperCase():"")),Js=/\B([A-Z])/g,Ks=$s(n=>n.replace(Js,"-$1").toLowerCase()),Qs=$s(n=>n.charAt(0).toUpperCase()+n.slice(1));function ni(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Qs(Xs(e))):n(Qs(e))||n(Ks(e))}const ei=Object.assign({},Ns,Zs),ti=n=>ei[n],ri=n=>Zs[n],ai=n=>Ns[n],oi=n=>Nt.component(n);function si(n){return ni(ri,n)}function ii(n){return ni(ai,n)}function li(n){return ni(ti,n)}function ci(n){return ni(oi,n)}function di(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!ci(n)&&li(n)){const e=await li(n)();Nt.component(n,e.default)}}))}function hi(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var mi=t(92),pi=t.n(mi),ui=t(93),gi=t.n(ui),fi={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${gi()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bi(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=Ei(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return pi()([{name:"description",content:this.$description}],n,this.siteMeta,yi)},updateCanonicalLink(){vi(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bi(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){Ei(null,this.currentMetaTags),vi()}};function vi(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bi(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function Ei(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function yi(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var xi=t(50),wi={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(xi)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],s=e[n+1],i=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(i&&l!==decodeURIComponent(o.hash)){const t=o;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ji=t(24),Ti=t.n(ji),Bi={mounted(){Ti.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Nt.component(n.name)||Ti.a.start(),t()}),this.$router.afterEach(()=>{Ti.a.done(),this.isSidebarOpen=!1})}};t(239),t(240);class Ai{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Si={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ai).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var zi={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Ci={},Pi=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},ki=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:zi[n]},Ii=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,o=e.children;a.appendChild(n(t,r,o))})),a},Mi=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},Ri=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),s=n.match(/<script>([\s\S]+)<\/script>/),i={css:a&&a[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:s&&s[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};i.htmlTpl=Pi(i.html),i.jsTpl=(t=i.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),i.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](a);return o.template=e,o}(i.js,i.html);var l=ki("vue");return i.jsLib.unshift(l),i},Li=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return s.htmlTpl=s.html,s.jsTpl=s.js,s.script=(t=s.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),s},Hi=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function _i(){var n=Mi(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Mi(n,"vuepress-plugin-demo-block__code"),t=Mi(n,"vuepress-plugin-demo-block__display"),r=Mi(n,"vuepress-plugin-demo-block__footer"),a=Mi(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),s=decodeURIComponent(n.dataset.config),i=decodeURIComponent(n.dataset.type);s=s?JSON.parse(s):{};var l=e.querySelector("div").clientHeight,c="react"===i?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),o={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Hi(n),htmlTpl:Pi("")},s=ki("react"),i=ki("reactDOM");return o.jsLib.unshift(s,i),o}(o,s):"vanilla"===i?Li(o,s):Ri(o,s),d=Ii("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(d),d.addEventListener("click",Di.bind(null,d,l,e,r)),ki("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,s=a.concat(o).concat(ki("cssLib")).concat(ki("jsLib")).join(",");return Ii("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:s}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),ki("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,s=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(ki("jsLib")).join(";"),css_external:o.concat(ki("cssLib")).join(";"),layout:ki("codepenLayout"),js_pre_processor:ki("codepenJsProcessor"),editors:ki("codepenEditors")});return Ii("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:s}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==s.horizontal?s.horizontal:ki("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var h=e.firstChild.cloneNode(!0);h.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(h)}if(c.css&&function(n){if(!Ci[n]){var e=Ii("style",{innerHTML:n});document.body.appendChild(e),Ci[n]=!0}}(c.css),"react"===i)ReactDOM.render(React.createElement(c.js),a);else if("vue"===i){var m=(new(Vue.extend(c.script))).$mount();a.appendChild(m.$el)}else"vanilla"===i&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){_i()}),300)}function Di(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var Gi={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},_i()},updated:function(){_i()}},Fi="auto",Oi="zoom-in",Wi="zoom-out",Ui="grab",Vi="move";function qi(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Ni(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Zi(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function $i(n,e,t){!function(n){var e=Yi,t=Xi;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var o in e)t&&(a[o]=r[o]||""),r[o]=e[o];return a}var Yi="transition",Xi="transform",Ji="transform",Ki="transitionend";var Qi=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Qi,onClose:Qi,onGrab:Qi,onMove:Qi,onRelease:Qi,onBeforeOpen:Qi,onBeforeClose:Qi,onBeforeGrab:Qi,onBeforeRelease:Qi,onImageLoading:Qi,onImageLoaded:Qi},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),rl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(a)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!rl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!rl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function rl(n){return n.metaKey||n.ctrlKey}var al={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,$i(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),qi(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){$i(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ol="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},sl=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),il=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Zi(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ui:Wi,transition:Ji+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=$i(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,$i(this.el,{transform:"none"})},grab:function(n,e,t){var r=cl(),a=r.x-n,o=r.y-e;$i(this.el,{cursor:Vi,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=cl(),a=r.x-n,o=r.y-e;$i(this.el,{transition:Ji,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){$i(this.el,this.styleClose)},restoreOpenStyle:function(){$i(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,o=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":ol(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var s=this.rect.width/2,i=this.rect.height/2,l=cl(),c={x:l.x-s,y:l.y-i},d=c.x/s,h=c.y/i,m=o+Math.min(d,h);if(a&&"string"==typeof a){var p=t||this.el.naturalWidth,u=e||this.el.naturalHeight,g=parseFloat(a)*p/(100*this.rect.width),f=parseFloat(a)*u/(100*this.rect.height);if(m>g||m>f)return{x:g,y:f}}return{x:m,y:m}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function dl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){qi(n,r,e[r],t)}))}var hl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(al),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=il({},nl,e),this.overlay.init(this),this.handler.init(this)}return sl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Oi,qi(n,"click",this.handler.click),this.options.preloadImage&&Ni(Zi(n)));return this}},{key:"config",value:function(n){return n?(il(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),Ni(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),qi(document,"scroll",this.handler.scroll),qi(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&qi(window,"resize",this.handler.resizeWindow);var o=function n(){qi(r,Ki,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&dl(document,e.handler,!0),t(r)};return qi(r,Ki,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Fi,this.overlay.fadeOut(),this.target.zoomOut(),qi(document,"scroll",this.handler.scroll,!1),qi(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&qi(window,"resize",this.handler.resizeWindow,!1);var r=function r(){qi(t,Ki,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&dl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return qi(t,Ki,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var o=function n(){qi(a,Ki,n,!1),r(a)};return qi(a,Ki,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Vi,this.target.move(n,e,t);var a=this.target.el,o=function n(){qi(a,Ki,n,!1),r(a)};return qi(a,Ki,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Fi,this.target.restoreOpenStyle();var r=function r(){qi(t,Ki,r,!1),n.lock=!1,n.released=!0,e(t)};return qi(t,Ki,r),this}}}]),n}();const ml=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),pl=Number("500");class ul{constructor(){this.instance=new hl(ml)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=pl){setTimeout(()=>this.update(n),e)}}var gl=[fi,wi,Bi,Si,Gi,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new ul,this.$vuepress.zooming.updateDelay()}}],fl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return hi("layout",n),Nt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vl=t(7),bl=Object(vl.a)(fl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",gl);const El=[{name:"v-59a1b962",path:"/pages/4a14ce/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-59a1b962").then(t)}},{path:"/pages/4a14ce/index.html",redirect:"/pages/4a14ce/"},{path:"/01.Three.js教程/0.0.学前说明/01.课程部分案例3D效果速览.html",redirect:"/pages/4a14ce/"},{name:"v-00662320",path:"/pages/2de1b9/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-00662320").then(t)}},{path:"/pages/2de1b9/index.html",redirect:"/pages/2de1b9/"},{path:"/01.Three.js教程/0.0.学前说明/03.学前基础、如何学习3D.html",redirect:"/pages/2de1b9/"},{name:"v-08114dcc",path:"/pages/336b66/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-08114dcc").then(t)}},{path:"/pages/336b66/index.html",redirect:"/pages/336b66/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/02.学习环境-编辑器和本地静态服务.html",redirect:"/pages/336b66/"},{name:"v-1de226ea",path:"/pages/aac9ab/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1de226ea").then(t)}},{path:"/pages/aac9ab/index.html",redirect:"/pages/aac9ab/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/01.threejs文件包下载和目录简介.html",redirect:"/pages/aac9ab/"},{name:"v-6d6dd174",path:"/pages/2e5d69/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6d6dd174").then(t)}},{path:"/pages/2e5d69/index.html",redirect:"/pages/2e5d69/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/04.第一个3D案例—创建3D场景.html",redirect:"/pages/2e5d69/"},{name:"v-739ad686",path:"/pages/c0b143/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-739ad686").then(t)}},{path:"/pages/c0b143/index.html",redirect:"/pages/c0b143/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/05.第一个3D案例—透视投影相机.html",redirect:"/pages/c0b143/"},{name:"v-f61c8362",path:"/pages/b483f0/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-f61c8362").then(t)}},{path:"/pages/b483f0/index.html",redirect:"/pages/b483f0/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/06.第一个3D案例—渲染器.html",redirect:"/pages/b483f0/"},{name:"v-6d376c5c",path:"/pages/cd35b2/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6d376c5c").then(t)}},{path:"/pages/cd35b2/index.html",redirect:"/pages/cd35b2/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/03.开发和学习环境，引入threejs库.html",redirect:"/pages/cd35b2/"},{name:"v-18d00a90",path:"/pages/6abb06/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-18d00a90").then(t)}},{path:"/pages/6abb06/index.html",redirect:"/pages/6abb06/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/07.Threejs三维坐标系—加强三维空间认识.html",redirect:"/pages/6abb06/"},{name:"v-7deb3ce7",path:"/pages/837374/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7deb3ce7").then(t)}},{path:"/pages/837374/index.html",redirect:"/pages/837374/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/09.相机控件轨道控制器OrbitControls.html",redirect:"/pages/837374/"},{name:"v-19f32a6c",path:"/pages/b9504a/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-19f32a6c").then(t)}},{path:"/pages/b9504a/index.html",redirect:"/pages/b9504a/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/08.光源对物体表面影响.html",redirect:"/pages/b9504a/"},{name:"v-2abb3539",path:"/pages/343ae9/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2abb3539").then(t)}},{path:"/pages/343ae9/index.html",redirect:"/pages/343ae9/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/10.平行光与环境光.html",redirect:"/pages/343ae9/"},{name:"v-5588bc62",path:"/pages/ffe0f4/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5588bc62").then(t)}},{path:"/pages/ffe0f4/index.html",redirect:"/pages/ffe0f4/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/11.动画渲染循环.html",redirect:"/pages/ffe0f4/"},{name:"v-e64fd4e6",path:"/pages/3c9b94/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-e64fd4e6").then(t)}},{path:"/pages/3c9b94/index.html",redirect:"/pages/3c9b94/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/13.stats查看threejs渲染帧率.html",redirect:"/pages/3c9b94/"},{name:"v-0ab12fef",path:"/pages/e04c44/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0ab12fef").then(t)}},{path:"/pages/e04c44/index.html",redirect:"/pages/e04c44/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/15.Threejs常见几何体简介.html",redirect:"/pages/e04c44/"},{name:"v-53d6f011",path:"/pages/2a45ee/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-53d6f011").then(t)}},{path:"/pages/2a45ee/index.html",redirect:"/pages/2a45ee/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/14.阵列立方体和相机适配体验.html",redirect:"/pages/2a45ee/"},{name:"v-88d78922",path:"/pages/2da02c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-88d78922").then(t)}},{path:"/pages/2da02c/index.html",redirect:"/pages/2da02c/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/16.高光网格材质MeshPhongMaterial.html",redirect:"/pages/2da02c/"},{name:"v-67300f90",path:"/pages/f636b8/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-67300f90").then(t)}},{path:"/pages/f636b8/index.html",redirect:"/pages/f636b8/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/17.WebGL渲染器设置(锯齿模糊、背景颜色).html",redirect:"/pages/f636b8/"},{name:"v-c9691bd2",path:"/pages/4e518f/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-c9691bd2").then(t)}},{path:"/pages/4e518f/index.html",redirect:"/pages/4e518f/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/12.Canvas画布布局和全屏.html",redirect:"/pages/4e518f/"},{name:"v-5298ab40",path:"/pages/5005d5/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5298ab40").then(t)}},{path:"/pages/5005d5/index.html",redirect:"/pages/5005d5/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/18.gui.js库(可视化改变三维场景).html",redirect:"/pages/5005d5/"},{name:"v-1fdb2764",path:"/pages/66ce2c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1fdb2764").then(t)}},{path:"/pages/66ce2c/index.html",redirect:"/pages/66ce2c/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/19.gui调试界面2—颜色、命名、步长、事件.html",redirect:"/pages/66ce2c/"},{name:"v-0ee268b4",path:"/pages/2e1b8c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0ee268b4").then(t)}},{path:"/pages/2e1b8c/index.html",redirect:"/pages/2e1b8c/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/21.gui.js库(分组).html",redirect:"/pages/2e1b8c/"},{name:"v-b5d04e02",path:"/pages/0569b5/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-b5d04e02").then(t)}},{path:"/pages/0569b5/index.html",redirect:"/pages/0569b5/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/20.gui调试界面3-下拉菜单、单选框.html",redirect:"/pages/0569b5/"},{name:"v-7210a980",path:"/pages/f1d3dd/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7210a980").then(t)}},{path:"/pages/f1d3dd/index.html",redirect:"/pages/f1d3dd/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/22.查询examples和文档(辅助开发).html",redirect:"/pages/f1d3dd/"},{name:"v-71604a53",path:"/pages/63ce1e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-71604a53").then(t)}},{path:"/pages/63ce1e/index.html",redirect:"/pages/63ce1e/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/23.threejs语法总结.html",redirect:"/pages/63ce1e/"},{name:"v-80a6d188",path:"/pages/637c91/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-80a6d188").then(t)}},{path:"/pages/637c91/index.html",redirect:"/pages/637c91/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/24.【选修】Vue+Threejs开发环境.html",redirect:"/pages/637c91/"},{name:"v-9b5795f0",path:"/pages/d6ce1f/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-9b5795f0").then(t)}},{path:"/pages/d6ce1f/index.html",redirect:"/pages/d6ce1f/"},{path:"/01.Three.js教程/01.1.Three.js快速入门/25.【选修】React+Threejs开发环境.html",redirect:"/pages/d6ce1f/"},{name:"v-57a088ec",path:"/pages/f84ca8/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-57a088ec").then(t)}},{path:"/pages/f84ca8/index.html",redirect:"/pages/f84ca8/"},{path:"/01.Three.js教程/02.2.几何体BufferGeometry/01.几何体顶点位置数据和点模型对象Points.html",redirect:"/pages/f84ca8/"},{name:"v-683c0a08",path:"/pages/ed3be5/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-683c0a08").then(t)}},{path:"/pages/ed3be5/index.html",redirect:"/pages/ed3be5/"},{path:"/01.Three.js教程/02.2.几何体BufferGeometry/02.线模型对象.html",redirect:"/pages/ed3be5/"},{name:"v-29e07cd8",path:"/pages/32785a/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-29e07cd8").then(t)}},{path:"/pages/32785a/index.html",redirect:"/pages/32785a/"},{path:"/01.Three.js教程/02.2.几何体BufferGeometry/03.网格模型(三角形概念).html",redirect:"/pages/32785a/"},{name:"v-86a14178",path:"/pages/6722b2/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-86a14178").then(t)}},{path:"/pages/6722b2/index.html",redirect:"/pages/6722b2/"},{path:"/01.Three.js教程/02.2.几何体BufferGeometry/04.构建一个矩形平面几何体.html",redirect:"/pages/6722b2/"},{name:"v-3e8fbd2b",path:"/pages/a97995/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3e8fbd2b").then(t)}},{path:"/pages/a97995/index.html",redirect:"/pages/a97995/"},{path:"/01.Three.js教程/0.0.学前说明/02.课程特点.html",redirect:"/pages/a97995/"},{name:"v-57fafbfe",path:"/pages/05b687/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-57fafbfe").then(t)}},{path:"/pages/05b687/index.html",redirect:"/pages/05b687/"},{path:"/01.Three.js教程/02.2.几何体BufferGeometry/05.几何体顶点索引数据.html",redirect:"/pages/05b687/"},{name:"v-202ce318",path:"/pages/ff37d3/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-202ce318").then(t)}},{path:"/pages/ff37d3/index.html",redirect:"/pages/ff37d3/"},{path:"/01.Three.js教程/02.2.几何体BufferGeometry/06.顶点法线数据.html",redirect:"/pages/ff37d3/"},{name:"v-10922bc2",path:"/pages/d8b07b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-10922bc2").then(t)}},{path:"/pages/d8b07b/index.html",redirect:"/pages/d8b07b/"},{path:"/01.Three.js教程/02.2.几何体BufferGeometry/07.查看three.js自带几何体顶点结构.html",redirect:"/pages/d8b07b/"},{name:"v-721d6ab3",path:"/pages/440e51/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-721d6ab3").then(t)}},{path:"/pages/440e51/index.html",redirect:"/pages/440e51/"},{path:"/01.Three.js教程/03.3.模型对象、材质/01.三维向量Vector3与模型位置、缩放属性.html",redirect:"/pages/440e51/"},{name:"v-bd1646ee",path:"/pages/cb4e2f/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-bd1646ee").then(t)}},{path:"/pages/cb4e2f/index.html",redirect:"/pages/cb4e2f/"},{path:"/01.Three.js教程/03.3.模型对象、材质/02.欧拉Euler与角度属性.rotation.html",redirect:"/pages/cb4e2f/"},{name:"v-17c7c929",path:"/pages/1b0d6c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-17c7c929").then(t)}},{path:"/pages/1b0d6c/index.html",redirect:"/pages/1b0d6c/"},{path:"/01.Three.js教程/02.2.几何体BufferGeometry/08.BufferGeometry的旋转、缩放、平移方法.html",redirect:"/pages/1b0d6c/"},{name:"v-0c3f3d1c",path:"/pages/ec1682/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0c3f3d1c").then(t)}},{path:"/pages/ec1682/index.html",redirect:"/pages/ec1682/"},{path:"/01.Three.js教程/03.3.模型对象、材质/03.模型材质颜色(Color对象).html",redirect:"/pages/ec1682/"},{name:"v-580f06fa",path:"/pages/24c407/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-580f06fa").then(t)}},{path:"/pages/24c407/index.html",redirect:"/pages/24c407/"},{path:"/01.Three.js教程/03.3.模型对象、材质/04.模型材质父类Material.html",redirect:"/pages/24c407/"},{name:"v-2d2ee09c",path:"/pages/091565/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2d2ee09c").then(t)}},{path:"/pages/091565/index.html",redirect:"/pages/091565/"},{path:"/01.Three.js教程/03.3.模型对象、材质/05.模型材质和几何体属性.html",redirect:"/pages/091565/"},{name:"v-f3679942",path:"/pages/186303/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-f3679942").then(t)}},{path:"/pages/186303/index.html",redirect:"/pages/186303/"},{path:"/01.Three.js教程/03.3.模型对象、材质/06.克隆.clone()和复制.copy().html",redirect:"/pages/186303/"},{name:"v-20bef0e8",path:"/pages/c86096/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-20bef0e8").then(t)}},{path:"/pages/c86096/index.html",redirect:"/pages/c86096/"},{path:"/01.Three.js教程/04.4.层级模型/01.三维向量Vector3与模型位置、缩放属性.html",redirect:"/pages/c86096/"},{name:"v-8030b53e",path:"/pages/4da2c3/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-8030b53e").then(t)}},{path:"/pages/4da2c3/index.html",redirect:"/pages/4da2c3/"},{path:"/01.Three.js教程/04.4.层级模型/02.递归遍历模型树结构、查询模型节点.html",redirect:"/pages/4da2c3/"},{name:"v-50155d20",path:"/pages/00ddfa/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-50155d20").then(t)}},{path:"/pages/00ddfa/index.html",redirect:"/pages/00ddfa/"},{path:"/01.Three.js教程/04.4.层级模型/03.本地坐标和世界坐标.html",redirect:"/pages/00ddfa/"},{name:"v-64ed261a",path:"/pages/a2fae0/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-64ed261a").then(t)}},{path:"/pages/a2fae0/index.html",redirect:"/pages/a2fae0/"},{path:"/01.Three.js教程/04.4.层级模型/04.改变模型相对局部坐标原点位置.html",redirect:"/pages/a2fae0/"},{name:"v-7dc03fae",path:"/pages/e66ea7/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7dc03fae").then(t)}},{path:"/pages/e66ea7/index.html",redirect:"/pages/e66ea7/"},{path:"/01.Three.js教程/04.4.层级模型/05.移除对象.remove().html",redirect:"/pages/e66ea7/"},{name:"v-6aa1157e",path:"/pages/eeb05a/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6aa1157e").then(t)}},{path:"/pages/eeb05a/index.html",redirect:"/pages/eeb05a/"},{path:"/01.Three.js教程/04.4.层级模型/06.模型隐藏或显示.html",redirect:"/pages/eeb05a/"},{name:"v-797cc37a",path:"/pages/2220d2/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-797cc37a").then(t)}},{path:"/pages/2220d2/index.html",redirect:"/pages/2220d2/"},{path:"/01.Three.js教程/05.5.顶点UV坐标、纹理贴图/01.创建纹理贴图.html",redirect:"/pages/2220d2/"},{name:"v-031f2e1d",path:"/pages/71e307/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-031f2e1d").then(t)}},{path:"/pages/71e307/index.html",redirect:"/pages/71e307/"},{path:"/01.Three.js教程/05.5.顶点UV坐标、纹理贴图/02.自定义顶点UV坐标.html",redirect:"/pages/71e307/"},{name:"v-250291f2",path:"/pages/dcc03b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-250291f2").then(t)}},{path:"/pages/dcc03b/index.html",redirect:"/pages/dcc03b/"},{path:"/01.Three.js教程/05.5.顶点UV坐标、纹理贴图/03.圆形平面CircleGeometry设置纹理贴图.html",redirect:"/pages/dcc03b/"},{name:"v-0672af9c",path:"/pages/e257c9/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0672af9c").then(t)}},{path:"/pages/e257c9/index.html",redirect:"/pages/e257c9/"},{path:"/01.Three.js教程/05.5.顶点UV坐标、纹理贴图/04.纹理对象Texture阵列( 瓷砖地面案例 ).html",redirect:"/pages/e257c9/"},{name:"v-6e3447f4",path:"/pages/bf71c4/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6e3447f4").then(t)}},{path:"/pages/bf71c4/index.html",redirect:"/pages/bf71c4/"},{path:"/01.Three.js教程/05.5.顶点UV坐标、纹理贴图/05.矩形Mesh+背景透明png贴图(场景地面导航标注).html",redirect:"/pages/bf71c4/"},{name:"v-3cd97688",path:"/pages/ed1694/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3cd97688").then(t)}},{path:"/pages/ed1694/index.html",redirect:"/pages/ed1694/"},{path:"/01.Three.js教程/05.5.顶点UV坐标、纹理贴图/06.UV动画.html",redirect:"/pages/ed1694/"},{name:"v-4c46d3c6",path:"/pages/f24993/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4c46d3c6").then(t)}},{path:"/pages/f24993/index.html",redirect:"/pages/f24993/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/01.建模软件绘制3D场景(比如Blender).html",redirect:"/pages/f24993/"},{name:"v-54146766",path:"/pages/2cdb29/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-54146766").then(t)}},{path:"/pages/2cdb29/index.html",redirect:"/pages/2cdb29/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/02. GLTF格式简介 (Web3D领域JPG).html",redirect:"/pages/2cdb29/"},{name:"v-c0905f02",path:"/pages/006fcb/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-c0905f02").then(t)}},{path:"/pages/006fcb/index.html",redirect:"/pages/006fcb/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/03.加载.gltf文件(模型加载全流程).html",redirect:"/pages/006fcb/"},{name:"v-0d2bc02d",path:"/pages/ed32ac/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0d2bc02d").then(t)}},{path:"/pages/ed32ac/index.html",redirect:"/pages/ed32ac/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/04.OrbitControls辅助设置相机参数.html",redirect:"/pages/ed32ac/"},{name:"v-5c2c5da4",path:"/pages/24ed9e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5c2c5da4").then(t)}},{path:"/pages/24ed9e/index.html",redirect:"/pages/24ed9e/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/05.gltf不同文件形式(.glb、贴图、.bin).html",redirect:"/pages/24ed9e/"},{name:"v-54d533e0",path:"/pages/a4813a/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-54d533e0").then(t)}},{path:"/pages/a4813a/index.html",redirect:"/pages/a4813a/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/06.模型命名(程序与美术协作)—层级模型节点选择.html",redirect:"/pages/a4813a/"},{name:"v-3411a9fe",path:"/pages/d78052/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3411a9fe").then(t)}},{path:"/pages/d78052/index.html",redirect:"/pages/d78052/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/07.递归遍历层级模型修改材质.html",redirect:"/pages/d78052/"},{name:"v-88d3b7ec",path:"/pages/f3c6d0/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-88d3b7ec").then(t)}},{path:"/pages/f3c6d0/index.html",redirect:"/pages/f3c6d0/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/08.外部模型材质是否共享的问题.html",redirect:"/pages/f3c6d0/"},{name:"v-7ca9b8a2",path:"/pages/c2fd5c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7ca9b8a2").then(t)}},{path:"/pages/c2fd5c/index.html",redirect:"/pages/c2fd5c/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/09.纹理.encoding和渲染器.outputEncoding.html",redirect:"/pages/c2fd5c/"},{name:"v-7b3457a0",path:"/pages/cbdb36/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7b3457a0").then(t)}},{path:"/pages/cbdb36/index.html",redirect:"/pages/cbdb36/"},{path:"/01.Three.js教程/06.6.加载外部三维模型(gltf)/10.gltf模型更换.map(纹理.flipY属性).html",redirect:"/pages/cbdb36/"},{name:"v-fe4e97a4",path:"/pages/56b66b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-fe4e97a4").then(t)}},{path:"/pages/56b66b/index.html",redirect:"/pages/56b66b/"},{path:"/01.Three.js教程/07.7.PBR材质与纹理贴图/01.PBR材质简介.html",redirect:"/pages/56b66b/"},{name:"v-ab57bc80",path:"/pages/ca9079/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-ab57bc80").then(t)}},{path:"/pages/ca9079/index.html",redirect:"/pages/ca9079/"},{path:"/01.Three.js教程/07.7.PBR材质与纹理贴图/02.PBR材质金属度和粗糙度(金属效果).html",redirect:"/pages/ca9079/"},{name:"v-11dd13bf",path:"/pages/780376/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-11dd13bf").then(t)}},{path:"/pages/780376/index.html",redirect:"/pages/780376/"},{path:"/01.Three.js教程/07.7.PBR材质与纹理贴图/03.环境贴图.envMap(金属效果).html",redirect:"/pages/780376/"},{name:"v-054810aa",path:"/pages/121b10/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-054810aa").then(t)}},{path:"/pages/121b10/index.html",redirect:"/pages/121b10/"},{path:"/01.Three.js教程/07.7.PBR材质与纹理贴图/05.MeshPhysicalMaterial清漆层Clearcoat.html",redirect:"/pages/121b10/"},{name:"v-6cc27f7d",path:"/pages/4f04e6/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6cc27f7d").then(t)}},{path:"/pages/4f04e6/index.html",redirect:"/pages/4f04e6/"},{path:"/01.Three.js教程/07.7.PBR材质与纹理贴图/06.物理材质透光率.transmission.html",redirect:"/pages/4f04e6/"},{name:"v-e4723f4c",path:"/pages/3b2d91/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-e4723f4c").then(t)}},{path:"/pages/3b2d91/index.html",redirect:"/pages/3b2d91/"},{path:"/01.Three.js教程/07.7.PBR材质与纹理贴图/04.环境贴图2.html",redirect:"/pages/3b2d91/"},{name:"v-1df7f180",path:"/pages/41c918/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1df7f180").then(t)}},{path:"/pages/41c918/index.html",redirect:"/pages/41c918/"},{path:"/01.Three.js教程/07.7.PBR材质与纹理贴图/07.三维软件导出PBR材质属性.html",redirect:"/pages/41c918/"},{name:"v-39711157",path:"/pages/12b014/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-39711157").then(t)}},{path:"/pages/12b014/index.html",redirect:"/pages/12b014/"},{path:"/01.Three.js教程/08.8.渲染器和前端UI界面/01.three.js Canvas画布布局.html",redirect:"/pages/12b014/"},{name:"v-698761d4",path:"/pages/780ceb/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-698761d4").then(t)}},{path:"/pages/780ceb/index.html",redirect:"/pages/780ceb/"},{path:"/01.Three.js教程/08.8.渲染器和前端UI界面/02.UI交互界面与Canvas画布叠加.html",redirect:"/pages/780ceb/"},{name:"v-4e79869f",path:"/pages/2a15e4/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4e79869f").then(t)}},{path:"/pages/2a15e4/index.html",redirect:"/pages/2a15e4/"},{path:"/01.Three.js教程/08.8.渲染器和前端UI界面/03.UI交互按钮与3D场景交互.html",redirect:"/pages/2a15e4/"},{name:"v-7f3230f8",path:"/pages/a4febe/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7f3230f8").then(t)}},{path:"/pages/a4febe/index.html",redirect:"/pages/a4febe/"},{path:"/01.Three.js教程/08.8.渲染器和前端UI界面/04.Three.js背景透明度.html",redirect:"/pages/a4febe/"},{name:"v-d5d385d8",path:"/pages/a1304b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-d5d385d8").then(t)}},{path:"/pages/a1304b/index.html",redirect:"/pages/a1304b/"},{path:"/01.Three.js教程/08.8.渲染器和前端UI界面/05.Three.js渲染结果保存为图片.html",redirect:"/pages/a1304b/"},{name:"v-544a2f3c",path:"/pages/e8f727/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-544a2f3c").then(t)}},{path:"/pages/e8f727/index.html",redirect:"/pages/e8f727/"},{path:"/01.Three.js教程/08.8.渲染器和前端UI界面/06.深度冲突(模型闪烁).html",redirect:"/pages/e8f727/"},{name:"v-d79514d0",path:"/pages/71ed82/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-d79514d0").then(t)}},{path:"/pages/71ed82/index.html",redirect:"/pages/71ed82/"},{path:"/01.Three.js教程/08.8.渲染器和前端UI界面/07.模型加载进度条.html",redirect:"/pages/71ed82/"},{name:"v-5f9a68e8",path:"/pages/8868a1/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5f9a68e8").then(t)}},{path:"/pages/8868a1/index.html",redirect:"/pages/8868a1/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/01.生成圆弧顶点.html",redirect:"/pages/8868a1/"},{name:"v-4c63bba6",path:"/pages/e28594/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4c63bba6").then(t)}},{path:"/pages/e28594/index.html",redirect:"/pages/e28594/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/02.几何体方法.setFromPoints().html",redirect:"/pages/e28594/"},{name:"v-04bb1726",path:"/pages/564039/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-04bb1726").then(t)}},{path:"/pages/564039/index.html",redirect:"/pages/564039/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/03.曲线Curve简介.html",redirect:"/pages/564039/"},{name:"v-f58673ce",path:"/pages/c64602/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-f58673ce").then(t)}},{path:"/pages/c64602/index.html",redirect:"/pages/c64602/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/04.椭圆、圆.html",redirect:"/pages/c64602/"},{name:"v-ab1a91e8",path:"/pages/717f0f/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-ab1a91e8").then(t)}},{path:"/pages/717f0f/index.html",redirect:"/pages/717f0f/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/05.样条曲线.html",redirect:"/pages/717f0f/"},{name:"v-4505f054",path:"/pages/15ba8d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4505f054").then(t)}},{path:"/pages/15ba8d/index.html",redirect:"/pages/15ba8d/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/06.贝塞尔曲线.html",redirect:"/pages/15ba8d/"},{name:"v-56bb56bc",path:"/pages/a8cc3a/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-56bb56bc").then(t)}},{path:"/pages/a8cc3a/index.html",redirect:"/pages/a8cc3a/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/07.样条、贝塞尔曲线应用.html",redirect:"/pages/a8cc3a/"},{name:"v-c60820fa",path:"/pages/e11f54/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-c60820fa").then(t)}},{path:"/pages/e11f54/index.html",redirect:"/pages/e11f54/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/08.组合曲线CurvePath拼接不同曲线.html",redirect:"/pages/e11f54/"},{name:"v-7ab36901",path:"/pages/4f1012/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7ab36901").then(t)}},{path:"/pages/4f1012/index.html",redirect:"/pages/4f1012/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/10.旋转成型LatheGeometry.html",redirect:"/pages/4f1012/"},{name:"v-7f63d78b",path:"/pages/f36362/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7f63d78b").then(t)}},{path:"/pages/f36362/index.html",redirect:"/pages/f36362/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/09.曲线路径管道TubeGeometry.html",redirect:"/pages/f36362/"},{name:"v-0d6eb080",path:"/pages/29f885/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0d6eb080").then(t)}},{path:"/pages/29f885/index.html",redirect:"/pages/29f885/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/11.轮廓填充ShapeGeometry.html",redirect:"/pages/29f885/"},{name:"v-b870ab44",path:"/pages/4ac668/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-b870ab44").then(t)}},{path:"/pages/4ac668/index.html",redirect:"/pages/4ac668/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/12.拉伸ExtrudeGeometry.html",redirect:"/pages/4ac668/"},{name:"v-09e41a95",path:"/pages/a06aed/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-09e41a95").then(t)}},{path:"/pages/a06aed/index.html",redirect:"/pages/a06aed/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/13.扫描ExtrudeGeometry.html",redirect:"/pages/a06aed/"},{name:"v-19d3bbba",path:"/pages/4b70af/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-19d3bbba").then(t)}},{path:"/pages/4b70af/index.html",redirect:"/pages/4b70af/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/14.多边形轮廓Shape简介.html",redirect:"/pages/4b70af/"},{name:"v-50cd75e2",path:"/pages/ccc74f/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-50cd75e2").then(t)}},{path:"/pages/ccc74f/index.html",redirect:"/pages/ccc74f/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/15.多边形轮廓Shape(圆弧).html",redirect:"/pages/ccc74f/"},{name:"v-2eff5cbc",path:"/pages/875c74/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2eff5cbc").then(t)}},{path:"/pages/875c74/index.html",redirect:"/pages/875c74/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/16.多边形Shape(内孔.holes).html",redirect:"/pages/875c74/"},{name:"v-40cdcbcf",path:"/pages/5fe984/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-40cdcbcf").then(t)}},{path:"/pages/5fe984/index.html",redirect:"/pages/5fe984/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/17.模型边界线EdgesGeometry.html",redirect:"/pages/5fe984/"},{name:"v-63702f6b",path:"/pages/92ea15/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-63702f6b").then(t)}},{path:"/pages/92ea15/index.html",redirect:"/pages/92ea15/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/18.几何体顶点颜色数数据.html",redirect:"/pages/92ea15/"},{name:"v-a9c900fe",path:"/pages/ace64e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a9c900fe").then(t)}},{path:"/pages/ace64e/index.html",redirect:"/pages/ace64e/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/19.一段曲线颜色渐变.html",redirect:"/pages/ace64e/"},{name:"v-5e7950d8",path:"/pages/05ca12/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5e7950d8").then(t)}},{path:"/pages/05ca12/index.html",redirect:"/pages/05ca12/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/20.Color颜色渐变插值.html",redirect:"/pages/05ca12/"},{name:"v-083e2755",path:"/pages/fde9a0/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-083e2755").then(t)}},{path:"/pages/fde9a0/index.html",redirect:"/pages/fde9a0/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/21.查看或设置gltf几何体顶点.html",redirect:"/pages/fde9a0/"},{name:"v-d8c63b20",path:"/pages/dbd776/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-d8c63b20").then(t)}},{path:"/pages/dbd776/index.html",redirect:"/pages/dbd776/"},{path:"/01.Three.js教程/09.9.生成曲线、几何体/22.山脉地形高度可视化.html",redirect:"/pages/dbd776/"},{name:"v-cfd35e92",path:"/pages/1c3a1a/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-cfd35e92").then(t)}},{path:"/pages/1c3a1a/index.html",redirect:"/pages/1c3a1a/"},{path:"/01.Three.js教程/10.10.相机基础/01.正投影相机.html",redirect:"/pages/1c3a1a/"},{name:"v-28edb3fc",path:"/pages/6f9387/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-28edb3fc").then(t)}},{path:"/pages/6f9387/index.html",redirect:"/pages/6f9387/"},{path:"/01.Three.js教程/10.10.相机基础/02.正投影相机-Canvas尺寸变化.html",redirect:"/pages/6f9387/"},{name:"v-48577124",path:"/pages/13d359/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-48577124").then(t)}},{path:"/pages/13d359/index.html",redirect:"/pages/13d359/"},{path:"/01.Three.js教程/10.10.相机基础/03.包围盒Box3.html",redirect:"/pages/13d359/"},{name:"v-33f176a4",path:"/pages/747cf1/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-33f176a4").then(t)}},{path:"/pages/747cf1/index.html",redirect:"/pages/747cf1/"},{path:"/01.Three.js教程/10.10.相机基础/04.地图案例(包围盒、正投影).html",redirect:"/pages/747cf1/"},{name:"v-6d7a8eb7",path:"/pages/ca57bd/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6d7a8eb7").then(t)}},{path:"/pages/ca57bd/index.html",redirect:"/pages/ca57bd/"},{path:"/01.Three.js教程/10.10.相机基础/05.相机动画( .position 和 .lookAt() ).html",redirect:"/pages/ca57bd/"},{name:"v-18a3e02e",path:"/pages/3153bf/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-18a3e02e").then(t)}},{path:"/pages/3153bf/index.html",redirect:"/pages/3153bf/"},{path:"/01.Three.js教程/10.10.相机基础/06.不同方向的投影视图.html",redirect:"/pages/3153bf/"},{name:"v-0732c0e2",path:"/pages/3bcff1/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0732c0e2").then(t)}},{path:"/pages/3bcff1/index.html",redirect:"/pages/3bcff1/"},{path:"/01.Three.js教程/10.10.相机基础/07.旋转渲染结果(.up相机上方向).html",redirect:"/pages/3bcff1/"},{name:"v-8afc710a",path:"/pages/188907/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-8afc710a").then(t)}},{path:"/pages/188907/index.html",redirect:"/pages/188907/"},{path:"/01.Three.js教程/10.10.相机基础/08.管道漫游案例.html",redirect:"/pages/188907/"},{name:"v-0ab635d8",path:"/pages/17b6dc/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0ab635d8").then(t)}},{path:"/pages/17b6dc/index.html",redirect:"/pages/17b6dc/"},{path:"/01.Three.js教程/10.10.相机基础/09.OrbitControls旋转缩放限制.html",redirect:"/pages/17b6dc/"},{name:"v-26ffe15a",path:"/pages/76953b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-26ffe15a").then(t)}},{path:"/pages/76953b/index.html",redirect:"/pages/76953b/"},{path:"/01.Three.js教程/10.10.相机基础/10.相机控件MapControls.html",redirect:"/pages/76953b/"},{name:"v-347f5f9f",path:"/pages/344c05/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-347f5f9f").then(t)}},{path:"/pages/344c05/index.html",redirect:"/pages/344c05/"},{path:"/01.Three.js教程/11.11.光源和阴影/01.聚光源SpotLight.html",redirect:"/pages/344c05/"},{name:"v-5c3633ad",path:"/pages/1dbe9d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5c3633ad").then(t)}},{path:"/pages/1dbe9d/index.html",redirect:"/pages/1dbe9d/"},{path:"/01.Three.js教程/11.11.光源和阴影/02.平行光阴影计算.html",redirect:"/pages/1dbe9d/"},{name:"v-a5dd4774",path:"/pages/68e9fd/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a5dd4774").then(t)}},{path:"/pages/68e9fd/index.html",redirect:"/pages/68e9fd/"},{path:"/01.Three.js教程/11.11.光源和阴影/03.阴影范围.shadow.camera.html",redirect:"/pages/68e9fd/"},{name:"v-f6b64df4",path:"/pages/547403/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-f6b64df4").then(t)}},{path:"/pages/547403/index.html",redirect:"/pages/547403/"},{path:"/01.Three.js教程/11.11.光源和阴影/04.阴影.mapSize和.radius.html",redirect:"/pages/547403/"},{name:"v-2a39b6e4",path:"/pages/c418f4/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2a39b6e4").then(t)}},{path:"/pages/c418f4/index.html",redirect:"/pages/c418f4/"},{path:"/01.Three.js教程/11.11.光源和阴影/06.工厂光源(平行光模拟太阳光).html",redirect:"/pages/c418f4/"},{name:"v-36a594f2",path:"/pages/3824bf/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-36a594f2").then(t)}},{path:"/pages/3824bf/index.html",redirect:"/pages/3824bf/"},{path:"/01.Three.js教程/11.11.光源和阴影/05.工厂光源(环境贴图和环境光).html",redirect:"/pages/3824bf/"},{name:"v-5a5e0b82",path:"/pages/96077e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5a5e0b82").then(t)}},{path:"/pages/96077e/index.html",redirect:"/pages/96077e/"},{path:"/01.Three.js教程/11.11.光源和阴影/07.工厂(模拟太阳光阴影).html",redirect:"/pages/96077e/"},{name:"v-4f8bdade",path:"/pages/3f1331/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4f8bdade").then(t)}},{path:"/pages/3f1331/index.html",redirect:"/pages/3f1331/"},{path:"/01.Three.js教程/11.11.光源和阴影/08.gui辅助调节光源阴影.html",redirect:"/pages/3f1331/"},{name:"v-44f45938",path:"/pages/bd93e5/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-44f45938").then(t)}},{path:"/pages/bd93e5/index.html",redirect:"/pages/bd93e5/"},{path:"/01.Three.js教程/12.12.精灵模型Sprite/02.精灵模型标注场景(贴图).html",redirect:"/pages/bd93e5/"},{name:"v-3a585300",path:"/pages/477843/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3a585300").then(t)}},{path:"/pages/477843/index.html",redirect:"/pages/477843/"},{path:"/01.Three.js教程/12.12.精灵模型Sprite/03.Sprite模拟下雨、下雪.html",redirect:"/pages/477843/"},{name:"v-41dffdd4",path:"/pages/75d790/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-41dffdd4").then(t)}},{path:"/pages/75d790/index.html",redirect:"/pages/75d790/"},{path:"/01.Three.js教程/12.12.精灵模型Sprite/01.精灵模型Sprite.html",redirect:"/pages/75d790/"},{name:"v-f21ec9e0",path:"/pages/e1e75d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-f21ec9e0").then(t)}},{path:"/pages/e1e75d/index.html",redirect:"/pages/e1e75d/"},{path:"/01.Three.js教程/13.13.后处理EffectComposer/01.后处理(高亮发光描边OutlinePass).html",redirect:"/pages/e1e75d/"},{name:"v-7fcce397",path:"/pages/4583d8/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7fcce397").then(t)}},{path:"/pages/4583d8/index.html",redirect:"/pages/4583d8/"},{path:"/01.Three.js教程/13.13.后处理EffectComposer/03.Bloom发光通道.html",redirect:"/pages/4583d8/"},{name:"v-0853d625",path:"/pages/73bfc8/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0853d625").then(t)}},{path:"/pages/73bfc8/index.html",redirect:"/pages/73bfc8/"},{path:"/01.Three.js教程/13.13.后处理EffectComposer/02.OutlinePass发光描边样式.html",redirect:"/pages/73bfc8/"},{name:"v-6e8891b6",path:"/pages/9618d5/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6e8891b6").then(t)}},{path:"/pages/9618d5/index.html",redirect:"/pages/9618d5/"},{path:"/01.Three.js教程/13.13.后处理EffectComposer/04.多通道组合(GlitchPass和描边).html",redirect:"/pages/9618d5/"},{name:"v-1529c538",path:"/pages/c9b485/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1529c538").then(t)}},{path:"/pages/c9b485/index.html",redirect:"/pages/c9b485/"},{path:"/01.Three.js教程/13.13.后处理EffectComposer/05.gltf工厂模型设置发光描边.html",redirect:"/pages/c9b485/"},{name:"v-58d55029",path:"/pages/db8785/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-58d55029").then(t)}},{path:"/pages/db8785/index.html",redirect:"/pages/db8785/"},{path:"/01.Three.js教程/13.13.后处理EffectComposer/06.gltf后处理颜色异常(伽马校正).html",redirect:"/pages/db8785/"},{name:"v-36e902b0",path:"/pages/fe22af/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-36e902b0").then(t)}},{path:"/pages/fe22af/index.html",redirect:"/pages/fe22af/"},{path:"/01.Three.js教程/13.13.后处理EffectComposer/07.抗锯齿后处理.html",redirect:"/pages/fe22af/"},{name:"v-0b069e57",path:"/pages/500511/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0b069e57").then(t)}},{path:"/pages/500511/index.html",redirect:"/pages/500511/"},{path:"/01.Three.js教程/14.14.射线拾取模型/01.射线Ray.html",redirect:"/pages/500511/"},{name:"v-281b710e",path:"/pages/a448b6/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-281b710e").then(t)}},{path:"/pages/a448b6/index.html",redirect:"/pages/a448b6/"},{path:"/01.Three.js教程/14.14.射线拾取模型/02.Raycaster(射线拾取模型).html",redirect:"/pages/a448b6/"},{name:"v-48b62e34",path:"/pages/f96af1/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-48b62e34").then(t)}},{path:"/pages/f96af1/index.html",redirect:"/pages/f96af1/"},{path:"/01.Three.js教程/14.14.射线拾取模型/04.Raycaster(鼠标点击选中模型).html",redirect:"/pages/f96af1/"},{name:"v-b8bc7f42",path:"/pages/6065de/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-b8bc7f42").then(t)}},{path:"/pages/6065de/index.html",redirect:"/pages/6065de/"},{path:"/01.Three.js教程/14.14.射线拾取模型/05.Canvas尺寸变化(射线坐标计算).html",redirect:"/pages/6065de/"},{name:"v-7a6b5bc6",path:"/pages/41d16d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7a6b5bc6").then(t)}},{path:"/pages/41d16d/index.html",redirect:"/pages/41d16d/"},{path:"/01.Three.js教程/14.14.射线拾取模型/03.屏幕坐标转标准设备坐标.html",redirect:"/pages/41d16d/"},{name:"v-5c5e9bdc",path:"/pages/dd2774/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5c5e9bdc").then(t)}},{path:"/pages/dd2774/index.html",redirect:"/pages/dd2774/"},{path:"/01.Three.js教程/14.14.射线拾取模型/06.射线拾取层级模型(选中模型发光描边).html",redirect:"/pages/dd2774/"},{name:"v-a691e0fc",path:"/pages/428714/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a691e0fc").then(t)}},{path:"/pages/428714/index.html",redirect:"/pages/428714/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/01.CSS2DRenderer(HTM元素作为标签).html",redirect:"/pages/428714/"},{name:"v-505a04dd",path:"/pages/63aef4/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-505a04dd").then(t)}},{path:"/pages/63aef4/index.html",redirect:"/pages/63aef4/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/02.HTML标签遮挡Canvas画布事件.html",redirect:"/pages/63aef4/"},{name:"v-20360617",path:"/pages/9b6a56/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-20360617").then(t)}},{path:"/pages/9b6a56/index.html",redirect:"/pages/9b6a56/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/04.标签位置不同设置方式.html",redirect:"/pages/9b6a56/"},{name:"v-a5230b16",path:"/pages/b73a83/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a5230b16").then(t)}},{path:"/pages/b73a83/index.html",redirect:"/pages/b73a83/"},{path:"/01.Three.js教程/14.14.射线拾取模型/07.射线拾取Sprite控制场景.html",redirect:"/pages/b73a83/"},{name:"v-bb92678c",path:"/pages/0801b3/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-bb92678c").then(t)}},{path:"/pages/0801b3/index.html",redirect:"/pages/0801b3/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/03.Canvas画布尺寸变化(HTML标签).html",redirect:"/pages/0801b3/"},{name:"v-4b104e94",path:"/pages/fb01c9/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4b104e94").then(t)}},{path:"/pages/fb01c9/index.html",redirect:"/pages/fb01c9/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/06.标签指示线或箭头指向标注点.html",redirect:"/pages/fb01c9/"},{name:"v-596ce778",path:"/pages/6ec16d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-596ce778").then(t)}},{path:"/pages/6ec16d/index.html",redirect:"/pages/6ec16d/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/05.标签位置(标注工厂设备).html",redirect:"/pages/6ec16d/"},{name:"v-af3ef6e0",path:"/pages/793f8d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-af3ef6e0").then(t)}},{path:"/pages/793f8d/index.html",redirect:"/pages/793f8d/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/07.鼠标选中模型弹出标签(工厂案例).html",redirect:"/pages/793f8d/"},{name:"v-442556e6",path:"/pages/1fa97c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-442556e6").then(t)}},{path:"/pages/1fa97c/index.html",redirect:"/pages/1fa97c/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/08.单机按钮关闭HTML标签.html",redirect:"/pages/1fa97c/"},{name:"v-a0685c18",path:"/pages/b5f8e2/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a0685c18").then(t)}},{path:"/pages/b5f8e2/index.html",redirect:"/pages/b5f8e2/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/10.CSS3批量标注多个标签.html",redirect:"/pages/b5f8e2/"},{name:"v-23d9bdae",path:"/pages/76a18d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-23d9bdae").then(t)}},{path:"/pages/76a18d/index.html",redirect:"/pages/76a18d/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/11.精灵模型Sprite作为标签.html",redirect:"/pages/76a18d/"},{name:"v-444b2197",path:"/pages/b23f11/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-444b2197").then(t)}},{path:"/pages/b23f11/index.html",redirect:"/pages/b23f11/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/09.CSS3DRenderer渲染HTML标签.html",redirect:"/pages/b23f11/"},{name:"v-04884aa9",path:"/pages/c15dd2/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-04884aa9").then(t)}},{path:"/pages/c15dd2/index.html",redirect:"/pages/c15dd2/"},{path:"/01.Three.js教程/15.15.场景标注标签信息/12.Sprite标签(Canvas作为贴图).html",redirect:"/pages/c15dd2/"},{name:"v-4a7931ea",path:"/pages/c8f25d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4a7931ea").then(t)}},{path:"/pages/c8f25d/index.html",redirect:"/pages/c8f25d/"},{path:"/01.Three.js教程/16.16.关键帧动画/02.动画播放(暂停、倍速、循环).html",redirect:"/pages/c8f25d/"},{name:"v-30f87000",path:"/pages/3aff37/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-30f87000").then(t)}},{path:"/pages/3aff37/index.html",redirect:"/pages/3aff37/"},{path:"/01.Three.js教程/16.16.关键帧动画/01.关键帧动画.html",redirect:"/pages/3aff37/"},{name:"v-a449bf94",path:"/pages/c98f2f/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a449bf94").then(t)}},{path:"/pages/c98f2f/index.html",redirect:"/pages/c98f2f/"},{path:"/01.Three.js教程/16.16.关键帧动画/03.动画播放(拖动任意时间状态).html",redirect:"/pages/c98f2f/"},{name:"v-2bbec22a",path:"/pages/e5737c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2bbec22a").then(t)}},{path:"/pages/e5737c/index.html",redirect:"/pages/e5737c/"},{path:"/01.Three.js教程/16.16.关键帧动画/04.解析外部模型关键帧动画.html",redirect:"/pages/e5737c/"},{name:"v-64040a28",path:"/pages/478039/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-64040a28").then(t)}},{path:"/pages/478039/index.html",redirect:"/pages/478039/"},{path:"/01.Three.js教程/16.16.关键帧动画/05.机械虚拟装配案例(播放).html",redirect:"/pages/478039/"},{name:"v-04470b50",path:"/pages/c9c18c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-04470b50").then(t)}},{path:"/pages/c9c18c/index.html",redirect:"/pages/c9c18c/"},{path:"/01.Three.js教程/16.16.关键帧动画/06.虚拟装配(任意时间定位).html",redirect:"/pages/c9c18c/"},{name:"v-26245688",path:"/pages/43c650/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-26245688").then(t)}},{path:"/pages/43c650/index.html",redirect:"/pages/43c650/"},{path:"/01.Three.js教程/16.16.关键帧动画/08.变形动画(定制人物胖瘦).html",redirect:"/pages/43c650/"},{name:"v-37c2a0b8",path:"/pages/d8c0b0/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-37c2a0b8").then(t)}},{path:"/pages/d8c0b0/index.html",redirect:"/pages/d8c0b0/"},{path:"/01.Three.js教程/16.16.关键帧动画/07.变形动画原理.html",redirect:"/pages/d8c0b0/"},{name:"v-4bf5cab4",path:"/pages/56644a/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4bf5cab4").then(t)}},{path:"/pages/56644a/index.html",redirect:"/pages/56644a/"},{path:"/01.Three.js教程/16.16.关键帧动画/10.查看外部模型骨骼动画.html",redirect:"/pages/56644a/"},{name:"v-3eb105a6",path:"/pages/870a19/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3eb105a6").then(t)}},{path:"/pages/870a19/index.html",redirect:"/pages/870a19/"},{path:"/01.Three.js教程/16.16.关键帧动画/09.骨骼关节Bone.html",redirect:"/pages/870a19/"},{name:"v-6028f147",path:"/pages/f5175e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6028f147").then(t)}},{path:"/pages/f5175e/index.html",redirect:"/pages/f5175e/"},{path:"/01.Three.js教程/16.16.关键帧动画/11.骨骼动画不同动作切换.html",redirect:"/pages/f5175e/"},{name:"v-1d2a71f8",path:"/pages/69bd16/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1d2a71f8").then(t)}},{path:"/pages/69bd16/index.html",redirect:"/pages/69bd16/"},{path:"/01.Three.js教程/17.17.动画库tween.js/01.tweenjs创建threejs动画.html",redirect:"/pages/69bd16/"},{name:"v-b55eba40",path:"/pages/406def/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-b55eba40").then(t)}},{path:"/pages/406def/index.html",redirect:"/pages/406def/"},{path:"/01.Three.js教程/17.17.动画库tween.js/02.tweenjs相机运动动画.html",redirect:"/pages/406def/"},{name:"v-4e113527",path:"/pages/c0b87e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4e113527").then(t)}},{path:"/pages/c0b87e/index.html",redirect:"/pages/c0b87e/"},{path:"/01.Three.js教程/17.17.动画库tween.js/03.点按钮,相机飞行靠近观察设备.html",redirect:"/pages/c0b87e/"},{name:"v-0ab7f00c",path:"/pages/f2273c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0ab7f00c").then(t)}},{path:"/pages/f2273c/index.html",redirect:"/pages/f2273c/"},{path:"/01.Three.js教程/17.17.动画库tween.js/04.点击设备,相机靠近放大预览.html",redirect:"/pages/f2273c/"},{name:"v-384d9b66",path:"/pages/5227e0/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-384d9b66").then(t)}},{path:"/pages/5227e0/index.html",redirect:"/pages/5227e0/"},{path:"/01.Three.js教程/17.17.动画库tween.js/06.模型或标签淡入淡出.html",redirect:"/pages/5227e0/"},{name:"v-773576a7",path:"/pages/001888/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-773576a7").then(t)}},{path:"/pages/001888/index.html",redirect:"/pages/001888/"},{path:"/02.Three.js进阶教程/01.1. 数学几何计算基础/01.threejs坐标系与三角函数.html",redirect:"/pages/001888/"},{name:"v-3996c29d",path:"/pages/51d9ae/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3996c29d").then(t)}},{path:"/pages/51d9ae/index.html",redirect:"/pages/51d9ae/"},{path:"/01.Three.js教程/17.17.动画库tween.js/05.缓动算法.easing(地球渐入相机动画).html",redirect:"/pages/51d9ae/"},{name:"v-551bde42",path:"/pages/b4b9bb/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-551bde42").then(t)}},{path:"/pages/b4b9bb/index.html",redirect:"/pages/b4b9bb/"},{path:"/02.Three.js进阶教程/01.1. 数学几何计算基础/02.三维向量Vector3简介.html",redirect:"/pages/b4b9bb/"},{name:"v-a8f143e2",path:"/pages/0a87db/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a8f143e2").then(t)}},{path:"/pages/0a87db/index.html",redirect:"/pages/0a87db/"},{path:"/02.Three.js进阶教程/01.1. 数学几何计算基础/03.向量大小(Vector3长度.length()).html",redirect:"/pages/0a87db/"},{name:"v-b17d2f24",path:"/pages/d69d76/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-b17d2f24").then(t)}},{path:"/pages/d69d76/index.html",redirect:"/pages/d69d76/"},{path:"/02.Three.js进阶教程/01.1. 数学几何计算基础/04.向量方向(归一化.normalize).html",redirect:"/pages/d69d76/"},{name:"v-1db0392e",path:"/pages/e24048/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1db0392e").then(t)}},{path:"/pages/e24048/index.html",redirect:"/pages/e24048/"},{path:"/02.Three.js进阶教程/01.1. 数学几何计算基础/06.箭头ArrowHelper.html",redirect:"/pages/e24048/"},{name:"v-9c41d56c",path:"/pages/a5e313/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-9c41d56c").then(t)}},{path:"/pages/a5e313/index.html",redirect:"/pages/a5e313/"},{path:"/02.Three.js进阶教程/01.1. 数学几何计算基础/05.相机沿着视线方向运动.html",redirect:"/pages/a5e313/"},{name:"v-8b41caee",path:"/pages/e3f92b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-8b41caee").then(t)}},{path:"/pages/e3f92b/index.html",redirect:"/pages/e3f92b/"},{path:"/02.Three.js进阶教程/02.2.位移、速度、加速度(向量)/01.匀速动画(向量表示速度).html",redirect:"/pages/e3f92b/"},{name:"v-41afb39f",path:"/pages/27de57/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-41afb39f").then(t)}},{path:"/pages/27de57/index.html",redirect:"/pages/27de57/"},{path:"/02.Three.js进阶教程/02.2.位移、速度、加速度(向量)/02.物体下落动画(重力加速度).html",redirect:"/pages/27de57/"},{name:"v-57df0166",path:"/pages/44b0ba/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-57df0166").then(t)}},{path:"/pages/44b0ba/index.html",redirect:"/pages/44b0ba/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/01.向量点乘dot.html",redirect:"/pages/44b0ba/"},{name:"v-7d387f1c",path:"/pages/acc4b8/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7d387f1c").then(t)}},{path:"/pages/acc4b8/index.html",redirect:"/pages/acc4b8/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/02.点乘练习-计算三角形夹角.html",redirect:"/pages/acc4b8/"},{name:"v-6333d9f8",path:"/pages/d32e58/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6333d9f8").then(t)}},{path:"/pages/d32e58/index.html",redirect:"/pages/d32e58/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/03.点乘判断物体在人前或人后.html",redirect:"/pages/d32e58/"},{name:"v-0a966bc7",path:"/pages/feb38e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0a966bc7").then(t)}},{path:"/pages/feb38e/index.html",redirect:"/pages/feb38e/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/04.点乘判断是否在扇形内.html",redirect:"/pages/feb38e/"},{name:"v-0e2ab762",path:"/pages/4558d6/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0e2ab762").then(t)}},{path:"/pages/4558d6/index.html",redirect:"/pages/4558d6/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/05.向量叉乘cross.html",redirect:"/pages/4558d6/"},{name:"v-2287542e",path:"/pages/9babd7/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2287542e").then(t)}},{path:"/pages/9babd7/index.html",redirect:"/pages/9babd7/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/06.叉乘判断人左右.html",redirect:"/pages/9babd7/"},{name:"v-f13a2722",path:"/pages/b03f77/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-f13a2722").then(t)}},{path:"/pages/b03f77/index.html",redirect:"/pages/b03f77/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/07.点乘判断平行向量方向异同.html",redirect:"/pages/b03f77/"},{name:"v-1672bc36",path:"/pages/d574b7/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1672bc36").then(t)}},{path:"/pages/d574b7/index.html",redirect:"/pages/d574b7/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/09.叉乘计算三角形法线.html",redirect:"/pages/d574b7/"},{name:"v-18951d86",path:"/pages/8da3bf/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-18951d86").then(t)}},{path:"/pages/8da3bf/index.html",redirect:"/pages/8da3bf/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/08.判断两个点是否在线段同一侧.html",redirect:"/pages/8da3bf/"},{name:"v-54519bd0",path:"/pages/ab63ef/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-54519bd0").then(t)}},{path:"/pages/ab63ef/index.html",redirect:"/pages/ab63ef/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/11.练习—计算物体的表面积.html",redirect:"/pages/ab63ef/"},{name:"v-763b4e35",path:"/pages/1e8af7/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-763b4e35").then(t)}},{path:"/pages/1e8af7/index.html",redirect:"/pages/1e8af7/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/12.点到直线的距离.html",redirect:"/pages/1e8af7/"},{name:"v-740abe3c",path:"/pages/03073e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-740abe3c").then(t)}},{path:"/pages/03073e/index.html",redirect:"/pages/03073e/"},{path:"/02.Three.js进阶教程/03.3.向量点乘、叉乘/10.叉乘计算三角形面积.html",redirect:"/pages/03073e/"},{name:"v-4217aa3d",path:"/pages/4b4a0b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4217aa3d").then(t)}},{path:"/pages/4b4a0b/index.html",redirect:"/pages/4b4a0b/"},{path:"/02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/01.欧拉角Euler.html",redirect:"/pages/4b4a0b/"},{name:"v-5195a875",path:"/pages/1fea5e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5195a875").then(t)}},{path:"/pages/1fea5e/index.html",redirect:"/pages/1fea5e/"},{path:"/02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/02.四元数Quaternion.html",redirect:"/pages/1fea5e/"},{name:"v-22a792ce",path:"/pages/435568/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-22a792ce").then(t)}},{path:"/pages/435568/index.html",redirect:"/pages/435568/"},{path:"/02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/04.四元数乘法运算.html",redirect:"/pages/435568/"},{name:"v-0717c793",path:"/pages/72cb3f/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0717c793").then(t)}},{path:"/pages/72cb3f/index.html",redirect:"/pages/72cb3f/"},{path:"/02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/05.四元数表示两个向量旋转.html",redirect:"/pages/72cb3f/"},{name:"v-1f67061d",path:"/pages/44207d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1f67061d").then(t)}},{path:"/pages/44207d/index.html",redirect:"/pages/44207d/"},{path:"/02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/03.四元数表示物体姿态.html",redirect:"/pages/44207d/"},{name:"v-a2b567ae",path:"/pages/0be3f8/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a2b567ae").then(t)}},{path:"/pages/0be3f8/index.html",redirect:"/pages/0be3f8/"},{path:"/02.Three.js进阶教程/05.5.矩阵/01.数学基础(平移、旋转、缩放矩阵).html",redirect:"/pages/0be3f8/"},{name:"v-64b14f88",path:"/pages/f6ddf9/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-64b14f88").then(t)}},{path:"/pages/f6ddf9/index.html",redirect:"/pages/f6ddf9/"},{path:"/02.Three.js进阶教程/05.5.矩阵/02.模型矩阵.html",redirect:"/pages/f6ddf9/"},{name:"v-5c0fecb8",path:"/pages/adcb9e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5c0fecb8").then(t)}},{path:"/pages/adcb9e/index.html",redirect:"/pages/adcb9e/"},{path:"/02.Three.js进阶教程/05.5.矩阵/03.Three.js矩阵Matrix4.html",redirect:"/pages/adcb9e/"},{name:"v-63de3e24",path:"/pages/6d4b1f/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-63de3e24").then(t)}},{path:"/pages/6d4b1f/index.html",redirect:"/pages/6d4b1f/"},{path:"/02.Three.js进阶教程/05.5.矩阵/04.矩阵乘法multiply.html",redirect:"/pages/6d4b1f/"},{name:"v-8eb408b8",path:"/pages/c5b6bb/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-8eb408b8").then(t)}},{path:"/pages/c5b6bb/index.html",redirect:"/pages/c5b6bb/"},{path:"/02.Three.js进阶教程/05.5.矩阵/05.模型本地矩阵、世界矩阵.html",redirect:"/pages/c5b6bb/"},{name:"v-4332b628",path:"/pages/c1c0e7/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4332b628").then(t)}},{path:"/pages/c1c0e7/index.html",redirect:"/pages/c1c0e7/"},{path:"/02.Three.js进阶教程/06.6.射线/01. 射线Ray(复习前面内容).html",redirect:"/pages/c1c0e7/"},{name:"v-05494578",path:"/pages/bf26f8/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-05494578").then(t)}},{path:"/pages/bf26f8/index.html",redirect:"/pages/bf26f8/"},{path:"/02.Three.js进阶教程/05.5.矩阵/06.视图矩阵、投影矩阵.html",redirect:"/pages/bf26f8/"},{name:"v-803ffe94",path:"/pages/bbc7ce/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-803ffe94").then(t)}},{path:"/pages/bbc7ce/index.html",redirect:"/pages/bbc7ce/"},{path:"/02.Three.js进阶教程/06.6.射线/02.射线拾取模型(复习前面).html",redirect:"/pages/bbc7ce/"},{name:"v-57df0643",path:"/pages/515d43/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-57df0643").then(t)}},{path:"/pages/515d43/index.html",redirect:"/pages/515d43/"},{path:"/02.Three.js进阶教程/07.7.包围盒/01.包围盒Box3(复习前面).html",redirect:"/pages/515d43/"},{name:"v-7c9b722a",path:"/pages/bb25ee/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7c9b722a").then(t)}},{path:"/pages/bb25ee/index.html",redirect:"/pages/bb25ee/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/01.键盘WASD按键状态记录.html",redirect:"/pages/bb25ee/"},{name:"v-2f97d739",path:"/pages/8d3d09/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2f97d739").then(t)}},{path:"/pages/8d3d09/index.html",redirect:"/pages/8d3d09/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/02.W键控制角色模型运动.html",redirect:"/pages/8d3d09/"},{name:"v-3ca61054",path:"/pages/e8e668/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3ca61054").then(t)}},{path:"/pages/e8e668/index.html",redirect:"/pages/e8e668/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/03.加速度(按键给玩家加速).html",redirect:"/pages/e8e668/"},{name:"v-e00e8ad8",path:"/pages/24d3be/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-e00e8ad8").then(t)}},{path:"/pages/24d3be/index.html",redirect:"/pages/24d3be/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/04.阻尼(玩家角色逐渐减速停止).html",redirect:"/pages/24d3be/"},{name:"v-625ca383",path:"/pages/99cd6d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-625ca383").then(t)}},{path:"/pages/99cd6d/index.html",redirect:"/pages/99cd6d/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/05.按键S退后运动.html",redirect:"/pages/99cd6d/"},{name:"v-c98105f0",path:"/pages/7fe7e3/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-c98105f0").then(t)}},{path:"/pages/7fe7e3/index.html",redirect:"/pages/7fe7e3/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/06.相机跟着玩家走(第三人称漫游).html",redirect:"/pages/7fe7e3/"},{name:"v-744c40be",path:"/pages/ef6fe2/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-744c40be").then(t)}},{path:"/pages/ef6fe2/index.html",redirect:"/pages/ef6fe2/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/07.鼠标左右拖动改变玩家视角.html",redirect:"/pages/ef6fe2/"},{name:"v-18333ca2",path:"/pages/c5d199/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-18333ca2").then(t)}},{path:"/pages/c5d199/index.html",redirect:"/pages/c5d199/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/08.获取玩家(相机)正前方方向.html",redirect:"/pages/c5d199/"},{name:"v-9709b4ce",path:"/pages/15d00d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-9709b4ce").then(t)}},{path:"/pages/15d00d/index.html",redirect:"/pages/15d00d/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/09.鼠标上下移动只改变相机视角.html",redirect:"/pages/15d00d/"},{name:"v-49244fca",path:"/pages/adb8cb/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-49244fca").then(t)}},{path:"/pages/adb8cb/index.html",redirect:"/pages/adb8cb/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/10.玩家角色左右运动(叉乘).html",redirect:"/pages/adb8cb/"},{name:"v-bdf3a312",path:"/pages/920120/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-bdf3a312").then(t)}},{path:"/pages/920120/index.html",redirect:"/pages/920120/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/11.鼠标滑动改变视角(指针锁定模式).html",redirect:"/pages/920120/"},{name:"v-c22b68d6",path:"/pages/c9f808/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-c22b68d6").then(t)}},{path:"/pages/c9f808/index.html",redirect:"/pages/c9f808/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/12.快捷键切换第一、第三人称.html",redirect:"/pages/c9f808/"},{name:"v-0d5aab1a",path:"/pages/dd3bfe/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0d5aab1a").then(t)}},{path:"/pages/dd3bfe/index.html",redirect:"/pages/dd3bfe/"},{path:"/02.Three.js进阶教程/08.8.第一、三人称漫游/13.骨骼动画与运动状态关联.html",redirect:"/pages/dd3bfe/"},{name:"v-2e90a37d",path:"/pages/db8906/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2e90a37d").then(t)}},{path:"/pages/db8906/index.html",redirect:"/pages/db8906/"},{path:"/02.Three.js进阶教程/09.9.漫游-八叉树碰撞检测/01.八叉树Octree扩展库介绍.html",redirect:"/pages/db8906/"},{name:"v-ec6f9786",path:"/pages/f92da6/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-ec6f9786").then(t)}},{path:"/pages/f92da6/index.html",redirect:"/pages/f92da6/"},{path:"/02.Three.js进阶教程/09.9.漫游-八叉树碰撞检测/02.八叉树与胶囊Capsule交叉计算.html",redirect:"/pages/f92da6/"},{name:"v-f5e61cc8",path:"/pages/e80014/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-f5e61cc8").then(t)}},{path:"/pages/e80014/index.html",redirect:"/pages/e80014/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/02.CannonJS自由落体计算.html",redirect:"/pages/e80014/"},{name:"v-1e2bcf16",path:"/pages/e48d3c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1e2bcf16").then(t)}},{path:"/pages/e48d3c/index.html",redirect:"/pages/e48d3c/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/01.物理引擎CannonJS简介和引入.html",redirect:"/pages/e48d3c/"},{name:"v-76f03d60",path:"/pages/ee7628/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-76f03d60").then(t)}},{path:"/pages/ee7628/index.html",redirect:"/pages/ee7628/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/05.练习-修改小球参数.html",redirect:"/pages/ee7628/"},{name:"v-580c898f",path:"/pages/a5ef46/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-580c898f").then(t)}},{path:"/pages/a5ef46/index.html",redirect:"/pages/a5ef46/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/06.练习-点按钮重复下落.html",redirect:"/pages/a5ef46/"},{name:"v-0c4a5c5c",path:"/pages/4a6320/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0c4a5c5c").then(t)}},{path:"/pages/4a6320/index.html",redirect:"/pages/4a6320/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/07.CannonJS碰撞事件，碰撞声音.html",redirect:"/pages/4a6320/"},{name:"v-25637300",path:"/pages/ae695b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-25637300").then(t)}},{path:"/pages/ae695b/index.html",redirect:"/pages/ae695b/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/04.CannonJS模拟乒乓球下落反弹.html",redirect:"/pages/ae695b/"},{name:"v-0f889bbc",path:"/pages/bcb959/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0f889bbc").then(t)}},{path:"/pages/bcb959/index.html",redirect:"/pages/bcb959/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/08.长方体Box碰撞体(箱子下落).html",redirect:"/pages/bcb959/"},{name:"v-949d0b96",path:"/pages/b646d4/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-949d0b96").then(t)}},{path:"/pages/b646d4/index.html",redirect:"/pages/b646d4/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/09.练习题-外部gltf箱子模型.html",redirect:"/pages/b646d4/"},{name:"v-2c6a8a39",path:"/pages/eb4d49/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2c6a8a39").then(t)}},{path:"/pages/eb4d49/index.html",redirect:"/pages/eb4d49/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/03.练习-threejs可视化cannon计算结果.html",redirect:"/pages/eb4d49/"},{name:"v-692d0a85",path:"/pages/280f40/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-692d0a85").then(t)}},{path:"/pages/280f40/index.html",redirect:"/pages/280f40/"},{path:"/02.Three.js进阶教程/10.10.CannonJS物理引擎/10.凸多面体ConvexPolyhedron.html",redirect:"/pages/280f40/"},{name:"v-a8d65390",path:"/pages/d30795/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a8d65390").then(t)}},{path:"/pages/d30795/index.html",redirect:"/pages/d30795/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/01.学前说明.html",redirect:"/pages/d30795/"},{name:"v-c1efc94c",path:"/pages/3b3f35/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-c1efc94c").then(t)}},{path:"/pages/3b3f35/index.html",redirect:"/pages/3b3f35/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/02.着色器GLSL ES语言(复习).html",redirect:"/pages/3b3f35/"},{name:"v-7cebfb4f",path:"/pages/eb2fda/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-7cebfb4f").then(t)}},{path:"/pages/eb2fda/index.html",redirect:"/pages/eb2fda/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/03.ShaderMaterial着色器材质.html",redirect:"/pages/eb2fda/"},{name:"v-1e96b2cc",path:"/pages/2c9721/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1e96b2cc").then(t)}},{path:"/pages/2c9721/index.html",redirect:"/pages/2c9721/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/05.uniform变量传值.html",redirect:"/pages/2c9721/"},{name:"v-3c4463d4",path:"/pages/8142c3/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3c4463d4").then(t)}},{path:"/pages/8142c3/index.html",redirect:"/pages/8142c3/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/04.ShaderMaterial半透明、双面显示.html",redirect:"/pages/8142c3/"},{name:"v-58412606",path:"/pages/21c48e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-58412606").then(t)}},{path:"/pages/21c48e/index.html",redirect:"/pages/21c48e/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/06.WebGL渲染管线.html",redirect:"/pages/21c48e/"},{name:"v-31b2dbbf",path:"/pages/b109f4/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-31b2dbbf").then(t)}},{path:"/pages/b109f4/index.html",redirect:"/pages/b109f4/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/07.片元屏幕坐标fragCoord.xy.html",redirect:"/pages/b109f4/"},{name:"v-555d9eed",path:"/pages/64fa98/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-555d9eed").then(t)}},{path:"/pages/64fa98/index.html",redirect:"/pages/64fa98/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/09.顶点位置插值(实现渐变色).html",redirect:"/pages/64fa98/"},{name:"v-047aa23a",path:"/pages/118412/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-047aa23a").then(t)}},{path:"/pages/118412/index.html",redirect:"/pages/118412/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/08.顶点颜色varying插值计算.html",redirect:"/pages/118412/"},{name:"v-5c0d32fb",path:"/pages/8db59b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5c0d32fb").then(t)}},{path:"/pages/8db59b/index.html",redirect:"/pages/8db59b/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/10.颜色贴图map(顶点UV坐标).html",redirect:"/pages/8db59b/"},{name:"v-301a465c",path:"/pages/964545/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-301a465c").then(t)}},{path:"/pages/964545/index.html",redirect:"/pages/964545/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/11.shader模仿点材质效果.html",redirect:"/pages/964545/"},{name:"v-6da97d6b",path:"/pages/f74c6d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6da97d6b").then(t)}},{path:"/pages/f74c6d/index.html",redirect:"/pages/f74c6d/"},{path:"/03.Threejs Shader教程/01.1.threejs Shader基础语法/12.attribute自定义顶点变量.html",redirect:"/pages/f74c6d/"},{name:"v-75e4b124",path:"/pages/b7b8ff/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-75e4b124").then(t)}},{path:"/pages/b7b8ff/index.html",redirect:"/pages/b7b8ff/"},{path:"/03.Threejs Shader教程/02.2.onBeforeCompile修改材质/01.threejs材质的shader代码.html",redirect:"/pages/b7b8ff/"},{name:"v-c11250be",path:"/pages/4dd4b2/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-c11250be").then(t)}},{path:"/pages/4dd4b2/index.html",redirect:"/pages/4dd4b2/"},{path:"/03.Threejs Shader教程/02.2.onBeforeCompile修改材质/02.onBeforeCompile修改材质shader.html",redirect:"/pages/4dd4b2/"},{name:"v-26882685",path:"/pages/d163ed/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-26882685").then(t)}},{path:"/pages/d163ed/index.html",redirect:"/pages/d163ed/"},{path:"/03.Threejs Shader教程/02.2.onBeforeCompile修改材质/03.修改材质shader(彩色图变灰度图).html",redirect:"/pages/d163ed/"},{name:"v-4871c65a",path:"/pages/a93f3a/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4871c65a").then(t)}},{path:"/pages/a93f3a/index.html",redirect:"/pages/a93f3a/"},{path:"/03.Threejs Shader教程/02.2.onBeforeCompile修改材质/04.顶点位置插值(设置片元颜色).html",redirect:"/pages/a93f3a/"},{name:"v-a7e2a9c6",path:"/pages/e9f8fd/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a7e2a9c6").then(t)}},{path:"/pages/e9f8fd/index.html",redirect:"/pages/e9f8fd/"},{path:"/03.Threejs Shader教程/02.2.onBeforeCompile修改材质/06.模型扫光效果(顶点位置插值).html",redirect:"/pages/e9f8fd/"},{name:"v-0b4ab0f6",path:"/pages/069520/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0b4ab0f6").then(t)}},{path:"/pages/069520/index.html",redirect:"/pages/069520/"},{path:"/03.Threejs Shader教程/02.2.onBeforeCompile修改材质/05.顶点位置插值(设置片元颜色)2.html",redirect:"/pages/069520/"},{name:"v-6908b822",path:"/blog/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6908b822").then(t)}},{path:"/blog/index.html",redirect:"/blog/"},{path:"/@pages/archivesPage.html",redirect:"/blog/"},{name:"v-21a84a04",path:"/pages/437645/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-21a84a04").then(t)}},{path:"/pages/437645/index.html",redirect:"/pages/437645/"},{path:"/03.Threejs Shader教程/02.2.onBeforeCompile修改材质/07.模型扫光效果(颜色渐变).html",redirect:"/pages/437645/"},{name:"v-0dd532f8",path:"/pages/00cfc0/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0dd532f8").then(t)}},{path:"/pages/00cfc0/index.html",redirect:"/pages/00cfc0/"},{path:"/Blender教程/01.1.Blender入门基础/01.Blender入门基础.html",redirect:"/pages/00cfc0/"},{name:"v-a994a3e0",path:"/pages/1c4bb8/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-a994a3e0").then(t)}},{path:"/pages/1c4bb8/index.html",redirect:"/pages/1c4bb8/"},{path:"/Blender教程/01.1.Blender入门基础/02.Blender下载、安装、中文界面.html",redirect:"/pages/1c4bb8/"},{name:"v-6fda0888",path:"/pages/b66c23/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6fda0888").then(t)}},{path:"/pages/b66c23/index.html",redirect:"/pages/b66c23/"},{path:"/Blender教程/01.1.Blender入门基础/03.基本操作：旋转、缩放、平移.html",redirect:"/pages/b66c23/"},{name:"v-947d9400",path:"/pages/73804e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-947d9400").then(t)}},{path:"/pages/73804e/index.html",redirect:"/pages/73804e/"},{path:"/Blender教程/01.1.Blender入门基础/04.编辑、保存网格模型.html",redirect:"/pages/73804e/"},{name:"v-139fa962",path:"/pages/0fdf7b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-139fa962").then(t)}},{path:"/pages/0fdf7b/index.html",redirect:"/pages/0fdf7b/"},{path:"/Threejs文章/01.谈谈Three.js版本问题.html",redirect:"/pages/0fdf7b/"},{name:"v-71cb85e4",path:"/pages/a4ad16/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-71cb85e4").then(t)}},{path:"/pages/a4ad16/index.html",redirect:"/pages/a4ad16/"},{path:"/Blender教程/01.1.Blender入门基础/05.Blender导出gltf(与threejs协作).html",redirect:"/pages/a4ad16/"},{name:"v-b72d140e",path:"/pages/33b01c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-b72d140e").then(t)}},{path:"/pages/33b01c/index.html",redirect:"/pages/33b01c/"},{path:"/Threejs文章/02.阅读Three.js源码.html",redirect:"/pages/33b01c/"},{name:"v-4ebeb0e4",path:"/pages/c3ecc9/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4ebeb0e4").then(t)}},{path:"/pages/c3ecc9/index.html",redirect:"/pages/c3ecc9/"},{path:"/Threejs文章/03.3D模型gltf下载网站(threejs开发).html",redirect:"/pages/c3ecc9/"},{name:"v-27b0f8bf",path:"/pages/6188ce/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-27b0f8bf").then(t)}},{path:"/pages/6188ce/index.html",redirect:"/pages/6188ce/"},{path:"/Threejs文章/04.three.js模拟显示屏模型播放视频.html",redirect:"/pages/6188ce/"},{name:"v-177bce0e",path:"/pages/46aa7c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-177bce0e").then(t)}},{path:"/pages/46aa7c/index.html",redirect:"/pages/46aa7c/"},{path:"/Vue+Three.js 3D可视化/01.1.学前说明/01.Vue+Three.js课程简介.html",redirect:"/pages/46aa7c/"},{name:"v-6c478b4f",path:"/pages/a837c2/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6c478b4f").then(t)}},{path:"/pages/a837c2/index.html",redirect:"/pages/a837c2/"},{path:"/Vue+Three.js 3D可视化/02.2.Vue+Three.js基础/01.Vite搭建Vue 3D开发环境.html",redirect:"/pages/a837c2/"},{name:"v-1c8eca98",path:"/pages/9bc0db/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1c8eca98").then(t)}},{path:"/pages/9bc0db/index.html",redirect:"/pages/9bc0db/"},{path:"/WebGL教程/01.1.WebGL快速入门/01.WebGL学前说明.html",redirect:"/pages/9bc0db/"},{name:"v-4b050e8e",path:"/pages/409d6c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4b050e8e").then(t)}},{path:"/pages/409d6c/index.html",redirect:"/pages/409d6c/"},{path:"/WebGL教程/01.1.WebGL快速入门/02.着色器GLSL ES语言.html",redirect:"/pages/409d6c/"},{name:"v-d98b1d80",path:"/pages/f66004/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-d98b1d80").then(t)}},{path:"/pages/f66004/index.html",redirect:"/pages/f66004/"},{path:"/WebGL教程/01.1.WebGL快速入门/03.第一个WebGL案例.html",redirect:"/pages/f66004/"},{name:"v-483f6004",path:"/pages/1dd7e1/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-483f6004").then(t)}},{path:"/pages/1dd7e1/index.html",redirect:"/pages/1dd7e1/"},{path:"/WebGL教程/02.2.3D几何变换数学基础/01.数学基础(平移、旋转、缩放矩阵).html",redirect:"/pages/1dd7e1/"},{name:"v-735dd117",path:"/pages/d6fb6c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-735dd117").then(t)}},{path:"/pages/d6fb6c/index.html",redirect:"/pages/d6fb6c/"},{path:"/WebGL教程/02.2.3D几何变换数学基础/02.模型矩阵.html",redirect:"/pages/d6fb6c/"},{name:"v-d0089e5a",path:"/pages/7d74bf/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-d0089e5a").then(t)}},{path:"/pages/7d74bf/index.html",redirect:"/pages/7d74bf/"},{path:"/WebGL教程/02.2.3D几何变换数学基础/03.gl-matrix数学计算库.html",redirect:"/pages/7d74bf/"},{name:"v-57c2ccdc",path:"/pages/9bbfa9/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-57c2ccdc").then(t)}},{path:"/pages/9bbfa9/index.html",redirect:"/pages/9bbfa9/"},{path:"/WebGPU教程/01.1.WebGPU快速入门/01.WebGPU学习开发环境配置.html",redirect:"/pages/9bbfa9/"},{name:"v-3f8b08d1",path:"/pages/a4735b/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3f8b08d1").then(t)}},{path:"/pages/a4735b/index.html",redirect:"/pages/a4735b/"},{path:"/WebGPU教程/01.1.WebGPU快速入门/02.WebGPU API和Canvas画布.html",redirect:"/pages/a4735b/"},{name:"v-e9796ed4",path:"/pages/d5968c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-e9796ed4").then(t)}},{path:"/pages/d5968c/index.html",redirect:"/pages/d5968c/"},{path:"/WebGPU教程/01.1.WebGPU快速入门/04.着色器语言WGSL快速了解.html",redirect:"/pages/d5968c/"},{name:"v-5febe29d",path:"/pages/359922/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5febe29d").then(t)}},{path:"/pages/359922/index.html",redirect:"/pages/359922/"},{path:"/WebGPU教程/01.1.WebGPU快速入门/03.创建顶点缓冲区、渲染管线.html",redirect:"/pages/359922/"},{name:"v-5c2b4d06",path:"/pages/55f573/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5c2b4d06").then(t)}},{path:"/pages/55f573/index.html",redirect:"/pages/55f573/"},{path:"/WebGPU教程/01.1.WebGPU快速入门/05.顶点着色器.html",redirect:"/pages/55f573/"},{name:"v-2f525902",path:"/pages/7be6ce/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2f525902").then(t)}},{path:"/pages/7be6ce/index.html",redirect:"/pages/7be6ce/"},{path:"/WebGPU教程/01.1.WebGPU快速入门/06.片元着色器、图元装配.html",redirect:"/pages/7be6ce/"},{name:"v-650e89cc",path:"/pages/ff1bbf/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-650e89cc").then(t)}},{path:"/pages/ff1bbf/index.html",redirect:"/pages/ff1bbf/"},{path:"/WebGPU教程/01.1.WebGPU快速入门/08.WebGPU 3D坐标系(投影).html",redirect:"/pages/ff1bbf/"},{name:"v-13085dfb",path:"/pages/6d5d59/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-13085dfb").then(t)}},{path:"/pages/6d5d59/index.html",redirect:"/pages/6d5d59/"},{path:"/WebGPU教程/01.1.WebGPU快速入门/07.渲染命令(至此完成第一个案例).html",redirect:"/pages/6d5d59/"},{name:"v-2dac77a6",path:"/pages/c033a7/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-2dac77a6").then(t)}},{path:"/pages/c033a7/index.html",redirect:"/pages/c033a7/"},{path:"/WebGPU教程/01.1.WebGPU快速入门/09.三角形拼接矩形.html",redirect:"/pages/c033a7/"},{name:"v-3f3ba29a",path:"/pages/17d42c/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-3f3ba29a").then(t)}},{path:"/pages/17d42c/index.html",redirect:"/pages/17d42c/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/04.顶点着色器矩阵变换.html",redirect:"/pages/17d42c/"},{name:"v-42bac2c6",path:"/pages/473326/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-42bac2c6").then(t)}},{path:"/pages/473326/index.html",redirect:"/pages/473326/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/03.gl-matrix数学计算库.html",redirect:"/pages/473326/"},{name:"v-4e577efe",path:"/pages/a1aa0e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-4e577efe").then(t)}},{path:"/pages/a1aa0e/index.html",redirect:"/pages/a1aa0e/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/05.WebGPU传递uniform数据.html",redirect:"/pages/a1aa0e/"},{name:"v-50c7990a",path:"/pages/47d092/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-50c7990a").then(t)}},{path:"/pages/47d092/index.html",redirect:"/pages/47d092/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/02.模型矩阵.html",redirect:"/pages/47d092/"},{name:"v-07a4d46e",path:"/pages/d69ed5/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-07a4d46e").then(t)}},{path:"/pages/d69ed5/index.html",redirect:"/pages/d69ed5/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/06.gl-matrix生成顶点着色器的矩阵.html",redirect:"/pages/d69ed5/"},{name:"v-79c7025f",path:"/pages/e69b13/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-79c7025f").then(t)}},{path:"/pages/e69b13/index.html",redirect:"/pages/e69b13/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/07.WebGPU动画(uniform旋转矩阵).html",redirect:"/pages/e69b13/"},{name:"v-09c2f018",path:"/pages/df319e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-09c2f018").then(t)}},{path:"/pages/df319e/index.html",redirect:"/pages/df319e/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/08.绕y轴旋转动画.html",redirect:"/pages/df319e/"},{name:"v-b352d932",path:"/pages/aac7f7/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-b352d932").then(t)}},{path:"/pages/aac7f7/index.html",redirect:"/pages/aac7f7/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/10.片元深度值、深度缓冲区.html",redirect:"/pages/aac7f7/"},{name:"v-42ec0e6e",path:"/pages/e2c95a/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-42ec0e6e").then(t)}},{path:"/pages/e2c95a/index.html",redirect:"/pages/e2c95a/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/09.片元的屏幕坐标.html",redirect:"/pages/e2c95a/"},{name:"v-0d1e30f7",path:"/pages/38777d/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0d1e30f7").then(t)}},{path:"/pages/38777d/index.html",redirect:"/pages/38777d/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/01.数学基础(平移、旋转、缩放矩阵).html",redirect:"/pages/38777d/"},{name:"v-18ffc03d",path:"/pages/0149ac/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-18ffc03d").then(t)}},{path:"/pages/0149ac/index.html",redirect:"/pages/0149ac/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/11.WebGPU顶点数据插值计算.html",redirect:"/pages/0149ac/"},{name:"v-63e0f928",path:"/pages/0c6955/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-63e0f928").then(t)}},{path:"/pages/0c6955/index.html",redirect:"/pages/0c6955/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/12.练习—顶点位置插值.html",redirect:"/pages/0c6955/"},{name:"v-d9f794c4",path:"/pages/3d0f41/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-d9f794c4").then(t)}},{path:"/pages/3d0f41/index.html",redirect:"/pages/3d0f41/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/13.顶点颜色数据插值计算.html",redirect:"/pages/3d0f41/"},{name:"v-53fb374d",path:"/pages/3a2ff2/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-53fb374d").then(t)}},{path:"/pages/3a2ff2/index.html",redirect:"/pages/3a2ff2/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/14.顶点位置、颜色数据共享缓冲区.html",redirect:"/pages/3a2ff2/"},{name:"v-b35f1826",path:"/pages/299242/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-b35f1826").then(t)}},{path:"/pages/299242/index.html",redirect:"/pages/299242/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/15.练习-顶点颜色.html",redirect:"/pages/299242/"},{name:"v-25fafc76",path:"/pages/8918c1/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-25fafc76").then(t)}},{path:"/pages/8918c1/index.html",redirect:"/pages/8918c1/"},{path:"/WebGPU教程/02.2. 3D几何变换数学基础/16.结构体作为WGLSL函数参数.html",redirect:"/pages/8918c1/"},{name:"v-37e75448",path:"/pages/0d3229/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-37e75448").then(t)}},{path:"/pages/0d3229/index.html",redirect:"/pages/0d3229/"},{path:"/_posts/Web3D人才推荐.html",redirect:"/pages/0d3229/"},{name:"v-5e46ee5e",path:"/pages/88e5dc/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-5e46ee5e").then(t)}},{path:"/pages/88e5dc/index.html",redirect:"/pages/88e5dc/"},{path:"/_posts/Web3D可视化面试(WebGL、Three.js).html",redirect:"/pages/88e5dc/"},{name:"v-720cbfa2",path:"/pages/8c57cd/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-720cbfa2").then(t)}},{path:"/pages/8c57cd/index.html",redirect:"/pages/8c57cd/"},{path:"/_posts/Web3D案例.html",redirect:"/pages/8c57cd/"},{name:"v-6e1e280a",path:"/pages/56bb7e/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-6e1e280a").then(t)}},{path:"/pages/56bb7e/index.html",redirect:"/pages/56bb7e/"},{path:"/_posts/免费课程.html",redirect:"/pages/56bb7e/"},{name:"v-0d65b539",path:"/pages/bab765/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0d65b539").then(t)}},{path:"/pages/bab765/index.html",redirect:"/pages/bab765/"},{path:"/_posts/外包项目.html",redirect:"/pages/bab765/"},{name:"v-1bed40a5",path:"/pages/b563a7/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-1bed40a5").then(t)}},{path:"/pages/b563a7/index.html",redirect:"/pages/b563a7/"},{path:"/_posts/本站内容转载和引用声明.html",redirect:"/pages/b563a7/"},{name:"v-0e429eca",path:"/",component:bl,beforeEnter:(n,e,t)=>{di("Layout","v-0e429eca").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:bl}],yl={title:"Three.js中文网",description:"提供Three.js、WebGL视频课程",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"webgl,three.js,教程"}],["meta",{name:"theme-color",content:"#aac9ab"}]],pages:[{title:"课程部分案例3D效果速览",frontmatter:{title:"课程部分案例3D效果速览",date:"2023-01-20T16:01:19.000Z",permalink:"/pages/4a14ce/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/0.0.%E5%AD%A6%E5%89%8D%E8%AF%B4%E6%98%8E/01.%E8%AF%BE%E7%A8%8B%E9%83%A8%E5%88%86%E6%A1%88%E4%BE%8B3D%E6%95%88%E6%9E%9C%E9%80%9F%E8%A7%88.html",relativePath:"01.Three.js教程/0.0.学前说明/01.课程部分案例3D效果速览.md",key:"v-59a1b962",path:"/pages/4a14ce/",headers:[{level:3,title:"物联网数字孪生3D可视化",slug:"物联网数字孪生3d可视化",normalizedTitle:"物联网数字孪生3d可视化",charIndex:62},{level:3,title:"机械、BIM领域在线展示交互",slug:"机械、bim领域在线展示交互",normalizedTitle:"机械、bim领域在线展示交互",charIndex:269},{level:3,title:"地球、地图数据Web3D大屏可视化",slug:"地球、地图数据web3d大屏可视化",normalizedTitle:"地球、地图数据web3d大屏可视化",charIndex:312},{level:3,title:"产品720展示",slug:"产品720展示",normalizedTitle:"产品720展示",charIndex:376},{level:3,title:"全景室内效果",slug:"全景室内效果",normalizedTitle:"全景室内效果",charIndex:407}],headersStr:"物联网数字孪生3D可视化 机械、BIM领域在线展示交互 地球、地图数据Web3D大屏可视化 产品720展示 全景室内效果",content:"# 课程部分案例3D效果速览\n\n下面是系统课程中部分3D效果的视频展示链接或在线3D链接。\n\n视频方式速览3D案例\n\n\n# 物联网数字孪生3D可视化\n\n在人与人之间联系的互联网时代，主要是满足人与人之间的交流，Web页面的交互界面主要呈现为2D的交互效果，比如按钮、输入框等。\n\n随着物联网的发展,工业、建筑等各个领域与物联网相关Web项目网页交互界面都会呈现出3D化的趋势。物联网相比较传统互联网更强调的是人与物、物与物的联系。\n\n物联网数字孪生：收费站——预览地址\n\n\n\n智慧城市——预览地址\n\n\n\n智慧小区——预览地址\n\n\n\n\n# 机械、BIM领域在线展示交互\n\n机械、BIM领域在线展示交互——预览地址\n\n\n\n\n# 地球、地图数据Web3D大屏可视化\n\n地球飞线大屏3D可视化——预览地址\n\n\n\n中国地图3D数据可视化——预览地址\n\n\n\n\n# 产品720展示\n\n轿车展品720展示——预览地址\n\n\n\n\n# 全景室内效果\n\n全景室内效果——预览地址\n\n",normalizedContent:"# 课程部分案例3d效果速览\n\n下面是系统课程中部分3d效果的视频展示链接或在线3d链接。\n\n视频方式速览3d案例\n\n\n# 物联网数字孪生3d可视化\n\n在人与人之间联系的互联网时代，主要是满足人与人之间的交流，web页面的交互界面主要呈现为2d的交互效果，比如按钮、输入框等。\n\n随着物联网的发展,工业、建筑等各个领域与物联网相关web项目网页交互界面都会呈现出3d化的趋势。物联网相比较传统互联网更强调的是人与物、物与物的联系。\n\n物联网数字孪生：收费站——预览地址\n\n\n\n智慧城市——预览地址\n\n\n\n智慧小区——预览地址\n\n\n\n\n# 机械、bim领域在线展示交互\n\n机械、bim领域在线展示交互——预览地址\n\n\n\n\n# 地球、地图数据web3d大屏可视化\n\n地球飞线大屏3d可视化——预览地址\n\n\n\n中国地图3d数据可视化——预览地址\n\n\n\n\n# 产品720展示\n\n轿车展品720展示——预览地址\n\n\n\n\n# 全景室内效果\n\n全景室内效果——预览地址\n\n",charsets:{cjk:!0}},{title:"学前基础、如何学习3D",frontmatter:{title:"学前基础、如何学习3D",date:"2023-01-20T16:02:21.000Z",permalink:"/pages/2de1b9/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/0.0.%E5%AD%A6%E5%89%8D%E8%AF%B4%E6%98%8E/03.%E5%AD%A6%E5%89%8D%E5%9F%BA%E7%A1%80%E3%80%81%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A03D.html",relativePath:"01.Three.js教程/0.0.学前说明/03.学前基础、如何学习3D.md",key:"v-00662320",path:"/pages/2de1b9/",headers:[{level:3,title:"学前Web前端基础",slug:"学前web前端基础",normalizedTitle:"学前web前端基础",charIndex:125},{level:3,title:"Web3D项目开发——前端基础",slug:"web3d项目开发-前端基础",normalizedTitle:"web3d项目开发——前端基础",charIndex:283},{level:3,title:"three.js广泛应用",slug:"three-js广泛应用",normalizedTitle:"three.js广泛应用",charIndex:424},{level:3,title:"如何学习Three.js",slug:"如何学习three-js",normalizedTitle:"如何学习three.js",charIndex:575},{level:3,title:"WebGL",slug:"webgl",normalizedTitle:"webgl",charIndex:22},{level:3,title:"3D建模——Blender",slug:"_3d建模-blender",normalizedTitle:"3d建模——blender",charIndex:979},{level:3,title:"Cesium",slug:"cesium",normalizedTitle:"cesium",charIndex:1318}],headersStr:"学前Web前端基础 Web3D项目开发——前端基础 three.js广泛应用 如何学习Three.js WebGL 3D建模——Blender Cesium",content:"# 3.学前基础、如何学习Web3D可视化(WebGL Threejs Blender建模)\n\n视频：Web 3D可视化学习技术栈选择\n\n下面主要大家谈谈怎么学习Web3D可视化，具体说就是怎么学习WebGL、Three.js、3D建模等。\n\n\n# 学前Web前端基础\n\n在学习WebGL和Three.js之前，首先确保你有web前端基础，最差也要掌握HTMl、CSS、JavaScript(含es6)，对nodejs也要有一定的了解，主要是搭建开发环境也离不开nodejs，如果你没有相关基础请提前学习。\n\n如果没有前端基础，请学习Web前端入门视频教程\n\n\n# Web3D项目开发——前端基础\n\nWebGL和threejs入门，对web前端要求比较低，如果是开发web3d项目，你肯定需要系统学习web前端，毕竟web3d也是建立在普通web前端基础上。\n\n关于web前端技术栈，你可以通过b站视频(web前端都需要学习什么？)了解。\n\n\n# three.js广泛应用\n\nThree.js是一款基于原生WebGL封装通用Web 3D引擎，在小游戏、产品展示、物联网、数字孪生、智慧城市园区、机械、建筑、全景看房、GIS等各个领域基本上都有three.js的身影。\n\n只要你有Web3D可视化的需求，基本上都可以首选学习Three.js。\n\n\n# 如何学习Three.js\n\n有没有原生WebGL基础，你都可以直接学习Three.js,刚刚入门three.js时候，可以先不用学习WebGL，当你需要进阶深入学习Three.js的时候，最好先去学学原生WebGL，了解了解图形学相关理论知识，即便只是稍微入门WebGL，那对于three.js深入学习帮助都是很大的。\n\n\n# WebGL\n\n原生WebGL和图形学是Three.js的底层知识，学习难度相对大些，尤其是没有计算机图形学基础的同学。\n\n我的建议是通过咱们课程先入门原生WebGL，渲染管线和着色器语法有一定的了解，最后根据个人情况考虑要不要深入学习图形学相关理论知识。\n\n关于计算机图形学相关的理论书籍，初学者也不用上来就看，可以有一定three.js和原生WebGL基础在翻看。\n\n书籍推荐： 入门：《WebGL编程指南》 图形学：《交互式计算机图形学基于WebGL的自顶向下方法》\n\n\n# 3D建模——Blender\n\n有些Web3D可视化项目，可能需要通过3D建模软件绘制模型，一般可以通过Blender、3dmax、c4d等任何三维软件实现。\n\n对于3D建模，一般工作的时候，都是美术负责，当然部分公司，也可能会要求程序员3D建模。\n\n即使公司日常是美术负责3D建模，不过作为WebGL开发，学习一下3D建模知识也是有一定必要性的，这对于Web3d项目开发还是很有帮助的，只不过要求没有美术那么高而已。\n\n关于3D建模，对于程序员而言，可以选择Blender学习，Blender更轻量，且开源免费。\n\n如果你们公司的美术用的三维软件不是Blender，其实你也可以建议学习下，这样与threejs配合更加方便。\n\nBledner视频教程——Web3D方向\n\n\n# Cesium\n\nCesium也是一款WebGL的3D引擎，相比Three.js封装更进一步，主要是给GIS行业使用，并不像three.js那么通用，如果你不是GIS专业方向，可以不用学习，如果你是GIS方向，可以同时学习WebGL、Three.js和Cesium。",normalizedContent:"# 3.学前基础、如何学习web3d可视化(webgl threejs blender建模)\n\n视频：web 3d可视化学习技术栈选择\n\n下面主要大家谈谈怎么学习web3d可视化，具体说就是怎么学习webgl、three.js、3d建模等。\n\n\n# 学前web前端基础\n\n在学习webgl和three.js之前，首先确保你有web前端基础，最差也要掌握html、css、javascript(含es6)，对nodejs也要有一定的了解，主要是搭建开发环境也离不开nodejs，如果你没有相关基础请提前学习。\n\n如果没有前端基础，请学习web前端入门视频教程\n\n\n# web3d项目开发——前端基础\n\nwebgl和threejs入门，对web前端要求比较低，如果是开发web3d项目，你肯定需要系统学习web前端，毕竟web3d也是建立在普通web前端基础上。\n\n关于web前端技术栈，你可以通过b站视频(web前端都需要学习什么？)了解。\n\n\n# three.js广泛应用\n\nthree.js是一款基于原生webgl封装通用web 3d引擎，在小游戏、产品展示、物联网、数字孪生、智慧城市园区、机械、建筑、全景看房、gis等各个领域基本上都有three.js的身影。\n\n只要你有web3d可视化的需求，基本上都可以首选学习three.js。\n\n\n# 如何学习three.js\n\n有没有原生webgl基础，你都可以直接学习three.js,刚刚入门three.js时候，可以先不用学习webgl，当你需要进阶深入学习three.js的时候，最好先去学学原生webgl，了解了解图形学相关理论知识，即便只是稍微入门webgl，那对于three.js深入学习帮助都是很大的。\n\n\n# webgl\n\n原生webgl和图形学是three.js的底层知识，学习难度相对大些，尤其是没有计算机图形学基础的同学。\n\n我的建议是通过咱们课程先入门原生webgl，渲染管线和着色器语法有一定的了解，最后根据个人情况考虑要不要深入学习图形学相关理论知识。\n\n关于计算机图形学相关的理论书籍，初学者也不用上来就看，可以有一定three.js和原生webgl基础在翻看。\n\n书籍推荐： 入门：《webgl编程指南》 图形学：《交互式计算机图形学基于webgl的自顶向下方法》\n\n\n# 3d建模——blender\n\n有些web3d可视化项目，可能需要通过3d建模软件绘制模型，一般可以通过blender、3dmax、c4d等任何三维软件实现。\n\n对于3d建模，一般工作的时候，都是美术负责，当然部分公司，也可能会要求程序员3d建模。\n\n即使公司日常是美术负责3d建模，不过作为webgl开发，学习一下3d建模知识也是有一定必要性的，这对于web3d项目开发还是很有帮助的，只不过要求没有美术那么高而已。\n\n关于3d建模，对于程序员而言，可以选择blender学习，blender更轻量，且开源免费。\n\n如果你们公司的美术用的三维软件不是blender，其实你也可以建议学习下，这样与threejs配合更加方便。\n\nbledner视频教程——web3d方向\n\n\n# cesium\n\ncesium也是一款webgl的3d引擎，相比three.js封装更进一步，主要是给gis行业使用，并不像three.js那么通用，如果你不是gis专业方向，可以不用学习，如果你是gis方向，可以同时学习webgl、three.js和cesium。",charsets:{cjk:!0}},{title:"2. 学习环境-编辑器和静态服务器",frontmatter:{title:"2. 学习环境-编辑器和静态服务器",date:"2023-01-20T11:01:30.000Z",permalink:"/pages/336b66/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02.%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83-%E7%BC%96%E8%BE%91%E5%99%A8%E5%92%8C%E6%9C%AC%E5%9C%B0%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/02.学习环境-编辑器和本地静态服务.md",key:"v-08114dcc",path:"/pages/336b66/",headers:[{level:3,title:"工欲善其事，必先利其器",slug:"工欲善其事-必先利其器",normalizedTitle:"工欲善其事，必先利其器",charIndex:28},{level:3,title:"vscode代码编辑器",slug:"vscode代码编辑器",normalizedTitle:"vscode代码编辑器",charIndex:83},{level:3,title:"本地静态服务器",slug:"本地静态服务器",normalizedTitle:"本地静态服务器",charIndex:13},{level:3,title:"vscode配置live-server插件",slug:"vscode配置live-server插件",normalizedTitle:"vscode配置live-server插件",charIndex:590},{level:3,title:"预览3D案例和文档",slug:"预览3d案例和文档",normalizedTitle:"预览3d案例和文档",charIndex:767},{level:3,title:"扩展：nodejs配置本地静态服务器",slug:"扩展-nodejs配置本地静态服务器",normalizedTitle:"扩展：nodejs配置本地静态服务器",charIndex:1084}],headersStr:"工欲善其事，必先利其器 vscode代码编辑器 本地静态服务器 vscode配置live-server插件 预览3D案例和文档 扩展：nodejs配置本地静态服务器",content:"# 学习环境—代码编辑器和本地静态服务器\n\n视频讲解\n\n工欲善其事，必先利其器，写threejs代码之前，需要先准备一个用于threejs学习的开发环境。\n\n 1. vscode代码编辑器\n 2. 本地静态服务器——预览文档、课程案例源码\n\n\n# 工欲善其事，必先利其器\n\n学习Web3D可视化，就像你想耕地，拖拉机就是比二哈更专业的开发学习工具。\n\n\n\n\n# vscode代码编辑器\n\nWeb3D开发的代码编辑器和平时web前端开发一样，你可以根据自己的喜好选择，本课程选择的代码编辑器是vscode。\n\n如果不了解vscode，想安装和使用vscode，可以参考我以前发布的前端公开课HTML入门教程，具体你可以参考视频。\n\n如果你用的是其他代码编辑器，建议转到vscode，当然不想转也行，毕竟都差不多。\n\n\n# 本地静态服务器\n\n平时学习Three.js，如果你想预览代码3D效果，咱们需要提供一个本地静态服务器的开发环境，如果你有一定的web前端基础，提到本地静态服务器肯定不陌生。\n\n作为前端工程师，大家都知道，正式的web项目开发，往往会用webpack或vite或其它方式配置一个开发环境。\n\n如果只是学习threejs的话，没必要这么麻烦，我最建议的方式就是，通过代码编辑器快速创建本地静态服务器，比如vsocde，安装live-server插件即可。\n\n\n# vscode配置live-server插件\n\n不同代码编辑器创建本地静态服务器方式不同，课程就以vscocde为了大家演示。\n\n * 安装\n\nvscode软件界面左侧，点击扩展，输入live-server关键词查询安装。\n\n * 使用\n\n如果你想预览代码3D效果，打开对应.html文件，右键点击Open with Live Server即可。\n\n\n# 预览3D案例和文档\n\n * 预览课程案例源码\n\n打开课件案例，注意把Three.js视频教程源码文件作为根目录，使用vscode创建本地静态服务就可以预览。\n\n * 预览官方examples中案例\n * 本地预览文档\n\n把threejs整个官方文件包作为根目录，用本地静服务打开任何一个.html文件即可预览\n\nthree.js-文件包\n...\n└───docs——Three.js API文档文件\n    │───index.html——打开该文件，本地离线方式预览threejs文档\n└───examples——大量的3D案例，是你平时开发参考学习的最佳资源\n    │───.html——各种3D案例\n...    \n\n\n\n# 扩展：nodejs配置本地静态服务器\n\n如果不用代码编辑器创建本地静服务器，也可以用nodejs配置。\n\n首先确保你电脑已经安装nodejs，然后npm安装live-server插件，安装后，进入课件或threejs官方文件根目录，输入live-server命令即可预览3D案例。\n\n// 安装live-server\nnpm install live-server -g\n\n\n不过平时为了开发方便，可以不用nodejs创建一个本地静态服务器，可以借助你的代码编辑器更方便，比如下面要说到的vscode。",normalizedContent:"# 学习环境—代码编辑器和本地静态服务器\n\n视频讲解\n\n工欲善其事，必先利其器，写threejs代码之前，需要先准备一个用于threejs学习的开发环境。\n\n 1. vscode代码编辑器\n 2. 本地静态服务器——预览文档、课程案例源码\n\n\n# 工欲善其事，必先利其器\n\n学习web3d可视化，就像你想耕地，拖拉机就是比二哈更专业的开发学习工具。\n\n\n\n\n# vscode代码编辑器\n\nweb3d开发的代码编辑器和平时web前端开发一样，你可以根据自己的喜好选择，本课程选择的代码编辑器是vscode。\n\n如果不了解vscode，想安装和使用vscode，可以参考我以前发布的前端公开课html入门教程，具体你可以参考视频。\n\n如果你用的是其他代码编辑器，建议转到vscode，当然不想转也行，毕竟都差不多。\n\n\n# 本地静态服务器\n\n平时学习three.js，如果你想预览代码3d效果，咱们需要提供一个本地静态服务器的开发环境，如果你有一定的web前端基础，提到本地静态服务器肯定不陌生。\n\n作为前端工程师，大家都知道，正式的web项目开发，往往会用webpack或vite或其它方式配置一个开发环境。\n\n如果只是学习threejs的话，没必要这么麻烦，我最建议的方式就是，通过代码编辑器快速创建本地静态服务器，比如vsocde，安装live-server插件即可。\n\n\n# vscode配置live-server插件\n\n不同代码编辑器创建本地静态服务器方式不同，课程就以vscocde为了大家演示。\n\n * 安装\n\nvscode软件界面左侧，点击扩展，输入live-server关键词查询安装。\n\n * 使用\n\n如果你想预览代码3d效果，打开对应.html文件，右键点击open with live server即可。\n\n\n# 预览3d案例和文档\n\n * 预览课程案例源码\n\n打开课件案例，注意把three.js视频教程源码文件作为根目录，使用vscode创建本地静态服务就可以预览。\n\n * 预览官方examples中案例\n * 本地预览文档\n\n把threejs整个官方文件包作为根目录，用本地静服务打开任何一个.html文件即可预览\n\nthree.js-文件包\n...\n└───docs——three.js api文档文件\n    │───index.html——打开该文件，本地离线方式预览threejs文档\n└───examples——大量的3d案例，是你平时开发参考学习的最佳资源\n    │───.html——各种3d案例\n...    \n\n\n\n# 扩展：nodejs配置本地静态服务器\n\n如果不用代码编辑器创建本地静服务器，也可以用nodejs配置。\n\n首先确保你电脑已经安装nodejs，然后npm安装live-server插件，安装后，进入课件或threejs官方文件根目录，输入live-server命令即可预览3d案例。\n\n// 安装live-server\nnpm install live-server -g\n\n\n不过平时为了开发方便，可以不用nodejs创建一个本地静态服务器，可以借助你的代码编辑器更方便，比如下面要说到的vscode。",charsets:{cjk:!0}},{title:"1. threejs文件包下载和目录简介",frontmatter:{title:"1. threejs文件包下载和目录简介",date:"2023-01-20T11:01:29.000Z",permalink:"/pages/aac9ab/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01.threejs%E6%96%87%E4%BB%B6%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/01.threejs文件包下载和目录简介.md",key:"v-1de226ea",path:"/pages/aac9ab/",headers:[{level:3,title:"Three.js版本问题",slug:"three-js版本问题",normalizedTitle:"three.js版本问题",charIndex:120},{level:3,title:"版本问题如何对待",slug:"版本问题如何对待",normalizedTitle:"版本问题如何对待",charIndex:310},{level:3,title:"特定版本three.js文件包下载",slug:"特定版本three-js文件包下载",normalizedTitle:"特定版本three.js文件包下载",charIndex:560},{level:3,title:"threejs文件资源目录介绍",slug:"threejs文件资源目录介绍",normalizedTitle:"threejs文件资源目录介绍",charIndex:811}],headersStr:"Three.js版本问题 版本问题如何对待 特定版本three.js文件包下载 threejs文件资源目录介绍",content:"# Threejs文件包下载和目录简介\n\n网易云付费系统课程\n\nb站免费入门视频\n\n在正式学习Three.js之前，先做一些必要的准备工作，具体说就是下载threejs官方文件包，threejs官方文件包提供了很多有用的学习资源。\n\n\n# Three.js版本问题\n\nThree.js处于飞速发展之中，过去几年和现在Three.js基本上每个月都会发布一个新的版本，主要是增加一些新的功能，也可能废弃或更名某些API。\n\nthreejs官方文件包所有版本：https://github.com/mrdoob/three.js/releases\n\nThreejs中文网(电子书课件)：www.webgl3d.cn\n\n\n# 版本问题如何对待\n\nthree.js官网可以下载three.js文件包，不过默认是最新版本的，three.js官网的文档一般也是当前最新版本。\n\n因为threejs每月更新的时候，API会有变化，我的建议是，实际开发的时候，three.js API的使用规则，一切以你项目threejs版本对应的文档为准，下节课会具体给大家说怎么在本地预览任何你想要的版本文档。\n\nThreejs官网中文文档链接：https://threejs.org/docs/index.html#manual/zh/\n\n\n# 特定版本three.js文件包下载\n\ngithub链接查看所有版本threejs：https://github.com/mrdoob/three.js/releases\n\n选择你需要的版本three.js文件包下载，然后解压，就可以预览里面的很多学习资源。\n\n如果你那边gihtub打不开或下载很慢，你可以去three.js中文网提供网盘资源下载。\n\n网盘链接:https://pan.baidu.com/s/1_Ix8TiOScypNcQe3BIl5vA?pwd=rrks 提取码:rrks\n\n\n# threejs文件资源目录介绍\n\n下载three.js文件包解压后，你可以看到如下目录(不同版本会略有差异)。\n\n对于开发者而言，大家经常接触的是文档docs和案例examples两个文件夹，平时查看文档，可以打开文档docs里面html文件，案例examples里面提供了海量threejs功能案例。\n\nthree.js-文件包\n└───build——three.js相关库，可以引入你的.html文件中。\n    │\n└───docs——Three.js API文档文件\n    │───index.html——打开该文件，本地离线方式预览threejs文档\n└───examples——大量的3D案例，是你平时开发参考学习的最佳资源\n    │───jsm——threejs各种功能扩展库\n└───src——Three.js引擎的源码，有兴趣可以阅读。\n    │\n└───editor——Three.js的可视化编辑器，可以编辑3D场景\n    │───index.html——打开应用程序  \n",normalizedContent:"# threejs文件包下载和目录简介\n\n网易云付费系统课程\n\nb站免费入门视频\n\n在正式学习three.js之前，先做一些必要的准备工作，具体说就是下载threejs官方文件包，threejs官方文件包提供了很多有用的学习资源。\n\n\n# three.js版本问题\n\nthree.js处于飞速发展之中，过去几年和现在three.js基本上每个月都会发布一个新的版本，主要是增加一些新的功能，也可能废弃或更名某些api。\n\nthreejs官方文件包所有版本：https://github.com/mrdoob/three.js/releases\n\nthreejs中文网(电子书课件)：www.webgl3d.cn\n\n\n# 版本问题如何对待\n\nthree.js官网可以下载three.js文件包，不过默认是最新版本的，three.js官网的文档一般也是当前最新版本。\n\n因为threejs每月更新的时候，api会有变化，我的建议是，实际开发的时候，three.js api的使用规则，一切以你项目threejs版本对应的文档为准，下节课会具体给大家说怎么在本地预览任何你想要的版本文档。\n\nthreejs官网中文文档链接：https://threejs.org/docs/index.html#manual/zh/\n\n\n# 特定版本three.js文件包下载\n\ngithub链接查看所有版本threejs：https://github.com/mrdoob/three.js/releases\n\n选择你需要的版本three.js文件包下载，然后解压，就可以预览里面的很多学习资源。\n\n如果你那边gihtub打不开或下载很慢，你可以去three.js中文网提供网盘资源下载。\n\n网盘链接:https://pan.baidu.com/s/1_ix8tioscypncqe3bil5va?pwd=rrks 提取码:rrks\n\n\n# threejs文件资源目录介绍\n\n下载three.js文件包解压后，你可以看到如下目录(不同版本会略有差异)。\n\n对于开发者而言，大家经常接触的是文档docs和案例examples两个文件夹，平时查看文档，可以打开文档docs里面html文件，案例examples里面提供了海量threejs功能案例。\n\nthree.js-文件包\n└───build——three.js相关库，可以引入你的.html文件中。\n    │\n└───docs——three.js api文档文件\n    │───index.html——打开该文件，本地离线方式预览threejs文档\n└───examples——大量的3d案例，是你平时开发参考学习的最佳资源\n    │───jsm——threejs各种功能扩展库\n└───src——three.js引擎的源码，有兴趣可以阅读。\n    │\n└───editor——three.js的可视化编辑器，可以编辑3d场景\n    │───index.html——打开应用程序  \n",charsets:{cjk:!0}},{title:"4. 第一个3D案例—创建3D场景",frontmatter:{title:"4. 第一个3D案例—创建3D场景",date:"2023-01-20T13:20:20.000Z",permalink:"/pages/2e5d69/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/04.%E7%AC%AC%E4%B8%80%E4%B8%AA3D%E6%A1%88%E4%BE%8B%E2%80%94%E5%88%9B%E5%BB%BA3D%E5%9C%BA%E6%99%AF.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/04.第一个3D案例—创建3D场景.md",key:"v-6d6dd174",path:"/pages/2e5d69/",headers:[{level:3,title:"三维场景Scene",slug:"三维场景scene",normalizedTitle:"三维场景scene",charIndex:204},{level:3,title:"物体形状：几何体Geometry",slug:"物体形状-几何体geometry",normalizedTitle:"物体形状：几何体geometry",charIndex:323},{level:3,title:"物体外观：材质Material",slug:"物体外观-材质material",normalizedTitle:"物体外观：材质material",charIndex:522},{level:3,title:"物体：网格模型Mesh",slug:"物体-网格模型mesh",normalizedTitle:"物体：网格模型mesh",charIndex:776},{level:3,title:"模型位置.position",slug:"模型位置-position",normalizedTitle:"模型位置.position",charIndex:948},{level:3,title:".add()方法",slug:"add-方法",normalizedTitle:".add()方法",charIndex:1165},{level:3,title:"后续内容",slug:"后续内容",normalizedTitle:"后续内容",charIndex:1265}],headersStr:"三维场景Scene 物体形状：几何体Geometry 物体外观：材质Material 物体：网格模型Mesh 模型位置.position .add()方法 后续内容",content:"# 第一个3D案例—创建3D场景\n\n网易云付费系统课程\n\nb站免费入门视频\n\n入门Three.js的第一步，就是认识场景Scene、相机Camera、渲染器Renderer三个基本概念，接下来，咱们通过三小节课，大家演示“第一个3D案例”完成实现过程。\n\n学习建议：只要你能把第一个3D案例搞明白，后面学习就会非常顺利了。\n\n本节课先完成第一个3D案例的一部分，也就是3D场景Scene的创建。\n\n\n\n\n# 三维场景Scene\n\n你可以把三维场景Scene对象理解为虚拟的3D场景，用来表示模拟生活中的真实三维场景,或者说三维世界。\n\n// 创建3D场景对象Scene\nconst scene = new THREE.Scene();\n\n\n\n# 物体形状：几何体Geometry\n\nThree.js提供了各种各样的几何体API，用来表示三维物体的几何形状。\n\n\n\n文档搜索关键词geometry你可以看到threejs提供各种几何体相关API，具体使用方法，也可以参考文档。\n\n//创建一个长方体几何对象Geometry\nconst geometry = new THREE.BoxGeometry(100, 100, 100); \n\n\n\n# 物体外观：材质Material\n\n如果你想定义物体的外观效果，比如颜色，就需要通过材质Material相关的API实现。\n\nthreejs不同材质渲染效果不同，下面就以threejs最简单的网格基础材质MeshBasicMaterial为例给大家实现一个红色材质效果。\n\n\n\n//创建一个材质对象Material\nconst material = new THREE.MeshBasicMaterial({\n    color: 0xff0000,//0xff0000设置材质颜色为红色\n}); \n\n\n\n# 物体：网格模型Mesh\n\n实际生活中有各种各样的物体，在threejs中可以通过网格模型Mesh表示一个虚拟的物体，比如一个箱子、一个鼠标。\n\n// 两个参数分别为几何体geometry、材质material\nconst mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh\n\n\n\n# 模型位置.position\n\n实际生活中，一个物体往往是有位置的，对于threejs而言也是一样的，你可以通过位置属性.position定义网格模型Mesh在三维场景Scene中的位置。\n\nconst mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh\n//设置网格模型在三维空间中的位置坐标，默认是坐标原点\nmesh.position.set(0,10,0);\n\n\n\n# .add()方法\n\n在threejs中你创建了一个表示物体的虚拟对象Mesh，需要通过.add()方法，把网格模型mesh添加到三维场景scene中。\n\nscene.add(mesh); \n\n\n\n# 后续内容\n\n写到这里，我知道你已经迫不及待想执行代码看看渲染效果了，那么你需要看看后面两节课关于相机Camera和渲染器Renderer的介绍\n\n本站内容转载和引用声明",normalizedContent:"# 第一个3d案例—创建3d场景\n\n网易云付费系统课程\n\nb站免费入门视频\n\n入门three.js的第一步，就是认识场景scene、相机camera、渲染器renderer三个基本概念，接下来，咱们通过三小节课，大家演示“第一个3d案例”完成实现过程。\n\n学习建议：只要你能把第一个3d案例搞明白，后面学习就会非常顺利了。\n\n本节课先完成第一个3d案例的一部分，也就是3d场景scene的创建。\n\n\n\n\n# 三维场景scene\n\n你可以把三维场景scene对象理解为虚拟的3d场景，用来表示模拟生活中的真实三维场景,或者说三维世界。\n\n// 创建3d场景对象scene\nconst scene = new three.scene();\n\n\n\n# 物体形状：几何体geometry\n\nthree.js提供了各种各样的几何体api，用来表示三维物体的几何形状。\n\n\n\n文档搜索关键词geometry你可以看到threejs提供各种几何体相关api，具体使用方法，也可以参考文档。\n\n//创建一个长方体几何对象geometry\nconst geometry = new three.boxgeometry(100, 100, 100); \n\n\n\n# 物体外观：材质material\n\n如果你想定义物体的外观效果，比如颜色，就需要通过材质material相关的api实现。\n\nthreejs不同材质渲染效果不同，下面就以threejs最简单的网格基础材质meshbasicmaterial为例给大家实现一个红色材质效果。\n\n\n\n//创建一个材质对象material\nconst material = new three.meshbasicmaterial({\n    color: 0xff0000,//0xff0000设置材质颜色为红色\n}); \n\n\n\n# 物体：网格模型mesh\n\n实际生活中有各种各样的物体，在threejs中可以通过网格模型mesh表示一个虚拟的物体，比如一个箱子、一个鼠标。\n\n// 两个参数分别为几何体geometry、材质material\nconst mesh = new three.mesh(geometry, material); //网格模型对象mesh\n\n\n\n# 模型位置.position\n\n实际生活中，一个物体往往是有位置的，对于threejs而言也是一样的，你可以通过位置属性.position定义网格模型mesh在三维场景scene中的位置。\n\nconst mesh = new three.mesh(geometry, material); //网格模型对象mesh\n//设置网格模型在三维空间中的位置坐标，默认是坐标原点\nmesh.position.set(0,10,0);\n\n\n\n# .add()方法\n\n在threejs中你创建了一个表示物体的虚拟对象mesh，需要通过.add()方法，把网格模型mesh添加到三维场景scene中。\n\nscene.add(mesh); \n\n\n\n# 后续内容\n\n写到这里，我知道你已经迫不及待想执行代码看看渲染效果了，那么你需要看看后面两节课关于相机camera和渲染器renderer的介绍\n\n本站内容转载和引用声明",charsets:{cjk:!0}},{title:"5. 第一个3D案例—透视投影相机",frontmatter:{title:"5. 第一个3D案例—透视投影相机",date:"2023-01-20T13:22:58.000Z",permalink:"/pages/c0b143/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/05.%E7%AC%AC%E4%B8%80%E4%B8%AA3D%E6%A1%88%E4%BE%8B%E2%80%94%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1%E7%9B%B8%E6%9C%BA.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/05.第一个3D案例—透视投影相机.md",key:"v-739ad686",path:"/pages/c0b143/",headers:[{level:3,title:"透视投影相机PerspectiveCamera",slug:"透视投影相机perspectivecamera",normalizedTitle:"透视投影相机perspectivecamera",charIndex:107},{level:3,title:"相机位置.position",slug:"相机位置-position",normalizedTitle:"相机位置.position",charIndex:341},{level:3,title:"相机观察目标.lookAt()",slug:"相机观察目标-lookat",normalizedTitle:"相机观察目标.lookat()",charIndex:583},{level:3,title:"判断相机相对三维场景中长方体位置",slug:"判断相机相对三维场景中长方体位置",normalizedTitle:"判断相机相对三维场景中长方体位置",charIndex:832},{level:3,title:"定义相机渲染输出的画布尺寸",slug:"定义相机渲染输出的画布尺寸",normalizedTitle:"定义相机渲染输出的画布尺寸",charIndex:1190},{level:3,title:"透视投影相机PerspectiveCamera：视锥体",slug:"透视投影相机perspectivecamera-视锥体",normalizedTitle:"透视投影相机perspectivecamera：视锥体",charIndex:1423}],headersStr:"透视投影相机PerspectiveCamera 相机位置.position 相机观察目标.lookAt() 判断相机相对三维场景中长方体位置 定义相机渲染输出的画布尺寸 透视投影相机PerspectiveCamera：视锥体",content:"# 第一个3D案例—透视投影相机\n\n视频讲解地址\n\nThreejs如果想把三维场景Scene渲染到web网页上，还需要定义一个虚拟相机Camera，就像你生活中想获得一张照片，需要一台用来拍照的相机。\n\n\n\n\n# 透视投影相机PerspectiveCamera\n\nThreejs提供了正投影相机OrthographicCamera和透视投影相机PerspectiveCamera。本节课先给大家比较常用的透视投影相机PerspectiveCamera。\n\n透视投影相机PerspectiveCamera本质上就是在模拟人眼观察这个世界的规律。\n\n// 实例化一个透视投影相机对象\nconst camera = new THREE.PerspectiveCamera();\n\n\n\n# 相机位置.position\n\n生活中用相机拍照，你相机位置不同，拍照结果也不同，threejs中虚拟相机同样如此。\n\n比如有一间房子，你拿着相机站在房间里面，看到的是房间内部，站在房子外面看到的是房子外面效果。\n\n相机对象Camera具有位置属性.position，通过位置属性.position可以设置相机的位置。\n\n//相机在Three.js三维坐标系中的位置\n// 根据需要设置相机位置具体值\ncamera.position.set(200, 200, 200); \n\n\n\n# 相机观察目标.lookAt()\n\n你用相机拍照你需要控制相机的拍照目标，具体说相机镜头对准哪个物体或说哪个坐标。对于threejs相机而言，就是设置.lookAt()方法的参数，指定一个3D坐标。\n\n//相机观察目标指向Threejs 3D空间中某个位置\ncamera.lookAt(0, 0, 0); //坐标原点\n\n\ncamera.lookAt(0, 10, 0);  //y轴上位置10\n\n\ncamera.lookAt(mesh.position);//指向mesh对应的位置\n\n\n\n\n\n# 判断相机相对三维场景中长方体位置\n\n你可以把三维场景中长方体mesh想象为一个房间，然后根据相机位置和长方体位置尺寸对比，判断两者相对位置。你可以发现设置相机坐标(200, 200, 200)，位于长方体外面一处位置。\n\n// 长方体尺寸100, 100, 100\nconst geometry = new THREE.BoxGeometry( 100, 100, 100 );\nconst mesh = new THREE.Mesh(geometry,material);\n// 网格模型位置xyz坐标：0,10,0\nmesh.position.set(0,10,0);\n// 相机位置xyz坐标：200, 200, 200\ncamera.position.set(200, 200, 200); \n\n\n\n\n\n# 定义相机渲染输出的画布尺寸\n\n你生活中相机拍照的照片是有大小的，对于threejs而言一样，需要定义相机在网页上输出的Canvas画布(照片)尺寸，大小可以根据需要定义，这里先随机定义一个尺寸。\n\nCanvas画布：课程中会把threejs虚拟相机渲染三维场景在浏览器网页上呈现的结果称为Canvas画布。\n\n// 定义相机输出画布的尺寸(单位:像素px)\nconst width = 800; //宽度\nconst height = 500; //高度\n\n\n\n# 透视投影相机PerspectiveCamera：视锥体\n\n透视投影相机的四个参数fov, aspect, near, far构成一个四棱台3D空间，被称为视锥体，只有视锥体之内的物体，才会渲染出来，视锥体范围之外的物体不会显示在Canvas画布上。\n\n\n\n// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)\nconst width = 800; //宽度\nconst height = 500; //高度\n// 30:视场角度, width / height:Canvas画布宽高比, 1:近裁截面, 3000：远裁截面\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\n\n\nPerspectiveCamera参数介绍：\n\nPerspectiveCamera( fov, aspect, near, far )\n\n\n参数       含义                                                 默认值\nfov      相机视锥体竖直方向视野角度                                      50\naspect   相机视锥体水平方向和竖直方向长度比，一般设置为Canvas画布宽高比width / height   1\nnear     相机视锥体近裁截面相对相机距离                                    0.1\nfar      相机视锥体远裁截面相对相机距离，far-near构成了视锥体高度方向                 2000",normalizedContent:"# 第一个3d案例—透视投影相机\n\n视频讲解地址\n\nthreejs如果想把三维场景scene渲染到web网页上，还需要定义一个虚拟相机camera，就像你生活中想获得一张照片，需要一台用来拍照的相机。\n\n\n\n\n# 透视投影相机perspectivecamera\n\nthreejs提供了正投影相机orthographiccamera和透视投影相机perspectivecamera。本节课先给大家比较常用的透视投影相机perspectivecamera。\n\n透视投影相机perspectivecamera本质上就是在模拟人眼观察这个世界的规律。\n\n// 实例化一个透视投影相机对象\nconst camera = new three.perspectivecamera();\n\n\n\n# 相机位置.position\n\n生活中用相机拍照，你相机位置不同，拍照结果也不同，threejs中虚拟相机同样如此。\n\n比如有一间房子，你拿着相机站在房间里面，看到的是房间内部，站在房子外面看到的是房子外面效果。\n\n相机对象camera具有位置属性.position，通过位置属性.position可以设置相机的位置。\n\n//相机在three.js三维坐标系中的位置\n// 根据需要设置相机位置具体值\ncamera.position.set(200, 200, 200); \n\n\n\n# 相机观察目标.lookat()\n\n你用相机拍照你需要控制相机的拍照目标，具体说相机镜头对准哪个物体或说哪个坐标。对于threejs相机而言，就是设置.lookat()方法的参数，指定一个3d坐标。\n\n//相机观察目标指向threejs 3d空间中某个位置\ncamera.lookat(0, 0, 0); //坐标原点\n\n\ncamera.lookat(0, 10, 0);  //y轴上位置10\n\n\ncamera.lookat(mesh.position);//指向mesh对应的位置\n\n\n\n\n\n# 判断相机相对三维场景中长方体位置\n\n你可以把三维场景中长方体mesh想象为一个房间，然后根据相机位置和长方体位置尺寸对比，判断两者相对位置。你可以发现设置相机坐标(200, 200, 200)，位于长方体外面一处位置。\n\n// 长方体尺寸100, 100, 100\nconst geometry = new three.boxgeometry( 100, 100, 100 );\nconst mesh = new three.mesh(geometry,material);\n// 网格模型位置xyz坐标：0,10,0\nmesh.position.set(0,10,0);\n// 相机位置xyz坐标：200, 200, 200\ncamera.position.set(200, 200, 200); \n\n\n\n\n\n# 定义相机渲染输出的画布尺寸\n\n你生活中相机拍照的照片是有大小的，对于threejs而言一样，需要定义相机在网页上输出的canvas画布(照片)尺寸，大小可以根据需要定义，这里先随机定义一个尺寸。\n\ncanvas画布：课程中会把threejs虚拟相机渲染三维场景在浏览器网页上呈现的结果称为canvas画布。\n\n// 定义相机输出画布的尺寸(单位:像素px)\nconst width = 800; //宽度\nconst height = 500; //高度\n\n\n\n# 透视投影相机perspectivecamera：视锥体\n\n透视投影相机的四个参数fov, aspect, near, far构成一个四棱台3d空间，被称为视锥体，只有视锥体之内的物体，才会渲染出来，视锥体范围之外的物体不会显示在canvas画布上。\n\n\n\n// width和height用来设置three.js输出的canvas画布尺寸(像素px)\nconst width = 800; //宽度\nconst height = 500; //高度\n// 30:视场角度, width / height:canvas画布宽高比, 1:近裁截面, 3000：远裁截面\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\n\n\nperspectivecamera参数介绍：\n\nperspectivecamera( fov, aspect, near, far )\n\n\n参数       含义                                                 默认值\nfov      相机视锥体竖直方向视野角度                                      50\naspect   相机视锥体水平方向和竖直方向长度比，一般设置为canvas画布宽高比width / height   1\nnear     相机视锥体近裁截面相对相机距离                                    0.1\nfar      相机视锥体远裁截面相对相机距离，far-near构成了视锥体高度方向                 2000",charsets:{cjk:!0}},{title:"6. 第一个3D案例—渲染器",frontmatter:{title:"6. 第一个3D案例—渲染器",date:"2023-01-20T13:24:55.000Z",permalink:"/pages/b483f0/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/06.%E7%AC%AC%E4%B8%80%E4%B8%AA3D%E6%A1%88%E4%BE%8B%E2%80%94%E6%B8%B2%E6%9F%93%E5%99%A8.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/06.第一个3D案例—渲染器.md",key:"v-f61c8362",path:"/pages/b483f0/",headers:[{level:3,title:"WebGL渲染器WebGLRenderer",slug:"webgl渲染器webglrenderer",normalizedTitle:"webgl渲染器webglrenderer",charIndex:105},{level:3,title:"设置Canvas画布尺寸.setSize()",slug:"设置canvas画布尺寸-setsize",normalizedTitle:"设置canvas画布尺寸.setsize()",charIndex:260},{level:3,title:"渲染器渲染方法.render()",slug:"渲染器渲染方法-render",normalizedTitle:"渲染器渲染方法.render()",charIndex:426},{level:3,title:"渲染器Canvas画布属性.domElement",slug:"渲染器canvas画布属性-domelement",normalizedTitle:"渲染器canvas画布属性.domelement",charIndex:595},{level:3,title:"Canvas画布插入到任意HTML元素中",slug:"canvas画布插入到任意html元素中",normalizedTitle:"canvas画布插入到任意html元素中",charIndex:770}],headersStr:"WebGL渲染器WebGLRenderer 设置Canvas画布尺寸.setSize() 渲染器渲染方法.render() 渲染器Canvas画布属性.domElement Canvas画布插入到任意HTML元素中",content:'# 第一个3D案例—渲染器\n\n视频讲解\n\n生活中如果有了景物和相机，那么如果想获得一张照片，就需要你拿着相机，按一下，咔，完成拍照。对于threejs而言，如果完成“咔”这个拍照动作，就需要一个新的对象，也就是WebGL渲染器WebGLRenderer。\n\n\n\n\n# WebGL渲染器WebGLRenderer\n\n通过WebGL渲染器WebGLRenderer可以实例化一个WebGL渲染器对象。\n\n// 创建渲染器对象\nconst renderer = new THREE.WebGLRenderer();\n\n\n\n# 设置Canvas画布尺寸.setSize()\n\n// 定义threejs输出画布的尺寸(单位:像素px)\nconst width = 800; //宽度\nconst height = 500; //高度\nrenderer.setSize(width, height); //设置three.js渲染区域的尺寸(像素px)\n\n\n\n# 渲染器渲染方法.render()\n\n渲染器WebGLRenderer执行渲染方法.render()就可以生成一个Canvas画布(照片)，并把三维场景Scene呈现在canvas画布上面,你可以把.render()理解为相机的拍照动作“咔”。\n\nrenderer.render(scene, camera); //执行渲染操作\n\n\n\n# 渲染器Canvas画布属性.domElement\n\n渲染器WebGLRenderer通过属性.domElement可以获得渲染方法.render()生成的Canvas画布，.domElement本质上就是一个HTML元素：Canvas画布。\n\ndocument.body.appendChild(renderer.domElement);\n\n\n\n# Canvas画布插入到任意HTML元素中\n\n<div id="webgl" style="margin-top: 200px;margin-left: 100px;"></div>\n\n\ndocument.getElementById(\'webgl\').appendChild(renderer.domElement);\n',normalizedContent:'# 第一个3d案例—渲染器\n\n视频讲解\n\n生活中如果有了景物和相机，那么如果想获得一张照片，就需要你拿着相机，按一下，咔，完成拍照。对于threejs而言，如果完成“咔”这个拍照动作，就需要一个新的对象，也就是webgl渲染器webglrenderer。\n\n\n\n\n# webgl渲染器webglrenderer\n\n通过webgl渲染器webglrenderer可以实例化一个webgl渲染器对象。\n\n// 创建渲染器对象\nconst renderer = new three.webglrenderer();\n\n\n\n# 设置canvas画布尺寸.setsize()\n\n// 定义threejs输出画布的尺寸(单位:像素px)\nconst width = 800; //宽度\nconst height = 500; //高度\nrenderer.setsize(width, height); //设置three.js渲染区域的尺寸(像素px)\n\n\n\n# 渲染器渲染方法.render()\n\n渲染器webglrenderer执行渲染方法.render()就可以生成一个canvas画布(照片)，并把三维场景scene呈现在canvas画布上面,你可以把.render()理解为相机的拍照动作“咔”。\n\nrenderer.render(scene, camera); //执行渲染操作\n\n\n\n# 渲染器canvas画布属性.domelement\n\n渲染器webglrenderer通过属性.domelement可以获得渲染方法.render()生成的canvas画布，.domelement本质上就是一个html元素：canvas画布。\n\ndocument.body.appendchild(renderer.domelement);\n\n\n\n# canvas画布插入到任意html元素中\n\n<div id="webgl" style="margin-top: 200px;margin-left: 100px;"></div>\n\n\ndocument.getelementbyid(\'webgl\').appendchild(renderer.domelement);\n',charsets:{cjk:!0}},{title:"3. 开发和学习环境，引入threejs",frontmatter:{title:"3. 开发和学习环境，引入threejs",date:"2023-01-20T13:19:52.000Z",permalink:"/pages/cd35b2/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03.%E5%BC%80%E5%8F%91%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%EF%BC%8C%E5%BC%95%E5%85%A5threejs%E5%BA%93.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/03.开发和学习环境，引入threejs库.md",key:"v-6d376c5c",path:"/pages/cd35b2/",headers:[{level:3,title:"项目的开发环境引入threejs",slug:"项目的开发环境引入threejs",normalizedTitle:"项目的开发环境引入threejs",charIndex:148},{level:3,title:"npm安装后，如何引入three.js",slug:"npm安装后-如何引入three-js",normalizedTitle:"npm安装后，如何引入three.js",charIndex:333},{level:3,title:"npm安装后，如何引入three.js其他扩展库",slug:"npm安装后-如何引入three-js其他扩展库",normalizedTitle:"npm安装后，如何引入three.js其他扩展库",charIndex:495},{level:3,title:"学习环境：.html文件中直接引入threejs",slug:"学习环境-html文件中直接引入threejs",normalizedTitle:"学习环境：.html文件中直接引入threejs",charIndex:935},{level:3,title:"script标签方式引入three.js",slug:"script标签方式引入three-js",normalizedTitle:"script标签方式引入three.js",charIndex:1081},{level:3,title:"ES6 import方式引入",slug:"es6-import方式引入",normalizedTitle:"es6 import方式引入",charIndex:1303},{level:3,title:'type="importmap"配置路径',slug:"type-importmap-配置路径",normalizedTitle:"type=&quot;importmap&quot;配置路径",charIndex:null},{level:3,title:'type="importmap"配置——扩展库引入',slug:"type-importmap-配置-扩展库引入",normalizedTitle:"type=&quot;importmap&quot;配置——扩展库引入",charIndex:null}],headersStr:'项目的开发环境引入threejs npm安装后，如何引入three.js npm安装后，如何引入three.js其他扩展库 学习环境：.html文件中直接引入threejs script标签方式引入three.js ES6 import方式引入 type="importmap"配置路径 type="importmap"配置——扩展库引入',content:'# 开发和学习环境，引入threejs库\n\n视频讲解\n\n本节课主要给大家说下threejs怎么引入的问题。\n\n 1. 开发环境：项目开发引入threejs，比如vue或react脚手架引入threejs。\n 2. 学习环境：入门threejs阶段，.html文件中直接引入threejs\n\n\n# 项目的开发环境引入threejs\n\n比如你采用的是Vue + threejs或React + threejs技术栈，这很简单，threejs就是一个js库，直接通过npm命令行安装就行。\n\nnpm安装特定版本three.js(注意使用哪个版本，查文档就查对应版本)\n\n// 比如安装148版本\nnpm install three@0.148.0 --save\n\n\n\n# npm安装后，如何引入three.js\n\n执行import * as THREE from \'three\';,ES6语法引入three.js核心。\n\n// 引入three.js\nimport * as THREE from \'three\';\n\n\n如果你没有前端ES6基础，可以参考我分享的前端公开课ES6入门教程。\n\n\n# npm安装后，如何引入three.js其他扩展库\n\n除了three.js核心库以外，在threejs文件包中examples/jsm目录下，你还可以看到各种不同功能的扩展库。\n\n一般来说，你项目用到那个扩展库，就引入那个，用不到就不需要引入。\n\n// 引入扩展库OrbitControls.js\nimport { OrbitControls } from \'three/addons/controls/OrbitControls.js\';\n// 引入扩展库GLTFLoader.js\nimport { GLTFLoader } from \'three/addons/loaders/GLTFLoader.js\';\n\n\n// 扩展库引入——旧版本，比如122, 新版本路径addons替换了examples/jsm\nimport { OrbitControls } from \'three/examples/jsm/controls/OrbitControls.js\';\n\n\n\n# 学习环境：.html文件中直接引入threejs\n\n如果不是正式开发Web3D项目，只是学习threejs功能，完全没必要用webpack或vite搭建一个开发环境。\n\n学习使用的环境，只要创建一个.html文件，编写threejs代码，最后通过本地静态服务打开.html文件就行。\n\n\n# script标签方式引入three.js\n\n你可以像平时开发web前端项目一样，通过script标签把three.js当做一个js库引入你的项目。\n\nthree.js库可以在threejs官方文件包下面的build目录获取到。\n\n<script src="./build/three.js"><\/script>\n\n\n//随便输入一个API，测试下是否已经正常引入three.js\nconsole.log(THREE.Scene); \n\n\n\n# ES6 import方式引入\n\n给script标签设置type="module",也可以在.html文件中使用import方式引入three.js。\n\n<script type="module">\n// 现在浏览器支持ES6语法，自然包括import方式引入js文件\nimport * as THREE from \'./build/three.module.js\';\n<\/script>\n\n\n\n# type="importmap"配置路径\n\n学习环境中，.html文件引入three.js，最好的方式就是参考threejs官方案例，通过配置<script type="importmap">,实现学习环境.html文件和vue或reaact脚手架开发环境一样的写法。这样你实际项目的开发环境复制课程源码，不用改变threejs引入代码。\n\n下面配置的type="importmap"代码具体写法不用掌握记忆，复制粘贴后，能修改目录就行，你可以去电子书课件或者课件源码中复制。\n\n\x3c!-- 具体路径配置，你根据自己文件目录设置，我的是课件中源码形式 --\x3e\n<script type="importmap">\n    {\n\t\t"imports": {\n\t\t\t"three": "../../../three.js/build/three.module.js"\n\t\t}\n\t}\n<\/script>\n\n\n\x3c!-- 配置type="importmap",.html文件也能和项目开发环境一样方式引入threejs --\x3e\n<script type="module">\n    import * as THREE from \'three\';\n    // 浏览器控制台测试，是否引入成功\n    console.log(THREE.Scene);\n<\/script>\n\n\n\n# type="importmap"配置——扩展库引入\n\n通过配置<script type="importmap">，让学习环境.html文件，也能和vue或react开发环境中一样方式方式引入threejs扩展库。\n\n配置addons/等价于examples/jsm/。\n\n<script type="importmap">\n    {\n\t\t"imports": {\n\t\t\t"three": "./three.js/build/three.module.js",\n            "three/addons/": "./three.js/examples/jsm/"\n\t\t}\n\t}\n<\/script>\n\n\n<script type="module">\n    // three/addons/路径之后对应的是three.js官方文件包`/examples/jsm/`中的js库\n    // 扩展库OrbitControls.js\n    import { OrbitControls } from \'three/addons/controls/OrbitControls.js\';\n    // 扩展库GLTFLoader.js\n    import { GLTFLoader } from \'three/addons/loaders/GLTFLoader.js\';\n    console.log(OrbitControls);\n    console.log(GLTFLoader);\n<\/script>\n',normalizedContent:'# 开发和学习环境，引入threejs库\n\n视频讲解\n\n本节课主要给大家说下threejs怎么引入的问题。\n\n 1. 开发环境：项目开发引入threejs，比如vue或react脚手架引入threejs。\n 2. 学习环境：入门threejs阶段，.html文件中直接引入threejs\n\n\n# 项目的开发环境引入threejs\n\n比如你采用的是vue + threejs或react + threejs技术栈，这很简单，threejs就是一个js库，直接通过npm命令行安装就行。\n\nnpm安装特定版本three.js(注意使用哪个版本，查文档就查对应版本)\n\n// 比如安装148版本\nnpm install three@0.148.0 --save\n\n\n\n# npm安装后，如何引入three.js\n\n执行import * as three from \'three\';,es6语法引入three.js核心。\n\n// 引入three.js\nimport * as three from \'three\';\n\n\n如果你没有前端es6基础，可以参考我分享的前端公开课es6入门教程。\n\n\n# npm安装后，如何引入three.js其他扩展库\n\n除了three.js核心库以外，在threejs文件包中examples/jsm目录下，你还可以看到各种不同功能的扩展库。\n\n一般来说，你项目用到那个扩展库，就引入那个，用不到就不需要引入。\n\n// 引入扩展库orbitcontrols.js\nimport { orbitcontrols } from \'three/addons/controls/orbitcontrols.js\';\n// 引入扩展库gltfloader.js\nimport { gltfloader } from \'three/addons/loaders/gltfloader.js\';\n\n\n// 扩展库引入——旧版本，比如122, 新版本路径addons替换了examples/jsm\nimport { orbitcontrols } from \'three/examples/jsm/controls/orbitcontrols.js\';\n\n\n\n# 学习环境：.html文件中直接引入threejs\n\n如果不是正式开发web3d项目，只是学习threejs功能，完全没必要用webpack或vite搭建一个开发环境。\n\n学习使用的环境，只要创建一个.html文件，编写threejs代码，最后通过本地静态服务打开.html文件就行。\n\n\n# script标签方式引入three.js\n\n你可以像平时开发web前端项目一样，通过script标签把three.js当做一个js库引入你的项目。\n\nthree.js库可以在threejs官方文件包下面的build目录获取到。\n\n<script src="./build/three.js"><\/script>\n\n\n//随便输入一个api，测试下是否已经正常引入three.js\nconsole.log(three.scene); \n\n\n\n# es6 import方式引入\n\n给script标签设置type="module",也可以在.html文件中使用import方式引入three.js。\n\n<script type="module">\n// 现在浏览器支持es6语法，自然包括import方式引入js文件\nimport * as three from \'./build/three.module.js\';\n<\/script>\n\n\n\n# type="importmap"配置路径\n\n学习环境中，.html文件引入three.js，最好的方式就是参考threejs官方案例，通过配置<script type="importmap">,实现学习环境.html文件和vue或reaact脚手架开发环境一样的写法。这样你实际项目的开发环境复制课程源码，不用改变threejs引入代码。\n\n下面配置的type="importmap"代码具体写法不用掌握记忆，复制粘贴后，能修改目录就行，你可以去电子书课件或者课件源码中复制。\n\n\x3c!-- 具体路径配置，你根据自己文件目录设置，我的是课件中源码形式 --\x3e\n<script type="importmap">\n    {\n\t\t"imports": {\n\t\t\t"three": "../../../three.js/build/three.module.js"\n\t\t}\n\t}\n<\/script>\n\n\n\x3c!-- 配置type="importmap",.html文件也能和项目开发环境一样方式引入threejs --\x3e\n<script type="module">\n    import * as three from \'three\';\n    // 浏览器控制台测试，是否引入成功\n    console.log(three.scene);\n<\/script>\n\n\n\n# type="importmap"配置——扩展库引入\n\n通过配置<script type="importmap">，让学习环境.html文件，也能和vue或react开发环境中一样方式方式引入threejs扩展库。\n\n配置addons/等价于examples/jsm/。\n\n<script type="importmap">\n    {\n\t\t"imports": {\n\t\t\t"three": "./three.js/build/three.module.js",\n            "three/addons/": "./three.js/examples/jsm/"\n\t\t}\n\t}\n<\/script>\n\n\n<script type="module">\n    // three/addons/路径之后对应的是three.js官方文件包`/examples/jsm/`中的js库\n    // 扩展库orbitcontrols.js\n    import { orbitcontrols } from \'three/addons/controls/orbitcontrols.js\';\n    // 扩展库gltfloader.js\n    import { gltfloader } from \'three/addons/loaders/gltfloader.js\';\n    console.log(orbitcontrols);\n    console.log(gltfloader);\n<\/script>\n',charsets:{cjk:!0}},{title:"7. 三维坐标系-加强三维空间认识",frontmatter:{title:"7. 三维坐标系-加强三维空间认识",date:"2023-01-20T14:44:05.000Z",permalink:"/pages/6abb06/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/07.Threejs%E4%B8%89%E7%BB%B4%E5%9D%90%E6%A0%87%E7%B3%BB%E2%80%94%E5%8A%A0%E5%BC%BA%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E8%AE%A4%E8%AF%86.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/07.Threejs三维坐标系—加强三维空间认识.md",key:"v-18d00a90",path:"/pages/6abb06/",headers:[{level:3,title:"辅助观察坐标系",slug:"辅助观察坐标系",normalizedTitle:"辅助观察坐标系",charIndex:66},{level:3,title:"材质半透明设置",slug:"材质半透明设置",normalizedTitle:"材质半透明设置",charIndex:222},{level:3,title:"AxesHelper的xyz轴",slug:"axeshelper的xyz轴",normalizedTitle:"axeshelper的xyz轴",charIndex:394},{level:3,title:"设置模型在坐标系中的位置或尺寸",slug:"设置模型在坐标系中的位置或尺寸",normalizedTitle:"设置模型在坐标系中的位置或尺寸",charIndex:475},{level:3,title:"改变相机参数——预览新的渲染效果",slug:"改变相机参数-预览新的渲染效果",normalizedTitle:"改变相机参数——预览新的渲染效果",charIndex:684}],headersStr:"辅助观察坐标系 材质半透明设置 AxesHelper的xyz轴 设置模型在坐标系中的位置或尺寸 改变相机参数——预览新的渲染效果",content:"# threejs三维坐标系—加强三维空间认识\n\n视频讲解\n\n本节课的目的就是为了加强大家对threejs三维空间的认识。\n\n\n# 辅助观察坐标系\n\nTHREE.AxesHelper()的参数表示坐标系坐标轴线段尺寸大小，你可以根据需要改变尺寸。\n\n// AxesHelper：辅助观察的坐标系\nconst axesHelper = new THREE.AxesHelper(150);\nscene.add(axesHelper);\n\n\n\n# 材质半透明设置\n\n设置材质半透明,这样可以看到坐标系的坐标原点。\n\nconst material = new THREE.MeshBasicMaterial({\n    color: 0x0000ff, //设置材质颜色\n    transparent:true,//开启透明\n    opacity:0.5,//设置透明度\n});\n\n\n\n# AxesHelper的xyz轴\n\nthree.js坐标轴颜色红R、绿G、蓝B分别对应坐标系的x、y、z轴，对于three.js的3D坐标系默认y轴朝上。\n\n\n# 设置模型在坐标系中的位置或尺寸\n\n通过模型的位置、尺寸设置，加深3D坐标系的概念。\n\n测试：设置长方体xyz不同方向尺寸\n\n// 设置几何体长宽高，也就是x、y、z三个方向的尺寸\n//对比三个参数分别对应xyz轴哪个方向\nnew THREE.BoxGeometry(100, 60, 20);\n\n\n测试：改变位置\n\n// 设置模型mesh的xyz坐标\nmesh.position.set(100,0,0);\n\n\n\n# 改变相机参数——预览新的渲染效果\n\n你可以尝试源码中改变相机的参数，看看场景中的物体渲染效果怎么变化。\n\n相机放在x轴负半轴，目标观察点是坐标原点，这样相当于相机的视线是沿着x轴正方向，只能看到长方体的一个矩形平面。\n\ncamera.position.set(-1000, 0, 0);\ncamera.lookAt(0, 0, 0);\n\n\n// 相机视线沿着x轴负半轴，mesh位于相机后面，自然看不到\ncamera.position.set(-1000, 0, 0);\ncamera.lookAt(-2000, 0, 0);\n\n\n相机far偏小，mesh位于far之外，物体不会显示在画布上。\n\n// const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\n// 你可以进行下面测试，改变相机参数，把mesh放在视锥体之外，看看是否显示\n// 3000改为300，使mesh位于far之外，mesh不在视锥体内，被剪裁掉\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 300);\n\n\n",normalizedContent:"# threejs三维坐标系—加强三维空间认识\n\n视频讲解\n\n本节课的目的就是为了加强大家对threejs三维空间的认识。\n\n\n# 辅助观察坐标系\n\nthree.axeshelper()的参数表示坐标系坐标轴线段尺寸大小，你可以根据需要改变尺寸。\n\n// axeshelper：辅助观察的坐标系\nconst axeshelper = new three.axeshelper(150);\nscene.add(axeshelper);\n\n\n\n# 材质半透明设置\n\n设置材质半透明,这样可以看到坐标系的坐标原点。\n\nconst material = new three.meshbasicmaterial({\n    color: 0x0000ff, //设置材质颜色\n    transparent:true,//开启透明\n    opacity:0.5,//设置透明度\n});\n\n\n\n# axeshelper的xyz轴\n\nthree.js坐标轴颜色红r、绿g、蓝b分别对应坐标系的x、y、z轴，对于three.js的3d坐标系默认y轴朝上。\n\n\n# 设置模型在坐标系中的位置或尺寸\n\n通过模型的位置、尺寸设置，加深3d坐标系的概念。\n\n测试：设置长方体xyz不同方向尺寸\n\n// 设置几何体长宽高，也就是x、y、z三个方向的尺寸\n//对比三个参数分别对应xyz轴哪个方向\nnew three.boxgeometry(100, 60, 20);\n\n\n测试：改变位置\n\n// 设置模型mesh的xyz坐标\nmesh.position.set(100,0,0);\n\n\n\n# 改变相机参数——预览新的渲染效果\n\n你可以尝试源码中改变相机的参数，看看场景中的物体渲染效果怎么变化。\n\n相机放在x轴负半轴，目标观察点是坐标原点，这样相当于相机的视线是沿着x轴正方向，只能看到长方体的一个矩形平面。\n\ncamera.position.set(-1000, 0, 0);\ncamera.lookat(0, 0, 0);\n\n\n// 相机视线沿着x轴负半轴，mesh位于相机后面，自然看不到\ncamera.position.set(-1000, 0, 0);\ncamera.lookat(-2000, 0, 0);\n\n\n相机far偏小，mesh位于far之外，物体不会显示在画布上。\n\n// const camera = new three.perspectivecamera(30, width / height, 1, 3000);\n// 你可以进行下面测试，改变相机参数，把mesh放在视锥体之外，看看是否显示\n// 3000改为300，使mesh位于far之外，mesh不在视锥体内，被剪裁掉\nconst camera = new three.perspectivecamera(30, width / height, 1, 300);\n\n\n",charsets:{cjk:!0}},{title:"9. 相机控件OrbitControls",frontmatter:{title:"9. 相机控件OrbitControls",date:"2023-01-20T15:09:08.000Z",permalink:"/pages/837374/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/09.%E7%9B%B8%E6%9C%BA%E6%8E%A7%E4%BB%B6%E8%BD%A8%E9%81%93%E6%8E%A7%E5%88%B6%E5%99%A8OrbitControls.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/09.相机控件轨道控制器OrbitControls.md",key:"v-7deb3ce7",path:"/pages/837374/",headers:[{level:3,title:"OrbitControls使用",slug:"orbitcontrols使用",normalizedTitle:"orbitcontrols使用",charIndex:88},{level:3,title:"引入扩展库OrbitControls.js",slug:"引入扩展库orbitcontrols-js",normalizedTitle:"引入扩展库orbitcontrols.js",charIndex:167},{level:3,title:"使用OrbitControls",slug:"使用orbitcontrols",normalizedTitle:"使用orbitcontrols",charIndex:607},{level:3,title:"OrbitControls本质",slug:"orbitcontrols本质",normalizedTitle:"orbitcontrols本质",charIndex:873}],headersStr:"OrbitControls使用 引入扩展库OrbitControls.js 使用OrbitControls OrbitControls本质",content:'# 相机控件轨道控制器OrbitControls\n\n视频讲解\n\n平时开发调试代码，或者展示模型的时候，可以通过相机控件OrbitControls实现旋转缩放预览效果。\n\n\n# OrbitControls使用\n\n你可以打开课件案例源码测试下效果。\n\n * 旋转：拖动鼠标左键\n * 缩放：滚动鼠标中键\n * 平移：拖动鼠标右键\n\n\n# 引入扩展库OrbitControls.js\n\n// 引入轨道控制器扩展库OrbitControls.js\nimport { OrbitControls } from \'three/addons/controls/OrbitControls.js\';\n\n\n注意：如果你在原生.html文件中，使用上面引入方式import { OrbitControls } from \'three/addons/controls/OrbitControls.js\';，注意通过<script type="importmap">配置。\n\n<script type="importmap">\n    {\n\t\t"imports": {\n\t\t\t"three": "../../../three.js/build/three.module.js",\n      "three/addons/": "../../../three.js/examples/jsm/"\n\t\t}\n\t}\n<\/script>\n\n\n\n# 使用OrbitControls\n\n// 设置相机控件轨道控制器OrbitControls\nconst controls = new OrbitControls(camera, renderer.domElement);\n// 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景\ncontrols.addEventListener(\'change\', function () {\n    renderer.render(scene, camera); //执行渲染操作\n});//监听鼠标、键盘事件\n\n\n\n\n# OrbitControls本质\n\nOrbitControls本质上就是改变相机的参数，比如相机的位置属性，改变相机位置也可以改变相机拍照场景中模型的角度，实现模型的360度旋转预览效果，改变透视投影相机距离模型的距离，就可以改变相机能看到的视野范围。\n\ncontrols.addEventListener(\'change\', function () {\n    // 浏览器控制台查看相机位置变化\n    console.log(\'camera.position\',camera.position);\n});\n',normalizedContent:'# 相机控件轨道控制器orbitcontrols\n\n视频讲解\n\n平时开发调试代码，或者展示模型的时候，可以通过相机控件orbitcontrols实现旋转缩放预览效果。\n\n\n# orbitcontrols使用\n\n你可以打开课件案例源码测试下效果。\n\n * 旋转：拖动鼠标左键\n * 缩放：滚动鼠标中键\n * 平移：拖动鼠标右键\n\n\n# 引入扩展库orbitcontrols.js\n\n// 引入轨道控制器扩展库orbitcontrols.js\nimport { orbitcontrols } from \'three/addons/controls/orbitcontrols.js\';\n\n\n注意：如果你在原生.html文件中，使用上面引入方式import { orbitcontrols } from \'three/addons/controls/orbitcontrols.js\';，注意通过<script type="importmap">配置。\n\n<script type="importmap">\n    {\n\t\t"imports": {\n\t\t\t"three": "../../../three.js/build/three.module.js",\n      "three/addons/": "../../../three.js/examples/jsm/"\n\t\t}\n\t}\n<\/script>\n\n\n\n# 使用orbitcontrols\n\n// 设置相机控件轨道控制器orbitcontrols\nconst controls = new orbitcontrols(camera, renderer.domelement);\n// 如果orbitcontrols改变了相机参数，重新调用渲染器渲染三维场景\ncontrols.addeventlistener(\'change\', function () {\n    renderer.render(scene, camera); //执行渲染操作\n});//监听鼠标、键盘事件\n\n\n\n\n# orbitcontrols本质\n\norbitcontrols本质上就是改变相机的参数，比如相机的位置属性，改变相机位置也可以改变相机拍照场景中模型的角度，实现模型的360度旋转预览效果，改变透视投影相机距离模型的距离，就可以改变相机能看到的视野范围。\n\ncontrols.addeventlistener(\'change\', function () {\n    // 浏览器控制台查看相机位置变化\n    console.log(\'camera.position\',camera.position);\n});\n',charsets:{cjk:!0}},{title:"8. 光源对物体表面影响",frontmatter:{title:"8. 光源对物体表面影响",date:"2023-01-20T14:56:09.000Z",permalink:"/pages/b9504a/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/08.%E5%85%89%E6%BA%90%E5%AF%B9%E7%89%A9%E4%BD%93%E8%A1%A8%E9%9D%A2%E5%BD%B1%E5%93%8D.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/08.光源对物体表面影响.md",key:"v-19f32a6c",path:"/pages/b9504a/",headers:[{level:3,title:"受光照影响材质",slug:"受光照影响材质",normalizedTitle:"受光照影响材质",charIndex:203},{level:3,title:"光源简介",slug:"光源简介",normalizedTitle:"光源简介",charIndex:574},{level:3,title:"点光源",slug:"点光源",normalizedTitle:"点光源",charIndex:630},{level:3,title:"光源衰减",slug:"光源衰减",normalizedTitle:"光源衰减",charIndex:922},{level:3,title:"光源位置",slug:"光源位置",normalizedTitle:"光源位置",charIndex:1258},{level:3,title:"光源添加到场景",slug:"光源添加到场景",normalizedTitle:"光源添加到场景",charIndex:1411},{level:3,title:"改变光源位置，观察网格模型表面的明暗变化。",slug:"改变光源位置-观察网格模型表面的明暗变化。",normalizedTitle:"改变光源位置，观察网格模型表面的明暗变化。",charIndex:1538}],headersStr:"受光照影响材质 光源简介 点光源 光源衰减 光源位置 光源添加到场景 改变光源位置，观察网格模型表面的明暗变化。",content:"# 光源对物体表面影响\n\n视频讲解\n\n实际生活中物体表面的明暗效果是会受到光照的影响，比如晚上不开灯，你就看不到物体，灯光比较暗，物体也比较暗。在threejs中，咱们用网格模型Mesh模拟生活中物体，所以threejs中模拟光照Light对物体表面的影响，就是模拟光照Light对网格模型Mesh表面的影响。\n\n你可以打开课件中案例源码，对比有光照和无光照两种情况，网格模型Mesh表面的差异。\n\n\n# 受光照影响材质\n\nthreejs提供的网格材质，有的受光照影响，有的不受光照影响。\n\n\n\n基础网格材质MeshBasicMaterial不会受到光照影响。\n\n//MeshBasicMaterial不受光照影响\nconst material = new THREE.MeshBasicMaterial(); \n\n\n漫反射网格材质MeshLambertMaterial会受到光照影响，该材质也可以称为Lambert网格材质，音译为兰伯特网格材质。\n\n一个立方体长方体使用MeshLambertMaterial材质，不同面和光线夹角不同，立方体不同面就会呈现出来不同的明暗效果。\n\n//MeshLambertMaterial受光照影响\nconst material = new THREE.MeshLambertMaterial(); \n\n\n\n# 光源简介\n\nThree.js提供了多种模拟生活中光源的API，文档搜索关键词light就可以看到。\n\n\n\n\n# 点光源\n\n\n\n点光源PointLight可以类比为一个发光点，就像生活中一个灯泡以灯泡为中心向四周发射光线。\n\n//点光源：两个参数分别表示光源颜色和光照强度\n// 参数1：0xffffff是纯白光,表示光源颜色\n// 参数2：1.0,表示光照强度，可以根据需要调整\nconst pointLight = new THREE.PointLight(0xffffff, 1.0);\n\n\n除了通过THREE.PointLight的参数2设置光照强度，你可以可以直接访问光照强度属性.intensity设置。\n\npointLight.intensity = 1.0;//光照强度\n\n\n\n# 光源衰减\n\n实际生活中点光源，比如比如一个灯泡，随机距离的改变，光线会衰减，越来越弱，光源衰减属性.decay默认值是2.0，如果你不希望衰减可以设置为0.0。\n\npointLight.decay = 0.0;//设置光源不随距离衰减\n\n\n【扩展提醒】：如果使用默认衰减2.0，不同版本可能有差异，对于部分threejs新版本，有时候你可能看不到光源效果，这时候可以把光照强度加强试试看,如果你的版本不影响，就不用加强光照强度(根据版本情况灵活对应)。\n\n// 你可以对比不同光照强度明暗差异(传播同样距离)\npointLight.intensity = 10000.0;//光照强度\npointLight.intensity = 50000.0;//光照强度\n\n\n\n# 光源位置\n\n你把点光源想象为一个电灯泡，你在3D空间中，放的位置不同，模型的渲染效果就不一样。\n\n注意光源位置尺寸大小：如果你希望光源照在模型的外表面，那你就需要把光源放在模型的外面。\n\n//点光源位置\npointLight.position.set(400, 0, 0);//点光源放在x轴上\n\n\n\n# 光源添加到场景\n\n光源和网格模型Mesh对应一样是三维场景的一部分，自然需要添加到三维场景中才能起作用。\n\nscene.add(pointLight); //点光源添加到场景中\n\n\n设置好上面所有代码，你现在可以执行代码，用浏览器查看渲染效果。\n\n\n# 改变光源位置，观察网格模型表面的明暗变化。\n\npointLight.position.set(400, 200, 300); \n",normalizedContent:"# 光源对物体表面影响\n\n视频讲解\n\n实际生活中物体表面的明暗效果是会受到光照的影响，比如晚上不开灯，你就看不到物体，灯光比较暗，物体也比较暗。在threejs中，咱们用网格模型mesh模拟生活中物体，所以threejs中模拟光照light对物体表面的影响，就是模拟光照light对网格模型mesh表面的影响。\n\n你可以打开课件中案例源码，对比有光照和无光照两种情况，网格模型mesh表面的差异。\n\n\n# 受光照影响材质\n\nthreejs提供的网格材质，有的受光照影响，有的不受光照影响。\n\n\n\n基础网格材质meshbasicmaterial不会受到光照影响。\n\n//meshbasicmaterial不受光照影响\nconst material = new three.meshbasicmaterial(); \n\n\n漫反射网格材质meshlambertmaterial会受到光照影响，该材质也可以称为lambert网格材质，音译为兰伯特网格材质。\n\n一个立方体长方体使用meshlambertmaterial材质，不同面和光线夹角不同，立方体不同面就会呈现出来不同的明暗效果。\n\n//meshlambertmaterial受光照影响\nconst material = new three.meshlambertmaterial(); \n\n\n\n# 光源简介\n\nthree.js提供了多种模拟生活中光源的api，文档搜索关键词light就可以看到。\n\n\n\n\n# 点光源\n\n\n\n点光源pointlight可以类比为一个发光点，就像生活中一个灯泡以灯泡为中心向四周发射光线。\n\n//点光源：两个参数分别表示光源颜色和光照强度\n// 参数1：0xffffff是纯白光,表示光源颜色\n// 参数2：1.0,表示光照强度，可以根据需要调整\nconst pointlight = new three.pointlight(0xffffff, 1.0);\n\n\n除了通过three.pointlight的参数2设置光照强度，你可以可以直接访问光照强度属性.intensity设置。\n\npointlight.intensity = 1.0;//光照强度\n\n\n\n# 光源衰减\n\n实际生活中点光源，比如比如一个灯泡，随机距离的改变，光线会衰减，越来越弱，光源衰减属性.decay默认值是2.0，如果你不希望衰减可以设置为0.0。\n\npointlight.decay = 0.0;//设置光源不随距离衰减\n\n\n【扩展提醒】：如果使用默认衰减2.0，不同版本可能有差异，对于部分threejs新版本，有时候你可能看不到光源效果，这时候可以把光照强度加强试试看,如果你的版本不影响，就不用加强光照强度(根据版本情况灵活对应)。\n\n// 你可以对比不同光照强度明暗差异(传播同样距离)\npointlight.intensity = 10000.0;//光照强度\npointlight.intensity = 50000.0;//光照强度\n\n\n\n# 光源位置\n\n你把点光源想象为一个电灯泡，你在3d空间中，放的位置不同，模型的渲染效果就不一样。\n\n注意光源位置尺寸大小：如果你希望光源照在模型的外表面，那你就需要把光源放在模型的外面。\n\n//点光源位置\npointlight.position.set(400, 0, 0);//点光源放在x轴上\n\n\n\n# 光源添加到场景\n\n光源和网格模型mesh对应一样是三维场景的一部分，自然需要添加到三维场景中才能起作用。\n\nscene.add(pointlight); //点光源添加到场景中\n\n\n设置好上面所有代码，你现在可以执行代码，用浏览器查看渲染效果。\n\n\n# 改变光源位置，观察网格模型表面的明暗变化。\n\npointlight.position.set(400, 200, 300); \n",charsets:{cjk:!0}},{title:"10. 平行光与环境光",frontmatter:{title:"10. 平行光与环境光",date:"2023-01-20T19:09:48.000Z",permalink:"/pages/343ae9/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/10.%E5%B9%B3%E8%A1%8C%E5%85%89%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%85%89.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/10.平行光与环境光.md",key:"v-2abb3539",path:"/pages/343ae9/",headers:[{level:3,title:"点光源辅助观察PointLightHelper",slug:"点光源辅助观察pointlighthelper",normalizedTitle:"点光源辅助观察pointlighthelper",charIndex:87},{level:3,title:"环境光设置",slug:"环境光设置",normalizedTitle:"环境光设置",charIndex:439},{level:3,title:"平行光",slug:"平行光",normalizedTitle:"平行光",charIndex:2},{level:3,title:"平行光辅助观察DirectionalLightHelper",slug:"平行光辅助观察directionallighthelper",normalizedTitle:"平行光辅助观察directionallighthelper",charIndex:894},{level:3,title:"平行光与Mesh表面光线反射规律",slug:"平行光与mesh表面光线反射规律",normalizedTitle:"平行光与mesh表面光线反射规律",charIndex:1119}],headersStr:"点光源辅助观察PointLightHelper 环境光设置 平行光 平行光辅助观察DirectionalLightHelper 平行光与Mesh表面光线反射规律",content:"# 平行光与环境光\n\n视频讲解\n\n本节课通过平行光DirectionalLight和环境光AmbientLight进一步了解光照对应模型Mesh表面的影响。\n\n\n\n\n\n\n# 点光源辅助观察PointLightHelper\n\n通过点光源辅助观察对象PointLightHelper可视化点光源。\n\n预览观察：可以借助相机控件OrbitControls旋转缩放三维场景便于预览点光源位置\n\n// 光源辅助观察\nconst pointLightHelper = new THREE.PointLightHelper(pointLight, 10);\nscene.add(pointLightHelper);\n\n\n改变点光源位置，观察光照效果变化。\n\npointLight.position.set(100, 60, 50);\n// 改变点光源位置，使用OrbitControls辅助观察\npointLight.position.set(-400, -200, -300);\n\n\n\n# 环境光设置\n\n环境光AmbientLight没有特定方向，只是整体改变场景的光照明暗。\n\n//环境光:没有特定方向，整体改变场景的光照明暗\nconst ambient = new THREE.AmbientLight(0xffffff, 0.4);\nscene.add(ambient);\n\n\n\n# 平行光\n\n平行光DirectionalLight就是沿着特定方向发射。\n\n\n\n// 平行光\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n// 设置光源的方向：通过光源position属性和目标指向对象的position属性计算\ndirectionalLight.position.set(80, 100, 50);\n// 方向光指向对象网格模型mesh，可以不设置，默认的位置是0,0,0\ndirectionalLight.target = mesh;\nscene.add(directionalLight);\n\n\n\n# 平行光辅助观察DirectionalLightHelper\n\n通过点光源辅助观察对象DirectionalLightHelper可视化点光源。\n\n// DirectionalLightHelper：可视化平行光\nconst dirLightHelper = new THREE.DirectionalLightHelper(directionalLight, 5,0xff0000);\nscene.add(dirLightHelper);\n\n\n\n# 平行光与Mesh表面光线反射规律\n\n平行光照射到网格模型Mesh表面，光线和模型表面构成一个入射角度，入射角度不同，对光照的反射能力不同。\n\n光线照射到漫反射网格材质MeshLambertMaterial对应Mesh表面，Mesh表面对光线反射程度与入射角大小有关。\n\n\n\n// 对比不同入射角，mesh表面对光照的反射效果\ndirectionalLight.position.set(100, 0, 0);\ndirectionalLight.position.set(0, 100, 0);\ndirectionalLight.position.set(100, 100, 100);\ndirectionalLight.position.set(100, 60, 50);\n//directionalLight.target默认指向坐标原点\n",normalizedContent:"# 平行光与环境光\n\n视频讲解\n\n本节课通过平行光directionallight和环境光ambientlight进一步了解光照对应模型mesh表面的影响。\n\n\n\n\n\n\n# 点光源辅助观察pointlighthelper\n\n通过点光源辅助观察对象pointlighthelper可视化点光源。\n\n预览观察：可以借助相机控件orbitcontrols旋转缩放三维场景便于预览点光源位置\n\n// 光源辅助观察\nconst pointlighthelper = new three.pointlighthelper(pointlight, 10);\nscene.add(pointlighthelper);\n\n\n改变点光源位置，观察光照效果变化。\n\npointlight.position.set(100, 60, 50);\n// 改变点光源位置，使用orbitcontrols辅助观察\npointlight.position.set(-400, -200, -300);\n\n\n\n# 环境光设置\n\n环境光ambientlight没有特定方向，只是整体改变场景的光照明暗。\n\n//环境光:没有特定方向，整体改变场景的光照明暗\nconst ambient = new three.ambientlight(0xffffff, 0.4);\nscene.add(ambient);\n\n\n\n# 平行光\n\n平行光directionallight就是沿着特定方向发射。\n\n\n\n// 平行光\nconst directionallight = new three.directionallight(0xffffff, 1);\n// 设置光源的方向：通过光源position属性和目标指向对象的position属性计算\ndirectionallight.position.set(80, 100, 50);\n// 方向光指向对象网格模型mesh，可以不设置，默认的位置是0,0,0\ndirectionallight.target = mesh;\nscene.add(directionallight);\n\n\n\n# 平行光辅助观察directionallighthelper\n\n通过点光源辅助观察对象directionallighthelper可视化点光源。\n\n// directionallighthelper：可视化平行光\nconst dirlighthelper = new three.directionallighthelper(directionallight, 5,0xff0000);\nscene.add(dirlighthelper);\n\n\n\n# 平行光与mesh表面光线反射规律\n\n平行光照射到网格模型mesh表面，光线和模型表面构成一个入射角度，入射角度不同，对光照的反射能力不同。\n\n光线照射到漫反射网格材质meshlambertmaterial对应mesh表面，mesh表面对光线反射程度与入射角大小有关。\n\n\n\n// 对比不同入射角，mesh表面对光照的反射效果\ndirectionallight.position.set(100, 0, 0);\ndirectionallight.position.set(0, 100, 0);\ndirectionallight.position.set(100, 100, 100);\ndirectionallight.position.set(100, 60, 50);\n//directionallight.target默认指向坐标原点\n",charsets:{cjk:!0}},{title:"11. 动画渲染循环",frontmatter:{title:"11. 动画渲染循环",date:"2023-01-20T19:15:04.000Z",permalink:"/pages/ffe0f4/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/11.%E5%8A%A8%E7%94%BB%E6%B8%B2%E6%9F%93%E5%BE%AA%E7%8E%AF.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/11.动画渲染循环.md",key:"v-5588bc62",path:"/pages/ffe0f4/",headers:[{level:3,title:"请求动画帧window.requestAnimationFrame",slug:"请求动画帧window-requestanimationframe",normalizedTitle:"请求动画帧window.requestanimationframe",charIndex:36},{level:3,title:"threejs旋转动画",slug:"threejs旋转动画",normalizedTitle:"threejs旋转动画",charIndex:477},{level:3,title:"计算两帧渲染时间间隔和帧率",slug:"计算两帧渲染时间间隔和帧率",normalizedTitle:"计算两帧渲染时间间隔和帧率",charIndex:910},{level:3,title:"渲染循环和相机控件OrbitControls",slug:"渲染循环和相机控件orbitcontrols",normalizedTitle:"渲染循环和相机控件orbitcontrols",charIndex:1261}],headersStr:"请求动画帧window.requestAnimationFrame threejs旋转动画 计算两帧渲染时间间隔和帧率 渲染循环和相机控件OrbitControls",content:"# 动画渲染循环\n\n视频讲解\n\nthreejs可以借助HTML5的API请求动画帧window.requestAnimationFrame实现动画渲染。\n\n\n# 请求动画帧window.requestAnimationFrame\n\n// requestAnimationFrame实现周期性循环执行\n// requestAnimationFrame默认每秒钟执行60次，但不一定能做到，要看代码的性能\nlet i = 0;\nfunction render() {\n    i+=1;\n    console.log('执行次数'+i);\n    requestAnimationFrame(render);//请求再次执行函数render\n}\nrender();\n\n\n备注说明：对于部分高刷新率的电脑硬件设备，.requestAnimationFrame每秒钟默认调用函数执行次数也是有可能超过60次的，比如你的电脑显卡、显示器等硬件能够支持144hz刷新频率，.requestAnimationFrame的每秒执行上限，也可以接近144帧率。\n\n\n# threejs旋转动画\n\n动画说白了就是一张张照片，连起来依次展示，这样就形成一个动画效果，只要帧率高，人的眼睛就感觉不到卡顿，是连续的视频效果。\n\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(width, height);\n// renderer.render(scene, camera); //执行渲染操作\ndocument.body.appendChild(renderer.domElement);\n\n// 渲染函数\nfunction render() {\n    renderer.render(scene, camera); //执行渲染操作\n    mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度\n    requestAnimationFrame(render);//请求再次执行渲染函数render，渲染下一帧\n}\nrender();\n\n\n\n# 计算两帧渲染时间间隔和帧率\n\n// 渲染循环\nconst clock = new THREE.Clock();\nfunction render() {\n    const spt = clock.getDelta()*1000;//毫秒\n    console.log('两帧渲染时间间隔(毫秒)',spt);\n    console.log('帧率FPS',1000/spt);\n    renderer.render(scene, camera); //执行渲染操作\n    mesh.rotateY(0.01);//每次绕y轴旋转0.01弧度\n    requestAnimationFrame(render);//请求再次执行渲染函数render，渲染下一帧\n}\nrender();\n\n\n\n# 渲染循环和相机控件OrbitControls\n\n设置了渲染循环,相机控件OrbitControls就不用再通过事件change执行renderer.render(scene, camera);，毕竟渲染循环一直在执行renderer.render(scene, camera);。",normalizedContent:"# 动画渲染循环\n\n视频讲解\n\nthreejs可以借助html5的api请求动画帧window.requestanimationframe实现动画渲染。\n\n\n# 请求动画帧window.requestanimationframe\n\n// requestanimationframe实现周期性循环执行\n// requestanimationframe默认每秒钟执行60次，但不一定能做到，要看代码的性能\nlet i = 0;\nfunction render() {\n    i+=1;\n    console.log('执行次数'+i);\n    requestanimationframe(render);//请求再次执行函数render\n}\nrender();\n\n\n备注说明：对于部分高刷新率的电脑硬件设备，.requestanimationframe每秒钟默认调用函数执行次数也是有可能超过60次的，比如你的电脑显卡、显示器等硬件能够支持144hz刷新频率，.requestanimationframe的每秒执行上限，也可以接近144帧率。\n\n\n# threejs旋转动画\n\n动画说白了就是一张张照片，连起来依次展示，这样就形成一个动画效果，只要帧率高，人的眼睛就感觉不到卡顿，是连续的视频效果。\n\nconst renderer = new three.webglrenderer();\nrenderer.setsize(width, height);\n// renderer.render(scene, camera); //执行渲染操作\ndocument.body.appendchild(renderer.domelement);\n\n// 渲染函数\nfunction render() {\n    renderer.render(scene, camera); //执行渲染操作\n    mesh.rotatey(0.01);//每次绕y轴旋转0.01弧度\n    requestanimationframe(render);//请求再次执行渲染函数render，渲染下一帧\n}\nrender();\n\n\n\n# 计算两帧渲染时间间隔和帧率\n\n// 渲染循环\nconst clock = new three.clock();\nfunction render() {\n    const spt = clock.getdelta()*1000;//毫秒\n    console.log('两帧渲染时间间隔(毫秒)',spt);\n    console.log('帧率fps',1000/spt);\n    renderer.render(scene, camera); //执行渲染操作\n    mesh.rotatey(0.01);//每次绕y轴旋转0.01弧度\n    requestanimationframe(render);//请求再次执行渲染函数render，渲染下一帧\n}\nrender();\n\n\n\n# 渲染循环和相机控件orbitcontrols\n\n设置了渲染循环,相机控件orbitcontrols就不用再通过事件change执行renderer.render(scene, camera);，毕竟渲染循环一直在执行renderer.render(scene, camera);。",charsets:{cjk:!0}},{title:"13. stats查看threejs渲染帧率",frontmatter:{title:"13. stats查看threejs渲染帧率",date:"2023-01-20T19:15:50.000Z",permalink:"/pages/3c9b94/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/13.stats%E6%9F%A5%E7%9C%8Bthreejs%E6%B8%B2%E6%9F%93%E5%B8%A7%E7%8E%87.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/13.stats查看threejs渲染帧率.md",key:"v-e64fd4e6",path:"/pages/3c9b94/",headers:[{level:3,title:"引入Stats",slug:"引入stats",normalizedTitle:"引入stats",charIndex:323},{level:3,title:"Stats使用",slug:"stats使用",normalizedTitle:"stats使用",charIndex:410},{level:3,title:"stats方法setMode(mode)",slug:"stats方法setmode-mode",normalizedTitle:"stats方法setmode(mode)",charIndex:756},{level:3,title:"性能测试",slug:"性能测试",normalizedTitle:"性能测试",charIndex:974}],headersStr:"引入Stats Stats使用 stats方法setMode(mode) 性能测试",content:"# stats性能监视器(计算渲染帧率FPS)\n\n视频讲解\n\nthree.js每执行WebGL渲染器.render()方法一次，就在canvas画布上得到一帧图像，不停地周期性执行.render()方法就可以更新canvas画布内容，一般场景越复杂往往渲染性能越低，也就是每秒钟执行.render()的次数越低。\n\n通过stats.js库可以查看three.js当前的渲染性能，具体说就是计算three.js的渲染帧率(FPS),所谓渲染帧率(FPS)，简单说就是three.js每秒钟完成的渲染次数，一般渲染达到每秒钟60次为最佳状态。\n\nstats.js下载链接：https://github.com/mrdoob/stats.js\n\n\n# 引入Stats\n\n//引入性能监视器stats.js\nimport Stats from 'three/addons/libs/stats.module.js';\n\n\n\n# Stats使用\n\n//创建stats对象\nconst stats = new Stats();\n//stats.domElement:web页面上输出计算结果,一个div元素，\ndocument.body.appendChild(stats.domElement);\n// 渲染函数\nfunction render() {\n\t//requestAnimationFrame循环调用的函数中调用方法update(),来刷新时间\n\tstats.update();\n\trenderer.render(scene, camera); //执行渲染操作\n\trequestAnimationFrame(render); //请求再次执行渲染函数render，渲染下一帧\n}\nrender();\n\n\n\n# stats方法setMode(mode)\n\n可以通过setMode()方法的参数mode的数值设置首次打开页面，测试结果的显示模式，鼠标单击可以更换不同的显示模式。\n\n// stats.domElement显示：渲染帧率  刷新频率,一秒渲染次数 \nstats.setMode(0);//默认模式\n//stats.domElement显示：渲染周期 渲染一帧多长时间(单位：毫秒ms)\n  stats.setMode(1);\n\n\n\n# 性能测试\n\n控制长方体模型数量，你可以逐渐增加或减少,看看帧率变化，电脑性能不同结果不同。\n\n// 随机创建大量的模型,测试渲染性能\nconst num = 1000; //控制长方体模型数量\nfor (let i = 0; i < num; i++) {\n    const geometry = new THREE.BoxGeometry(5, 5, 5);\n    const material = new THREE.MeshLambertMaterial({\n        color: 0x00ffff\n    });\n    const mesh = new THREE.Mesh(geometry, material);\n    // 随机生成长方体xyz坐标\n    const x = (Math.random() - 0.5) * 200\n    const y = (Math.random() - 0.5) * 200\n    const z = (Math.random() - 0.5) * 200\n    mesh.position.set(x, y, z)\n    scene.add(mesh); // 模型对象插入场景中\n}\n",normalizedContent:"# stats性能监视器(计算渲染帧率fps)\n\n视频讲解\n\nthree.js每执行webgl渲染器.render()方法一次，就在canvas画布上得到一帧图像，不停地周期性执行.render()方法就可以更新canvas画布内容，一般场景越复杂往往渲染性能越低，也就是每秒钟执行.render()的次数越低。\n\n通过stats.js库可以查看three.js当前的渲染性能，具体说就是计算three.js的渲染帧率(fps),所谓渲染帧率(fps)，简单说就是three.js每秒钟完成的渲染次数，一般渲染达到每秒钟60次为最佳状态。\n\nstats.js下载链接：https://github.com/mrdoob/stats.js\n\n\n# 引入stats\n\n//引入性能监视器stats.js\nimport stats from 'three/addons/libs/stats.module.js';\n\n\n\n# stats使用\n\n//创建stats对象\nconst stats = new stats();\n//stats.domelement:web页面上输出计算结果,一个div元素，\ndocument.body.appendchild(stats.domelement);\n// 渲染函数\nfunction render() {\n\t//requestanimationframe循环调用的函数中调用方法update(),来刷新时间\n\tstats.update();\n\trenderer.render(scene, camera); //执行渲染操作\n\trequestanimationframe(render); //请求再次执行渲染函数render，渲染下一帧\n}\nrender();\n\n\n\n# stats方法setmode(mode)\n\n可以通过setmode()方法的参数mode的数值设置首次打开页面，测试结果的显示模式，鼠标单击可以更换不同的显示模式。\n\n// stats.domelement显示：渲染帧率  刷新频率,一秒渲染次数 \nstats.setmode(0);//默认模式\n//stats.domelement显示：渲染周期 渲染一帧多长时间(单位：毫秒ms)\n  stats.setmode(1);\n\n\n\n# 性能测试\n\n控制长方体模型数量，你可以逐渐增加或减少,看看帧率变化，电脑性能不同结果不同。\n\n// 随机创建大量的模型,测试渲染性能\nconst num = 1000; //控制长方体模型数量\nfor (let i = 0; i < num; i++) {\n    const geometry = new three.boxgeometry(5, 5, 5);\n    const material = new three.meshlambertmaterial({\n        color: 0x00ffff\n    });\n    const mesh = new three.mesh(geometry, material);\n    // 随机生成长方体xyz坐标\n    const x = (math.random() - 0.5) * 200\n    const y = (math.random() - 0.5) * 200\n    const z = (math.random() - 0.5) * 200\n    mesh.position.set(x, y, z)\n    scene.add(mesh); // 模型对象插入场景中\n}\n",charsets:{cjk:!0}},{title:"15. Threejs常见几何体简介",frontmatter:{title:"15. Threejs常见几何体简介",date:"2023-01-20T19:17:00.000Z",permalink:"/pages/e04c44/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/15.Threejs%E5%B8%B8%E8%A7%81%E5%87%A0%E4%BD%95%E4%BD%93%E7%AE%80%E4%BB%8B.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/15.Threejs常见几何体简介.md",key:"v-0ab12fef",path:"/pages/e04c44/",headers:[{level:3,title:"双面可见",slug:"双面可见",normalizedTitle:"双面可见",charIndex:495}],headersStr:"双面可见",content:"# Threejs常见简单几何体简介\n\n视频讲解\n\nThree.js提供的几何体API很多，本节课先给大家介绍几个比较简单的案例，为后面的学习打下基础。\n\n\n\n你可以结合threejs文档，把下面动手把下面几何体相关代码全部测试一遍，并预览3D效果。\n\n//BoxGeometry：长方体\nconst geometry = new THREE.BoxGeometry(100, 100, 100);\n// SphereGeometry：球体\nconst geometry = new THREE.SphereGeometry(50);\n// CylinderGeometry：圆柱\nconst geometry = new THREE.CylinderGeometry(50,50,100);\n// PlaneGeometry：矩形平面\nconst geometry = new THREE.PlaneGeometry(100,50);\n// CircleGeometry：圆形平面\nconst geometry = new THREE.CircleGeometry(50);\n\n\n\n\n# 双面可见\n\nThree.js的材质默认正面可见，反面不可见,对于矩形平面PlaneGeometry、圆形平面如果你想看到两面，可以设置side: THREE.DoubleSide。\n\nnew THREE.MeshBasicMaterial({\n    side: THREE.FrontSide, //默认只有正面可见\n});\n\n\nnew THREE.MeshBasicMaterial({\n    side: THREE.DoubleSide, //两面可见\n});\n",normalizedContent:"# threejs常见简单几何体简介\n\n视频讲解\n\nthree.js提供的几何体api很多，本节课先给大家介绍几个比较简单的案例，为后面的学习打下基础。\n\n\n\n你可以结合threejs文档，把下面动手把下面几何体相关代码全部测试一遍，并预览3d效果。\n\n//boxgeometry：长方体\nconst geometry = new three.boxgeometry(100, 100, 100);\n// spheregeometry：球体\nconst geometry = new three.spheregeometry(50);\n// cylindergeometry：圆柱\nconst geometry = new three.cylindergeometry(50,50,100);\n// planegeometry：矩形平面\nconst geometry = new three.planegeometry(100,50);\n// circlegeometry：圆形平面\nconst geometry = new three.circlegeometry(50);\n\n\n\n\n# 双面可见\n\nthree.js的材质默认正面可见，反面不可见,对于矩形平面planegeometry、圆形平面如果你想看到两面，可以设置side: three.doubleside。\n\nnew three.meshbasicmaterial({\n    side: three.frontside, //默认只有正面可见\n});\n\n\nnew three.meshbasicmaterial({\n    side: three.doubleside, //两面可见\n});\n",charsets:{cjk:!0}},{title:"14. 阵列立方体和相机适配体验",frontmatter:{title:"14. 阵列立方体和相机适配体验",date:"2023-01-20T19:16:17.000Z",permalink:"/pages/2a45ee/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/14.%E9%98%B5%E5%88%97%E7%AB%8B%E6%96%B9%E4%BD%93%E5%92%8C%E7%9B%B8%E6%9C%BA%E9%80%82%E9%85%8D%E4%BD%93%E9%AA%8C.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/14.阵列立方体和相机适配体验.md",key:"v-53d6f011",path:"/pages/2a45ee/",headers:[{level:3,title:"for循环创建一列模型",slug:"for循环创建一列模型",normalizedTitle:"for循环创建一列模型",charIndex:58},{level:3,title:"双层for循环创建阵列模型",slug:"双层for循环创建阵列模型",normalizedTitle:"双层for循环创建阵列模型",charIndex:464},{level:3,title:"相机位置拉远，可以看到更大的观察范围",slug:"相机位置拉远-可以看到更大的观察范围",normalizedTitle:"相机位置拉远，可以看到更大的观察范围",charIndex:966},{level:3,title:"超出视锥体远裁界面的范围的会被剪裁掉",slug:"超出视锥体远裁界面的范围的会被剪裁掉",normalizedTitle:"超出视锥体远裁界面的范围的会被剪裁掉",charIndex:1191},{level:3,title:"改变相机观察目标",slug:"改变相机观察目标",normalizedTitle:"改变相机观察目标",charIndex:1506},{level:3,title:"远小近大投影规律",slug:"远小近大投影规律",normalizedTitle:"远小近大投影规律",charIndex:2136},{level:3,title:"fov改变",slug:"fov改变",normalizedTitle:"fov改变",charIndex:2208}],headersStr:"for循环创建一列模型 双层for循环创建阵列模型 相机位置拉远，可以看到更大的观察范围 超出视锥体远裁界面的范围的会被剪裁掉 改变相机观察目标 远小近大投影规律 fov改变",content:"# 阵列立方体和相机适配体验\n\n视频讲解\n\n本节课通过阵列一片立方体，进一步体验下透视投影相机的投影规律。\n\n\n# for循环创建一列模型\n\nconst geometry = new THREE.BoxGeometry(100, 100, 100);\n//材质对象Material\nconst material = new THREE.MeshLambertMaterial({\n    color: 0x00ffff, //设置材质颜色\n    transparent: true,//开启透明\n    opacity: 0.5,//设置透明度\n});\nfor (let i = 0; i < 10; i++) {\n    const mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh\n    // 沿着x轴分布\n    mesh.position.set(i*200,0,0);\n    scene.add(mesh); //网格模型添加到场景中\n}\n\n\n\n# 双层for循环创建阵列模型\n\n//创建一个长方体几何对象Geometry\nconst geometry = new THREE.BoxGeometry(100, 100, 100);\n//材质对象Material\nconst material = new THREE.MeshLambertMaterial({\n    color: 0x00ffff, //设置材质颜色\n    transparent: true,//开启透明\n    opacity: 0.5,//设置透明度\n});\nfor (let i = 0; i < 10; i++) {\n    for (let j = 0; j < 10; j++) {\n        const mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh\n        // 在XOZ平面上分布\n        mesh.position.set(i * 200, 0, j * 200);\n        scene.add(mesh); //网格模型添加到场景中  \n    }\n}\n\n\n\n# 相机位置拉远，可以看到更大的观察范围\n\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\n// camera.position.set(292, 223, 185);\n//在原来相机位置基础上拉远，可以观察到更大的范围\n camera.position.set(800, 800, 800);\n camera.lookAt(0, 0, 0);\n\n\n\n# 超出视锥体远裁界面的范围的会被剪裁掉\n\n// const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 8000);\n// camera.position.set(292, 223, 185);\n// 超出视锥体远裁界面的范围的会被剪裁掉，不渲染  可以调整far参数适配\ncamera.position.set(2000, 2000, 2000);\ncamera.lookAt(0, 0, 0);\n\n\n\n# 改变相机观察目标\n\n// const camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 8000);\ncamera.position.set(2000, 2000, 2000);\n// camera.lookAt(0, 0, 0);\n// 改变相机观察目标点\ncamera.lookAt(1000, 0, 1000);\n\n\n注意相机控件OrbitControls会影响lookAt设置，注意手动设置OrbitControls的目标参数\n\n// 设置相机控件轨道控制器OrbitControls\nconst controls = new OrbitControls(camera, renderer.domElement);\n// 相机控件.target属性在OrbitControls.js内部表示相机目标观察点，默认0,0,0\n// console.log('controls.target', controls.target);\ncontrols.target.set(1000, 0, 1000);\ncontrols.update();//update()函数内会执行camera.lookAt(controls.targe)\n\n\n\n# 远小近大投影规律\n\n透视投影相机的投影规律是远小近大，通过相机观察阵列立方体大小变化，可以看到距离相机越远，立方体的渲染视觉效果越小。\n\n\n# fov改变\n\n增加相机视角fov，视锥体范围更大，意味着可以看到渲染范围更大，远小近大的视觉效果更明显。",normalizedContent:"# 阵列立方体和相机适配体验\n\n视频讲解\n\n本节课通过阵列一片立方体，进一步体验下透视投影相机的投影规律。\n\n\n# for循环创建一列模型\n\nconst geometry = new three.boxgeometry(100, 100, 100);\n//材质对象material\nconst material = new three.meshlambertmaterial({\n    color: 0x00ffff, //设置材质颜色\n    transparent: true,//开启透明\n    opacity: 0.5,//设置透明度\n});\nfor (let i = 0; i < 10; i++) {\n    const mesh = new three.mesh(geometry, material); //网格模型对象mesh\n    // 沿着x轴分布\n    mesh.position.set(i*200,0,0);\n    scene.add(mesh); //网格模型添加到场景中\n}\n\n\n\n# 双层for循环创建阵列模型\n\n//创建一个长方体几何对象geometry\nconst geometry = new three.boxgeometry(100, 100, 100);\n//材质对象material\nconst material = new three.meshlambertmaterial({\n    color: 0x00ffff, //设置材质颜色\n    transparent: true,//开启透明\n    opacity: 0.5,//设置透明度\n});\nfor (let i = 0; i < 10; i++) {\n    for (let j = 0; j < 10; j++) {\n        const mesh = new three.mesh(geometry, material); //网格模型对象mesh\n        // 在xoz平面上分布\n        mesh.position.set(i * 200, 0, j * 200);\n        scene.add(mesh); //网格模型添加到场景中  \n    }\n}\n\n\n\n# 相机位置拉远，可以看到更大的观察范围\n\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\n// camera.position.set(292, 223, 185);\n//在原来相机位置基础上拉远，可以观察到更大的范围\n camera.position.set(800, 800, 800);\n camera.lookat(0, 0, 0);\n\n\n\n# 超出视锥体远裁界面的范围的会被剪裁掉\n\n// const camera = new three.perspectivecamera(30, width / height, 1, 3000);\nconst camera = new three.perspectivecamera(30, width / height, 1, 8000);\n// camera.position.set(292, 223, 185);\n// 超出视锥体远裁界面的范围的会被剪裁掉，不渲染  可以调整far参数适配\ncamera.position.set(2000, 2000, 2000);\ncamera.lookat(0, 0, 0);\n\n\n\n# 改变相机观察目标\n\n// const camera = new three.perspectivecamera(30, width / height, 1, 3000);\nconst camera = new three.perspectivecamera(30, width / height, 1, 8000);\ncamera.position.set(2000, 2000, 2000);\n// camera.lookat(0, 0, 0);\n// 改变相机观察目标点\ncamera.lookat(1000, 0, 1000);\n\n\n注意相机控件orbitcontrols会影响lookat设置，注意手动设置orbitcontrols的目标参数\n\n// 设置相机控件轨道控制器orbitcontrols\nconst controls = new orbitcontrols(camera, renderer.domelement);\n// 相机控件.target属性在orbitcontrols.js内部表示相机目标观察点，默认0,0,0\n// console.log('controls.target', controls.target);\ncontrols.target.set(1000, 0, 1000);\ncontrols.update();//update()函数内会执行camera.lookat(controls.targe)\n\n\n\n# 远小近大投影规律\n\n透视投影相机的投影规律是远小近大，通过相机观察阵列立方体大小变化，可以看到距离相机越远，立方体的渲染视觉效果越小。\n\n\n# fov改变\n\n增加相机视角fov，视锥体范围更大，意味着可以看到渲染范围更大，远小近大的视觉效果更明显。",charsets:{cjk:!0}},{title:"16. 高光网格材质Phong",frontmatter:{title:"16. 高光网格材质Phong",date:"2023-01-20T19:17:25.000Z",permalink:"/pages/2da02c/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/16.%E9%AB%98%E5%85%89%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8MeshPhongMaterial.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/16.高光网格材质MeshPhongMaterial.md",key:"v-88d78922",path:"/pages/2da02c/",headers:[{level:3,title:"MeshPhongMaterial对光照反射特点",slug:"meshphongmaterial对光照反射特点",normalizedTitle:"meshphongmaterial对光照反射特点",charIndex:194},{level:3,title:"镜面反射与漫反射",slug:"镜面反射与漫反射",normalizedTitle:"镜面反射与漫反射",charIndex:400},{level:3,title:"高光亮度属性.shininess",slug:"高光亮度属性-shininess",normalizedTitle:"高光亮度属性.shininess",charIndex:583},{level:3,title:"高光颜色属性.specular",slug:"高光颜色属性-specular",normalizedTitle:"高光颜色属性.specular",charIndex:781}],headersStr:"MeshPhongMaterial对光照反射特点 镜面反射与漫反射 高光亮度属性.shininess 高光颜色属性.specular",content:"# 高光网格材质MeshPhongMaterial\n\n视频讲解\n\n高光网格材质MeshPhongMaterial和基础网格材质MeshBasicMaterial、漫反射网格材质MeshLambertMaterial一样都是网格模型的Mesh的材质。\n\n高光网格材质MeshPhongMaterial和漫反射网格材质MeshLambertMaterial一样会受到光照的影响。\n\n\n\n\n# MeshPhongMaterial对光照反射特点\n\nMeshPhongMaterial和MeshLambertMaterial都会收到光照的影响区别在于，对光线反射方式有差异。\n\nMeshPhongMaterial可以实现MeshLambertMaterial不能实现的高光反射效果。对于高光效果，你可以想象一下，你在太阳下面观察一辆车，你会发现在特定角度和位置，你可以看到车表面某个局部区域非常高亮。\n\n\n# 镜面反射与漫反射\n\nMeshPhongMaterial可以提供一个镜面反射效果,可以类比你生活中拿一面镜子，放在太阳光下，调整角度，可以把太阳光反射到其它地方，如果反射光对着眼睛，也就是反射光线和视线平行的时候，会非常刺眼。\n\nMeshLambertMaterial对应的Mesh受到光线照射，没有镜面反射的效果，只是一个漫反射，也就是光线向四周反射。\n\n\n\n\n# 高光亮度属性.shininess\n\n通过MeshPhongMaterial的高光亮度.shininess属性,可以控制高光反射效果。\n\n// 模拟镜面反射，产生一个高光效果\nconst material = new THREE.MeshPhongMaterial({\n    color: 0xff0000,\n    shininess: 20, //高光部分的亮度，默认30\n});\n\n\n\n# 高光颜色属性.specular\n\n可以给颜色属性.specular设置不同的值，比如0x444444、0xfffffff 查看渲染效果变化。\n\n// 模拟镜面反射，产生一个高光效果\nconst material = new THREE.MeshPhongMaterial({\n    color: 0xff0000,\n    shininess: 20, //高光部分的亮度，默认30\n    specular: 0x444444, //高光部分的颜色\n});\n",normalizedContent:"# 高光网格材质meshphongmaterial\n\n视频讲解\n\n高光网格材质meshphongmaterial和基础网格材质meshbasicmaterial、漫反射网格材质meshlambertmaterial一样都是网格模型的mesh的材质。\n\n高光网格材质meshphongmaterial和漫反射网格材质meshlambertmaterial一样会受到光照的影响。\n\n\n\n\n# meshphongmaterial对光照反射特点\n\nmeshphongmaterial和meshlambertmaterial都会收到光照的影响区别在于，对光线反射方式有差异。\n\nmeshphongmaterial可以实现meshlambertmaterial不能实现的高光反射效果。对于高光效果，你可以想象一下，你在太阳下面观察一辆车，你会发现在特定角度和位置，你可以看到车表面某个局部区域非常高亮。\n\n\n# 镜面反射与漫反射\n\nmeshphongmaterial可以提供一个镜面反射效果,可以类比你生活中拿一面镜子，放在太阳光下，调整角度，可以把太阳光反射到其它地方，如果反射光对着眼睛，也就是反射光线和视线平行的时候，会非常刺眼。\n\nmeshlambertmaterial对应的mesh受到光线照射，没有镜面反射的效果，只是一个漫反射，也就是光线向四周反射。\n\n\n\n\n# 高光亮度属性.shininess\n\n通过meshphongmaterial的高光亮度.shininess属性,可以控制高光反射效果。\n\n// 模拟镜面反射，产生一个高光效果\nconst material = new three.meshphongmaterial({\n    color: 0xff0000,\n    shininess: 20, //高光部分的亮度，默认30\n});\n\n\n\n# 高光颜色属性.specular\n\n可以给颜色属性.specular设置不同的值，比如0x444444、0xfffffff 查看渲染效果变化。\n\n// 模拟镜面反射，产生一个高光效果\nconst material = new three.meshphongmaterial({\n    color: 0xff0000,\n    shininess: 20, //高光部分的亮度，默认30\n    specular: 0x444444, //高光部分的颜色\n});\n",charsets:{cjk:!0}},{title:"17. WebGL渲染器设置(锯齿模糊)",frontmatter:{title:"17. WebGL渲染器设置(锯齿模糊)",date:"2023-01-20T19:18:40.000Z",permalink:"/pages/f636b8/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/17.WebGL%E6%B8%B2%E6%9F%93%E5%99%A8%E8%AE%BE%E7%BD%AE(%E9%94%AF%E9%BD%BF%E6%A8%A1%E7%B3%8A%E3%80%81%E8%83%8C%E6%99%AF%E9%A2%9C%E8%89%B2).html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/17.WebGL渲染器设置(锯齿模糊、背景颜色).md",key:"v-67300f90",path:"/pages/f636b8/",headers:[{level:3,title:"渲染器锯齿属性.antialias",slug:"渲染器锯齿属性-antialias",normalizedTitle:"渲染器锯齿属性.antialias",charIndex:99},{level:3,title:"设备像素比window.devicePixelRatio",slug:"设备像素比window-devicepixelratio",normalizedTitle:"设备像素比window.devicepixelratio",charIndex:268},{level:3,title:"设置设备像素比.setPixelRatio()",slug:"设置设备像素比-setpixelratio",normalizedTitle:"设置设备像素比.setpixelratio()",charIndex:540},{level:3,title:"设置背景颜色.setClearColor()",slug:"设置背景颜色-setclearcolor",normalizedTitle:"设置背景颜色.setclearcolor()",charIndex:849}],headersStr:"渲染器锯齿属性.antialias 设备像素比window.devicePixelRatio 设置设备像素比.setPixelRatio() 设置背景颜色.setClearColor()",content:"# WebGL渲染器基础设置(锯齿模糊、背景颜色)\n\n视频讲解\n\n一般实际开发，threejs的WebGL渲染器需要进行一些通用的基础配置，本节课给大家简单介绍下,比如渲染模糊或锯齿问题。\n\n\n# 渲染器锯齿属性.antialias\n\n设置渲染器锯齿属性.antialias的值可以直接在参数中设置，也可通过渲染器对象属性设置。\n\nconst renderer = new THREE.WebGLRenderer({\n  antialias:true,\n});\n\n\n或\n\nrenderer.antialias = true,\n\n\n\n# 设备像素比window.devicePixelRatio\n\n如果你有web前端基础，应该了解window对象，设备像素比.devicePixelRatio是window对象的一个属性，该属性的值和你的硬件设备屏幕相关，不同硬件设备的屏幕window.devicePixelRatio的值可能不同，可能就是1、1.5、2.0等其它值。\n\n// 不同硬件设备的屏幕的设备像素比window.devicePixelRatio值可能不同\nconsole.log('查看当前屏幕设备像素比',window.devicePixelRatio);\n\n\n\n# 设置设备像素比.setPixelRatio()\n\n如果你遇到你的canvas画布输出模糊问题，注意设置renderer.setPixelRatio(window.devicePixelRatio)。\n\n注意：注意你的硬件设备设备像素比window.devicePixelRatio刚好是1，那么是否执行.setPixelRatio()不会有明显差异，不过为了适应不同的硬件设备屏幕，通常需要执行该方法。\n\n// 获取你屏幕对应的设备像素比.devicePixelRatio告诉threejs,以免渲染模糊问题\nrenderer.setPixelRatio(window.devicePixelRatio);\n\n\n\n# 设置背景颜色.setClearColor()\n\nrenderer.setClearColor(0x444444, 1); //设置背景颜色\n",normalizedContent:"# webgl渲染器基础设置(锯齿模糊、背景颜色)\n\n视频讲解\n\n一般实际开发，threejs的webgl渲染器需要进行一些通用的基础配置，本节课给大家简单介绍下,比如渲染模糊或锯齿问题。\n\n\n# 渲染器锯齿属性.antialias\n\n设置渲染器锯齿属性.antialias的值可以直接在参数中设置，也可通过渲染器对象属性设置。\n\nconst renderer = new three.webglrenderer({\n  antialias:true,\n});\n\n\n或\n\nrenderer.antialias = true,\n\n\n\n# 设备像素比window.devicepixelratio\n\n如果你有web前端基础，应该了解window对象，设备像素比.devicepixelratio是window对象的一个属性，该属性的值和你的硬件设备屏幕相关，不同硬件设备的屏幕window.devicepixelratio的值可能不同，可能就是1、1.5、2.0等其它值。\n\n// 不同硬件设备的屏幕的设备像素比window.devicepixelratio值可能不同\nconsole.log('查看当前屏幕设备像素比',window.devicepixelratio);\n\n\n\n# 设置设备像素比.setpixelratio()\n\n如果你遇到你的canvas画布输出模糊问题，注意设置renderer.setpixelratio(window.devicepixelratio)。\n\n注意：注意你的硬件设备设备像素比window.devicepixelratio刚好是1，那么是否执行.setpixelratio()不会有明显差异，不过为了适应不同的硬件设备屏幕，通常需要执行该方法。\n\n// 获取你屏幕对应的设备像素比.devicepixelratio告诉threejs,以免渲染模糊问题\nrenderer.setpixelratio(window.devicepixelratio);\n\n\n\n# 设置背景颜色.setclearcolor()\n\nrenderer.setclearcolor(0x444444, 1); //设置背景颜色\n",charsets:{cjk:!0}},{title:"12. Canvas画布布局和全屏",frontmatter:{title:"12. Canvas画布布局和全屏",date:"2023-01-20T19:15:24.000Z",permalink:"/pages/4e518f/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/12.Canvas%E7%94%BB%E5%B8%83%E5%B8%83%E5%B1%80%E5%92%8C%E5%85%A8%E5%B1%8F.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/12.Canvas画布布局和全屏.md",key:"v-c9691bd2",path:"/pages/4e518f/",headers:[{level:3,title:"非全屏局部布局",slug:"非全屏局部布局",normalizedTitle:"非全屏局部布局",charIndex:171},{level:3,title:"全屏渲染",slug:"全屏渲染",normalizedTitle:"全屏渲染",charIndex:854},{level:3,title:"canvas画布宽高度动态变化",slug:"canvas画布宽高度动态变化",normalizedTitle:"canvas画布宽高度动态变化",charIndex:1207}],headersStr:"非全屏局部布局 全屏渲染 canvas画布宽高度动态变化",content:'# threejs画布尺寸和布局\n\n视频讲解\n\nthreejs渲染输出的结果就是一个Cavnas画布，canvas画布也是HTML的元素之一，这意味着three.js渲染结果的布局和普通web前端习惯是一样的。\n\n通过renderer.domElement属性可以访问threejs的渲染结果，也就是HTML的元素canvas画布。\n\n\n# 非全屏局部布局\n\n你可以把threejs的渲染结果renderer.domElement，插入到web页面上任何一个元素中，只要符合你项目的布局规则即可。\n\n<div id="webgl" style="margin-top: 100px;margin-left: 200px;"></div>\n<script type="module">\n// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)\nconst width = 800; //宽度\nconst height = 500; //高度\n\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\n\n/**\n * 创建渲染器对象\n */\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(width, height); //设置three.js渲染区域的尺寸(像素px)\nrenderer.render(scene, camera); //执行渲染操作\n//three.js执行渲染命令会输出一个canvas画布，也就是一个HTML元素，你可以插入到web页面中\n// document.body.appendChild(renderer.domElement);\ndocument.getElementById(\'wegbl\').appendChild(renderer.domElement);\n\n\n\n# 全屏渲染\n\n// width和height用来设置Three.js输出的Canvas画布尺寸(像素px)\nconst width = window.innerWidth; //窗口文档显示区的宽度作为画布宽度\nconst height = window.innerHeight; //窗口文档显示区的高度作为画布高度\nconst renderer = new THREE.WebGLRenderer();\ndocument.body.appendChild(renderer.domElement);\n\n\n全屏布局注意CSS的设置。\n\n<style>\n    body{\n        overflow: hidden;\n        margin: 0px;\n    }\n</style>\n\n\n\n# canvas画布宽高度动态变化\n\ncanvas画布宽高度动态变化,需要更新相机和渲染的参数，否则无法正常渲染。\n\n// onresize 事件会在窗口被调整大小时发生\nwindow.onresize = function () {\n    // 重置渲染器输出画布canvas尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    // 全屏情况下：设置观察范围长宽比aspect为窗口宽高比\n    camera.aspect = window.innerWidth / window.innerHeight;\n    // 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix\n    // 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)\n    // 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵\n    camera.updateProjectionMatrix();\n};\n',normalizedContent:'# threejs画布尺寸和布局\n\n视频讲解\n\nthreejs渲染输出的结果就是一个cavnas画布，canvas画布也是html的元素之一，这意味着three.js渲染结果的布局和普通web前端习惯是一样的。\n\n通过renderer.domelement属性可以访问threejs的渲染结果，也就是html的元素canvas画布。\n\n\n# 非全屏局部布局\n\n你可以把threejs的渲染结果renderer.domelement，插入到web页面上任何一个元素中，只要符合你项目的布局规则即可。\n\n<div id="webgl" style="margin-top: 100px;margin-left: 200px;"></div>\n<script type="module">\n// width和height用来设置three.js输出的canvas画布尺寸(像素px)\nconst width = 800; //宽度\nconst height = 500; //高度\n\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\n\n/**\n * 创建渲染器对象\n */\nconst renderer = new three.webglrenderer();\nrenderer.setsize(width, height); //设置three.js渲染区域的尺寸(像素px)\nrenderer.render(scene, camera); //执行渲染操作\n//three.js执行渲染命令会输出一个canvas画布，也就是一个html元素，你可以插入到web页面中\n// document.body.appendchild(renderer.domelement);\ndocument.getelementbyid(\'wegbl\').appendchild(renderer.domelement);\n\n\n\n# 全屏渲染\n\n// width和height用来设置three.js输出的canvas画布尺寸(像素px)\nconst width = window.innerwidth; //窗口文档显示区的宽度作为画布宽度\nconst height = window.innerheight; //窗口文档显示区的高度作为画布高度\nconst renderer = new three.webglrenderer();\ndocument.body.appendchild(renderer.domelement);\n\n\n全屏布局注意css的设置。\n\n<style>\n    body{\n        overflow: hidden;\n        margin: 0px;\n    }\n</style>\n\n\n\n# canvas画布宽高度动态变化\n\ncanvas画布宽高度动态变化,需要更新相机和渲染的参数，否则无法正常渲染。\n\n// onresize 事件会在窗口被调整大小时发生\nwindow.onresize = function () {\n    // 重置渲染器输出画布canvas尺寸\n    renderer.setsize(window.innerwidth, window.innerheight);\n    // 全屏情况下：设置观察范围长宽比aspect为窗口宽高比\n    camera.aspect = window.innerwidth / window.innerheight;\n    // 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionmatrix\n    // 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)\n    // 如果相机的一些属性发生了变化，需要执行updateprojectionmatrix ()方法更新相机的投影矩阵\n    camera.updateprojectionmatrix();\n};\n',charsets:{cjk:!0}},{title:"18. gui.js库(可视化改变三维场景)",frontmatter:{title:"18. gui.js库(可视化改变三维场景)",date:"2023-01-20T19:19:52.000Z",permalink:"/pages/5005d5/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/18.gui.js%E5%BA%93(%E5%8F%AF%E8%A7%86%E5%8C%96%E6%94%B9%E5%8F%98%E4%B8%89%E7%BB%B4%E5%9C%BA%E6%99%AF).html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/18.gui.js库(可视化改变三维场景).md",key:"v-5298ab40",path:"/pages/5005d5/",headers:[{level:3,title:"gui.js库(可视化改变三维场景)",slug:"gui-js库-可视化改变三维场景",normalizedTitle:"gui.js库(可视化改变三维场景)",charIndex:2},{level:3,title:"引入dat.gui.js",slug:"引入dat-gui-js",normalizedTitle:"引入dat.gui.js",charIndex:223},{level:3,title:"创建一个GUI对象",slug:"创建一个gui对象",normalizedTitle:"创建一个gui对象",charIndex:495},{level:3,title:".domElement：改变GUI界面默认的style属性",slug:"domelement-改变gui界面默认的style属性",normalizedTitle:".domelement：改变gui界面默认的style属性",charIndex:596},{level:3,title:".add()方法",slug:"add-方法",normalizedTitle:".add()方法",charIndex:786},{level:3,title:"体验.add()功能——改变对象属性值",slug:"体验-add-功能-改变对象属性值",normalizedTitle:"体验.add()功能——改变对象属性值",charIndex:1175},{level:3,title:"gui改变js对象多个属性",slug:"gui改变js对象多个属性",normalizedTitle:"gui改变js对象多个属性",charIndex:1374},{level:3,title:"gui改变threejs光照强度测试",slug:"gui改变threejs光照强度测试",normalizedTitle:"gui改变threejs光照强度测试",charIndex:1550},{level:3,title:"gui改变threejs模型位置测试",slug:"gui改变threejs模型位置测试",normalizedTitle:"gui改变threejs模型位置测试",charIndex:1862}],headersStr:"gui.js库(可视化改变三维场景) 引入dat.gui.js 创建一个GUI对象 .domElement：改变GUI界面默认的style属性 .add()方法 体验.add()功能——改变对象属性值 gui改变js对象多个属性 gui改变threejs光照强度测试 gui改变threejs模型位置测试",content:"# gui.js库(可视化改变三维场景)\n\ndat.gui.js说白了就是一个前端js库，对HTML、CSS和JavaScript进行了封装，学习开发的时候，借助dat.gui.js可以快速创建控制三维场景的UI交互界面，你打开课件中案例源码体验一下就能感受到。\n\n课程学习dat.gui.js也不仅仅是为了学习dat.gui.js，也是建立一种思想，就是threejs三维空间的很多参数，不是心算出来的，往往需要可视化的方式调试出来。\n\n\n# 引入dat.gui.js\n\ngihtub地址：https://github.com/dataarts/dat.gui\n\nnpm地址：https://www.npmjs.com/package/dat.gui\n\n你可以通过npm或github方式获得dat.gui.js库，当然为了学习方便，threejs官方案例扩展库中也提供了gui.js，你可以直接使用。\n\n// 引入dat.gui.js的一个类GUI\nimport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\n\n# 创建一个GUI对象\n\n创建一个GUI对象，你可以看到浏览器右上角多了一个交互界面，GUI本质上就是一个前端js库。\n\n// 实例化一个gui对象\nconst gui = new GUI();\n\n\n\n# .domElement：改变GUI界面默认的style属性\n\n通过.domElement属性可以获取gui界面的HTML元素，那就意味着你可以改变默认的style样式，比如位置、宽度等。\n\n//改变交互界面style属性\ngui.domElement.style.right = '0px';\ngui.domElement.style.width = '300px';\n\n\n\n# .add()方法\n\n执行gui的.add()方法可以快速创建一个UI交互界面，比如一个拖动条，可以用来改变一个JavaScript对象属性的属性值。\n\n格式：.add(控制对象，对象具体属性，其他参数)\n\n其他参数，可以一个或多个，数据类型也可以不同，gui会自动根据参数形式，自动生成对应的交互界面。\n\n参数3和参数4，分别是一个数字，交互界面是一个鼠标可以拖动的拖动条，可以在一个区间改变属性的值\n\n执行gui.add(obj, 'x', 0, 100);你可以发现右上角gui界面增加了新的内容，可以控制obj对象x属性的新交互界面。\n\n//创建一个对象，对象属性的值可以被GUI库创建的交互界面改变\nconst obj = {\n    x: 30,\n};\n// gui增加交互界面，用来改变obj对应属性\ngui.add(obj, 'x', 0, 100);\n\n\n\n# 体验.add()功能——改变对象属性值\n\n为了方便观察.add()是如何改变JavaScript对象属性的，可以浏览器控制台不停地打印obj的值，这样通过gui界面拖动改变obj对象属性的的时候，便于观察obj的变化。\n\nconst obj = {x: 30};\nsetInterval(function () {\n    console.log('x', obj.x);\n}, 10)\n\n\n\n# gui改变js对象多个属性\n\nconst obj = {\n    x: 30,\n    y: 60,\n    z: 300,\n};\n// gui界面上增加交互界面，改变obj对应属性\ngui.add(obj, 'x', 0, 100);\ngui.add(obj, 'y', 0, 50);\ngui.add(obj, 'z', 0, 60);\n\n\n\n# gui改变threejs光照强度测试\n\nthree.js在调试场景渲染效果的时候，比如光照的强度，人大脑的CPU是没有能力通过光照参数算出来模型渲染效果的，一般来说你先大概给一个经验值，然后通过gui在这个大概值的基础上下浮动可视化调试。\n\n光源对象具有一个光照强度属性.intensity，可以通过gui拖动条改变该属性。\n\n// 光照强度属性.intensity\nconsole.log('ambient.intensity',ambient.intensity);\n// 通过GUI改变mesh.position对象的xyz属性\ngui.add(ambient, 'intensity', 0, 2.0);\n\n\n\n# gui改变threejs模型位置测试\n\nmesh.position是JavaScript对象，具有x、y、z属性,这三个属性分别表示模型的xyz坐标，这就是说，gui改变mesh.position的x、y、z属性，就可以可视化改变mesh的位置。\n\ngui.add(mesh.position, 'x', 0, 180);\ngui.add(mesh.position, 'y', 0, 180);\ngui.add(mesh.position, 'z', 0, 180);\n",normalizedContent:"# gui.js库(可视化改变三维场景)\n\ndat.gui.js说白了就是一个前端js库，对html、css和javascript进行了封装，学习开发的时候，借助dat.gui.js可以快速创建控制三维场景的ui交互界面，你打开课件中案例源码体验一下就能感受到。\n\n课程学习dat.gui.js也不仅仅是为了学习dat.gui.js，也是建立一种思想，就是threejs三维空间的很多参数，不是心算出来的，往往需要可视化的方式调试出来。\n\n\n# 引入dat.gui.js\n\ngihtub地址：https://github.com/dataarts/dat.gui\n\nnpm地址：https://www.npmjs.com/package/dat.gui\n\n你可以通过npm或github方式获得dat.gui.js库，当然为了学习方便，threejs官方案例扩展库中也提供了gui.js，你可以直接使用。\n\n// 引入dat.gui.js的一个类gui\nimport { gui } from 'three/addons/libs/lil-gui.module.min.js';\n\n\n\n# 创建一个gui对象\n\n创建一个gui对象，你可以看到浏览器右上角多了一个交互界面，gui本质上就是一个前端js库。\n\n// 实例化一个gui对象\nconst gui = new gui();\n\n\n\n# .domelement：改变gui界面默认的style属性\n\n通过.domelement属性可以获取gui界面的html元素，那就意味着你可以改变默认的style样式，比如位置、宽度等。\n\n//改变交互界面style属性\ngui.domelement.style.right = '0px';\ngui.domelement.style.width = '300px';\n\n\n\n# .add()方法\n\n执行gui的.add()方法可以快速创建一个ui交互界面，比如一个拖动条，可以用来改变一个javascript对象属性的属性值。\n\n格式：.add(控制对象，对象具体属性，其他参数)\n\n其他参数，可以一个或多个，数据类型也可以不同，gui会自动根据参数形式，自动生成对应的交互界面。\n\n参数3和参数4，分别是一个数字，交互界面是一个鼠标可以拖动的拖动条，可以在一个区间改变属性的值\n\n执行gui.add(obj, 'x', 0, 100);你可以发现右上角gui界面增加了新的内容，可以控制obj对象x属性的新交互界面。\n\n//创建一个对象，对象属性的值可以被gui库创建的交互界面改变\nconst obj = {\n    x: 30,\n};\n// gui增加交互界面，用来改变obj对应属性\ngui.add(obj, 'x', 0, 100);\n\n\n\n# 体验.add()功能——改变对象属性值\n\n为了方便观察.add()是如何改变javascript对象属性的，可以浏览器控制台不停地打印obj的值，这样通过gui界面拖动改变obj对象属性的的时候，便于观察obj的变化。\n\nconst obj = {x: 30};\nsetinterval(function () {\n    console.log('x', obj.x);\n}, 10)\n\n\n\n# gui改变js对象多个属性\n\nconst obj = {\n    x: 30,\n    y: 60,\n    z: 300,\n};\n// gui界面上增加交互界面，改变obj对应属性\ngui.add(obj, 'x', 0, 100);\ngui.add(obj, 'y', 0, 50);\ngui.add(obj, 'z', 0, 60);\n\n\n\n# gui改变threejs光照强度测试\n\nthree.js在调试场景渲染效果的时候，比如光照的强度，人大脑的cpu是没有能力通过光照参数算出来模型渲染效果的，一般来说你先大概给一个经验值，然后通过gui在这个大概值的基础上下浮动可视化调试。\n\n光源对象具有一个光照强度属性.intensity，可以通过gui拖动条改变该属性。\n\n// 光照强度属性.intensity\nconsole.log('ambient.intensity',ambient.intensity);\n// 通过gui改变mesh.position对象的xyz属性\ngui.add(ambient, 'intensity', 0, 2.0);\n\n\n\n# gui改变threejs模型位置测试\n\nmesh.position是javascript对象，具有x、y、z属性,这三个属性分别表示模型的xyz坐标，这就是说，gui改变mesh.position的x、y、z属性，就可以可视化改变mesh的位置。\n\ngui.add(mesh.position, 'x', 0, 180);\ngui.add(mesh.position, 'y', 0, 180);\ngui.add(mesh.position, 'z', 0, 180);\n",charsets:{cjk:!0}},{title:"19. gui调试界面2-颜色命名等",frontmatter:{title:"19. gui调试界面2-颜色命名等",date:"2023-01-20T19:20:08.000Z",permalink:"/pages/66ce2c/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/19.gui%E8%B0%83%E8%AF%95%E7%95%8C%E9%9D%A22%E2%80%94%E9%A2%9C%E8%89%B2%E3%80%81%E5%91%BD%E5%90%8D%E3%80%81%E6%AD%A5%E9%95%BF%E3%80%81%E4%BA%8B%E4%BB%B6.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/19.gui调试界面2—颜色、命名、步长、事件.md",key:"v-1fdb2764",path:"/pages/66ce2c/",headers:[{level:3,title:".name()方法",slug:"name-方法",normalizedTitle:".name()方法",charIndex:60},{level:3,title:"步长.step()方法",slug:"步长-step-方法",normalizedTitle:"步长.step()方法",charIndex:308},{level:3,title:".onChange()方法",slug:"onchange-方法",normalizedTitle:".onchange()方法",charIndex:423},{level:3,title:".addColor()颜色值改变",slug:"addcolor-颜色值改变",normalizedTitle:".addcolor()颜色值改变",charIndex:722}],headersStr:".name()方法 步长.step()方法 .onChange()方法 .addColor()颜色值改变",content:"# gui.js库(颜色、命名、步长、事件)\n\n本节课结合threejs，给大家介绍gui.js库更多的方法。\n\n\n# .name()方法\n\n.add()创建的交互界面，会默认显示所改变属性的名字，为了通过交互界面更好理解你改变的某个对象属性，你可以通过.name()方法改变gui生成交互界面显示的内容。\n\nconst gui = new GUI();//创建GUI对象 \ngui.add(ambient, 'intensity', 0, 2.0).name('环境光强度');\ngui.add(directionalLight, 'intensity', 0, 2.0).name('平行光强度');\n\n\n\n# 步长.step()方法\n\n步长.step()方法可以设置交互界面每次改变属性值间隔是多少。\n\ngui.add(ambient, 'intensity', 0, 2.0).name('环境光强度').step(0.1);\n\n\n\n# .onChange()方法\n\n当gui界面某个值的时候，.onChange()方法就会执行，这时候你可以根据需要通过.onChange()执行某些代码。\n\nconst obj = {\n    x: 30,\n};\n// 当obj的x属性变化的时候，就把此时obj.x的值value赋值给mesh的x坐标\ngui.add(obj, 'x', 0, 180).onChange(function(value){\n    mesh.position.x = value;\n\t// 你可以写任何你想跟着obj.x同步变化的代码\n\t// 比如mesh.position.y = value;\n});\n\n\n\n# .addColor()颜色值改变\n\n.addColor()生成颜色值改变的交互界面\n\nconst obj = {\n    color:0x00ffff,\n};\n// .addColor()生成颜色值改变的交互界面\ngui.addColor(obj, 'color').onChange(function(value){\n    mesh.material.color.set(value);\n});\n",normalizedContent:"# gui.js库(颜色、命名、步长、事件)\n\n本节课结合threejs，给大家介绍gui.js库更多的方法。\n\n\n# .name()方法\n\n.add()创建的交互界面，会默认显示所改变属性的名字，为了通过交互界面更好理解你改变的某个对象属性，你可以通过.name()方法改变gui生成交互界面显示的内容。\n\nconst gui = new gui();//创建gui对象 \ngui.add(ambient, 'intensity', 0, 2.0).name('环境光强度');\ngui.add(directionallight, 'intensity', 0, 2.0).name('平行光强度');\n\n\n\n# 步长.step()方法\n\n步长.step()方法可以设置交互界面每次改变属性值间隔是多少。\n\ngui.add(ambient, 'intensity', 0, 2.0).name('环境光强度').step(0.1);\n\n\n\n# .onchange()方法\n\n当gui界面某个值的时候，.onchange()方法就会执行，这时候你可以根据需要通过.onchange()执行某些代码。\n\nconst obj = {\n    x: 30,\n};\n// 当obj的x属性变化的时候，就把此时obj.x的值value赋值给mesh的x坐标\ngui.add(obj, 'x', 0, 180).onchange(function(value){\n    mesh.position.x = value;\n\t// 你可以写任何你想跟着obj.x同步变化的代码\n\t// 比如mesh.position.y = value;\n});\n\n\n\n# .addcolor()颜色值改变\n\n.addcolor()生成颜色值改变的交互界面\n\nconst obj = {\n    color:0x00ffff,\n};\n// .addcolor()生成颜色值改变的交互界面\ngui.addcolor(obj, 'color').onchange(function(value){\n    mesh.material.color.set(value);\n});\n",charsets:{cjk:!0}},{title:"21. gui.js库(分组)",frontmatter:{title:"21. gui.js库(分组)",date:"2023-01-20T19:22:17.000Z",permalink:"/pages/2e1b8c/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/21.gui.js%E5%BA%93(%E5%88%86%E7%BB%84).html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/21.gui.js库(分组).md",key:"v-0ee268b4",path:"/pages/2e1b8c/",headers:[{level:3,title:"gui交互界面不分组",slug:"gui交互界面不分组",normalizedTitle:"gui交互界面不分组",charIndex:76},{level:3,title:".addFolder()分组",slug:"addfolder-分组",normalizedTitle:".addfolder()分组",charIndex:735},{level:3,title:"关闭.close()和展开.open()交互界面",slug:"关闭-close-和展开-open-交互界面",normalizedTitle:"关闭.close()和展开.open()交互界面",charIndex:1651},{level:3,title:".addFolder()套娃——子菜单嵌套子菜单",slug:"addfolder-套娃-子菜单嵌套子菜单",normalizedTitle:".addfolder()套娃——子菜单嵌套子菜单",charIndex:1867}],headersStr:"gui交互界面不分组 .addFolder()分组 关闭.close()和展开.open()交互界面 .addFolder()套娃——子菜单嵌套子菜单",content:"# gui.js库分组方法.addFolder()\n\n当GUI交互界面需要控制的属性比较多的时候，为了避免混合，可以适当分组管理，这样更清晰。\n\n\n# gui交互界面不分组\n\ngui交互界面不分组,只有一个默认的总的菜单。\n\nconst gui = new GUI(); //创建GUI对象 \n//创建一个对象，对象属性的值可以被GUI库创建的交互界面改变\nconst obj = {\n    color: 0x00ffff,// 材质颜色\n    specular: 0x111111,// 材质高光颜色\n};\n\n\n// 材质颜色color\ngui.addColor(obj, 'color').onChange(function(value){\n    material.color.set(value);\n});\n// 材质高光颜色specular\ngui.addColor(obj, 'specular').onChange(function(value){\n    material.specular.set(value);\n});\n\n// 环境光强度\ngui.add(ambient, 'intensity',0,2);\n// 平行光强度\ngui.add(directionalLight, 'intensity',0,2);\n// 平行光位置\ngui.add(directionalLight.position, 'x',-400,400);\ngui.add(directionalLight.position, 'y',-400,400);\ngui.add(directionalLight.position, 'z',-400,400);\n\n\n\n\n# .addFolder()分组\n\nnew GUI()实例化一个gui对象，默认创建一个总的菜单，通过gui对象的.addFolder()方法可以创建一个子菜单，当你通过GUI控制的属性比较多的时候，可以使用.addFolder()进行分组。\n\n.addFolder()返回的子文件夹对象，同样具有gui对象的.add()、.onChange()、.addColor()等等属性。\n\nconst gui = new GUI(); //创建GUI对象 \nconst obj = {\n    color: 0x00ffff,// 材质颜色\n};\n// 创建材质子菜单\nconst matFolder = gui.addFolder('材质');\nmatFolder.close();\n// 材质颜色color\nmatFolder.addColor(obj, 'color').onChange(function(value){\n    material.color.set(value);\n});\n// 材质高光颜色specular\nmatFolder.addColor(obj, 'specular').onChange(function(value){\n    material.specular.set(value);\n});\n\n\n// 环境光子菜单\nconst ambientFolder = gui.addFolder('环境光');\n// 环境光强度\nambientFolder.add(ambient, 'intensity',0,2);\n\n\n// 平行光强度\ndirFolder.add(directionalLight, 'intensity',0,2);\n// 平行光位置\ndirFolder.add(directionalLight.position, 'x',-400,400);\ndirFolder.add(directionalLight.position, 'y',-400,400);\ndirFolder.add(directionalLight.position, 'z',-400,400);\n\n\n\n# 关闭.close()和展开.open()交互界面\n\ngui对象创建的总菜单或gui.addFolder()创建的子菜单都可以用代码控制交互界面关闭或开展状态。\n\nconst gui = new GUI(); //创建GUI对象 \ngui.close();//关闭菜单\n\n\n// 创建材质子菜单\nconst matFolder = gui.addFolder('材质');\nmatFolder.close();//关闭菜单\n\n\n\n# .addFolder()套娃——子菜单嵌套子菜单\n\n.addFolder()创建的对象，同样也具有.addFolder()属性，可以继续嵌套子菜单。\n\n// 平行光子菜单\nconst dirFolder = gui.addFolder('平行光');\ndirFolder.close();//关闭菜单\n// 平行光强度\ndirFolder.add(directionalLight, 'intensity',0,2);\nconst dirFolder2 = dirFolder.addFolder('位置');//子菜单的子菜单\ndirFolder2.close();//关闭菜单\n// 平行光位置\ndirFolder2.add(directionalLight.position, 'x',-400,400);\ndirFolder2.add(directionalLight.position, 'y',-400,400);\ndirFolder2.add(directionalLight.position, 'z',-400,400);\n\n",normalizedContent:"# gui.js库分组方法.addfolder()\n\n当gui交互界面需要控制的属性比较多的时候，为了避免混合，可以适当分组管理，这样更清晰。\n\n\n# gui交互界面不分组\n\ngui交互界面不分组,只有一个默认的总的菜单。\n\nconst gui = new gui(); //创建gui对象 \n//创建一个对象，对象属性的值可以被gui库创建的交互界面改变\nconst obj = {\n    color: 0x00ffff,// 材质颜色\n    specular: 0x111111,// 材质高光颜色\n};\n\n\n// 材质颜色color\ngui.addcolor(obj, 'color').onchange(function(value){\n    material.color.set(value);\n});\n// 材质高光颜色specular\ngui.addcolor(obj, 'specular').onchange(function(value){\n    material.specular.set(value);\n});\n\n// 环境光强度\ngui.add(ambient, 'intensity',0,2);\n// 平行光强度\ngui.add(directionallight, 'intensity',0,2);\n// 平行光位置\ngui.add(directionallight.position, 'x',-400,400);\ngui.add(directionallight.position, 'y',-400,400);\ngui.add(directionallight.position, 'z',-400,400);\n\n\n\n\n# .addfolder()分组\n\nnew gui()实例化一个gui对象，默认创建一个总的菜单，通过gui对象的.addfolder()方法可以创建一个子菜单，当你通过gui控制的属性比较多的时候，可以使用.addfolder()进行分组。\n\n.addfolder()返回的子文件夹对象，同样具有gui对象的.add()、.onchange()、.addcolor()等等属性。\n\nconst gui = new gui(); //创建gui对象 \nconst obj = {\n    color: 0x00ffff,// 材质颜色\n};\n// 创建材质子菜单\nconst matfolder = gui.addfolder('材质');\nmatfolder.close();\n// 材质颜色color\nmatfolder.addcolor(obj, 'color').onchange(function(value){\n    material.color.set(value);\n});\n// 材质高光颜色specular\nmatfolder.addcolor(obj, 'specular').onchange(function(value){\n    material.specular.set(value);\n});\n\n\n// 环境光子菜单\nconst ambientfolder = gui.addfolder('环境光');\n// 环境光强度\nambientfolder.add(ambient, 'intensity',0,2);\n\n\n// 平行光强度\ndirfolder.add(directionallight, 'intensity',0,2);\n// 平行光位置\ndirfolder.add(directionallight.position, 'x',-400,400);\ndirfolder.add(directionallight.position, 'y',-400,400);\ndirfolder.add(directionallight.position, 'z',-400,400);\n\n\n\n# 关闭.close()和展开.open()交互界面\n\ngui对象创建的总菜单或gui.addfolder()创建的子菜单都可以用代码控制交互界面关闭或开展状态。\n\nconst gui = new gui(); //创建gui对象 \ngui.close();//关闭菜单\n\n\n// 创建材质子菜单\nconst matfolder = gui.addfolder('材质');\nmatfolder.close();//关闭菜单\n\n\n\n# .addfolder()套娃——子菜单嵌套子菜单\n\n.addfolder()创建的对象，同样也具有.addfolder()属性，可以继续嵌套子菜单。\n\n// 平行光子菜单\nconst dirfolder = gui.addfolder('平行光');\ndirfolder.close();//关闭菜单\n// 平行光强度\ndirfolder.add(directionallight, 'intensity',0,2);\nconst dirfolder2 = dirfolder.addfolder('位置');//子菜单的子菜单\ndirfolder2.close();//关闭菜单\n// 平行光位置\ndirfolder2.add(directionallight.position, 'x',-400,400);\ndirfolder2.add(directionallight.position, 'y',-400,400);\ndirfolder2.add(directionallight.position, 'z',-400,400);\n\n",charsets:{cjk:!0}},{title:"20. gui调试3-下拉菜单、单选框",frontmatter:{title:"20. gui调试3-下拉菜单、单选框",date:"2023-01-20T19:21:09.000Z",permalink:"/pages/0569b5/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/20.gui%E8%B0%83%E8%AF%95%E7%95%8C%E9%9D%A23-%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E3%80%81%E5%8D%95%E9%80%89%E6%A1%86.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/20.gui调试界面3-下拉菜单、单选框.md",key:"v-b5d04e02",path:"/pages/0569b5/",headers:[{level:3,title:".add()方法参数3和4数据类型：数字",slug:"add-方法参数3和4数据类型-数字",normalizedTitle:".add()方法参数3和4数据类型：数字",charIndex:101},{level:3,title:".add()方法参数3数据类型：数组",slug:"add-方法参数3数据类型-数组",normalizedTitle:".add()方法参数3数据类型：数组",charIndex:363},{level:3,title:".add()方法参数3数据类型：对象",slug:"add-方法参数3数据类型-对象",normalizedTitle:".add()方法参数3数据类型：对象",charIndex:572},{level:3,title:".add()方法对应属性的数据类型：布尔值",slug:"add-方法对应属性的数据类型-布尔值",normalizedTitle:".add()方法对应属性的数据类型：布尔值",charIndex:867},{level:3,title:".add()方法改变布尔值案例",slug:"add-方法改变布尔值案例",normalizedTitle:".add()方法改变布尔值案例",charIndex:1155}],headersStr:".add()方法参数3和4数据类型：数字 .add()方法参数3数据类型：数组 .add()方法参数3数据类型：对象 .add()方法对应属性的数据类型：布尔值 .add()方法改变布尔值案例",content:"# gui.js库(下拉菜单、单选框)\n\n前面大家学过通过.add()方法可以添加一个拖动条用来改变对象的某个属性，本节课给大家介绍.add()方法创建新的UI交互界面，比如下拉菜单、单选框。\n\n\n# .add()方法参数3和4数据类型：数字\n\n格式：add(控制对象，对象具体属性，其他参数)\n\n其他参数，可以一个或多个，数据类型也可以不同，gui会自动根据参数形式，自动生成对应的交互界面。\n\n参数3和参数4，分别是一个数字，交互界面是一个鼠标可以拖动的拖动条，可以在一个区间改变属性的值\n\n// 参数3、参数4数据类型：数字(拖动条)\ngui.add(obj, 'x', 0, 180).onChange(function (value) {\n    mesh.position.x = value;\n});\n\n\n\n# .add()方法参数3数据类型：数组\n\n参数3是一个数组，生成交互界面是下拉菜单\n\nconst obj = {\n    scale: 0,\n};\n// 参数3数据类型：数组(下拉菜单)\ngui.add(obj, 'scale', [-100, 0, 100]).name('y坐标').onChange(function (value) {\n    mesh.position.y = value;\n});\n\n\n\n# .add()方法参数3数据类型：对象\n\n参数3是一个对象，生成交互界面是下拉菜单\n\nconst obj = {\n    scale: 0,\n};\n// 参数3数据类型：对象(下拉菜单)\ngui.add(obj, 'scale', {\n    left: -100,\n    center: 0,\n    right: 100\n    // 左: -100,//可以用中文\n    // 中: 0,\n    // 右: 100\n}).name('位置选择').onChange(function (value) {\n    mesh.position.x = value;\n});\n\n\n\n# .add()方法对应属性的数据类型：布尔值\n\n如果.add()改变属性的对应的数据类型如果是布尔值，那么交互界面就是一个单选框。\n\nconst obj = {\n    bool: false,\n};\n// 改变的obj属性数据类型是布尔值，交互界面是单选框\ngui.add(obj, 'bool').name('是否旋转');\n\n\ngui.add(obj, 'bool').onChange(function (value) {\n    // 点击单选框，控制台打印obj.bool变化\n    console.log('obj.bool',value);\n});\n\n\n\n# .add()方法改变布尔值案例\n\n控制一个对象是否旋转。\n\ngui.add(obj, 'bool').name('旋转动画');\n\n// 渲染循环\nfunction render() {\n    // 当gui界面设置obj.bool为true,mesh执行旋转动画\n    if (obj.bool) mesh.rotateY(0.01);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# gui.js库(下拉菜单、单选框)\n\n前面大家学过通过.add()方法可以添加一个拖动条用来改变对象的某个属性，本节课给大家介绍.add()方法创建新的ui交互界面，比如下拉菜单、单选框。\n\n\n# .add()方法参数3和4数据类型：数字\n\n格式：add(控制对象，对象具体属性，其他参数)\n\n其他参数，可以一个或多个，数据类型也可以不同，gui会自动根据参数形式，自动生成对应的交互界面。\n\n参数3和参数4，分别是一个数字，交互界面是一个鼠标可以拖动的拖动条，可以在一个区间改变属性的值\n\n// 参数3、参数4数据类型：数字(拖动条)\ngui.add(obj, 'x', 0, 180).onchange(function (value) {\n    mesh.position.x = value;\n});\n\n\n\n# .add()方法参数3数据类型：数组\n\n参数3是一个数组，生成交互界面是下拉菜单\n\nconst obj = {\n    scale: 0,\n};\n// 参数3数据类型：数组(下拉菜单)\ngui.add(obj, 'scale', [-100, 0, 100]).name('y坐标').onchange(function (value) {\n    mesh.position.y = value;\n});\n\n\n\n# .add()方法参数3数据类型：对象\n\n参数3是一个对象，生成交互界面是下拉菜单\n\nconst obj = {\n    scale: 0,\n};\n// 参数3数据类型：对象(下拉菜单)\ngui.add(obj, 'scale', {\n    left: -100,\n    center: 0,\n    right: 100\n    // 左: -100,//可以用中文\n    // 中: 0,\n    // 右: 100\n}).name('位置选择').onchange(function (value) {\n    mesh.position.x = value;\n});\n\n\n\n# .add()方法对应属性的数据类型：布尔值\n\n如果.add()改变属性的对应的数据类型如果是布尔值，那么交互界面就是一个单选框。\n\nconst obj = {\n    bool: false,\n};\n// 改变的obj属性数据类型是布尔值，交互界面是单选框\ngui.add(obj, 'bool').name('是否旋转');\n\n\ngui.add(obj, 'bool').onchange(function (value) {\n    // 点击单选框，控制台打印obj.bool变化\n    console.log('obj.bool',value);\n});\n\n\n\n# .add()方法改变布尔值案例\n\n控制一个对象是否旋转。\n\ngui.add(obj, 'bool').name('旋转动画');\n\n// 渲染循环\nfunction render() {\n    // 当gui界面设置obj.bool为true,mesh执行旋转动画\n    if (obj.bool) mesh.rotatey(0.01);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"22. examples和文档(辅助开发)",frontmatter:{title:"22. examples和文档(辅助开发)",date:"2023-01-20T19:23:04.000Z",permalink:"/pages/f1d3dd/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/22.%E6%9F%A5%E8%AF%A2examples%E5%92%8C%E6%96%87%E6%A1%A3(%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91).html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/22.查询examples和文档(辅助开发).md",key:"v-7210a980",path:"/pages/f1d3dd/",headers:[{level:3,title:"案例examples",slug:"案例examples",normalizedTitle:"案例examples",charIndex:4},{level:3,title:"文档搜索",slug:"文档搜索",normalizedTitle:"文档搜索",charIndex:486},{level:3,title:"文档搜索API",slug:"文档搜索api",normalizedTitle:"文档搜索api",charIndex:591},{level:3,title:"搜索方法或属性",slug:"搜索方法或属性",normalizedTitle:"搜索方法或属性",charIndex:665},{level:3,title:"【扩展】查看src目录下源码或者examples/jms目录下源码",slug:"【扩展】查看src目录下源码或者examples-jms目录下源码",normalizedTitle:"【扩展】查看src目录下源码或者examples/jms目录下源码",charIndex:850}],headersStr:"案例examples 文档搜索 文档搜索API 搜索方法或属性 【扩展】查看src目录下源码或者examples/jms目录下源码",content:"# 查询案例examples和文档(辅助开发)\n\n有些时候你想了解threejs某个类(对象)的语法，或者某个对象属性和方法的语法，这时候你可以查询threejs官方文件包提供的案例examples、文档docs。\n\nthree.js-文件包\n...\n└───docs——Three.js API文档文件\n    │───index.html——打开该文件，本地离线方式预览threejs文档\n└───examples——大量的3D案例，是你平时开发参考学习的最佳资源\n    │───.html——各种3D案例\n...    \n\n\n\n# 案例examples\n\n案例examples文件里面提供了很多3D案例，平时学习你可以参考里面的小案例去学习。\n\n通过关键词全文检索案例examples，比如vscode代码编辑器，在左侧找到threejs文件包的examples目录，右键，点击在文件中查找，输入一个关键词就可以查找，比如输入类名gui、OrbitControls、.lookAt()...，通过关键字找到对应的.html文件，你就可以参考里面的代码了。\n\n\n# 文档搜索\n\n关于文档的使用，前面也说过，这里再给大家再给大家介绍更多文档使用技巧。\n\n通过threejs中文网(webgl3d.cn)分享一个文档链接，可以直接跳转到threejs官网提供的中文文档。\n\n\n# 文档搜索API\n\n文档左上角提供了一个输入框，可以快速查看某个API，如果你不记得完整名字，也可以通过threejs API部分名字查询。\n\n\n# 搜索方法或属性\n\n进入threejs API页面，有的类属性或方法比较多，滚动页面查询比较麻烦的话，如果你想查询某个方法或属性，可以Ctrl+F调用谷歌浏览器的当前网页关键字查询功能，找到特定的API的方法或属性,比如找到类PerspectiveCamera，搜索该类的.fov、.aspect、.updateProjectionMatrix()等属性或方法。\n\n\n# 【扩展】查看src目录下源码或者examples/jms目录下源码\n\n如果你通过案例examples、文档docs还不能更加清晰的了解某个属性或方法的含义，可以查看threejs封装的源码，当然对于threejs新手或编程基础不好的学员，不太推荐。",normalizedContent:"# 查询案例examples和文档(辅助开发)\n\n有些时候你想了解threejs某个类(对象)的语法，或者某个对象属性和方法的语法，这时候你可以查询threejs官方文件包提供的案例examples、文档docs。\n\nthree.js-文件包\n...\n└───docs——three.js api文档文件\n    │───index.html——打开该文件，本地离线方式预览threejs文档\n└───examples——大量的3d案例，是你平时开发参考学习的最佳资源\n    │───.html——各种3d案例\n...    \n\n\n\n# 案例examples\n\n案例examples文件里面提供了很多3d案例，平时学习你可以参考里面的小案例去学习。\n\n通过关键词全文检索案例examples，比如vscode代码编辑器，在左侧找到threejs文件包的examples目录，右键，点击在文件中查找，输入一个关键词就可以查找，比如输入类名gui、orbitcontrols、.lookat()...，通过关键字找到对应的.html文件，你就可以参考里面的代码了。\n\n\n# 文档搜索\n\n关于文档的使用，前面也说过，这里再给大家再给大家介绍更多文档使用技巧。\n\n通过threejs中文网(webgl3d.cn)分享一个文档链接，可以直接跳转到threejs官网提供的中文文档。\n\n\n# 文档搜索api\n\n文档左上角提供了一个输入框，可以快速查看某个api，如果你不记得完整名字，也可以通过threejs api部分名字查询。\n\n\n# 搜索方法或属性\n\n进入threejs api页面，有的类属性或方法比较多，滚动页面查询比较麻烦的话，如果你想查询某个方法或属性，可以ctrl+f调用谷歌浏览器的当前网页关键字查询功能，找到特定的api的方法或属性,比如找到类perspectivecamera，搜索该类的.fov、.aspect、.updateprojectionmatrix()等属性或方法。\n\n\n# 【扩展】查看src目录下源码或者examples/jms目录下源码\n\n如果你通过案例examples、文档docs还不能更加清晰的了解某个属性或方法的含义，可以查看threejs封装的源码，当然对于threejs新手或编程基础不好的学员，不太推荐。",charsets:{cjk:!0}},{title:"23. threejs语法总结",frontmatter:{title:"23. threejs语法总结",date:"2023-01-20T19:23:17.000Z",permalink:"/pages/63ce1e/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/23.threejs%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/23.threejs语法总结.md",key:"v-71604a53",path:"/pages/63ce1e/",headers:[{level:3,title:"Three.js语法总结：类(构造函数)",slug:"three-js语法总结-类-构造函数",normalizedTitle:"three.js语法总结：类(构造函数)",charIndex:90},{level:3,title:"类(构造函数)的参数设置属性",slug:"类-构造函数-的参数设置属性",normalizedTitle:"类(构造函数)的参数设置属性",charIndex:594},{level:3,title:"访问对象属性改变属性的值",slug:"访问对象属性改变属性的值",normalizedTitle:"访问对象属性改变属性的值",charIndex:1003},{level:3,title:"父类和子类",slug:"父类和子类",normalizedTitle:"父类和子类",charIndex:1187},{level:3,title:"通过对象的方法改变对象的属性",slug:"通过对象的方法改变对象的属性",normalizedTitle:"通过对象的方法改变对象的属性",charIndex:1348}],headersStr:"Three.js语法总结：类(构造函数) 类(构造函数)的参数设置属性 访问对象属性改变属性的值 父类和子类 通过对象的方法改变对象的属性",content:"# threejs语法总结\n\n本节课从JavaScript面向对象语法的角度，给大家总结下threejs API的使用习惯，这样方便大家更好的使用threejs API。\n\n\n# Three.js语法总结：类(构造函数)\n\nThree.js提供了各种各样的类(构造函数),通过new关键字可以实例化类(构造函数)，获得一个对象，对象具有属性和方法。\n\n// new实例化类THREE.MeshLambertMaterial，创建一个材质对象\nconst material = new THREE.MeshLambertMaterial();\n// 可以看到材质对象的属性color、side、opacity、transparent...\n// 通过属性可以看到threejs默认的属性值\nconsole.log('查看材质对象',material);\n\n\n// 查看材质默认属性值\nconsole.log('material.color',material.color);\nconsole.log('material.side',material.side);\nconsole.log('material.transparent',material.transparent);\nconsole.log('material.opacity',material.opacity);\n\n\n\n# 类(构造函数)的参数设置属性\n\n通过类(构造函数)的参数设置属性\n\nconst material = new THREE.MeshLambertMaterial({\n    color: 0x00ffff, \n    side:THREE.DoubleSide,\n    transparent:true,\n    opacity:0.5,\n});\n\n\n查看选项参数设置的材质属性值,可以和原来默认属性值对比\n\nconsole.log('material.color',material.color);\nconsole.log('material.side',material.side);\nconsole.log('material.transparent',material.transparent);\nconsole.log('material.opacity',material.opacity);\n\n\n\n# 访问对象属性改变属性的值\n\n// 访问对象属性改变属性的值\nmaterial.transparent = false;\nmaterial.opacity = 1.0;\n\n\nconsole.log('directionalLight',ambient.intensity);\ndirectionalLight.intensity = 0.1;//改变光源强度\n\n\n\n# 父类和子类\n\n如果你学习过JavaScript面向对象，应该有父类和子类的概念，子类是通过父类派生出来的，会继承父类的属性或方法。\n\n * 环境光、平行光源的父类Light\n\n * mesh、light光源的父类Object3D\n\n如果你想通过文档查询一个类的方法或属性，除了可以查询类本身，还可以查询类的父类。\n\n\n# 通过对象的方法改变对象的属性\n\nconsole.log('模型位置属性',mesh.position);\nmesh.position.x = 50;//访问属性改变位置x坐标\nmesh.translateX(50);//执行方法改变位置属性\n",normalizedContent:"# threejs语法总结\n\n本节课从javascript面向对象语法的角度，给大家总结下threejs api的使用习惯，这样方便大家更好的使用threejs api。\n\n\n# three.js语法总结：类(构造函数)\n\nthree.js提供了各种各样的类(构造函数),通过new关键字可以实例化类(构造函数)，获得一个对象，对象具有属性和方法。\n\n// new实例化类three.meshlambertmaterial，创建一个材质对象\nconst material = new three.meshlambertmaterial();\n// 可以看到材质对象的属性color、side、opacity、transparent...\n// 通过属性可以看到threejs默认的属性值\nconsole.log('查看材质对象',material);\n\n\n// 查看材质默认属性值\nconsole.log('material.color',material.color);\nconsole.log('material.side',material.side);\nconsole.log('material.transparent',material.transparent);\nconsole.log('material.opacity',material.opacity);\n\n\n\n# 类(构造函数)的参数设置属性\n\n通过类(构造函数)的参数设置属性\n\nconst material = new three.meshlambertmaterial({\n    color: 0x00ffff, \n    side:three.doubleside,\n    transparent:true,\n    opacity:0.5,\n});\n\n\n查看选项参数设置的材质属性值,可以和原来默认属性值对比\n\nconsole.log('material.color',material.color);\nconsole.log('material.side',material.side);\nconsole.log('material.transparent',material.transparent);\nconsole.log('material.opacity',material.opacity);\n\n\n\n# 访问对象属性改变属性的值\n\n// 访问对象属性改变属性的值\nmaterial.transparent = false;\nmaterial.opacity = 1.0;\n\n\nconsole.log('directionallight',ambient.intensity);\ndirectionallight.intensity = 0.1;//改变光源强度\n\n\n\n# 父类和子类\n\n如果你学习过javascript面向对象，应该有父类和子类的概念，子类是通过父类派生出来的，会继承父类的属性或方法。\n\n * 环境光、平行光源的父类light\n\n * mesh、light光源的父类object3d\n\n如果你想通过文档查询一个类的方法或属性，除了可以查询类本身，还可以查询类的父类。\n\n\n# 通过对象的方法改变对象的属性\n\nconsole.log('模型位置属性',mesh.position);\nmesh.position.x = 50;//访问属性改变位置x坐标\nmesh.translatex(50);//执行方法改变位置属性\n",charsets:{cjk:!0}},{title:"【选修】Vue+Threejs开发环境",frontmatter:{title:"【选修】Vue+Threejs开发环境",date:"2023-10-29T15:11:25.000Z",permalink:"/pages/637c91/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/24.%E3%80%90%E9%80%89%E4%BF%AE%E3%80%91Vue+Threejs%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/24.【选修】Vue+Threejs开发环境.md",key:"v-80a6d188",path:"/pages/637c91/",headers:[{level:3,title:"threejs与前端框架结合问题",slug:"threejs与前端框架结合问题",normalizedTitle:"threejs与前端框架结合问题",charIndex:214},{level:3,title:"Vue与threejs结合思路",slug:"vue与threejs结合思路",normalizedTitle:"vue与threejs结合思路",charIndex:435},{level:3,title:"脚手架Vite",slug:"脚手架vite",normalizedTitle:"脚手架vite",charIndex:922},{level:3,title:"预览vite项目默认效果",slug:"预览vite项目默认效果",normalizedTitle:"预览vite项目默认效果",charIndex:1120},{level:3,title:"npm安装threejs",slug:"npm安装threejs",normalizedTitle:"npm安装threejs",charIndex:1242},{level:3,title:"Vue中引入threejs代码",slug:"vue中引入threejs代码",normalizedTitle:"vue中引入threejs代码",charIndex:1330},{level:3,title:"设置canvas画布全屏",slug:"设置canvas画布全屏",normalizedTitle:"设置canvas画布全屏",charIndex:2351},{level:3,title:"引入扩展库OrbitControls",slug:"引入扩展库orbitcontrols",normalizedTitle:"引入扩展库orbitcontrols",charIndex:2713}],headersStr:"threejs与前端框架结合问题 Vue与threejs结合思路 脚手架Vite 预览vite项目默认效果 npm安装threejs Vue中引入threejs代码 设置canvas画布全屏 引入扩展库OrbitControls",content:"# 【选修】Vue+Three.js开发环境\n\n视频讲解\n\n * Vue开发环境引入threejs\n * 提醒：如果你不怎么熟悉Vue，那么本节课你完全不用学习，直接跳过去就行\n * 本节课是选修内容，即便不学习本节课，也不影响你学习threejs后面的知识点。\n\n如果你想了解更多Vue+Threejs结合开发的详细知识点，可以参考系统课程后面Vue+Threejs实战案例或课件里面Vue+Threejs案例模板。\n\n\n# threejs与前端框架结合问题\n\n有些同学是前端转来过来的，受到平时开发习惯影响，第一反应可能是threejs能不能与vue或react结合。\n\n其实threejs知识点相对普通web前端是比较独立的，threejs的用法，你直接用.html文件写，还是结合vue或React框架写，API语法都是一样的。\n\n所以你学习threejs的重点不是考虑前端框架问题，而是threejs本身，掌握了threejs，剩下的事情就很简单了。\n\n\n# Vue与threejs结合思路\n\n回顾下前面1.6. 第一个3D案例知识点\n\nthree.js执行渲染方法.render();会输出一个canvas画布renderer.domElement，这个Canvas画布本质上就是一个HTML元素。\n\nthreejs与Vue结合的时候，你只需要把Canvas画布renderer.domElement插入到你的Vue页面上就行，插入任何一个div或其它元素中，或者放到某个Vue组件中都行。\n\n// WebGL渲染器\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(width, height); \nrenderer.render(scene, camera);\n//three.js执行渲染命令会输出一个canvas画布(HTML元素)\ndocument.body.appendChild(renderer.domElement);\n\n\n接下来，你写的threejs代码结构，并不一定就要和我下面视频完全一致，你可以根据你自己项目情况，自由调整。\n\n\n# 脚手架Vite\n\n使用脚手架Vite快速创建一个vue工程文件，具体跟着视频可操作即可\n\nnpm create  vite@latest\n\n\n执行命令npm create vite@latest，然后选择你想要的开发环境即可。\n\nvite使用文档\n\n第一步是选择你的前端框架，第二步是选择是否支持TS。\n\n注意：安装使用Vite之前，确保你电脑已经安装Nodejs了，尽量用最新版本的。\n\n\n# 预览vite项目默认效果\n\n * 命令行执行npm i，安装所有默认依赖\n\n * 命令行执行npm run dev，查看vite里面Vue代码默认渲染效果。\n\n现在你可以把默认的HTML和CSS代码删掉，然后在引入threejs代码。\n\n\n# npm安装threejs\n\n安装threesjs时候，你可以指定你想要的版本。\n\n// 比如安装157版本\nnpm install three@0.157.0 -S\n\n\n\n# Vue中引入threejs代码\n\n新建index.js文件,把threejs代码写在index.js里面。\n\nindex.js文件引入three.js。\n\nimport * as THREE from 'three';\n\n\n复制前面课程第一个3D案例的代码，粘贴到index.js文件。\n\n// 三维场景\nconst scene = new THREE.Scene();\n// 模型对象\nconst geometry = new THREE.BoxGeometry(50, 50, 50);\nconst material = new THREE.MeshBasicMaterial({\n    color: 0x0000ff, \n});\nconst mesh = new THREE.Mesh(geometry, material); \nscene.add(mesh); \n// AxesHelper：辅助观察的坐标系\nconst axesHelper = new THREE.AxesHelper(250);\nscene.add(axesHelper);\nconst width = 800; //宽度\nconst height = 500; //高度\n// 相机\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\ncamera.position.set(292, 223, 185);\ncamera.lookAt(0, 0, 0);\n// WebGL渲染器\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(width, height); \nrenderer.render(scene, camera);\n//three.js执行渲染命令会输出一个canvas画布(HTML元素)，你可以插入到web页面中\ndocument.body.appendChild(renderer.domElement);\n\n\n然后把threejs对应的index.js文件引入到vue的main.js文件中。\n\n// main.js文件\nimport './index.js'// 执行threejs代码\n\n\n当然你也可以根据需要，在其它Vue组件中调用执行threejs代码。\n\n\n# 设置canvas画布全屏\n\n上面画布设置了固定宽高度，下面改成文档区域宽高度，也就是所谓canvas画布全屏\n\nconst width = window.innerWidth;\nconst height = window.innerHeight;\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(width, height);\n\n\n// 可以放到vite项目style.css文件中\nbody{\n    // 把canvas画布与body区域边距设置为0\n    margin: 0px;\n}\n\n\n\n# 引入扩展库OrbitControls\n\n查看文件node_modules，在目录three/examples/jsm中，你可以看到threejs的很多扩展库。\n\n对于这些扩展库，不会一次都引入，一般你用到那个，单独引入即可，下面以OrbitControls为例给大家展示。\n\nOrbitControls功能就是旋转缩放平移，在1.9小节有具体讲解：1.9. 相机控件OrbitControls，如果还没学习，可以提前看下。\n\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n\n\n复制1.9. 相机控件OrbitControls里面关于相机控件的代码。\n\n// 设置相机控件轨道控制器OrbitControls\nconst controls = new OrbitControls(camera, renderer.domElement);\n// 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景\ncontrols.addEventListener('change', function () {\n    renderer.render(scene, camera); //执行渲染操作\n});//监听鼠标、键盘事件\n",normalizedContent:"# 【选修】vue+three.js开发环境\n\n视频讲解\n\n * vue开发环境引入threejs\n * 提醒：如果你不怎么熟悉vue，那么本节课你完全不用学习，直接跳过去就行\n * 本节课是选修内容，即便不学习本节课，也不影响你学习threejs后面的知识点。\n\n如果你想了解更多vue+threejs结合开发的详细知识点，可以参考系统课程后面vue+threejs实战案例或课件里面vue+threejs案例模板。\n\n\n# threejs与前端框架结合问题\n\n有些同学是前端转来过来的，受到平时开发习惯影响，第一反应可能是threejs能不能与vue或react结合。\n\n其实threejs知识点相对普通web前端是比较独立的，threejs的用法，你直接用.html文件写，还是结合vue或react框架写，api语法都是一样的。\n\n所以你学习threejs的重点不是考虑前端框架问题，而是threejs本身，掌握了threejs，剩下的事情就很简单了。\n\n\n# vue与threejs结合思路\n\n回顾下前面1.6. 第一个3d案例知识点\n\nthree.js执行渲染方法.render();会输出一个canvas画布renderer.domelement，这个canvas画布本质上就是一个html元素。\n\nthreejs与vue结合的时候，你只需要把canvas画布renderer.domelement插入到你的vue页面上就行，插入任何一个div或其它元素中，或者放到某个vue组件中都行。\n\n// webgl渲染器\nconst renderer = new three.webglrenderer();\nrenderer.setsize(width, height); \nrenderer.render(scene, camera);\n//three.js执行渲染命令会输出一个canvas画布(html元素)\ndocument.body.appendchild(renderer.domelement);\n\n\n接下来，你写的threejs代码结构，并不一定就要和我下面视频完全一致，你可以根据你自己项目情况，自由调整。\n\n\n# 脚手架vite\n\n使用脚手架vite快速创建一个vue工程文件，具体跟着视频可操作即可\n\nnpm create  vite@latest\n\n\n执行命令npm create vite@latest，然后选择你想要的开发环境即可。\n\nvite使用文档\n\n第一步是选择你的前端框架，第二步是选择是否支持ts。\n\n注意：安装使用vite之前，确保你电脑已经安装nodejs了，尽量用最新版本的。\n\n\n# 预览vite项目默认效果\n\n * 命令行执行npm i，安装所有默认依赖\n\n * 命令行执行npm run dev，查看vite里面vue代码默认渲染效果。\n\n现在你可以把默认的html和css代码删掉，然后在引入threejs代码。\n\n\n# npm安装threejs\n\n安装threesjs时候，你可以指定你想要的版本。\n\n// 比如安装157版本\nnpm install three@0.157.0 -s\n\n\n\n# vue中引入threejs代码\n\n新建index.js文件,把threejs代码写在index.js里面。\n\nindex.js文件引入three.js。\n\nimport * as three from 'three';\n\n\n复制前面课程第一个3d案例的代码，粘贴到index.js文件。\n\n// 三维场景\nconst scene = new three.scene();\n// 模型对象\nconst geometry = new three.boxgeometry(50, 50, 50);\nconst material = new three.meshbasicmaterial({\n    color: 0x0000ff, \n});\nconst mesh = new three.mesh(geometry, material); \nscene.add(mesh); \n// axeshelper：辅助观察的坐标系\nconst axeshelper = new three.axeshelper(250);\nscene.add(axeshelper);\nconst width = 800; //宽度\nconst height = 500; //高度\n// 相机\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\ncamera.position.set(292, 223, 185);\ncamera.lookat(0, 0, 0);\n// webgl渲染器\nconst renderer = new three.webglrenderer();\nrenderer.setsize(width, height); \nrenderer.render(scene, camera);\n//three.js执行渲染命令会输出一个canvas画布(html元素)，你可以插入到web页面中\ndocument.body.appendchild(renderer.domelement);\n\n\n然后把threejs对应的index.js文件引入到vue的main.js文件中。\n\n// main.js文件\nimport './index.js'// 执行threejs代码\n\n\n当然你也可以根据需要，在其它vue组件中调用执行threejs代码。\n\n\n# 设置canvas画布全屏\n\n上面画布设置了固定宽高度，下面改成文档区域宽高度，也就是所谓canvas画布全屏\n\nconst width = window.innerwidth;\nconst height = window.innerheight;\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\nconst renderer = new three.webglrenderer();\nrenderer.setsize(width, height);\n\n\n// 可以放到vite项目style.css文件中\nbody{\n    // 把canvas画布与body区域边距设置为0\n    margin: 0px;\n}\n\n\n\n# 引入扩展库orbitcontrols\n\n查看文件node_modules，在目录three/examples/jsm中，你可以看到threejs的很多扩展库。\n\n对于这些扩展库，不会一次都引入，一般你用到那个，单独引入即可，下面以orbitcontrols为例给大家展示。\n\norbitcontrols功能就是旋转缩放平移，在1.9小节有具体讲解：1.9. 相机控件orbitcontrols，如果还没学习，可以提前看下。\n\nimport { orbitcontrols } from 'three/examples/jsm/controls/orbitcontrols.js';\n\n\n复制1.9. 相机控件orbitcontrols里面关于相机控件的代码。\n\n// 设置相机控件轨道控制器orbitcontrols\nconst controls = new orbitcontrols(camera, renderer.domelement);\n// 如果orbitcontrols改变了相机参数，重新调用渲染器渲染三维场景\ncontrols.addeventlistener('change', function () {\n    renderer.render(scene, camera); //执行渲染操作\n});//监听鼠标、键盘事件\n",charsets:{cjk:!0}},{title:"【选修】React+Three.js开发环境",frontmatter:{title:"【选修】React+Three.js开发环境",date:"2023-10-29T22:23:52.000Z",permalink:"/pages/d6ce1f/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/01.1.Three.js%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/25.%E3%80%90%E9%80%89%E4%BF%AE%E3%80%91React+Threejs%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html",relativePath:"01.Three.js教程/01.1.Three.js快速入门/25.【选修】React+Threejs开发环境.md",key:"v-9b5795f0",path:"/pages/d6ce1f/",headers:[{level:3,title:"脚手架create-react-app",slug:"脚手架create-react-app",normalizedTitle:"脚手架create-react-app",charIndex:134},{level:3,title:"启动项目",slug:"启动项目",normalizedTitle:"启动项目",charIndex:275},{level:3,title:"npm安装threejs",slug:"npm安装threejs",normalizedTitle:"npm安装threejs",charIndex:386},{level:3,title:"知识点回顾",slug:"知识点回顾",normalizedTitle:"知识点回顾",charIndex:469},{level:3,title:"React与threejs结合思路",slug:"react与threejs结合思路",normalizedTitle:"react与threejs结合思路",charIndex:818},{level:3,title:"新建indexThree.js文件",slug:"新建indexthree-js文件",normalizedTitle:"新建indexthree.js文件",charIndex:1005},{level:3,title:"设置canvas画布全屏",slug:"设置canvas画布全屏",normalizedTitle:"设置canvas画布全屏",charIndex:2214},{level:3,title:"引入扩展库OrbitControls",slug:"引入扩展库orbitcontrols",normalizedTitle:"引入扩展库orbitcontrols",charIndex:2577}],headersStr:"脚手架create-react-app 启动项目 npm安装threejs 知识点回顾 React与threejs结合思路 新建indexThree.js文件 设置canvas画布全屏 引入扩展库OrbitControls",content:"# 【选修】React + Three.js开发环境\n\n视频讲解\n\n * 在React开发环境引入threejs\n * 如果你不熟悉React，直接跳过本节课即可，不用学习\n * 本节课是选修内容，即便不学习本节课，也不影响你学习threejs后面的知识点。\n\n\n# 脚手架create-react-app\n\n脚手架create-react-app创建react项目。\n\nnpx create-react-app 项目名字\n\n\n创建一个名为reactthree的项目文件。\n\nnpx create-react-app reactthree\n\n\n\n# 启动项目\n\n进入reactthree项目目录，命令行输入npm run start,启动打开项目\n\nnpm run start\n\n\n你可以删除react默认页面对应的HTML和CSS代码，再写threejs代码。\n\n\n# npm安装threejs\n\n你可以选择你想安装的threejs版本。\n\n// 比如安装157版本\nnpm install three@0.157.0 -S\n\n\n\n# 知识点回顾\n\n回顾下前面1.6. 第一个3D案例知识点\n\n大家都知道three.js执行渲染命令.render();会输出一个canvas画布renderer.domElement，这个Canvas画布本质上就是一个HTML元素，你可以插入到web页面任何一个元素中。\n\n// WebGL渲染器\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(width, height); \nrenderer.render(scene, camera);\n//three.js执行渲染命令会输出一个canvas画布(HTML元素)\ndocument.body.appendChild(renderer.domElement);\n\n\n\n# React与threejs结合思路\n\nthreejs与React结合的时候，你只需要把Canvas画布renderer.domElement插入到你的react页面上就行，可以放在web网页的任何位置，插入任何一个div或其它元素中，或者放到某个React组件中。\n\n你写的threejs代码结构，并不一定就要和我视频完全一致，你可以根据你自己项目情况，自由封装。\n\n\n# 新建indexThree.js文件\n\n新建indexThree.js文件,把threejs代码写在indexThree.js里面。\n\n引入three.jsimport * as THREE from 'three';。\n\n// indexThree.js文件\nimport * as THREE from 'three';\n\n\n你可以把前面第一个3D案例的代码复制到indexThree.js文件。\n\n// 三维场景\nconst scene = new THREE.Scene();\n// 模型对象\nconst geometry = new THREE.BoxGeometry(50, 50, 50);\nconst material = new THREE.MeshBasicMaterial({\n    color: 0x0000ff, \n});\nconst mesh = new THREE.Mesh(geometry, material); \nscene.add(mesh); \n// AxesHelper：辅助观察的坐标系\nconst axesHelper = new THREE.AxesHelper(250);\nscene.add(axesHelper);\nconst width = 800; //宽度\nconst height = 500; //高度\n// 相机\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\ncamera.position.set(292, 223, 185);\ncamera.lookAt(0, 0, 0);\n// WebGL渲染器\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(width, height); \nrenderer.render(scene, camera);\n//three.js执行渲染命令会输出一个canvas画布(HTML元素)，你可以插入到web页面中\ndocument.body.appendChild(renderer.domElement);\n\n\n然后把indexThree.js引入到index.js文件执行即可,这样threejs的代码会跟着index.js执行，当然你也可以在其的React文件，比如某个组件中调用threejs代码。\n\n// index.js文件\nimport React from 'react';\n...\n// 执行threejs代码\nimport './indexThree.js'\n...\nconst root = ReactDOM.createRoot(document.getElementById('root'));\n...\n\n\n\n# 设置canvas画布全屏\n\n上面画布设置了固定宽高度，下面改成文档区域宽高度，也就是所谓canvas画布全屏\n\nconst width = window.innerWidth;\nconst height = window.innerHeight;\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize(width, height);\n\n\n// 可以放到react项目index.css文件中\nbody{\n    // 把canvas画布与body区域边距设置为0\n    margin: 0px;\n}\n\n\n\n# 引入扩展库OrbitControls\n\n查看你npm安装文件node_modules，在目录three/examples/jsm下面有threejs的很多扩展库，一般你用到那个，单独引入即可，下面以OrbitControls为例给大家展示。\n\nOrbitControls功能就是旋转缩放平移，在1.9小节有具体讲解：1.9. 相机控件OrbitControls，如果还没学习，可以提前看下。\n\n// 引入路径\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\n\n\n复制1.9. 相机控件OrbitControls里面关于相机控件的代码。\n\n// 设置相机控件轨道控制器OrbitControls\nconst controls = new OrbitControls(camera, renderer.domElement);\n// 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景\ncontrols.addEventListener('change', function () {\n    renderer.render(scene, camera); //执行渲染操作\n});//监听鼠标、键盘事件\n",normalizedContent:"# 【选修】react + three.js开发环境\n\n视频讲解\n\n * 在react开发环境引入threejs\n * 如果你不熟悉react，直接跳过本节课即可，不用学习\n * 本节课是选修内容，即便不学习本节课，也不影响你学习threejs后面的知识点。\n\n\n# 脚手架create-react-app\n\n脚手架create-react-app创建react项目。\n\nnpx create-react-app 项目名字\n\n\n创建一个名为reactthree的项目文件。\n\nnpx create-react-app reactthree\n\n\n\n# 启动项目\n\n进入reactthree项目目录，命令行输入npm run start,启动打开项目\n\nnpm run start\n\n\n你可以删除react默认页面对应的html和css代码，再写threejs代码。\n\n\n# npm安装threejs\n\n你可以选择你想安装的threejs版本。\n\n// 比如安装157版本\nnpm install three@0.157.0 -s\n\n\n\n# 知识点回顾\n\n回顾下前面1.6. 第一个3d案例知识点\n\n大家都知道three.js执行渲染命令.render();会输出一个canvas画布renderer.domelement，这个canvas画布本质上就是一个html元素，你可以插入到web页面任何一个元素中。\n\n// webgl渲染器\nconst renderer = new three.webglrenderer();\nrenderer.setsize(width, height); \nrenderer.render(scene, camera);\n//three.js执行渲染命令会输出一个canvas画布(html元素)\ndocument.body.appendchild(renderer.domelement);\n\n\n\n# react与threejs结合思路\n\nthreejs与react结合的时候，你只需要把canvas画布renderer.domelement插入到你的react页面上就行，可以放在web网页的任何位置，插入任何一个div或其它元素中，或者放到某个react组件中。\n\n你写的threejs代码结构，并不一定就要和我视频完全一致，你可以根据你自己项目情况，自由封装。\n\n\n# 新建indexthree.js文件\n\n新建indexthree.js文件,把threejs代码写在indexthree.js里面。\n\n引入three.jsimport * as three from 'three';。\n\n// indexthree.js文件\nimport * as three from 'three';\n\n\n你可以把前面第一个3d案例的代码复制到indexthree.js文件。\n\n// 三维场景\nconst scene = new three.scene();\n// 模型对象\nconst geometry = new three.boxgeometry(50, 50, 50);\nconst material = new three.meshbasicmaterial({\n    color: 0x0000ff, \n});\nconst mesh = new three.mesh(geometry, material); \nscene.add(mesh); \n// axeshelper：辅助观察的坐标系\nconst axeshelper = new three.axeshelper(250);\nscene.add(axeshelper);\nconst width = 800; //宽度\nconst height = 500; //高度\n// 相机\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\ncamera.position.set(292, 223, 185);\ncamera.lookat(0, 0, 0);\n// webgl渲染器\nconst renderer = new three.webglrenderer();\nrenderer.setsize(width, height); \nrenderer.render(scene, camera);\n//three.js执行渲染命令会输出一个canvas画布(html元素)，你可以插入到web页面中\ndocument.body.appendchild(renderer.domelement);\n\n\n然后把indexthree.js引入到index.js文件执行即可,这样threejs的代码会跟着index.js执行，当然你也可以在其的react文件，比如某个组件中调用threejs代码。\n\n// index.js文件\nimport react from 'react';\n...\n// 执行threejs代码\nimport './indexthree.js'\n...\nconst root = reactdom.createroot(document.getelementbyid('root'));\n...\n\n\n\n# 设置canvas画布全屏\n\n上面画布设置了固定宽高度，下面改成文档区域宽高度，也就是所谓canvas画布全屏\n\nconst width = window.innerwidth;\nconst height = window.innerheight;\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\nconst renderer = new three.webglrenderer();\nrenderer.setsize(width, height);\n\n\n// 可以放到react项目index.css文件中\nbody{\n    // 把canvas画布与body区域边距设置为0\n    margin: 0px;\n}\n\n\n\n# 引入扩展库orbitcontrols\n\n查看你npm安装文件node_modules，在目录three/examples/jsm下面有threejs的很多扩展库，一般你用到那个，单独引入即可，下面以orbitcontrols为例给大家展示。\n\norbitcontrols功能就是旋转缩放平移，在1.9小节有具体讲解：1.9. 相机控件orbitcontrols，如果还没学习，可以提前看下。\n\n// 引入路径\nimport { orbitcontrols } from 'three/examples/jsm/controls/orbitcontrols.js';\n\n\n复制1.9. 相机控件orbitcontrols里面关于相机控件的代码。\n\n// 设置相机控件轨道控制器orbitcontrols\nconst controls = new orbitcontrols(camera, renderer.domelement);\n// 如果orbitcontrols改变了相机参数，重新调用渲染器渲染三维场景\ncontrols.addeventlistener('change', function () {\n    renderer.render(scene, camera); //执行渲染操作\n});//监听鼠标、键盘事件\n",charsets:{cjk:!0}},{title:"1. 几何体顶点位置数据和点模型",frontmatter:{title:"1. 几何体顶点位置数据和点模型",date:"2023-01-20T11:02:49.000Z",permalink:"/pages/f84ca8/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/02.2.%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/01.%E5%87%A0%E4%BD%95%E4%BD%93%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%92%8C%E7%82%B9%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1Points.html",relativePath:"01.Three.js教程/02.2.几何体BufferGeometry/01.几何体顶点位置数据和点模型对象Points.md",key:"v-57a088ec",path:"/pages/f84ca8/",headers:[{level:3,title:"缓冲类型几何体BufferGeometry",slug:"缓冲类型几何体buffergeometry",normalizedTitle:"缓冲类型几何体buffergeometry",charIndex:100},{level:3,title:"BufferAttribute定义几何体顶点数据",slug:"bufferattribute定义几何体顶点数据",normalizedTitle:"bufferattribute定义几何体顶点数据",charIndex:328},{level:3,title:"设置几何体顶点.attributes.position",slug:"设置几何体顶点-attributes-position",normalizedTitle:"设置几何体顶点.attributes.position",charIndex:747},{level:3,title:"点模型Points",slug:"点模型points",normalizedTitle:"点模型points",charIndex:909}],headersStr:"缓冲类型几何体BufferGeometry BufferAttribute定义几何体顶点数据 设置几何体顶点.attributes.position 点模型Points",content:"# 几何体顶点位置数据和点模型对象Points\n\n本章节主要目的是给大家讲解几何体geometry的顶点概念,相对偏底层一些，不过掌握以后，你更容易深入理解Threejs的几何体和模型对象。\n\n\n# 缓冲类型几何体BufferGeometry\n\nthreejs的长方体BoxGeometry、球体SphereGeometry等几何体都是基于BufferGeometry类构建的，BufferGeometry是一个没有任何形状的空几何体，你可以通过BufferGeometry自定义任何几何形状，具体一点说就是定义顶点数据。\n\n//创建一个空的几何体对象\nconst geometry = new THREE.BufferGeometry(); \n\n\n\n# BufferAttribute定义几何体顶点数据\n\n通过javascript类型化数组Float32Array创建一组xyz坐标数据用来表示几何体的顶点坐标。\n\n//类型化数组创建顶点数据\nconst vertices = new Float32Array([\n    0, 0, 0, //顶点1坐标\n    50, 0, 0, //顶点2坐标\n    0, 100, 0, //顶点3坐标\n    0, 0, 10, //顶点4坐标\n    0, 0, 100, //顶点5坐标\n    50, 0, 10, //顶点6坐标\n]);\n\n\n通过threejs的属性缓冲区对象BufferAttribute表示threejs几何体顶点数据。\n\n// 创建属性缓冲区对象\n//3个为一组，表示一个顶点的xyz坐标\nconst attribue = new THREE.BufferAttribute(vertices, 3); \n\n\n\n# 设置几何体顶点.attributes.position\n\n通过geometry.attributes.position设置几何体顶点位置属性的值BufferAttribute。\n\n// 设置几何体attributes属性的位置属性\ngeometry.attributes.position = attribue;\n\n\n\n# 点模型Points\n\n点模型Points和网格模型Mesh一样，都是threejs的一种模型对象，只是大部分情况下都是用Mesh表示物体。\n\n网格模型Mesh有自己对应的网格材质，同样点模型Points有自己对应的点材质PointsMaterial\n\n// 点渲染模式\nconst material = new THREE.PointsMaterial({\n    color: 0xffff00,\n    size: 10.0 //点对象像素尺寸\n}); \n\n\n几何体geometry作为点模型Points参数，会把几何体渲染为点，把几何体作为Mesh的参数会把几何体渲染为面。\n\nconst points = new THREE.Points(geometry, material); //点模型对象\n",normalizedContent:"# 几何体顶点位置数据和点模型对象points\n\n本章节主要目的是给大家讲解几何体geometry的顶点概念,相对偏底层一些，不过掌握以后，你更容易深入理解threejs的几何体和模型对象。\n\n\n# 缓冲类型几何体buffergeometry\n\nthreejs的长方体boxgeometry、球体spheregeometry等几何体都是基于buffergeometry类构建的，buffergeometry是一个没有任何形状的空几何体，你可以通过buffergeometry自定义任何几何形状，具体一点说就是定义顶点数据。\n\n//创建一个空的几何体对象\nconst geometry = new three.buffergeometry(); \n\n\n\n# bufferattribute定义几何体顶点数据\n\n通过javascript类型化数组float32array创建一组xyz坐标数据用来表示几何体的顶点坐标。\n\n//类型化数组创建顶点数据\nconst vertices = new float32array([\n    0, 0, 0, //顶点1坐标\n    50, 0, 0, //顶点2坐标\n    0, 100, 0, //顶点3坐标\n    0, 0, 10, //顶点4坐标\n    0, 0, 100, //顶点5坐标\n    50, 0, 10, //顶点6坐标\n]);\n\n\n通过threejs的属性缓冲区对象bufferattribute表示threejs几何体顶点数据。\n\n// 创建属性缓冲区对象\n//3个为一组，表示一个顶点的xyz坐标\nconst attribue = new three.bufferattribute(vertices, 3); \n\n\n\n# 设置几何体顶点.attributes.position\n\n通过geometry.attributes.position设置几何体顶点位置属性的值bufferattribute。\n\n// 设置几何体attributes属性的位置属性\ngeometry.attributes.position = attribue;\n\n\n\n# 点模型points\n\n点模型points和网格模型mesh一样，都是threejs的一种模型对象，只是大部分情况下都是用mesh表示物体。\n\n网格模型mesh有自己对应的网格材质，同样点模型points有自己对应的点材质pointsmaterial\n\n// 点渲染模式\nconst material = new three.pointsmaterial({\n    color: 0xffff00,\n    size: 10.0 //点对象像素尺寸\n}); \n\n\n几何体geometry作为点模型points参数，会把几何体渲染为点，把几何体作为mesh的参数会把几何体渲染为面。\n\nconst points = new three.points(geometry, material); //点模型对象\n",charsets:{cjk:!0}},{title:"2. 线模型对象",frontmatter:{title:"2. 线模型对象",date:"2023-01-25T22:56:02.000Z",permalink:"/pages/ed3be5/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/02.2.%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/02.%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1.html",relativePath:"01.Three.js教程/02.2.几何体BufferGeometry/02.线模型对象.md",key:"v-683c0a08",path:"/pages/ed3be5/",headers:[{level:3,title:"线模型Line渲染顶点数据",slug:"线模型line渲染顶点数据",normalizedTitle:"线模型line渲染顶点数据",charIndex:2},{level:3,title:"线模型LineLoop、LineSegments",slug:"线模型lineloop、linesegments",normalizedTitle:"线模型lineloop、linesegments",charIndex:223}],headersStr:"线模型Line渲染顶点数据 线模型LineLoop、LineSegments",content:"# 线模型Line渲染顶点数据\n\n下面代码是把几何体作为线模型Line的参数，你会发现渲染效果是从第一个点开始到最后一个点，依次连成线。\n\n// 线材质对象\nconst material = new THREE.LineBasicMaterial({\n    color: 0xff0000 //线条颜色\n}); \n// 创建线模型对象\nconst line = new THREE.Line(geometry, material);\n\n\n\n# 线模型LineLoop、LineSegments\n\nthreejs线模型除了Line，还提供了LineLoop、LineSegments，区别在于绘制线条的规则不同。\n\n// 闭合线条\nconst line = new THREE.LineLoop(geometry, material); \n\n\n//非连续的线条\nconst line = new THREE.LineSegments(geometry, material);\n",normalizedContent:"# 线模型line渲染顶点数据\n\n下面代码是把几何体作为线模型line的参数，你会发现渲染效果是从第一个点开始到最后一个点，依次连成线。\n\n// 线材质对象\nconst material = new three.linebasicmaterial({\n    color: 0xff0000 //线条颜色\n}); \n// 创建线模型对象\nconst line = new three.line(geometry, material);\n\n\n\n# 线模型lineloop、linesegments\n\nthreejs线模型除了line，还提供了lineloop、linesegments，区别在于绘制线条的规则不同。\n\n// 闭合线条\nconst line = new three.lineloop(geometry, material); \n\n\n//非连续的线条\nconst line = new three.linesegments(geometry, material);\n",charsets:{cjk:!0}},{title:"3. 网格模型(三角形概念)",frontmatter:{title:"3. 网格模型(三角形概念)",date:"2023-01-25T22:57:08.000Z",permalink:"/pages/32785a/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/02.2.%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/03.%E7%BD%91%E6%A0%BC%E6%A8%A1%E5%9E%8B(%E4%B8%89%E8%A7%92%E5%BD%A2%E6%A6%82%E5%BF%B5).html",relativePath:"01.Three.js教程/02.2.几何体BufferGeometry/03.网格模型(三角形概念).md",key:"v-29e07cd8",path:"/pages/32785a/",headers:[{level:3,title:"三角形(面)",slug:"三角形-面",normalizedTitle:"三角形(面)",charIndex:75},{level:3,title:"网格模型三角形：正反面",slug:"网格模型三角形-正反面",normalizedTitle:"网格模型三角形：正反面",charIndex:208},{level:3,title:"双面可见",slug:"双面可见",normalizedTitle:"双面可见",charIndex:353}],headersStr:"三角形(面) 网格模型三角形：正反面 双面可见",content:"# 网格模型(三角形概念)\n\n本节课给大家演示网格模型Mesh渲染自定义几何体BufferGeometry的顶点坐标,通过这样一个例子帮助大家建立**三角形(面)**的概念\n\n\n# 三角形(面)\n\n网格模型Mesh其实就一个一个三角形(面)拼接构成。使用网格模型Mesh渲染几何体geometry，就是几何体所有顶点坐标三个为一组，构成一个三角形，多组顶点构成多个三角形，就可以用来模拟表示物体的表面。\n\n\n\n\n# 网格模型三角形：正反面\n\n * 正面：逆时针\n * 反面：顺时针\n\n空间中一个三角形有正反两面，那么Three.js的规则是如何区分正反面的？非常简单，你的眼睛(相机)对着三角形的一个面，如果三个顶点的顺序是逆时针方向，该面视为正面，如果三个顶点的顺序是顺时针方向，该面视为反面。\n\n\n# 双面可见\n\nThree.js的材质默认正面可见，反面不可见。\n\nconst material = new THREE.MeshBasicMaterial({\n    color: 0x0000ff, //材质颜色\n    side: THREE.FrontSide, //默认只有正面可见\n});\n\n\nconst material = new THREE.MeshBasicMaterial({\n    side: THREE.DoubleSide, //两面可见\n});\n\n\nconst material = new THREE.MeshBasicMaterial({\n    side: THREE.BackSide, //设置只有背面可见\n});\n",normalizedContent:"# 网格模型(三角形概念)\n\n本节课给大家演示网格模型mesh渲染自定义几何体buffergeometry的顶点坐标,通过这样一个例子帮助大家建立**三角形(面)**的概念\n\n\n# 三角形(面)\n\n网格模型mesh其实就一个一个三角形(面)拼接构成。使用网格模型mesh渲染几何体geometry，就是几何体所有顶点坐标三个为一组，构成一个三角形，多组顶点构成多个三角形，就可以用来模拟表示物体的表面。\n\n\n\n\n# 网格模型三角形：正反面\n\n * 正面：逆时针\n * 反面：顺时针\n\n空间中一个三角形有正反两面，那么three.js的规则是如何区分正反面的？非常简单，你的眼睛(相机)对着三角形的一个面，如果三个顶点的顺序是逆时针方向，该面视为正面，如果三个顶点的顺序是顺时针方向，该面视为反面。\n\n\n# 双面可见\n\nthree.js的材质默认正面可见，反面不可见。\n\nconst material = new three.meshbasicmaterial({\n    color: 0x0000ff, //材质颜色\n    side: three.frontside, //默认只有正面可见\n});\n\n\nconst material = new three.meshbasicmaterial({\n    side: three.doubleside, //两面可见\n});\n\n\nconst material = new three.meshbasicmaterial({\n    side: three.backside, //设置只有背面可见\n});\n",charsets:{cjk:!0}},{title:"4. 构建一个矩形平面几何体",frontmatter:{title:"4. 构建一个矩形平面几何体",date:"2023-01-25T22:59:14.000Z",permalink:"/pages/6722b2/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/02.2.%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/04.%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95%E4%BD%93.html",relativePath:"01.Three.js教程/02.2.几何体BufferGeometry/04.构建一个矩形平面几何体.md",key:"v-86a14178",path:"/pages/6722b2/",headers:[{level:3,title:"定义矩形几何体顶点坐标",slug:"定义矩形几何体顶点坐标",normalizedTitle:"定义矩形几何体顶点坐标",charIndex:74}],headersStr:"定义矩形几何体顶点坐标",content:"# 构建一个矩形平面几何体\n\n有了前面几节课，自定义几何体BufferGeometry的基础，你可以尝试自己去构建一个矩形平面几何体。\n\n\n\n\n# 定义矩形几何体顶点坐标\n\n一个矩形平面，可以至少通过两个三角形拼接而成。而且两个三角形有两个顶点的坐标是重合的。\n\n注意三角形的正反面问题：保证矩形平面两个三角形的正面是一样的，也就是从一个方向观察，两个三角形都是逆时针或顺时针。\n\n\n\nconst vertices = new Float32Array([\n    0, 0, 0, //顶点1坐标\n    80, 0, 0, //顶点2坐标\n    80, 80, 0, //顶点3坐标\n\n    0, 0, 0, //顶点4坐标   和顶点1位置相同\n    80, 80, 0, //顶点5坐标  和顶点3位置相同\n    0, 80, 0, //顶点6坐标\n]);\n",normalizedContent:"# 构建一个矩形平面几何体\n\n有了前面几节课，自定义几何体buffergeometry的基础，你可以尝试自己去构建一个矩形平面几何体。\n\n\n\n\n# 定义矩形几何体顶点坐标\n\n一个矩形平面，可以至少通过两个三角形拼接而成。而且两个三角形有两个顶点的坐标是重合的。\n\n注意三角形的正反面问题：保证矩形平面两个三角形的正面是一样的，也就是从一个方向观察，两个三角形都是逆时针或顺时针。\n\n\n\nconst vertices = new float32array([\n    0, 0, 0, //顶点1坐标\n    80, 0, 0, //顶点2坐标\n    80, 80, 0, //顶点3坐标\n\n    0, 0, 0, //顶点4坐标   和顶点1位置相同\n    80, 80, 0, //顶点5坐标  和顶点3位置相同\n    0, 80, 0, //顶点6坐标\n]);\n",charsets:{cjk:!0}},{title:"课程特点",frontmatter:{title:"课程特点",date:"2023-01-20T15:59:22.000Z",permalink:"/pages/a97995/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/0.0.%E5%AD%A6%E5%89%8D%E8%AF%B4%E6%98%8E/02.%E8%AF%BE%E7%A8%8B%E7%89%B9%E7%82%B9.html",relativePath:"01.Three.js教程/0.0.学前说明/02.课程特点.md",key:"v-3e8fbd2b",path:"/pages/a97995/",headers:[{level:3,title:"入门开发环境超简单",slug:"入门开发环境超简单",normalizedTitle:"入门开发环境超简单",charIndex:184}],headersStr:"入门开发环境超简单",content:"# 课程特点\n\n课程支持多种方式学习，视频 + 电子书 + 案例源码，适配更多人的需求。\n\n 1. 视频：不会闷着头敲代码，视频会重点解析思路。\n\n 2. 案例源码(注释)：与视频对应，直接打开预览，一方面辅助视频学习，另一方面方便你学完查看，甚至当做手册\n\n 3. 电子书：可以作为课件辅助视频学习，学习后，也适合随时翻阅复习或当做手册使用用。\n\n淘宝源码\n\n\n# 入门开发环境超简单\n\n没有麻烦的开发环境配置，最快开始，你平常用的任何代码编辑器，本地静态服务器方式打开.html文件直接开搞，且可以保持nodejs开发环境中的npm安装、import方式引入的模块化风格，同样也和threejs官方案例习惯保持一致。",normalizedContent:"# 课程特点\n\n课程支持多种方式学习，视频 + 电子书 + 案例源码，适配更多人的需求。\n\n 1. 视频：不会闷着头敲代码，视频会重点解析思路。\n\n 2. 案例源码(注释)：与视频对应，直接打开预览，一方面辅助视频学习，另一方面方便你学完查看，甚至当做手册\n\n 3. 电子书：可以作为课件辅助视频学习，学习后，也适合随时翻阅复习或当做手册使用用。\n\n淘宝源码\n\n\n# 入门开发环境超简单\n\n没有麻烦的开发环境配置，最快开始，你平常用的任何代码编辑器，本地静态服务器方式打开.html文件直接开搞，且可以保持nodejs开发环境中的npm安装、import方式引入的模块化风格，同样也和threejs官方案例习惯保持一致。",charsets:{cjk:!0}},{title:"5. 几何体顶点索引数据",frontmatter:{title:"5. 几何体顶点索引数据",date:"2023-01-25T23:00:38.000Z",permalink:"/pages/05b687/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/02.2.%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/05.%E5%87%A0%E4%BD%95%E4%BD%93%E9%A1%B6%E7%82%B9%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE.html",relativePath:"01.Three.js教程/02.2.几何体BufferGeometry/05.几何体顶点索引数据.md",key:"v-57fafbfe",path:"/pages/05b687/",headers:[{level:3,title:"定义顶点位置坐标数据",slug:"定义顶点位置坐标数据",normalizedTitle:"定义顶点位置坐标数据",charIndex:121},{level:3,title:"BufferAttribute定义顶点索引.index数据",slug:"bufferattribute定义顶点索引-index数据",normalizedTitle:"bufferattribute定义顶点索引.index数据",charIndex:550}],headersStr:"定义顶点位置坐标数据 BufferAttribute定义顶点索引.index数据",content:"# 几何体顶点索引数据\n\n网格模型Mesh对应的几何体BufferGeometry，拆分为多个三角后，很多三角形重合的顶点位置坐标是相同的，这时候如果你想减少顶点坐标数据量，可以借助几何体顶点索引geometry.index来实现。\n\n\n# 定义顶点位置坐标数据\n\n每个三角形3个顶点坐标，矩形平面可以拆分为两个三角形，也就是6个顶点坐标。\n\nconst vertices = new Float32Array([\n    0, 0, 0, //顶点1坐标\n    80, 0, 0, //顶点2坐标\n    80, 80, 0, //顶点3坐标\n    0, 0, 0, //顶点4坐标   和顶点1位置相同\n    80, 80, 0, //顶点5坐标  和顶点3位置相同\n    0, 80, 0, //顶点6坐标\n]);\n\n\n如果几何体有顶点索引geometry.index，那么你可以吧三角形重复的顶点位置坐标删除。\n\nconst vertices = new Float32Array([\n    0, 0, 0, //顶点1坐标\n    80, 0, 0, //顶点2坐标\n    80, 80, 0, //顶点3坐标\n    0, 80, 0, //顶点4坐标\n]);\n\n\n\n\n\n# BufferAttribute定义顶点索引.index数据\n\n通过javascript类型化数组Uint16Array创建顶点索引.index数据。\n\n// Uint16Array类型数组创建顶点索引数据\nconst indexes = new Uint16Array([\n    // 下面索引值对应顶点位置数据中的顶点坐标\n    0, 1, 2, 0, 2, 3,\n])\n\n\n通过threejs的属性缓冲区对象BufferAttribute表示几何体顶点索引.index数据。\n\n// 索引数据赋值给几何体的index属性\ngeometry.index = new THREE.BufferAttribute(indexes, 1); //1个为一组\n",normalizedContent:"# 几何体顶点索引数据\n\n网格模型mesh对应的几何体buffergeometry，拆分为多个三角后，很多三角形重合的顶点位置坐标是相同的，这时候如果你想减少顶点坐标数据量，可以借助几何体顶点索引geometry.index来实现。\n\n\n# 定义顶点位置坐标数据\n\n每个三角形3个顶点坐标，矩形平面可以拆分为两个三角形，也就是6个顶点坐标。\n\nconst vertices = new float32array([\n    0, 0, 0, //顶点1坐标\n    80, 0, 0, //顶点2坐标\n    80, 80, 0, //顶点3坐标\n    0, 0, 0, //顶点4坐标   和顶点1位置相同\n    80, 80, 0, //顶点5坐标  和顶点3位置相同\n    0, 80, 0, //顶点6坐标\n]);\n\n\n如果几何体有顶点索引geometry.index，那么你可以吧三角形重复的顶点位置坐标删除。\n\nconst vertices = new float32array([\n    0, 0, 0, //顶点1坐标\n    80, 0, 0, //顶点2坐标\n    80, 80, 0, //顶点3坐标\n    0, 80, 0, //顶点4坐标\n]);\n\n\n\n\n\n# bufferattribute定义顶点索引.index数据\n\n通过javascript类型化数组uint16array创建顶点索引.index数据。\n\n// uint16array类型数组创建顶点索引数据\nconst indexes = new uint16array([\n    // 下面索引值对应顶点位置数据中的顶点坐标\n    0, 1, 2, 0, 2, 3,\n])\n\n\n通过threejs的属性缓冲区对象bufferattribute表示几何体顶点索引.index数据。\n\n// 索引数据赋值给几何体的index属性\ngeometry.index = new three.bufferattribute(indexes, 1); //1个为一组\n",charsets:{cjk:!0}},{title:"6. 顶点法线数据",frontmatter:{title:"6. 顶点法线数据",date:"2023-01-25T23:02:23.000Z",permalink:"/pages/ff37d3/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/02.2.%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/06.%E9%A1%B6%E7%82%B9%E6%B3%95%E7%BA%BF%E6%95%B0%E6%8D%AE.html",relativePath:"01.Three.js教程/02.2.几何体BufferGeometry/06.顶点法线数据.md",key:"v-202ce318",path:"/pages/ff37d3/",headers:[{level:3,title:"测试：Basic材质改为Lambert材质",slug:"测试-basic材质改为lambert材质",normalizedTitle:"测试：basic材质改为lambert材质",charIndex:118},{level:3,title:"数学上法线概念",slug:"数学上法线概念",normalizedTitle:"数学上法线概念",charIndex:447},{level:3,title:"Three.js顶点法线",slug:"three-js顶点法线",normalizedTitle:"three.js顶点法线",charIndex:518},{level:3,title:"矩形平面几何体法线案例——无顶点索引",slug:"矩形平面几何体法线案例-无顶点索引",normalizedTitle:"矩形平面几何体法线案例——无顶点索引",charIndex:612},{level:3,title:"矩形平面几何体法线案例——有顶点索引",slug:"矩形平面几何体法线案例-有顶点索引",normalizedTitle:"矩形平面几何体法线案例——有顶点索引",charIndex:1015}],headersStr:"测试：Basic材质改为Lambert材质 数学上法线概念 Three.js顶点法线 矩形平面几何体法线案例——无顶点索引 矩形平面几何体法线案例——有顶点索引",content:"# 顶点法线数据\n\n前面给大家讲解过几何体顶点位置数据geometry.attributes.position，本节课给大家介绍一种新的顶点数据，就是顶点法线(法向量)数据geometry.attributes.normal。\n\n\n# 测试：Basic材质改为Lambert材质\n\n你可以测试下，把前面两节课的案例源码中MeshBasicMaterial材质改为MeshLambertMaterial材质，你会发现原来的矩形平面无法正常渲染，这其实很简单，使用受光照影响的材质，几何体BufferGeometry需要定义顶点法线数据。\n\n// MeshBasicMaterial不受光照影响\n// 使用受光照影响的材质，几何体Geometry需要定义顶点法线数据\nconst material = new THREE.MeshLambertMaterial({\n    color: 0x0000ff, \n    side: THREE.DoubleSide, //两面可见\n});\n\n\n\n# 数学上法线概念\n\n先来理解一下数学上的法线概念，比如一个平面，法线的就是改平面的垂线，如果是光滑曲面，一点的法线就是该点切面的法线。\n\n\n# Three.js顶点法线\n\nThree.js中法线和数学中法线概念相似，只是定义的时候更灵活，会根据需要进行调整，作为初学者，只要先有顶点法线的概念就行，下面会举一个简单小例子。\n\n\n# 矩形平面几何体法线案例——无顶点索引\n\nThree.js中法线是通过顶点定义，默认情况下，每个顶点都有一个法线数据，就像每一个顶点都有一个位置数据。\n\n// 矩形平面，无索引，两个三角形，6个顶点\n// 每个顶点的法线数据和顶点位置数据一一对应\nconst normals = new Float32Array([\n    0, 0, 1, //顶点1法线( 法向量 )\n    0, 0, 1, //顶点2法线\n    0, 0, 1, //顶点3法线\n    0, 0, 1, //顶点4法线\n    0, 0, 1, //顶点5法线\n    0, 0, 1, //顶点6法线\n]);\n// 设置几何体的顶点法线属性.attributes.normal\ngeometry.attributes.normal = new THREE.BufferAttribute(normals, 3); \n\n\n\n# 矩形平面几何体法线案例——有顶点索引\n\n// 矩形平面，有索引，两个三角形，有2个顶点重合，有4个顶点\n// 每个顶点的法线数据和顶点位置数据一一对应\nconst normals = new Float32Array([\n    0, 0, 1, //顶点1法线( 法向量 )\n    0, 0, 1, //顶点2法线\n    0, 0, 1, //顶点3法线\n    0, 0, 1, //顶点4法线\n]);\n// 设置几何体的顶点法线属性.attributes.normal\ngeometry.attributes.normal = new THREE.BufferAttribute(normals, 3);\n",normalizedContent:"# 顶点法线数据\n\n前面给大家讲解过几何体顶点位置数据geometry.attributes.position，本节课给大家介绍一种新的顶点数据，就是顶点法线(法向量)数据geometry.attributes.normal。\n\n\n# 测试：basic材质改为lambert材质\n\n你可以测试下，把前面两节课的案例源码中meshbasicmaterial材质改为meshlambertmaterial材质，你会发现原来的矩形平面无法正常渲染，这其实很简单，使用受光照影响的材质，几何体buffergeometry需要定义顶点法线数据。\n\n// meshbasicmaterial不受光照影响\n// 使用受光照影响的材质，几何体geometry需要定义顶点法线数据\nconst material = new three.meshlambertmaterial({\n    color: 0x0000ff, \n    side: three.doubleside, //两面可见\n});\n\n\n\n# 数学上法线概念\n\n先来理解一下数学上的法线概念，比如一个平面，法线的就是改平面的垂线，如果是光滑曲面，一点的法线就是该点切面的法线。\n\n\n# three.js顶点法线\n\nthree.js中法线和数学中法线概念相似，只是定义的时候更灵活，会根据需要进行调整，作为初学者，只要先有顶点法线的概念就行，下面会举一个简单小例子。\n\n\n# 矩形平面几何体法线案例——无顶点索引\n\nthree.js中法线是通过顶点定义，默认情况下，每个顶点都有一个法线数据，就像每一个顶点都有一个位置数据。\n\n// 矩形平面，无索引，两个三角形，6个顶点\n// 每个顶点的法线数据和顶点位置数据一一对应\nconst normals = new float32array([\n    0, 0, 1, //顶点1法线( 法向量 )\n    0, 0, 1, //顶点2法线\n    0, 0, 1, //顶点3法线\n    0, 0, 1, //顶点4法线\n    0, 0, 1, //顶点5法线\n    0, 0, 1, //顶点6法线\n]);\n// 设置几何体的顶点法线属性.attributes.normal\ngeometry.attributes.normal = new three.bufferattribute(normals, 3); \n\n\n\n# 矩形平面几何体法线案例——有顶点索引\n\n// 矩形平面，有索引，两个三角形，有2个顶点重合，有4个顶点\n// 每个顶点的法线数据和顶点位置数据一一对应\nconst normals = new float32array([\n    0, 0, 1, //顶点1法线( 法向量 )\n    0, 0, 1, //顶点2法线\n    0, 0, 1, //顶点3法线\n    0, 0, 1, //顶点4法线\n]);\n// 设置几何体的顶点法线属性.attributes.normal\ngeometry.attributes.normal = new three.bufferattribute(normals, 3);\n",charsets:{cjk:!0}},{title:"7. 查看threejs自带几何体顶点",frontmatter:{title:"7. 查看threejs自带几何体顶点",date:"2023-01-25T23:02:52.000Z",permalink:"/pages/d8b07b/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/02.2.%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/07.%E6%9F%A5%E7%9C%8Bthree.js%E8%87%AA%E5%B8%A6%E5%87%A0%E4%BD%95%E4%BD%93%E9%A1%B6%E7%82%B9%E7%BB%93%E6%9E%84.html",relativePath:"01.Three.js教程/02.2.几何体BufferGeometry/07.查看three.js自带几何体顶点结构.md",key:"v-10922bc2",path:"/pages/d8b07b/",headers:[{level:3,title:"查看three.js自带几何体顶点结构，基类(父类)BufferGeometry",slug:"查看three-js自带几何体顶点结构-基类-父类-buffergeometry",normalizedTitle:"查看three.js自带几何体顶点结构，基类(父类)buffergeometry",charIndex:2},{level:3,title:"查看几何体顶点位置和索引数据",slug:"查看几何体顶点位置和索引数据",normalizedTitle:"查看几何体顶点位置和索引数据",charIndex:192},{level:3,title:"材质属性.wireframe",slug:"材质属性-wireframe",normalizedTitle:"材质属性.wireframe",charIndex:531},{level:3,title:"几何体细分数",slug:"几何体细分数",normalizedTitle:"几何体细分数",charIndex:686},{level:3,title:"球体SphereGeometry细分数",slug:"球体spheregeometry细分数",normalizedTitle:"球体spheregeometry细分数",charIndex:1046},{level:3,title:"三角形数量与性能",slug:"三角形数量与性能",normalizedTitle:"三角形数量与性能",charIndex:1271}],headersStr:"查看three.js自带几何体顶点结构，基类(父类)BufferGeometry 查看几何体顶点位置和索引数据 材质属性.wireframe 几何体细分数 球体SphereGeometry细分数 三角形数量与性能",content:"# 查看three.js自带几何体顶点结构，基类(父类)BufferGeometry\n\nthree.js提供的矩形平面PlaneGeometry、长方体BoxGeometry、球体SphereGeometry等各种形状的几何体，他们都有一个共同的父类BufferGeometry。这意味着这些几何体有哪些属性或方法，你可以查询文档关于BufferGeometry的介绍。\n\n\n\n\n# 查看几何体顶点位置和索引数据\n\n可以用顶点索引index数据构建几何体，也可以不用，threejs默认的大部分几何体都有三角形的顶点索引数据，具体可以通过浏览器控制台打印几何体数据查看。\n\nconst geometry = new THREE.PlaneGeometry(100,50); //矩形平面几何体\n// const geometry = new THREE.BoxGeometry(50,50,50); //长方体\n\nconsole.log('几何体',geometry);\nconsole.log('顶点位置数据',geometry.attributes.position);\nconsole.log('顶点索引数据',geometry.index);\n\n\n\n# 材质属性.wireframe\n\n线条模式渲染，查看几何体三角形结构\n\nconst material = new THREE.MeshLambertMaterial({\n    color: 0x00ffff, \n    wireframe:true,//线条模式渲染mesh对应的三角形数据\n});\n\n\n\n# 几何体细分数\n\nThree.js很多几何体都提供了细分数相关的参数，这里以矩形平面几何体PlaneGeometry为例介绍。\n\n矩形平面几何体至少需要两个三角形拼接而成。\n\n //矩形几何体PlaneGeometry的参数3,4表示细分数，默认是1,1\nconst geometry = new THREE.PlaneGeometry(100,50,1,1);\n\n\n把一个矩形分为2份，每个矩形2个三角形，总共就是4个三角形\n\nconst geometry = new THREE.PlaneGeometry(100,50,2,1);\n\n\n把一个矩形分为4份，每个矩形2个三角形，总共就是8个三角形\n\nconst geometry = new THREE.PlaneGeometry(100,50,2,2);\n\n\n\n# 球体SphereGeometry细分数\n\n球体SphereGeometry参数2、3分别代表宽、高度两个方向上的细分数，默认32,16，具体多少以你所用版本为准。\n\nconst geometry = new THREE.SphereGeometry( 50, 32, 16 );\n\n\n如果球体细分数比较低，表面就不会那么光滑。\n\nconst geometry = new THREE.SphereGeometry( 15, 8, 8 );\n\n\n\n# 三角形数量与性能\n\n对于一个曲面而言，细分数越大，表面越光滑，但是三角形和顶点数量却越多。\n\n几何体三角形数量或者说顶点数量直接影响Three.js的渲染性能，在不影响渲染效果的情况下，一般尽量越少越好。",normalizedContent:"# 查看three.js自带几何体顶点结构，基类(父类)buffergeometry\n\nthree.js提供的矩形平面planegeometry、长方体boxgeometry、球体spheregeometry等各种形状的几何体，他们都有一个共同的父类buffergeometry。这意味着这些几何体有哪些属性或方法，你可以查询文档关于buffergeometry的介绍。\n\n\n\n\n# 查看几何体顶点位置和索引数据\n\n可以用顶点索引index数据构建几何体，也可以不用，threejs默认的大部分几何体都有三角形的顶点索引数据，具体可以通过浏览器控制台打印几何体数据查看。\n\nconst geometry = new three.planegeometry(100,50); //矩形平面几何体\n// const geometry = new three.boxgeometry(50,50,50); //长方体\n\nconsole.log('几何体',geometry);\nconsole.log('顶点位置数据',geometry.attributes.position);\nconsole.log('顶点索引数据',geometry.index);\n\n\n\n# 材质属性.wireframe\n\n线条模式渲染，查看几何体三角形结构\n\nconst material = new three.meshlambertmaterial({\n    color: 0x00ffff, \n    wireframe:true,//线条模式渲染mesh对应的三角形数据\n});\n\n\n\n# 几何体细分数\n\nthree.js很多几何体都提供了细分数相关的参数，这里以矩形平面几何体planegeometry为例介绍。\n\n矩形平面几何体至少需要两个三角形拼接而成。\n\n //矩形几何体planegeometry的参数3,4表示细分数，默认是1,1\nconst geometry = new three.planegeometry(100,50,1,1);\n\n\n把一个矩形分为2份，每个矩形2个三角形，总共就是4个三角形\n\nconst geometry = new three.planegeometry(100,50,2,1);\n\n\n把一个矩形分为4份，每个矩形2个三角形，总共就是8个三角形\n\nconst geometry = new three.planegeometry(100,50,2,2);\n\n\n\n# 球体spheregeometry细分数\n\n球体spheregeometry参数2、3分别代表宽、高度两个方向上的细分数，默认32,16，具体多少以你所用版本为准。\n\nconst geometry = new three.spheregeometry( 50, 32, 16 );\n\n\n如果球体细分数比较低，表面就不会那么光滑。\n\nconst geometry = new three.spheregeometry( 15, 8, 8 );\n\n\n\n# 三角形数量与性能\n\n对于一个曲面而言，细分数越大，表面越光滑，但是三角形和顶点数量却越多。\n\n几何体三角形数量或者说顶点数量直接影响three.js的渲染性能，在不影响渲染效果的情况下，一般尽量越少越好。",charsets:{cjk:!0}},{title:"1. 三维向量Vector3与模型位置",frontmatter:{title:"1. 三维向量Vector3与模型位置",date:"2023-01-20T18:59:03.000Z",permalink:"/pages/440e51/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/03.3.%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9D%90%E8%B4%A8/01.%E4%B8%89%E7%BB%B4%E5%90%91%E9%87%8FVector3%E4%B8%8E%E6%A8%A1%E5%9E%8B%E4%BD%8D%E7%BD%AE%E3%80%81%E7%BC%A9%E6%94%BE%E5%B1%9E%E6%80%A7.html",relativePath:"01.Three.js教程/03.3.模型对象、材质/01.三维向量Vector3与模型位置、缩放属性.md",key:"v-721d6ab3",path:"/pages/440e51/",headers:[{level:3,title:"三维向量Vector3",slug:"三维向量vector3",normalizedTitle:"三维向量vector3",charIndex:2},{level:3,title:"位置属性.position",slug:"位置属性-position",normalizedTitle:"位置属性.position",charIndex:460},{level:3,title:"改变位置属性",slug:"改变位置属性",normalizedTitle:"改变位置属性",charIndex:602},{level:3,title:"平移",slug:"平移",normalizedTitle:"平移",charIndex:88},{level:3,title:"缩放",slug:"缩放",normalizedTitle:"缩放",charIndex:19}],headersStr:"三维向量Vector3 位置属性.position 改变位置属性 平移 缩放",content:"# 三维向量Vector3与模型位置、缩放属性\n\n点模型Points、线模型Line、网格网格模型Mesh等模型对象的父类都是Object3D，如果想对这些模型进行旋转、缩放、平移等操作，如何实现，可以查询Threejs文档Object3D对相关属性和方法的介绍。\n\n\n\n\n# 三维向量Vector3\n\n三维向量Vector3有xyz三个分量，threejs中会用三维向量Vector3表示很多种数据，本节课提到的比较简单，就是位置.position和缩放.scale属性。\n\n查看three.js文档你可以知道Vector3对象具有属性.x、.y、.z，Vector3对象还具有.set()等方法。\n\n//new THREE.Vector3()实例化一个三维向量对象\nconst v3 = new THREE.Vector3(0,0,0);\nconsole.log('v3', v3);\nv3.set(10,0,0);//set方法设置向量的值\nv3.x = 100;//访问x、y或z属性改变某个分量的值\n\n\n\n# 位置属性.position\n\n// 位置属性.position使用threejs三维向量对象Vector3表示的\nconsole.log('模型位置属性.position的值', mesh.position);\n\n\n模型位置.position属性用一个三维向量表示，那意味着，以后你想改变位置属性，就应该查询文档Vector3。\n\n这里之所以强调这一点，课程目的不单单是给你介绍具体的知识点，也是在引导你学会查文档，降低记忆压力。\n\n\n# 改变位置属性\n\n通过模型位置属性.position可以设置模型在场景Scene中的位置。模型位置.position的默认值是THREE.Vector3(0.0,0.0,0.0)，表示坐标原点。\n\n设置网格模型y坐标\n\nmesh.position.y = 80;\n\n\n设置模型xyz坐标\n\nmesh.position.set(80,2,10);\n\n\n\n# 平移\n\n执行.translateX()、.translateY()等方法本质上改变的都是模型的位置属性.position。\n\n网格模型沿着x轴正方向平移100，可以多次执行该语句，每次执行都是相对上一次的位置进行平移变换。\n\n// 等价于mesh.position = mesh.position + 100;\nmesh.translateX(100);//沿着x轴正方向平移距离100\n\n\n沿着Z轴负方向平移距离50。\n\nmesh.translateZ(-50);\n\n\n沿着自定义的方向移动。\n\n//向量Vector3对象表示方向\nconst axis = new THREE.Vector3(1, 1, 1);\naxis.normalize(); //向量归一化\n//沿着axis轴表示方向平移100\nmesh.translateOnAxis(axis, 100);\n\n\n\n# 缩放\n\n属性.scale表示模型对象的xyz三个方向上的缩放比例，.scale的属性值是一个三维向量对象Vector3,默认值是THREE.Vector3(1.0,1.0,1.0)。\n\nx轴方向放大2倍\n\nmesh.scale.x = 2.0;\n\n\n网格模型xyz方向分别缩放0.5,1.5,2倍\n\nmesh.scale.set(0.5, 1.5, 2)\n",normalizedContent:"# 三维向量vector3与模型位置、缩放属性\n\n点模型points、线模型line、网格网格模型mesh等模型对象的父类都是object3d，如果想对这些模型进行旋转、缩放、平移等操作，如何实现，可以查询threejs文档object3d对相关属性和方法的介绍。\n\n\n\n\n# 三维向量vector3\n\n三维向量vector3有xyz三个分量，threejs中会用三维向量vector3表示很多种数据，本节课提到的比较简单，就是位置.position和缩放.scale属性。\n\n查看three.js文档你可以知道vector3对象具有属性.x、.y、.z，vector3对象还具有.set()等方法。\n\n//new three.vector3()实例化一个三维向量对象\nconst v3 = new three.vector3(0,0,0);\nconsole.log('v3', v3);\nv3.set(10,0,0);//set方法设置向量的值\nv3.x = 100;//访问x、y或z属性改变某个分量的值\n\n\n\n# 位置属性.position\n\n// 位置属性.position使用threejs三维向量对象vector3表示的\nconsole.log('模型位置属性.position的值', mesh.position);\n\n\n模型位置.position属性用一个三维向量表示，那意味着，以后你想改变位置属性，就应该查询文档vector3。\n\n这里之所以强调这一点，课程目的不单单是给你介绍具体的知识点，也是在引导你学会查文档，降低记忆压力。\n\n\n# 改变位置属性\n\n通过模型位置属性.position可以设置模型在场景scene中的位置。模型位置.position的默认值是three.vector3(0.0,0.0,0.0)，表示坐标原点。\n\n设置网格模型y坐标\n\nmesh.position.y = 80;\n\n\n设置模型xyz坐标\n\nmesh.position.set(80,2,10);\n\n\n\n# 平移\n\n执行.translatex()、.translatey()等方法本质上改变的都是模型的位置属性.position。\n\n网格模型沿着x轴正方向平移100，可以多次执行该语句，每次执行都是相对上一次的位置进行平移变换。\n\n// 等价于mesh.position = mesh.position + 100;\nmesh.translatex(100);//沿着x轴正方向平移距离100\n\n\n沿着z轴负方向平移距离50。\n\nmesh.translatez(-50);\n\n\n沿着自定义的方向移动。\n\n//向量vector3对象表示方向\nconst axis = new three.vector3(1, 1, 1);\naxis.normalize(); //向量归一化\n//沿着axis轴表示方向平移100\nmesh.translateonaxis(axis, 100);\n\n\n\n# 缩放\n\n属性.scale表示模型对象的xyz三个方向上的缩放比例，.scale的属性值是一个三维向量对象vector3,默认值是three.vector3(1.0,1.0,1.0)。\n\nx轴方向放大2倍\n\nmesh.scale.x = 2.0;\n\n\n网格模型xyz方向分别缩放0.5,1.5,2倍\n\nmesh.scale.set(0.5, 1.5, 2)\n",charsets:{cjk:!0}},{title:"2. 欧拉Euler与角度属性.rotation",frontmatter:{title:"2. 欧拉Euler与角度属性.rotation",date:"2023-01-25T23:07:36.000Z",permalink:"/pages/cb4e2f/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/03.3.%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9D%90%E8%B4%A8/02.%E6%AC%A7%E6%8B%89Euler%E4%B8%8E%E8%A7%92%E5%BA%A6%E5%B1%9E%E6%80%A7.rotation.html",relativePath:"01.Three.js教程/03.3.模型对象、材质/02.欧拉Euler与角度属性.rotation.md",key:"v-bd1646ee",path:"/pages/cb4e2f/",headers:[{level:3,title:"欧拉对象Euler",slug:"欧拉对象euler",normalizedTitle:"欧拉对象euler",charIndex:86},{level:3,title:"改变角度属性.rotation",slug:"改变角度属性-rotation",normalizedTitle:"改变角度属性.rotation",charIndex:407},{level:3,title:"旋转方法.rotateX()、.rotateY()、.rotateZ()",slug:"旋转方法-rotatex-、-rotatey-、-rotatez",normalizedTitle:"旋转方法.rotatex()、.rotatey()、.rotatez()",charIndex:627},{level:3,title:"旋转动画",slug:"旋转动画",normalizedTitle:"旋转动画",charIndex:859},{level:3,title:"绕某个轴旋转",slug:"绕某个轴旋转",normalizedTitle:"绕某个轴旋转",charIndex:1012}],headersStr:"欧拉对象Euler 改变角度属性.rotation 旋转方法.rotateX()、.rotateY()、.rotateZ() 旋转动画 绕某个轴旋转",content:"# 角度属性.rotation\n\n\n\n模型的角度属性.rotation和四元数属性.quaternion都是表示模型的角度状态，只是表示方法不同，.rotation属性值是欧拉对象Euler,.quaternion属性值是是四元数对象Quaternion\n\n大家刚入门，就先给大家介绍比较容易理解的角度属性.rotation和对应属性值欧拉对象Euler。\n\n\n# 欧拉对象Euler\n\n// 创建一个欧拉对象，表示绕着xyz轴分别旋转45度，0度，90度\nconst Euler = new THREE.Euler( Math.PI/4,0, Math.PI/2);\n\n\n通过属性设置欧拉对象的三个分量值。\n\nconst Euler = new THREE.Euler();\nEuler.x = Math.PI/4;\nEuler.y = Math.PI/2;\nEuler.z = Math.PI/4;\n\n\n\n# 改变角度属性.rotation\n\n角度属性.rotation的值是欧拉对象Euler，意味着你想改变属性.rotation,可以查询文档关于Euler类的介绍。\n\n//绕y轴的角度设置为60度\nmesh.rotation.y += Math.PI/3;\n//绕y轴的角度增加60度\nmesh.rotation.y += Math.PI/3;\n//绕y轴的角度减去60度\nmesh.rotation.y -= Math.PI/3;\n\n\n\n# 旋转方法.rotateX()、.rotateY()、.rotateZ()\n\n模型执行.rotateX()、.rotateY()等旋转方法，你会发现改变了模型的角度属性.rotation。\n\nmesh.rotateX(Math.PI/4);//绕x轴旋转π/4\n\n\n// 绕着Y轴旋转90度\nmesh.rotateY(Math.PI / 2);\n//控制台查看：旋转方法，改变了rotation属性\nconsole.log(mesh.rotation);\n\n\n\n# 旋转动画\n\n// 渲染循环\nfunction render() {\n    model.rotation.y+=0.01;\n    requestAnimationFrame(render);\n}\n\n\nfunction render() {\n    model.rotateY(0.01);\n}\n\n\n\n# 绕某个轴旋转\n\n网格模型绕(0,1,0)向量表示的轴旋转π/8。\n\nconst axis = new THREE.Vector3(0,1,0);//向量axis\nmesh.rotateOnAxis(axis,Math.PI/8);//绕axis轴旋转π/8\n",normalizedContent:"# 角度属性.rotation\n\n\n\n模型的角度属性.rotation和四元数属性.quaternion都是表示模型的角度状态，只是表示方法不同，.rotation属性值是欧拉对象euler,.quaternion属性值是是四元数对象quaternion\n\n大家刚入门，就先给大家介绍比较容易理解的角度属性.rotation和对应属性值欧拉对象euler。\n\n\n# 欧拉对象euler\n\n// 创建一个欧拉对象，表示绕着xyz轴分别旋转45度，0度，90度\nconst euler = new three.euler( math.pi/4,0, math.pi/2);\n\n\n通过属性设置欧拉对象的三个分量值。\n\nconst euler = new three.euler();\neuler.x = math.pi/4;\neuler.y = math.pi/2;\neuler.z = math.pi/4;\n\n\n\n# 改变角度属性.rotation\n\n角度属性.rotation的值是欧拉对象euler，意味着你想改变属性.rotation,可以查询文档关于euler类的介绍。\n\n//绕y轴的角度设置为60度\nmesh.rotation.y += math.pi/3;\n//绕y轴的角度增加60度\nmesh.rotation.y += math.pi/3;\n//绕y轴的角度减去60度\nmesh.rotation.y -= math.pi/3;\n\n\n\n# 旋转方法.rotatex()、.rotatey()、.rotatez()\n\n模型执行.rotatex()、.rotatey()等旋转方法，你会发现改变了模型的角度属性.rotation。\n\nmesh.rotatex(math.pi/4);//绕x轴旋转π/4\n\n\n// 绕着y轴旋转90度\nmesh.rotatey(math.pi / 2);\n//控制台查看：旋转方法，改变了rotation属性\nconsole.log(mesh.rotation);\n\n\n\n# 旋转动画\n\n// 渲染循环\nfunction render() {\n    model.rotation.y+=0.01;\n    requestanimationframe(render);\n}\n\n\nfunction render() {\n    model.rotatey(0.01);\n}\n\n\n\n# 绕某个轴旋转\n\n网格模型绕(0,1,0)向量表示的轴旋转π/8。\n\nconst axis = new three.vector3(0,1,0);//向量axis\nmesh.rotateonaxis(axis,math.pi/8);//绕axis轴旋转π/8\n",charsets:{cjk:!0}},{title:"8. 旋转、缩放、平移几何体",frontmatter:{title:"8. 旋转、缩放、平移几何体",date:"2023-01-25T23:03:25.000Z",permalink:"/pages/1b0d6c/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/02.2.%E5%87%A0%E4%BD%95%E4%BD%93BufferGeometry/08.BufferGeometry%E7%9A%84%E6%97%8B%E8%BD%AC%E3%80%81%E7%BC%A9%E6%94%BE%E3%80%81%E5%B9%B3%E7%A7%BB%E6%96%B9%E6%B3%95.html",relativePath:"01.Three.js教程/02.2.几何体BufferGeometry/08.BufferGeometry的旋转、缩放、平移方法.md",key:"v-17c7c929",path:"/pages/1b0d6c/",headers:[{level:3,title:"缩放.scale()",slug:"缩放-scale",normalizedTitle:"缩放.scale()",charIndex:404},{level:3,title:"平移.translate()",slug:"平移-translate",normalizedTitle:"平移.translate()",charIndex:595},{level:3,title:"旋转.rotateX()、.rotateY()、.rotateZ()",slug:"旋转-rotatex-、-rotatey-、-rotatez",normalizedTitle:"旋转.rotatex()、.rotatey()、.rotatez()",charIndex:662},{level:3,title:"居中.center()",slug:"居中-center",normalizedTitle:"居中.center()",charIndex:752}],headersStr:"缩放.scale() 平移.translate() 旋转.rotateX()、.rotateY()、.rotateZ() 居中.center()",content:"# BufferGeometry的旋转、缩放、平移方法\n\nBufferGeometry通过.scale()、.translate()、.rotateX()、.rotateY()等方法可以对几何体本身进行缩放、平移、旋转,这些方法本质上都是改变几何体的顶点数据。\n\n\n\n// 几何体xyz三个方向都放大2倍\ngeometry.scale(2, 2, 2);\n// 几何体沿着x轴平移50\ngeometry.translate(50, 0, 0);\n// 几何体绕着x轴旋转45度\ngeometry.rotateX(Math.PI / 4);\n// 几何体旋转、缩放或平移之后，查看几何体顶点位置坐标的变化\n// BufferGeometry的旋转、缩放、平移等方法本质上就是改变顶点的位置坐标\nconsole.log('顶点位置数据', geometry.attributes.position);\n\n\n\n# 缩放.scale()\n\n// 几何体xyz三个方向都放大2倍\ngeometry.scale(2, 2, 2);\n\n// 几何体旋转、缩放或平移之后，查看几何体顶点位置坐标的变化\n// BufferGeometry的旋转、缩放、平移等方法本质上就是改变顶点的位置坐标\nconsole.log('顶点位置数据', geometry.attributes.position);\n\n\n\n# 平移.translate()\n\n// 几何体沿着x轴平移50\ngeometry.translate(50, 0, 0);\n\n\n\n\n# 旋转.rotateX()、.rotateY()、.rotateZ()\n\n// 几何体绕着x轴旋转45度\ngeometry.rotateX(Math.PI / 4);\n\n\n\n\n\n# 居中.center()\n\ngeometry.translate(50, 0, 0);//偏移\n// 居中：已经偏移的几何体居中，执行.center()，你可以看到几何体重新与坐标原点重合\ngeometry.center();\n",normalizedContent:"# buffergeometry的旋转、缩放、平移方法\n\nbuffergeometry通过.scale()、.translate()、.rotatex()、.rotatey()等方法可以对几何体本身进行缩放、平移、旋转,这些方法本质上都是改变几何体的顶点数据。\n\n\n\n// 几何体xyz三个方向都放大2倍\ngeometry.scale(2, 2, 2);\n// 几何体沿着x轴平移50\ngeometry.translate(50, 0, 0);\n// 几何体绕着x轴旋转45度\ngeometry.rotatex(math.pi / 4);\n// 几何体旋转、缩放或平移之后，查看几何体顶点位置坐标的变化\n// buffergeometry的旋转、缩放、平移等方法本质上就是改变顶点的位置坐标\nconsole.log('顶点位置数据', geometry.attributes.position);\n\n\n\n# 缩放.scale()\n\n// 几何体xyz三个方向都放大2倍\ngeometry.scale(2, 2, 2);\n\n// 几何体旋转、缩放或平移之后，查看几何体顶点位置坐标的变化\n// buffergeometry的旋转、缩放、平移等方法本质上就是改变顶点的位置坐标\nconsole.log('顶点位置数据', geometry.attributes.position);\n\n\n\n# 平移.translate()\n\n// 几何体沿着x轴平移50\ngeometry.translate(50, 0, 0);\n\n\n\n\n# 旋转.rotatex()、.rotatey()、.rotatez()\n\n// 几何体绕着x轴旋转45度\ngeometry.rotatex(math.pi / 4);\n\n\n\n\n\n# 居中.center()\n\ngeometry.translate(50, 0, 0);//偏移\n// 居中：已经偏移的几何体居中，执行.center()，你可以看到几何体重新与坐标原点重合\ngeometry.center();\n",charsets:{cjk:!0}},{title:"3. 模型材质颜色(Color对象)",frontmatter:{title:"3. 模型材质颜色(Color对象)",date:"2023-01-25T23:08:00.000Z",permalink:"/pages/ec1682/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/03.3.%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9D%90%E8%B4%A8/03.%E6%A8%A1%E5%9E%8B%E6%9D%90%E8%B4%A8%E9%A2%9C%E8%89%B2(Color%E5%AF%B9%E8%B1%A1).html",relativePath:"01.Three.js教程/03.3.模型对象、材质/03.模型材质颜色(Color对象).md",key:"v-0c3f3d1c",path:"/pages/ec1682/",headers:[{level:3,title:"材质颜色属性.color",slug:"材质颜色属性-color",normalizedTitle:"材质颜色属性.color",charIndex:163},{level:3,title:"颜色对象Color",slug:"颜色对象color",normalizedTitle:"颜色对象color",charIndex:272},{level:3,title:"通过.r、.g、.b属性改变颜色值",slug:"通过-r、-g、-b属性改变颜色值",normalizedTitle:"通过.r、.g、.b属性改变颜色值",charIndex:629},{level:3,title:"改变颜色的方法",slug:"改变颜色的方法",normalizedTitle:"改变颜色的方法",charIndex:683},{level:3,title:"重置模型材质的颜色",slug:"重置模型材质的颜色",normalizedTitle:"重置模型材质的颜色",charIndex:992}],headersStr:"材质颜色属性.color 颜色对象Color 通过.r、.g、.b属性改变颜色值 改变颜色的方法 重置模型材质的颜色",content:"# 模型材质颜色(Color对象)\n\n你去文档搜索MeshBasicMaterial、MeshLambertMaterial、MeshPhongMaterial等网格材质，可以看到他们都有一个颜色属性.color。\n\n下面结合threejs文档，带领大家探索一下，如何通过查询文档来修改模型材质的颜色值.color。\n\n\n# 材质颜色属性.color\n\n如果你想修改材质的颜色属性.color,那么你就需要了解该属性对应属性值的形式。\n\n 1. 查文档，找到.color属性，可以发现threejs材质对象颜色属性.color是threejs的颜色对象Color。\n\n 2. console.log()打印：浏览器控制台查看材质颜色属性的属性值\n\nconsole.log('material.color',material.color);\n\n\n\n# 颜色对象Color\n\n查看颜色对象Color文档,可以看到颜色对象有三个属性，分别为.r、.g、.b，表示颜色RGB的三个分量。\n\n// 创建一个颜色对象\nconst color = new THREE.Color();//默认是纯白色0xffffff。\nconsole.log('查看颜色对象结构',color);//可以查看rgb的值\n\n\n// 查看Color对象设置0x00ff00对应的的.r、.g、.b值\nconst color = new THREE.Color(0x00ff00);\n\n\n\n# 通过.r、.g、.b属性改变颜色值\n\ncolor.r = 0.0;\ncolor.b = 0.0;\n\n\n\n# 改变颜色的方法\n\n查看Color文档，可以看到Color提供了.setHex()、.setRGB()、.setStyle()、.set()等修改颜色值的方法。\n\ncolor.setRGB(0,1,0);//RGB方式设置颜色\ncolor.setHex(0x00ff00);//十六进制方式设置颜色\ncolor.setStyle('#00ff00');//前端CSS颜色值设置颜色\n\n\n.setHex()、.setStyle()风格的颜色值都可以作为.set()的参数\n\ncolor.set(0x00ff00);//十六进制方式设置颜色\ncolor.set('#00ff00');//前端CSS颜色值设置颜色\n\n\n\n# 重置模型材质的颜色\n\n十六进制颜色\n\nmaterial.color.set(0x00ffff);\n\n\n前端CSS风格颜色值：'#00ff00'、'rgb(0,255,0)'等形式\n\nmaterial.color.set('#00ff00');\nmaterial.color.set('rgb(0,255,0)');\n",normalizedContent:"# 模型材质颜色(color对象)\n\n你去文档搜索meshbasicmaterial、meshlambertmaterial、meshphongmaterial等网格材质，可以看到他们都有一个颜色属性.color。\n\n下面结合threejs文档，带领大家探索一下，如何通过查询文档来修改模型材质的颜色值.color。\n\n\n# 材质颜色属性.color\n\n如果你想修改材质的颜色属性.color,那么你就需要了解该属性对应属性值的形式。\n\n 1. 查文档，找到.color属性，可以发现threejs材质对象颜色属性.color是threejs的颜色对象color。\n\n 2. console.log()打印：浏览器控制台查看材质颜色属性的属性值\n\nconsole.log('material.color',material.color);\n\n\n\n# 颜色对象color\n\n查看颜色对象color文档,可以看到颜色对象有三个属性，分别为.r、.g、.b，表示颜色rgb的三个分量。\n\n// 创建一个颜色对象\nconst color = new three.color();//默认是纯白色0xffffff。\nconsole.log('查看颜色对象结构',color);//可以查看rgb的值\n\n\n// 查看color对象设置0x00ff00对应的的.r、.g、.b值\nconst color = new three.color(0x00ff00);\n\n\n\n# 通过.r、.g、.b属性改变颜色值\n\ncolor.r = 0.0;\ncolor.b = 0.0;\n\n\n\n# 改变颜色的方法\n\n查看color文档，可以看到color提供了.sethex()、.setrgb()、.setstyle()、.set()等修改颜色值的方法。\n\ncolor.setrgb(0,1,0);//rgb方式设置颜色\ncolor.sethex(0x00ff00);//十六进制方式设置颜色\ncolor.setstyle('#00ff00');//前端css颜色值设置颜色\n\n\n.sethex()、.setstyle()风格的颜色值都可以作为.set()的参数\n\ncolor.set(0x00ff00);//十六进制方式设置颜色\ncolor.set('#00ff00');//前端css颜色值设置颜色\n\n\n\n# 重置模型材质的颜色\n\n十六进制颜色\n\nmaterial.color.set(0x00ffff);\n\n\n前端css风格颜色值：'#00ff00'、'rgb(0,255,0)'等形式\n\nmaterial.color.set('#00ff00');\nmaterial.color.set('rgb(0,255,0)');\n",charsets:{cjk:!0}},{title:"4. 模型材质父类Material",frontmatter:{title:"4. 模型材质父类Material",date:"2023-01-25T23:08:10.000Z",permalink:"/pages/24c407/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/03.3.%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9D%90%E8%B4%A8/04.%E6%A8%A1%E5%9E%8B%E6%9D%90%E8%B4%A8%E7%88%B6%E7%B1%BBMaterial.html",relativePath:"01.Three.js教程/03.3.模型对象、材质/04.模型材质父类Material.md",key:"v-580f06fa",path:"/pages/24c407/",headers:[{level:3,title:"材质父类Material",slug:"材质父类material",normalizedTitle:"材质父类material",charIndex:4},{level:3,title:"网格材质继承父类属性",slug:"网格材质继承父类属性",normalizedTitle:"网格材质继承父类属性",charIndex:226},{level:3,title:"材质半透明设置",slug:"材质半透明设置",normalizedTitle:"材质半透明设置",charIndex:421},{level:3,title:"材质面属性.side",slug:"材质面属性-side",normalizedTitle:"材质面属性.side",charIndex:501}],headersStr:"材质父类Material 网格材质继承父类属性 材质半透明设置 材质面属性.side",content:"# 模型材质父类Material\n\n学习到现在大家对threejs的材质都有简单的了解，本节课主要结合文档，从JavaScript语法角度，给大家总结一下材质API的语法。\n\n\n# 材质父类Material\n\n查询threejs文档，你可以看到基础网格材质MeshBasicMaterial、漫反射网格材质MeshLambertMaterial、高光网格材质MeshPhongMaterial等网格材质都有一个共同的父类Material。\n\n\n\n\n# 网格材质继承父类属性\n\n从JavaScript语法角度看子类都会继承父类的属性和方法，threejs的材质同样道理。\n\nMeshBasicMaterial、MeshLambertMaterial、MeshPhongMaterial等子类网格材质会从父类Material继承一些属性和方法，比如透明度属性.opacity、面属性.side、是否透明属性.transparent等等。\n\n\n# 材质半透明设置\n\nmaterial.transparent = true;//开启透明\nmaterial.opacity = 0.5;//设置透明度\n\n\n\n# 材质面属性.side\n\n你可以用矩形平面PlaneGeometry来测试材质的面属性.side。\n\n查看文档，可以知道材质面属性.side默认值是THREE.FrontSide,表示网格模型正面可以看到，THREE.BackSide表示背面可以看到，THREE.DoubleSide表示双面可以看到。\n\nmaterial.side = THREE.BackSide;//背面可以看到\nmaterial.side = THREE.DoubleSide;//双面可见\n\n\nTHREE.FrontSide、THREE.BackSide、THREE.DoubleSide其实在theeejs内部都表示一个数字,你可以通过浏览器控制log打印查看验证，具体可以查看src目录下constants.js的源码文件。\n\nconsole.log('material.side',material.side);\n",normalizedContent:"# 模型材质父类material\n\n学习到现在大家对threejs的材质都有简单的了解，本节课主要结合文档，从javascript语法角度，给大家总结一下材质api的语法。\n\n\n# 材质父类material\n\n查询threejs文档，你可以看到基础网格材质meshbasicmaterial、漫反射网格材质meshlambertmaterial、高光网格材质meshphongmaterial等网格材质都有一个共同的父类material。\n\n\n\n\n# 网格材质继承父类属性\n\n从javascript语法角度看子类都会继承父类的属性和方法，threejs的材质同样道理。\n\nmeshbasicmaterial、meshlambertmaterial、meshphongmaterial等子类网格材质会从父类material继承一些属性和方法，比如透明度属性.opacity、面属性.side、是否透明属性.transparent等等。\n\n\n# 材质半透明设置\n\nmaterial.transparent = true;//开启透明\nmaterial.opacity = 0.5;//设置透明度\n\n\n\n# 材质面属性.side\n\n你可以用矩形平面planegeometry来测试材质的面属性.side。\n\n查看文档，可以知道材质面属性.side默认值是three.frontside,表示网格模型正面可以看到，three.backside表示背面可以看到，three.doubleside表示双面可以看到。\n\nmaterial.side = three.backside;//背面可以看到\nmaterial.side = three.doubleside;//双面可见\n\n\nthree.frontside、three.backside、three.doubleside其实在theeejs内部都表示一个数字,你可以通过浏览器控制log打印查看验证，具体可以查看src目录下constants.js的源码文件。\n\nconsole.log('material.side',material.side);\n",charsets:{cjk:!0}},{title:"5. 模型材质和几何体属性",frontmatter:{title:"5. 模型材质和几何体属性",date:"2023-01-25T23:08:17.000Z",permalink:"/pages/091565/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/03.3.%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9D%90%E8%B4%A8/05.%E6%A8%A1%E5%9E%8B%E6%9D%90%E8%B4%A8%E5%92%8C%E5%87%A0%E4%BD%95%E4%BD%93%E5%B1%9E%E6%80%A7.html",relativePath:"01.Three.js教程/03.3.模型对象、材质/05.模型材质和几何体属性.md",key:"v-2d2ee09c",path:"/pages/091565/",headers:[{level:3,title:"浏览器控制台查看对象和属性",slug:"浏览器控制台查看对象和属性",normalizedTitle:"浏览器控制台查看对象和属性",charIndex:59},{level:3,title:"访问改变模型材质属性",slug:"访问改变模型材质属性",normalizedTitle:"访问改变模型材质属性",charIndex:343},{level:3,title:"访问改变模型几何体属性",slug:"访问改变模型几何体属性",normalizedTitle:"访问改变模型几何体属性",charIndex:416},{level:3,title:"材质或几何体共享",slug:"材质或几何体共享",normalizedTitle:"材质或几何体共享",charIndex:490}],headersStr:"浏览器控制台查看对象和属性 访问改变模型材质属性 访问改变模型几何体属性 材质或几何体共享",content:"# 模型材质和几何体属性\n\n本节课给大家介绍模型对象的几何体.geometry和材质属性.material。\n\n\n# 浏览器控制台查看对象和属性\n\n浏览器控制打印模型对象mesh，可以展开对象，查看对象的几何体.geometry和材质属性.material。\n\nconst mesh = new THREE.Mesh(geometry, material);\nconsole.log('mesh',mesh);\n\n\n浏览器控制台打印模型的几何体属性.geometry和材质属性.material。\n\nconsole.log('mesh.geometry',mesh.geometry);\nconsole.log('mesh.material',mesh.material);\n\n\n\n# 访问改变模型材质属性\n\n// 访问模型材质,并设置材质的颜色属性\nmesh.material.color.set(0xffff00);\n\n\n\n# 访问改变模型几何体属性\n\n// 访问模型几何体,并平移几何体顶点数据\nmesh.geometry.translate(0,100,0);\n\n\n\n# 材质或几何体共享\n\nconst mesh = new THREE.Mesh(geometry, material);\nconst mesh2 = new THREE.Mesh(geometry, material);\nmesh2.position.x = 100;\n// 两个mesh共享一个材质，改变一个mesh的颜色，另一个mesh2的颜色也会跟着改变\n// mesh.material和mesh2.material都指向同一个material\n// 三者等价：mesh.material、mesh2.material、material\nmesh.material.color.set(0xffff00);\n// 三者等价：mesh.geometry、mesh2.geometry、geometry\nmesh.geometry.translate(0,100,0);\n",normalizedContent:"# 模型材质和几何体属性\n\n本节课给大家介绍模型对象的几何体.geometry和材质属性.material。\n\n\n# 浏览器控制台查看对象和属性\n\n浏览器控制打印模型对象mesh，可以展开对象，查看对象的几何体.geometry和材质属性.material。\n\nconst mesh = new three.mesh(geometry, material);\nconsole.log('mesh',mesh);\n\n\n浏览器控制台打印模型的几何体属性.geometry和材质属性.material。\n\nconsole.log('mesh.geometry',mesh.geometry);\nconsole.log('mesh.material',mesh.material);\n\n\n\n# 访问改变模型材质属性\n\n// 访问模型材质,并设置材质的颜色属性\nmesh.material.color.set(0xffff00);\n\n\n\n# 访问改变模型几何体属性\n\n// 访问模型几何体,并平移几何体顶点数据\nmesh.geometry.translate(0,100,0);\n\n\n\n# 材质或几何体共享\n\nconst mesh = new three.mesh(geometry, material);\nconst mesh2 = new three.mesh(geometry, material);\nmesh2.position.x = 100;\n// 两个mesh共享一个材质，改变一个mesh的颜色，另一个mesh2的颜色也会跟着改变\n// mesh.material和mesh2.material都指向同一个material\n// 三者等价：mesh.material、mesh2.material、material\nmesh.material.color.set(0xffff00);\n// 三者等价：mesh.geometry、mesh2.geometry、geometry\nmesh.geometry.translate(0,100,0);\n",charsets:{cjk:!0}},{title:"6. 克隆.clone()和复制.copy()",frontmatter:{title:"6. 克隆.clone()和复制.copy()",date:"2023-01-25T23:08:26.000Z",permalink:"/pages/186303/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/03.3.%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9D%90%E8%B4%A8/06.%E5%85%8B%E9%9A%86.clone()%E5%92%8C%E5%A4%8D%E5%88%B6.copy().html",relativePath:"01.Three.js教程/03.3.模型对象、材质/06.克隆.clone()和复制.copy().md",key:"v-f3679942",path:"/pages/186303/",headers:[{level:3,title:"克隆.clone()",slug:"克隆-clone",normalizedTitle:"克隆.clone()",charIndex:2},{level:3,title:"复制.copy()",slug:"复制-copy",normalizedTitle:"复制.copy()",charIndex:13},{level:3,title:"Mesh克隆.clone()",slug:"mesh克隆-clone",normalizedTitle:"mesh克隆.clone()",charIndex:562},{level:3,title:"几何体和材质克隆.clone()",slug:"几何体和材质克隆-clone",normalizedTitle:"几何体和材质克隆.clone()",charIndex:819},{level:3,title:"练习：mesh.position.copy()",slug:"练习-mesh-position-copy",normalizedTitle:"练习：mesh.position.copy()",charIndex:1042},{level:3,title:"练习：mesh.rotation.copy()",slug:"练习-mesh-rotation-copy",normalizedTitle:"练习：mesh.rotation.copy()",charIndex:1204}],headersStr:"克隆.clone() 复制.copy() Mesh克隆.clone() 几何体和材质克隆.clone() 练习：mesh.position.copy() 练习：mesh.rotation.copy()",content:"# 克隆.clone()和复制.copy()\n\n克隆.clone()、复制.copy()是threejs很多对象都具有的方法，比如三维向量对象Vector3、网格模型Mesh、几何体、材质。\n\n\n# 克隆.clone()\n\n克隆.clone()简单说就是复制一个和原对象一样的新对象,下面以三维向量对象Vector3给大家举例，其他的threejs对象都可以参照类似的写法。\n\nconst v1 = new THREE.Vector3(1, 2, 3);\nconsole.log('v1',v1);\n//v2是一个新的Vector3对象，和v1的.x、.y、.z属性值一样\nconst v2 = v1.clone();\nconsole.log('v2',v2);\n\n\n\n# 复制.copy()\n\n复制.copy()简单说就是把一个对象属性的属性值赋值给另一个对象,下面以三维向量对象Vector3给大家举例，其他的threejs对象都可以参照类似的写法。\n\nconst v1 = new THREE.Vector3(1, 2, 3);\nconst v3 = new THREE.Vector3(4, 5, 6);\n//读取v1.x、v1.y、v1.z的赋值给v3.x、v3.y、v3.z\nv3.copy(v1);\n\n\n\n# Mesh克隆.clone()\n\n通过mesh克隆.clone()一个和mesh一样的新模型对象mesh2。\n\nconst mesh2 = mesh.clone();\nmesh2.position.x = 100;\n\n\n通过克隆.clone()获得的新模型和原来的模型共享材质和几何体\n\n// 改变材质颜色，或者说改变mesh2颜色，mesh和mesh2颜色都会改变\n// material.color.set(0xffff00);\nmesh2.material.color.set(0xffff00);\n\n\n\n# 几何体和材质克隆.clone()\n\nconst mesh2 = mesh.clone();\n// 克隆几何体和材质，重新设置mesh2的材质和几何体属性\nmesh2.geometry = mesh.geometry.clone();\nmesh2.material = mesh.material.clone();\n// 改变mesh2颜色，不会改变mesh的颜色\nmesh2.material.color.set(0xff0000);\n\n\n\n# 练习：mesh.position.copy()\n\n改变mesh的位置，使之位于mesh2的正上方(y)，距离100。\n\nmesh.position.copy(mesh2.position);//1. 第1步位置重合\nmesh.position.y += 100;//1. 第2步mesh在原来y的基础上增加100\n\n\n\n# 练习：mesh.rotation.copy()\n\n两个模型的姿态角度始终保持一样。\n\n// 渲染循环\nfunction render() {\n    mesh.rotateY(0.01);// mesh旋转动画\n    // 同步mesh2和mesh的姿态角度一样，不管mesh姿态角度怎么变化，mesh2始终保持同步\n    mesh2.rotation.copy(mesh.rotation);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# 克隆.clone()和复制.copy()\n\n克隆.clone()、复制.copy()是threejs很多对象都具有的方法，比如三维向量对象vector3、网格模型mesh、几何体、材质。\n\n\n# 克隆.clone()\n\n克隆.clone()简单说就是复制一个和原对象一样的新对象,下面以三维向量对象vector3给大家举例，其他的threejs对象都可以参照类似的写法。\n\nconst v1 = new three.vector3(1, 2, 3);\nconsole.log('v1',v1);\n//v2是一个新的vector3对象，和v1的.x、.y、.z属性值一样\nconst v2 = v1.clone();\nconsole.log('v2',v2);\n\n\n\n# 复制.copy()\n\n复制.copy()简单说就是把一个对象属性的属性值赋值给另一个对象,下面以三维向量对象vector3给大家举例，其他的threejs对象都可以参照类似的写法。\n\nconst v1 = new three.vector3(1, 2, 3);\nconst v3 = new three.vector3(4, 5, 6);\n//读取v1.x、v1.y、v1.z的赋值给v3.x、v3.y、v3.z\nv3.copy(v1);\n\n\n\n# mesh克隆.clone()\n\n通过mesh克隆.clone()一个和mesh一样的新模型对象mesh2。\n\nconst mesh2 = mesh.clone();\nmesh2.position.x = 100;\n\n\n通过克隆.clone()获得的新模型和原来的模型共享材质和几何体\n\n// 改变材质颜色，或者说改变mesh2颜色，mesh和mesh2颜色都会改变\n// material.color.set(0xffff00);\nmesh2.material.color.set(0xffff00);\n\n\n\n# 几何体和材质克隆.clone()\n\nconst mesh2 = mesh.clone();\n// 克隆几何体和材质，重新设置mesh2的材质和几何体属性\nmesh2.geometry = mesh.geometry.clone();\nmesh2.material = mesh.material.clone();\n// 改变mesh2颜色，不会改变mesh的颜色\nmesh2.material.color.set(0xff0000);\n\n\n\n# 练习：mesh.position.copy()\n\n改变mesh的位置，使之位于mesh2的正上方(y)，距离100。\n\nmesh.position.copy(mesh2.position);//1. 第1步位置重合\nmesh.position.y += 100;//1. 第2步mesh在原来y的基础上增加100\n\n\n\n# 练习：mesh.rotation.copy()\n\n两个模型的姿态角度始终保持一样。\n\n// 渲染循环\nfunction render() {\n    mesh.rotatey(0.01);// mesh旋转动画\n    // 同步mesh2和mesh的姿态角度一样，不管mesh姿态角度怎么变化，mesh2始终保持同步\n    mesh2.rotation.copy(mesh.rotation);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"1. Vector3与模型位置、缩放属性",frontmatter:{title:"1. Vector3与模型位置、缩放属性",date:"2023-01-26T14:22:42.000Z",permalink:"/pages/c86096/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/04.4.%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/01.%E4%B8%89%E7%BB%B4%E5%90%91%E9%87%8FVector3%E4%B8%8E%E6%A8%A1%E5%9E%8B%E4%BD%8D%E7%BD%AE%E3%80%81%E7%BC%A9%E6%94%BE%E5%B1%9E%E6%80%A7.html",relativePath:"01.Three.js教程/04.4.层级模型/01.三维向量Vector3与模型位置、缩放属性.md",key:"v-20bef0e8",path:"/pages/c86096/",headers:[{level:3,title:"Group层级模型(树结构)案例",slug:"group层级模型-树结构-案例",normalizedTitle:"group层级模型(树结构)案例",charIndex:62},{level:3,title:"查看子对象.children",slug:"查看子对象-children",normalizedTitle:"查看子对象.children",charIndex:776},{level:3,title:"场景对象结构",slug:"场景对象结构",normalizedTitle:"场景对象结构",charIndex:1005},{level:3,title:".add()方法总结",slug:"add-方法总结",normalizedTitle:".add()方法总结",charIndex:1300},{level:3,title:"父对象旋转缩放平移变换，子对象跟着变化",slug:"父对象旋转缩放平移变换-子对象跟着变化",normalizedTitle:"父对象旋转缩放平移变换，子对象跟着变化",charIndex:1467},{level:3,title:"Object3D表示模型对象节点",slug:"object3d表示模型对象节点",normalizedTitle:"object3d表示模型对象节点",charIndex:1727},{level:3,title:"mesh也能添加mesh子对象",slug:"mesh也能添加mesh子对象",normalizedTitle:"mesh也能添加mesh子对象",charIndex:2030}],headersStr:"Group层级模型(树结构)案例 查看子对象.children 场景对象结构 .add()方法总结 父对象旋转缩放平移变换，子对象跟着变化 Object3D表示模型对象节点 mesh也能添加mesh子对象",content:"# 组对象Group、层级模型\n\n本节课给通过组对象Group给大家讲解一下threejs层级模型或树结构的概念。\n\n\n# Group层级模型(树结构)案例\n\n\n\n下面代码创建了两个网格模型mesh1、mesh2，通过THREE.Group类创建一个组对象group,然后通过add方法把网格模型mesh1、mesh2作为设置为组对象group的子对象，然后在通过执行scene.add(group)把组对象group作为场景对象的scene的子对象。也就是说场景对象是scene是group的父对象，group是mesh1、mesh2的父对象。这样就构成了一个三层的层级结构，当然了你也可以通过Group自己创建新模型节点作为层级结构中的一层。\n\n//创建两个网格模型mesh1、mesh2\nconst geometry = new THREE.BoxGeometry(20, 20, 20);\nconst material = new THREE.MeshLambertMaterial({color: 0x00ffff});\nconst group = new THREE.Group();\nconst mesh1 = new THREE.Mesh(geometry, material);\nconst mesh2 = new THREE.Mesh(geometry, material);\nmesh2.translateX(25);\n//把mesh1型插入到组group中，mesh1作为group的子对象\ngroup.add(mesh1);\n//把mesh2型插入到组group中，mesh2作为group的子对象\ngroup.add(mesh2);\n//把group插入到场景中作为场景子对象\nscene.add(group);\n\n\n\n# 查看子对象.children\n\nThreejs场景对象Scene、组对象Group都有一个子对象属性.children,通过该属性可以访问父对象的子对象，子对象属性.children的值是数组，所有子对象是数组的值，你可以在浏览器控制台打印测试上面案例代码。\n\n父对象执行.add()方法的本质就是把参数中的子对象添加到自身的子对象属性.children中。\n\nconsole.log('查看group的子对象',group.children);\n\n\n\n# 场景对象结构\n\nconsole.log('查看Scene的子对象',scene.children);\n\n\n\n\n场景对象Scene的子对象，除了组对象Group之外，还可以看到环境光AmbientLight、平行光DirectionalLight、辅助坐标对象AxesHelper。\n\n场景对象对象scene构成的层级模型本身是一个树结构，场景对象层级模型的第一层，也就是树结构的根节点，一般来说网格模型Mesh、点模型Points、线模型Line是树结构的最外层叶子结点。构建层级模型的中间层一般都是通过Threejs的Group类来完成，Group类实例化的对象可以称为组对象。\n\n\n# .add()方法总结\n\n场景对象Scene、组对象Group的.add()方法都是继承自它们共同的基类(父类)Object3D。\n\ngroup.add(mesh1);\ngroup.add(mesh2);\n\n\n.add()方法可以单独插入一个对象，也可以同时插入多个子对象。\n\ngroup.add(mesh1,mesh2);\n\n\n\n# 父对象旋转缩放平移变换，子对象跟着变化\n\n网格模型mesh1、mesh2作为设置为父对象group的子对象，如果父对象group进行旋转、缩放、平移变换，子对象同样跟着变换，就像你的头旋转了，眼睛会跟着头旋转。\n\n//沿着Y轴平移mesh1和mesh2的父对象，mesh1和mesh2跟着平移\ngroup.translateY(100);\n\n\n//父对象缩放，子对象跟着缩放\ngroup.scale.set(4,4,4);\n\n\n//父对象旋转，子对象跟着旋转\ngroup.rotateY(Math.PI/6)\n\n\n\n# Object3D表示模型对象节点\n\n受threejs历史影响，你会在很多别的代码中看到Object3D作为Group来使用，如果看到不用奇怪。某种程度上，你可把两者画等号，只是Group更加语义化，Object3D本身就是表示模型节点的意思。\n\nconst mesh1 = new THREE.Mesh(geometry, material);\nconst mesh2 = new THREE.Mesh(geometry, material);\nconst obj = new THREE.Object3D();//作为mesh1和mesh2的父对象\nobj.add(mesh1,mesh2);\n\n\n\n# mesh也能添加mesh子对象\n\nthreejs默认mesh也可以添加子对象,其实原因很简单，mesh和Group父类都是Object3D，本质上也可以认为都是Object3D。\n\n//threejs默认mesh也可以添加子对象,mesh基类也是Object3D\nmesh1.add(mesh2);\n",normalizedContent:"# 组对象group、层级模型\n\n本节课给通过组对象group给大家讲解一下threejs层级模型或树结构的概念。\n\n\n# group层级模型(树结构)案例\n\n\n\n下面代码创建了两个网格模型mesh1、mesh2，通过three.group类创建一个组对象group,然后通过add方法把网格模型mesh1、mesh2作为设置为组对象group的子对象，然后在通过执行scene.add(group)把组对象group作为场景对象的scene的子对象。也就是说场景对象是scene是group的父对象，group是mesh1、mesh2的父对象。这样就构成了一个三层的层级结构，当然了你也可以通过group自己创建新模型节点作为层级结构中的一层。\n\n//创建两个网格模型mesh1、mesh2\nconst geometry = new three.boxgeometry(20, 20, 20);\nconst material = new three.meshlambertmaterial({color: 0x00ffff});\nconst group = new three.group();\nconst mesh1 = new three.mesh(geometry, material);\nconst mesh2 = new three.mesh(geometry, material);\nmesh2.translatex(25);\n//把mesh1型插入到组group中，mesh1作为group的子对象\ngroup.add(mesh1);\n//把mesh2型插入到组group中，mesh2作为group的子对象\ngroup.add(mesh2);\n//把group插入到场景中作为场景子对象\nscene.add(group);\n\n\n\n# 查看子对象.children\n\nthreejs场景对象scene、组对象group都有一个子对象属性.children,通过该属性可以访问父对象的子对象，子对象属性.children的值是数组，所有子对象是数组的值，你可以在浏览器控制台打印测试上面案例代码。\n\n父对象执行.add()方法的本质就是把参数中的子对象添加到自身的子对象属性.children中。\n\nconsole.log('查看group的子对象',group.children);\n\n\n\n# 场景对象结构\n\nconsole.log('查看scene的子对象',scene.children);\n\n\n\n\n场景对象scene的子对象，除了组对象group之外，还可以看到环境光ambientlight、平行光directionallight、辅助坐标对象axeshelper。\n\n场景对象对象scene构成的层级模型本身是一个树结构，场景对象层级模型的第一层，也就是树结构的根节点，一般来说网格模型mesh、点模型points、线模型line是树结构的最外层叶子结点。构建层级模型的中间层一般都是通过threejs的group类来完成，group类实例化的对象可以称为组对象。\n\n\n# .add()方法总结\n\n场景对象scene、组对象group的.add()方法都是继承自它们共同的基类(父类)object3d。\n\ngroup.add(mesh1);\ngroup.add(mesh2);\n\n\n.add()方法可以单独插入一个对象，也可以同时插入多个子对象。\n\ngroup.add(mesh1,mesh2);\n\n\n\n# 父对象旋转缩放平移变换，子对象跟着变化\n\n网格模型mesh1、mesh2作为设置为父对象group的子对象，如果父对象group进行旋转、缩放、平移变换，子对象同样跟着变换，就像你的头旋转了，眼睛会跟着头旋转。\n\n//沿着y轴平移mesh1和mesh2的父对象，mesh1和mesh2跟着平移\ngroup.translatey(100);\n\n\n//父对象缩放，子对象跟着缩放\ngroup.scale.set(4,4,4);\n\n\n//父对象旋转，子对象跟着旋转\ngroup.rotatey(math.pi/6)\n\n\n\n# object3d表示模型对象节点\n\n受threejs历史影响，你会在很多别的代码中看到object3d作为group来使用，如果看到不用奇怪。某种程度上，你可把两者画等号，只是group更加语义化，object3d本身就是表示模型节点的意思。\n\nconst mesh1 = new three.mesh(geometry, material);\nconst mesh2 = new three.mesh(geometry, material);\nconst obj = new three.object3d();//作为mesh1和mesh2的父对象\nobj.add(mesh1,mesh2);\n\n\n\n# mesh也能添加mesh子对象\n\nthreejs默认mesh也可以添加子对象,其实原因很简单，mesh和group父类都是object3d，本质上也可以认为都是object3d。\n\n//threejs默认mesh也可以添加子对象,mesh基类也是object3d\nmesh1.add(mesh2);\n",charsets:{cjk:!0}},{title:"2. 遍历模型树结构、查询模型节点",frontmatter:{title:"2. 遍历模型树结构、查询模型节点",date:"2023-01-26T14:22:48.000Z",permalink:"/pages/4da2c3/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/04.4.%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/02.%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E6%A8%A1%E5%9E%8B%E6%A0%91%E7%BB%93%E6%9E%84%E3%80%81%E6%9F%A5%E8%AF%A2%E6%A8%A1%E5%9E%8B%E8%8A%82%E7%82%B9.html",relativePath:"01.Three.js教程/04.4.层级模型/02.递归遍历模型树结构、查询模型节点.md",key:"v-8030b53e",path:"/pages/4da2c3/",headers:[{level:3,title:"模型命名(.name属性)",slug:"模型命名-name属性",normalizedTitle:"模型命名(.name属性)",charIndex:142},{level:3,title:"树结构层级模型设置.name属性",slug:"树结构层级模型设置-name属性",normalizedTitle:"树结构层级模型设置.name属性",charIndex:313},{level:3,title:"递归遍历方法.traverse()",slug:"递归遍历方法-traverse",normalizedTitle:"递归遍历方法.traverse()",charIndex:1452},{level:3,title:"查找某个具体的模型.getObjectByName()",slug:"查找某个具体的模型-getobjectbyname",normalizedTitle:"查找某个具体的模型.getobjectbyname()",charIndex:1770}],headersStr:"模型命名(.name属性) 树结构层级模型设置.name属性 递归遍历方法.traverse() 查找某个具体的模型.getObjectByName()",content:"# 层级模型节点命名、查找、遍历\n\n上节课说过Threejs场景对象Scene和各种子对象构成的层级模型就是一个树结构。如果你有一定的算法基础对树结构肯定会非常了解，如果你了解前端的DOM树结构也非常有助于本节课的学习，如果这些都不了解也没有关系，直接体验本节课的案例源码。\n\n\n# 模型命名(.name属性)\n\n在层级模型中可以给一些模型对象通过.name属性命名进行标记。\n\nconst group = new THREE.Group();\ngroup.name='小区房子';\nconst mesh = new THREE.Mesh(geometry, material);\nmesh.name='一号楼';\n\n\n\n# 树结构层级模型设置.name属性\n\n下面是通过代码创建了一个层级模型，一般实际开发的时候，会加载外部的模型，然后从模型对象通过节点的名称.name查找某个子对象。\n\n\n\n// 批量创建多个长方体表示高层楼\nconst group1 = new THREE.Group(); //所有高层楼的父对象\ngroup1.name = \"高层\";\nfor (let i = 0; i < 5; i++) {\n    const geometry = new THREE.BoxGeometry(20, 60, 10);\n    const material = new THREE.MeshLambertMaterial({\n        color: 0x00ffff\n    });\n    const mesh = new THREE.Mesh(geometry, material);\n    mesh.position.x = i * 30; // 网格模型mesh沿着x轴方向阵列\n    group1.add(mesh); //添加到组对象group1\n    mesh.name = i + 1 + '号楼';\n    // console.log('mesh.name',mesh.name);\n}\ngroup1.position.y = 30;\n\n\nconst group2 = new THREE.Group();\ngroup2.name = \"洋房\";\n// 批量创建多个长方体表示洋房\nfor (let i = 0; i < 5; i++) {\n    const geometry = new THREE.BoxGeometry(20, 30, 10);\n    const material = new THREE.MeshLambertMaterial({\n        color: 0x00ffff\n    });\n    const mesh = new THREE.Mesh(geometry, material);\n    mesh.position.x = i * 30;\n    group2.add(mesh); //添加到组对象group2\n    mesh.name = i + 6 + '号楼';\n}\ngroup2.position.z = 50;\ngroup2.position.y = 15;\n\nconst model = new THREE.Group();\nmodel.name='小区房子';\nmodel.add(group1, group2);\nmodel.position.set(-50,0,-25);\n\n\n\n# 递归遍历方法.traverse()\n\nThreejs层级模型就是一个树结构，可以通过递归遍历的算法去遍历Threejs一个模型对象包含的所有后代。\n\n// 递归遍历model包含所有的模型节点\nmodel.traverse(function(obj) {\n    console.log('所有模型节点的名称',obj.name);\n    // obj.isMesh：if判断模型对象obj是不是网格模型'Mesh'\n    if (obj.isMesh) {//判断条件也可以是obj.type === 'Mesh'\n        obj.material.color.set(0xffff00);\n    }\n});\n\n\n\n# 查找某个具体的模型.getObjectByName()\n\n看到Object3D的.getObjectByName()方法，如果已有前端基础，很容易联想到DOM的一些方法。\n\nThreejs和前端DOM一样，可以通过一个方法查找树结构父元素的某个后代对象，对于普通前端而言可以通过name或id等方式查找一个或多个DOM元素，Threejs同样可以通过一些方法查找一个模型树中的某个节点。更多的查找方法和方法的使用细节可以查看基类Object3D。\n\n// 返回名.name为\"4号楼\"对应的对象\nconst nameNode = scene.getObjectByName (\"4号楼\");\nnameNode.material.color.set(0xff0000);\n",normalizedContent:"# 层级模型节点命名、查找、遍历\n\n上节课说过threejs场景对象scene和各种子对象构成的层级模型就是一个树结构。如果你有一定的算法基础对树结构肯定会非常了解，如果你了解前端的dom树结构也非常有助于本节课的学习，如果这些都不了解也没有关系，直接体验本节课的案例源码。\n\n\n# 模型命名(.name属性)\n\n在层级模型中可以给一些模型对象通过.name属性命名进行标记。\n\nconst group = new three.group();\ngroup.name='小区房子';\nconst mesh = new three.mesh(geometry, material);\nmesh.name='一号楼';\n\n\n\n# 树结构层级模型设置.name属性\n\n下面是通过代码创建了一个层级模型，一般实际开发的时候，会加载外部的模型，然后从模型对象通过节点的名称.name查找某个子对象。\n\n\n\n// 批量创建多个长方体表示高层楼\nconst group1 = new three.group(); //所有高层楼的父对象\ngroup1.name = \"高层\";\nfor (let i = 0; i < 5; i++) {\n    const geometry = new three.boxgeometry(20, 60, 10);\n    const material = new three.meshlambertmaterial({\n        color: 0x00ffff\n    });\n    const mesh = new three.mesh(geometry, material);\n    mesh.position.x = i * 30; // 网格模型mesh沿着x轴方向阵列\n    group1.add(mesh); //添加到组对象group1\n    mesh.name = i + 1 + '号楼';\n    // console.log('mesh.name',mesh.name);\n}\ngroup1.position.y = 30;\n\n\nconst group2 = new three.group();\ngroup2.name = \"洋房\";\n// 批量创建多个长方体表示洋房\nfor (let i = 0; i < 5; i++) {\n    const geometry = new three.boxgeometry(20, 30, 10);\n    const material = new three.meshlambertmaterial({\n        color: 0x00ffff\n    });\n    const mesh = new three.mesh(geometry, material);\n    mesh.position.x = i * 30;\n    group2.add(mesh); //添加到组对象group2\n    mesh.name = i + 6 + '号楼';\n}\ngroup2.position.z = 50;\ngroup2.position.y = 15;\n\nconst model = new three.group();\nmodel.name='小区房子';\nmodel.add(group1, group2);\nmodel.position.set(-50,0,-25);\n\n\n\n# 递归遍历方法.traverse()\n\nthreejs层级模型就是一个树结构，可以通过递归遍历的算法去遍历threejs一个模型对象包含的所有后代。\n\n// 递归遍历model包含所有的模型节点\nmodel.traverse(function(obj) {\n    console.log('所有模型节点的名称',obj.name);\n    // obj.ismesh：if判断模型对象obj是不是网格模型'mesh'\n    if (obj.ismesh) {//判断条件也可以是obj.type === 'mesh'\n        obj.material.color.set(0xffff00);\n    }\n});\n\n\n\n# 查找某个具体的模型.getobjectbyname()\n\n看到object3d的.getobjectbyname()方法，如果已有前端基础，很容易联想到dom的一些方法。\n\nthreejs和前端dom一样，可以通过一个方法查找树结构父元素的某个后代对象，对于普通前端而言可以通过name或id等方式查找一个或多个dom元素，threejs同样可以通过一些方法查找一个模型树中的某个节点。更多的查找方法和方法的使用细节可以查看基类object3d。\n\n// 返回名.name为\"4号楼\"对应的对象\nconst namenode = scene.getobjectbyname (\"4号楼\");\nnamenode.material.color.set(0xff0000);\n",charsets:{cjk:!0}},{title:"3. 本地坐标和世界坐标",frontmatter:{title:"3. 本地坐标和世界坐标",date:"2023-01-26T14:22:49.000Z",permalink:"/pages/00ddfa/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/04.4.%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/03.%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E5%92%8C%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87.html",relativePath:"01.Three.js教程/04.4.层级模型/03.本地坐标和世界坐标.md",key:"v-50155d20",path:"/pages/00ddfa/",headers:[{level:3,title:"本地(局部)坐标和世界坐标",slug:"本地-局部-坐标和世界坐标-2",normalizedTitle:"本地(局部)坐标和世界坐标",charIndex:2},{level:3,title:".getWorldPosition()获取世界坐标",slug:"getworldposition-获取世界坐标",normalizedTitle:".getworldposition()获取世界坐标",charIndex:504},{level:3,title:"给子对象添加一个局部坐标系",slug:"给子对象添加一个局部坐标系",normalizedTitle:"给子对象添加一个局部坐标系",charIndex:822}],headersStr:"本地(局部)坐标和世界坐标 .getWorldPosition()获取世界坐标 给子对象添加一个局部坐标系",content:"# 本地(局部)坐标和世界坐标\n\n通过前面两节课的学习，大家对threejs的层级模型或者模型的树结构有了一定了解。\n\n\n# 本地(局部)坐标和世界坐标\n\n// mesh的世界坐标就是mesh.position与group.position的累加\nconst mesh = new THREE.Mesh(geometry, material); \nmesh.position.set(50, 0, 0);\nconst group = new THREE.Group();\ngroup.add(mesh);\ngroup.position.set(50, 0, 0);\n\n\n 1. 改变子对象的.position，子对象在3D空间中的坐标会发生改变。\n\n 2. 改变父对象的.position，子对象在3D空间中的位置也会跟着变化，也就是说父对象.position和子对象.position叠加才是才是子对象的.position。\n\n任何一个模型的本地坐标(局部坐标)就是模型的.position属性。\n\n一个模型的世界坐标，说的是，模型自身.position和所有父对象.position累加的坐标。\n\n\n# .getWorldPosition()获取世界坐标\n\nmesh.getWorldPosition(Vector3)读取一个模型的世界坐标，并把读取结果存储到参数Vector3中。\n\n// 声明一个三维向量用来表示某个坐标\nconst worldPosition = new THREE.Vector3();\n// 获取mesh的世界坐标，你会发现mesh的世界坐标受到父对象group的.position影响\nmesh.getWorldPosition(worldPosition);\nconsole.log('世界坐标',worldPosition);\nconsole.log('本地坐标',mesh.position);\n\n\n\n# 给子对象添加一个局部坐标系\n\nmesh.add(坐标系)给mesh添加一个局部坐标系。\n\n//可视化mesh的局部坐标系\nconst meshAxesHelper = new THREE.AxesHelper(50);\nmesh.add(meshAxesHelper);\n",normalizedContent:"# 本地(局部)坐标和世界坐标\n\n通过前面两节课的学习，大家对threejs的层级模型或者模型的树结构有了一定了解。\n\n\n# 本地(局部)坐标和世界坐标\n\n// mesh的世界坐标就是mesh.position与group.position的累加\nconst mesh = new three.mesh(geometry, material); \nmesh.position.set(50, 0, 0);\nconst group = new three.group();\ngroup.add(mesh);\ngroup.position.set(50, 0, 0);\n\n\n 1. 改变子对象的.position，子对象在3d空间中的坐标会发生改变。\n\n 2. 改变父对象的.position，子对象在3d空间中的位置也会跟着变化，也就是说父对象.position和子对象.position叠加才是才是子对象的.position。\n\n任何一个模型的本地坐标(局部坐标)就是模型的.position属性。\n\n一个模型的世界坐标，说的是，模型自身.position和所有父对象.position累加的坐标。\n\n\n# .getworldposition()获取世界坐标\n\nmesh.getworldposition(vector3)读取一个模型的世界坐标，并把读取结果存储到参数vector3中。\n\n// 声明一个三维向量用来表示某个坐标\nconst worldposition = new three.vector3();\n// 获取mesh的世界坐标，你会发现mesh的世界坐标受到父对象group的.position影响\nmesh.getworldposition(worldposition);\nconsole.log('世界坐标',worldposition);\nconsole.log('本地坐标',mesh.position);\n\n\n\n# 给子对象添加一个局部坐标系\n\nmesh.add(坐标系)给mesh添加一个局部坐标系。\n\n//可视化mesh的局部坐标系\nconst meshaxeshelper = new three.axeshelper(50);\nmesh.add(meshaxeshelper);\n",charsets:{cjk:!0}},{title:"4. 改变模型相对局部坐标原点位置",frontmatter:{title:"4. 改变模型相对局部坐标原点位置",date:"2023-01-26T14:22:48.000Z",permalink:"/pages/a2fae0/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/04.4.%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/04.%E6%94%B9%E5%8F%98%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%AF%B9%E5%B1%80%E9%83%A8%E5%9D%90%E6%A0%87%E5%8E%9F%E7%82%B9%E4%BD%8D%E7%BD%AE.html",relativePath:"01.Three.js教程/04.4.层级模型/04.改变模型相对局部坐标原点位置.md",key:"v-64ed261a",path:"/pages/a2fae0/",headers:[{level:3,title:"旋转测试",slug:"旋转测试",normalizedTitle:"旋转测试",charIndex:196}],headersStr:"旋转测试",content:"# 改变模型相对局部坐标原点位置\n\n通过改变几何体顶点坐标，可以改变模型自身相对坐标原点的位置。\n\n//长方体的几何中心默认与本地坐标原点重合\nconst geometry = new THREE.BoxGeometry(50, 50, 50);\n\n\n// 平移几何体的顶点坐标,改变几何体自身相对局部坐标原点的位置\ngeometry.translate(50/2,0,0,);;\n\n\n\n# 旋转测试\n\n局部坐标相对模型发生改变，旋转轴自然也会发生变化。\n\n// .rotateY()默认绕几何体中心旋转，经过上面几何体平移变化，你会发现.rotateY()是绕长方体面上一条线旋转\nmesh.rotateY(Math.PI/3);\n\n\n你可以设置旋转动画，观察几何体平移前后旋转动画差异。\n\nfunction render() {\n    model.rotateY(0.01);//旋转动画\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# 改变模型相对局部坐标原点位置\n\n通过改变几何体顶点坐标，可以改变模型自身相对坐标原点的位置。\n\n//长方体的几何中心默认与本地坐标原点重合\nconst geometry = new three.boxgeometry(50, 50, 50);\n\n\n// 平移几何体的顶点坐标,改变几何体自身相对局部坐标原点的位置\ngeometry.translate(50/2,0,0,);;\n\n\n\n# 旋转测试\n\n局部坐标相对模型发生改变，旋转轴自然也会发生变化。\n\n// .rotatey()默认绕几何体中心旋转，经过上面几何体平移变化，你会发现.rotatey()是绕长方体面上一条线旋转\nmesh.rotatey(math.pi/3);\n\n\n你可以设置旋转动画，观察几何体平移前后旋转动画差异。\n\nfunction render() {\n    model.rotatey(0.01);//旋转动画\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"5. 移除对象.remove()",frontmatter:{title:"5. 移除对象.remove()",date:"2023-01-26T14:22:48.000Z",permalink:"/pages/e66ea7/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/04.4.%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/05.%E7%A7%BB%E9%99%A4%E5%AF%B9%E8%B1%A1.remove().html",relativePath:"01.Three.js教程/04.4.层级模型/05.移除对象.remove().md",key:"v-7dc03fae",path:"/pages/e66ea7/",headers:[{level:3,title:"查看父类Object3D的移除方法.remove()",slug:"查看父类object3d的移除方法-remove",normalizedTitle:"查看父类object3d的移除方法.remove()",charIndex:177},{level:3,title:".remove()方法使用",slug:"remove-方法使用",normalizedTitle:".remove()方法使用",charIndex:276},{level:3,title:"一次移除多个子对象",slug:"一次移除多个子对象",normalizedTitle:"一次移除多个子对象",charIndex:560}],headersStr:"查看父类Object3D的移除方法.remove() .remove()方法使用 一次移除多个子对象",content:"# 移除对象.remove()\n\n前面课程给大家讲解过.add()方法,比如可以通过.add()可以把模型或光源添加到场景中。\n\ngroup.add(mesh);\nscene.add(group);\nscene.add(light);\n\n\n.remove()方法和.add()方法是相反的，是把子对象从父对象的.children()属性中删除。\n\n\n# 查看父类Object3D的移除方法.remove()\n\n场景对象Scene、组对象Group、网格模型对象Mesh的.remove()方法都是继承自它们共同的基类(父类)Object3D。\n\n\n# .remove()方法使用\n\n.add()方法是给父对象添加一个子对象，.remove()方法是删除父对象中的一个子对象。\n\n// 删除父对象group的子对象网格模型mesh1\ngroup.remove(mesh1);\n\n\nscene.remove(ambient);//移除场景中环境光\nscene.remove(model);//移除场景中模型对象\n\n\n通过.remove()方法删除父对象的子对象之后，可以通过浏览器控制台查看.children()属性的变化。\n\nconsole.log('查看group的子对象',group.children);\n\n\n\n# 一次移除多个子对象\n\ngroup.remove(mesh1,mesh2);\n",normalizedContent:"# 移除对象.remove()\n\n前面课程给大家讲解过.add()方法,比如可以通过.add()可以把模型或光源添加到场景中。\n\ngroup.add(mesh);\nscene.add(group);\nscene.add(light);\n\n\n.remove()方法和.add()方法是相反的，是把子对象从父对象的.children()属性中删除。\n\n\n# 查看父类object3d的移除方法.remove()\n\n场景对象scene、组对象group、网格模型对象mesh的.remove()方法都是继承自它们共同的基类(父类)object3d。\n\n\n# .remove()方法使用\n\n.add()方法是给父对象添加一个子对象，.remove()方法是删除父对象中的一个子对象。\n\n// 删除父对象group的子对象网格模型mesh1\ngroup.remove(mesh1);\n\n\nscene.remove(ambient);//移除场景中环境光\nscene.remove(model);//移除场景中模型对象\n\n\n通过.remove()方法删除父对象的子对象之后，可以通过浏览器控制台查看.children()属性的变化。\n\nconsole.log('查看group的子对象',group.children);\n\n\n\n# 一次移除多个子对象\n\ngroup.remove(mesh1,mesh2);\n",charsets:{cjk:!0}},{title:"6. 模型隐藏或显示",frontmatter:{title:"6. 模型隐藏或显示",date:"2023-01-26T14:22:48.000Z",permalink:"/pages/eeb05a/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/04.4.%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/06.%E6%A8%A1%E5%9E%8B%E9%9A%90%E8%97%8F%E6%88%96%E6%98%BE%E7%A4%BA.html",relativePath:"01.Three.js教程/04.4.层级模型/06.模型隐藏或显示.md",key:"v-6aa1157e",path:"/pages/eeb05a/",headers:[{level:3,title:"模型属性.visible",slug:"模型属性-visible",normalizedTitle:"模型属性.visible",charIndex:62},{level:3,title:"材质属性.visible",slug:"材质属性-visible",normalizedTitle:"材质属性.visible",charIndex:264}],headersStr:"模型属性.visible 材质属性.visible",content:"# 模型隐藏或显示\n\n开发web3d项目，有时候需要临时隐藏一个模型，或者一个模型处于隐藏状态，需要重新恢复显示。\n\n\n# 模型属性.visible\n\n模型对象的父类Object3D封装了一个属性.visible，通过该属性可以隐藏或显示一个模型。\n\nmesh.visible =false;// 隐藏一个网格模型，visible的默认值是true\ngroup.visible =false;// 隐藏一个包含多个模型的组对象group\n\n\nmesh.visible =true;// 使网格模型mesh处于显示状态\n\n\n\n# 材质属性.visible\n\n材质对象的父类Material封装了一个.visible属性，通过该属性可以控制是否隐藏该材质对应的模型对象。\n\n// 隐藏网格模型mesh，visible的默认值是true\nmesh.material.visible =false;\n// 注意如果mesh2和mesh的.material属性指向同一个材质，mesh2也会跟着mesh隐藏\n\n\n注意:如果多个模型引用了同一个材质，如果该材质.visible设置为false，意味着隐藏绑定该材质的所有模型。",normalizedContent:"# 模型隐藏或显示\n\n开发web3d项目，有时候需要临时隐藏一个模型，或者一个模型处于隐藏状态，需要重新恢复显示。\n\n\n# 模型属性.visible\n\n模型对象的父类object3d封装了一个属性.visible，通过该属性可以隐藏或显示一个模型。\n\nmesh.visible =false;// 隐藏一个网格模型，visible的默认值是true\ngroup.visible =false;// 隐藏一个包含多个模型的组对象group\n\n\nmesh.visible =true;// 使网格模型mesh处于显示状态\n\n\n\n# 材质属性.visible\n\n材质对象的父类material封装了一个.visible属性，通过该属性可以控制是否隐藏该材质对应的模型对象。\n\n// 隐藏网格模型mesh，visible的默认值是true\nmesh.material.visible =false;\n// 注意如果mesh2和mesh的.material属性指向同一个材质，mesh2也会跟着mesh隐藏\n\n\n注意:如果多个模型引用了同一个材质，如果该材质.visible设置为false，意味着隐藏绑定该材质的所有模型。",charsets:{cjk:!0}},{title:"1. 创建纹理贴图",frontmatter:{title:"1. 创建纹理贴图",date:"2023-01-27T14:32:41.000Z",permalink:"/pages/2220d2/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/05.5.%E9%A1%B6%E7%82%B9UV%E5%9D%90%E6%A0%87%E3%80%81%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/01.%E5%88%9B%E5%BB%BA%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE.html",relativePath:"01.Three.js教程/05.5.顶点UV坐标、纹理贴图/01.创建纹理贴图.md",key:"v-797cc37a",path:"/pages/2220d2/",headers:[{level:3,title:"颜色贴图属性.map",slug:"颜色贴图属性-map",normalizedTitle:"颜色贴图属性.map",charIndex:429},{level:3,title:"颜色贴图和color属性颜色值会混合",slug:"颜色贴图和color属性颜色值会混合",normalizedTitle:"颜色贴图和color属性颜色值会混合",charIndex:507},{level:3,title:"测试不同几何体添加纹理贴图的效果",slug:"测试不同几何体添加纹理贴图的效果",normalizedTitle:"测试不同几何体添加纹理贴图的效果",charIndex:852}],headersStr:"颜色贴图属性.map 颜色贴图和color属性颜色值会混合 测试不同几何体添加纹理贴图的效果",content:"# 创建纹理贴图\n\n通过纹理贴图加载器TextureLoader的load()方法加载一张图片可以返回一个纹理对象Texture，纹理对象Texture可以作为模型材质颜色贴图.map属性的值。\n\nconst geometry = new THREE.PlaneGeometry(200, 100); \n//纹理贴图加载器TextureLoader\nconst texLoader = new THREE.TextureLoader();\n// .load()方法加载图像，返回一个纹理对象Texture\nconst texture = texLoader.load('./earth.jpg');\nconst material = new THREE.MeshLambertMaterial({\n    // 设置纹理贴图：Texture对象作为材质map属性的属性值\n    map: texture,//map表示材质的颜色贴图属性\n});\n\n\n\n# 颜色贴图属性.map\n\n也可以通过颜色贴图属性.map直接设置纹理贴图，和材质的参数设置一样。\n\nmaterial.map = texture;\n\n\n\n# 颜色贴图和color属性颜色值会混合\n\n材质的颜色贴图属性.map设置后，模型会从纹理贴图上采集像素值，这时候一般来说不需要再设置材质颜色.color。.map贴图之所以称之为颜色贴图就是因为网格模型会获得颜色贴图的颜色值RGB。\n\n颜色贴图map和color属性颜色值会混合。如果没有特殊需要，设置了颜色贴图.map,不用设置color的值，color默认白色0xffffff。\n\nconst material = new THREE.MeshLambertMaterial({\n    // color: 0x00ffff,\n    // 设置纹理贴图：Texture对象作为材质map属性的属性值\n    map: texture,//map表示材质的颜色贴图属性\n});\n\n\n\n# 测试不同几何体添加纹理贴图的效果\n\n你可以尝试把颜色纹理贴图映射到不同的几何体上查看渲染效果，至于为什么映射效果不同，其实和UV坐标相关，具体可以关注下节课关于UV坐标的讲解。\n\nconst geometry = new THREE.BoxGeometry(100, 100, 100); //长方体\n\n\nconst geometry = new THREE.SphereGeometry(60, 25, 25); //球体\n",normalizedContent:"# 创建纹理贴图\n\n通过纹理贴图加载器textureloader的load()方法加载一张图片可以返回一个纹理对象texture，纹理对象texture可以作为模型材质颜色贴图.map属性的值。\n\nconst geometry = new three.planegeometry(200, 100); \n//纹理贴图加载器textureloader\nconst texloader = new three.textureloader();\n// .load()方法加载图像，返回一个纹理对象texture\nconst texture = texloader.load('./earth.jpg');\nconst material = new three.meshlambertmaterial({\n    // 设置纹理贴图：texture对象作为材质map属性的属性值\n    map: texture,//map表示材质的颜色贴图属性\n});\n\n\n\n# 颜色贴图属性.map\n\n也可以通过颜色贴图属性.map直接设置纹理贴图，和材质的参数设置一样。\n\nmaterial.map = texture;\n\n\n\n# 颜色贴图和color属性颜色值会混合\n\n材质的颜色贴图属性.map设置后，模型会从纹理贴图上采集像素值，这时候一般来说不需要再设置材质颜色.color。.map贴图之所以称之为颜色贴图就是因为网格模型会获得颜色贴图的颜色值rgb。\n\n颜色贴图map和color属性颜色值会混合。如果没有特殊需要，设置了颜色贴图.map,不用设置color的值，color默认白色0xffffff。\n\nconst material = new three.meshlambertmaterial({\n    // color: 0x00ffff,\n    // 设置纹理贴图：texture对象作为材质map属性的属性值\n    map: texture,//map表示材质的颜色贴图属性\n});\n\n\n\n# 测试不同几何体添加纹理贴图的效果\n\n你可以尝试把颜色纹理贴图映射到不同的几何体上查看渲染效果，至于为什么映射效果不同，其实和uv坐标相关，具体可以关注下节课关于uv坐标的讲解。\n\nconst geometry = new three.boxgeometry(100, 100, 100); //长方体\n\n\nconst geometry = new three.spheregeometry(60, 25, 25); //球体\n",charsets:{cjk:!0}},{title:"2. 自定义顶点UV坐标",frontmatter:{title:"2. 自定义顶点UV坐标",date:"2023-01-27T14:32:41.000Z",permalink:"/pages/71e307/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/05.5.%E9%A1%B6%E7%82%B9UV%E5%9D%90%E6%A0%87%E3%80%81%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/02.%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B6%E7%82%B9UV%E5%9D%90%E6%A0%87.html",relativePath:"01.Three.js教程/05.5.顶点UV坐标、纹理贴图/02.自定义顶点UV坐标.md",key:"v-031f2e1d",path:"/pages/71e307/",headers:[{level:3,title:"顶点UV坐标的作用",slug:"顶点uv坐标的作用",normalizedTitle:"顶点uv坐标的作用",charIndex:70},{level:3,title:"纹理贴图UV坐标范围",slug:"纹理贴图uv坐标范围",normalizedTitle:"纹理贴图uv坐标范围",charIndex:385},{level:3,title:"自定义顶点UVgeometry.attributes.uv",slug:"自定义顶点uvgeometry-attributes-uv",normalizedTitle:"自定义顶点uvgeometry.attributes.uv",charIndex:460},{level:3,title:"获取纹理贴图四分之一",slug:"获取纹理贴图四分之一",normalizedTitle:"获取纹理贴图四分之一",charIndex:865}],headersStr:"顶点UV坐标的作用 纹理贴图UV坐标范围 自定义顶点UVgeometry.attributes.uv 获取纹理贴图四分之一",content:"# 自定义顶点UV坐标\n\n学习自定义顶点UV坐标之前，首先保证你对BufferGeometry的顶点数据、纹理贴图都有一定的理解。\n\n\n# 顶点UV坐标的作用\n\n顶点UV坐标的作用是从纹理贴图上提取像素映射到网格模型Mesh的几何体表面上。\n\n浏览器控制台查看threejs几何体默认的UV坐标数据。\n\nconst geometry = new THREE.PlaneGeometry(200, 100); //矩形平面\n// const geometry = new THREE.BoxGeometry(100, 100, 100); //长方体\n// const geometry = new THREE.SphereGeometry(100, 30, 30);//球体\nconsole.log('uv',geometry.attributes.uv);\n\n\n\n# 纹理贴图UV坐标范围\n\n顶点UV坐标可以在0~1.0之间任意取值，纹理贴图左下角对应的UV坐标是(0,0)，右上角对应的坐标(1,1)。\n\n\n\n\n# 自定义顶点UVgeometry.attributes.uv\n\n顶点UV坐标geometry.attributes.uv和顶点位置坐标geometry.attributes.position是一一对应的，\n\nUV顶点坐标你可以根据需要在0~1之间任意设置，具体怎么设置，要看你想把图片的哪部分映射到Mesh的几何体表面上。\n\n/**纹理坐标0~1之间随意定义*/\nconst uvs = new Float32Array([\n    0, 0, //图片左下角\n    1, 0, //图片右下角\n    1, 1, //图片右上角\n    0, 1, //图片左上角\n]);\n// 设置几何体attributes属性的位置normal属性\ngeometry.attributes.uv = new THREE.BufferAttribute(uvs, 2); //2个为一组,表示一个顶点的纹理坐标\n\n\n\n# 获取纹理贴图四分之一\n\n获取纹理贴图左下角四分之一部分的像素值\n\nconst uvs = new Float32Array([\n    0, 0, \n    0.5, 0, \n    0.5, 0.5, \n    0, 0.5, \n]);\n",normalizedContent:"# 自定义顶点uv坐标\n\n学习自定义顶点uv坐标之前，首先保证你对buffergeometry的顶点数据、纹理贴图都有一定的理解。\n\n\n# 顶点uv坐标的作用\n\n顶点uv坐标的作用是从纹理贴图上提取像素映射到网格模型mesh的几何体表面上。\n\n浏览器控制台查看threejs几何体默认的uv坐标数据。\n\nconst geometry = new three.planegeometry(200, 100); //矩形平面\n// const geometry = new three.boxgeometry(100, 100, 100); //长方体\n// const geometry = new three.spheregeometry(100, 30, 30);//球体\nconsole.log('uv',geometry.attributes.uv);\n\n\n\n# 纹理贴图uv坐标范围\n\n顶点uv坐标可以在0~1.0之间任意取值，纹理贴图左下角对应的uv坐标是(0,0)，右上角对应的坐标(1,1)。\n\n\n\n\n# 自定义顶点uvgeometry.attributes.uv\n\n顶点uv坐标geometry.attributes.uv和顶点位置坐标geometry.attributes.position是一一对应的，\n\nuv顶点坐标你可以根据需要在0~1之间任意设置，具体怎么设置，要看你想把图片的哪部分映射到mesh的几何体表面上。\n\n/**纹理坐标0~1之间随意定义*/\nconst uvs = new float32array([\n    0, 0, //图片左下角\n    1, 0, //图片右下角\n    1, 1, //图片右上角\n    0, 1, //图片左上角\n]);\n// 设置几何体attributes属性的位置normal属性\ngeometry.attributes.uv = new three.bufferattribute(uvs, 2); //2个为一组,表示一个顶点的纹理坐标\n\n\n\n# 获取纹理贴图四分之一\n\n获取纹理贴图左下角四分之一部分的像素值\n\nconst uvs = new float32array([\n    0, 0, \n    0.5, 0, \n    0.5, 0.5, \n    0, 0.5, \n]);\n",charsets:{cjk:!0}},{title:"3. 圆形平面设置纹理贴图",frontmatter:{title:"3. 圆形平面设置纹理贴图",date:"2023-01-27T14:32:41.000Z",permalink:"/pages/dcc03b/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/05.5.%E9%A1%B6%E7%82%B9UV%E5%9D%90%E6%A0%87%E3%80%81%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/03.%E5%9C%86%E5%BD%A2%E5%B9%B3%E9%9D%A2CircleGeometry%E8%AE%BE%E7%BD%AE%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE.html",relativePath:"01.Three.js教程/05.5.顶点UV坐标、纹理贴图/03.圆形平面CircleGeometry设置纹理贴图.md",key:"v-250291f2",path:"/pages/dcc03b/",headers:[{level:3,title:"本质原理",slug:"本质原理",normalizedTitle:"本质原理",charIndex:510}],headersStr:"本质原理",content:"# 圆形平面CircleGeometry设置纹理贴图\n\n你可以思考下，怎么实现矩形图片剪裁为圆形渲染。\n\n其实很简单，可以通过圆形几何体CircleGeometry创建一个网格模型Mesh，把一张图片作为圆形Mesh材质的颜色贴图，这样就可以把一张方形图片剪裁渲染为圆形效果。\n\n//CircleGeometry的顶点UV坐标是按照圆形采样纹理贴图\nconst geometry = new THREE.CircleGeometry(60, 100);\n//纹理贴图加载器TextureLoader\nconst texLoader = new THREE.TextureLoader();\nconst texture = texLoader.load('./texture.jpg');\nconst material = new THREE.MeshBasicMaterial({\n    map: texture,//map表示材质的颜色贴图属性\n    side:THREE.DoubleSide,\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n\n# 本质原理\n\nCircleGeometry的UV坐标会对颜色纹理贴图.map进行提取，CircleGeometry的UV坐标默认提取的就是一个圆形轮廓。",normalizedContent:"# 圆形平面circlegeometry设置纹理贴图\n\n你可以思考下，怎么实现矩形图片剪裁为圆形渲染。\n\n其实很简单，可以通过圆形几何体circlegeometry创建一个网格模型mesh，把一张图片作为圆形mesh材质的颜色贴图，这样就可以把一张方形图片剪裁渲染为圆形效果。\n\n//circlegeometry的顶点uv坐标是按照圆形采样纹理贴图\nconst geometry = new three.circlegeometry(60, 100);\n//纹理贴图加载器textureloader\nconst texloader = new three.textureloader();\nconst texture = texloader.load('./texture.jpg');\nconst material = new three.meshbasicmaterial({\n    map: texture,//map表示材质的颜色贴图属性\n    side:three.doubleside,\n});\nconst mesh = new three.mesh(geometry, material);\n\n\n\n# 本质原理\n\ncirclegeometry的uv坐标会对颜色纹理贴图.map进行提取，circlegeometry的uv坐标默认提取的就是一个圆形轮廓。",charsets:{cjk:!0}},{title:"4. 纹理对象Texture阵列",frontmatter:{title:"4. 纹理对象Texture阵列",date:"2023-01-27T14:32:41.000Z",permalink:"/pages/e257c9/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/05.5.%E9%A1%B6%E7%82%B9UV%E5%9D%90%E6%A0%87%E3%80%81%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/04.%E7%BA%B9%E7%90%86%E5%AF%B9%E8%B1%A1Texture%E9%98%B5%E5%88%97(%20%E7%93%B7%E7%A0%96%E5%9C%B0%E9%9D%A2%E6%A1%88%E4%BE%8B%20).html",relativePath:"01.Three.js教程/05.5.顶点UV坐标、纹理贴图/04.纹理对象Texture阵列( 瓷砖地面案例 ).md",key:"v-0672af9c",path:"/pages/e257c9/",headers:[{level:3,title:"矩形平面设置颜色贴图",slug:"矩形平面设置颜色贴图",normalizedTitle:"矩形平面设置颜色贴图",charIndex:89},{level:3,title:"纹理对象Texture的阵列功能",slug:"纹理对象texture的阵列功能",normalizedTitle:"纹理对象texture的阵列功能",charIndex:36},{level:3,title:"旋转矩形平面",slug:"旋转矩形平面",normalizedTitle:"旋转矩形平面",charIndex:720}],headersStr:"矩形平面设置颜色贴图 纹理对象Texture的阵列功能 旋转矩形平面",content:"# 纹理对象Texture阵列( 瓷砖地面案例 )\n\n使用threejs纹理对象Texture的阵列功能+矩形平面几何体PlaneGeometry实现一个地面瓷砖效果。\n\n\n# 矩形平面设置颜色贴图\n\nconst geometry = new THREE.PlaneGeometry(2000, 2000);\n//纹理贴图加载器TextureLoader\nconst texLoader = new THREE.TextureLoader();\n// .load()方法加载图像，返回一个纹理对象Texture\nconst texture = texLoader.load('./瓷砖.jpg');\nconst material = new THREE.MeshLambertMaterial({\n    // 设置纹理贴图：Texture对象作为材质map属性的属性值\n    map: texture,//map表示材质的颜色贴图属性\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n\n# 纹理对象Texture的阵列功能\n\n// .load()方法加载图像，返回一个纹理对象Texture\nconst texture = texLoader.load('./瓷砖.jpg');\n// 设置阵列模式\ntexture.wrapS = THREE.RepeatWrapping;\ntexture.wrapT = THREE.RepeatWrapping;\n// uv两个方向纹理重复数量\ntexture.repeat.set(12,12);//注意选择合适的阵列数量\n\n\n\n# 旋转矩形平面\n\n注意旋转方向影响矩形平面背面还是正面朝上，threejs默认渲染正面，不渲染背面。\n\n// 旋转矩形平面\nmesh.rotateX(-Math.PI/2);\n",normalizedContent:"# 纹理对象texture阵列( 瓷砖地面案例 )\n\n使用threejs纹理对象texture的阵列功能+矩形平面几何体planegeometry实现一个地面瓷砖效果。\n\n\n# 矩形平面设置颜色贴图\n\nconst geometry = new three.planegeometry(2000, 2000);\n//纹理贴图加载器textureloader\nconst texloader = new three.textureloader();\n// .load()方法加载图像，返回一个纹理对象texture\nconst texture = texloader.load('./瓷砖.jpg');\nconst material = new three.meshlambertmaterial({\n    // 设置纹理贴图：texture对象作为材质map属性的属性值\n    map: texture,//map表示材质的颜色贴图属性\n});\nconst mesh = new three.mesh(geometry, material);\n\n\n\n# 纹理对象texture的阵列功能\n\n// .load()方法加载图像，返回一个纹理对象texture\nconst texture = texloader.load('./瓷砖.jpg');\n// 设置阵列模式\ntexture.wraps = three.repeatwrapping;\ntexture.wrapt = three.repeatwrapping;\n// uv两个方向纹理重复数量\ntexture.repeat.set(12,12);//注意选择合适的阵列数量\n\n\n\n# 旋转矩形平面\n\n注意旋转方向影响矩形平面背面还是正面朝上，threejs默认渲染正面，不渲染背面。\n\n// 旋转矩形平面\nmesh.rotatex(-math.pi/2);\n",charsets:{cjk:!0}},{title:"5. 矩形Mesh+背景透明png贴图",frontmatter:{title:"5. 矩形Mesh+背景透明png贴图",date:"2023-01-27T14:32:42.000Z",permalink:"/pages/bf71c4/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/05.5.%E9%A1%B6%E7%82%B9UV%E5%9D%90%E6%A0%87%E3%80%81%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/05.%E7%9F%A9%E5%BD%A2Mesh+%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8Epng%E8%B4%B4%E5%9B%BE(%E5%9C%BA%E6%99%AF%E5%9C%B0%E9%9D%A2%E5%AF%BC%E8%88%AA%E6%A0%87%E6%B3%A8).html",relativePath:"01.Three.js教程/05.5.顶点UV坐标、纹理贴图/05.矩形Mesh+背景透明png贴图(场景地面导航标注).md",key:"v-6e3447f4",path:"/pages/bf71c4/",headers:[{level:3,title:"网格地面辅助观察GridHelper",slug:"网格地面辅助观察gridhelper",normalizedTitle:"网格地面辅助观察gridhelper",charIndex:573},{level:3,title:"矩形平面PlaneGeometry设置颜色贴图",slug:"矩形平面planegeometry设置颜色贴图",normalizedTitle:"矩形平面planegeometry设置颜色贴图",charIndex:682},{level:3,title:"开启透明transparent: true",slug:"开启透明transparent-true",normalizedTitle:"开启透明transparent: true",charIndex:953},{level:3,title:"旋转平移矩形平面",slug:"旋转平移矩形平面",normalizedTitle:"旋转平移矩形平面",charIndex:1148}],headersStr:"网格地面辅助观察GridHelper 矩形平面PlaneGeometry设置颜色贴图 开启透明transparent: true 旋转平移矩形平面",content:"# 矩形Mesh+背景透明png贴图(场景标注)\n\nthree.js项目开发中，把一个背景透明的.png图像作为平面矩形网格模型Mesh的颜色贴图是一个非常有用的功能，通过这样一个功能，可以对three.js三维场景进行标注。\n\n整体思路：创建一个矩形平面，设置颜色贴图.map,注意选择背景透明的.png图像作为颜色贴图，同时材质设置transparent: true，这样png图片背景完全透明的部分不显示。\n\n// 矩形平面网格模型设置背景透明的png贴图\nconst geometry = new THREE.PlaneGeometry(60, 60); //默认在XOY平面上\nconst textureLoader = new THREE.TextureLoader();\nconst material = new THREE.MeshBasicMaterial({\n    map: textureLoader.load('./指南针.png'),        \n    transparent: true, //使用背景透明的png贴图，注意开启透明计算\n});\nconst mesh = new THREE.Mesh(geometry, material);\nmesh.rotateX(-Math.PI / 2);\n\n\n\n# 网格地面辅助观察GridHelper\n\n// 添加一个辅助网格地面\nconst gridHelper = new THREE.GridHelper(300, 25, 0x004444, 0x004444);\n\n\n\n# 矩形平面PlaneGeometry设置颜色贴图\n\nconst geometry = new THREE.PlaneGeometry(60, 60);\nconst textureLoader = new THREE.TextureLoader();\nconst material = new THREE.MeshBasicMaterial({\n    map: textureLoader.load('./指南针.png'),\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n\n# 开启透明transparent: true\n\nconst material = new THREE.MeshBasicMaterial({\n    map: textureLoader.load('./指南针.png'),   \n    //transparent: true：使用背景透明的png贴图，注意允许透明   \n    transparent: true, \n});\n\n\n\n# 旋转平移矩形平面\n\nPlaneGeometry矩形平面默认是在XOY平面上，如果你想平行于XOZ平面，就需要手动旋转。\n\nmesh.rotateX(-Math.PI/2);//平行地面：矩形Mesh默认单面可见，注意旋转-Math.PI / 2\n\n\n如果你不想矩形平面Mesh与地面网格线重合，可以通过位置属性.position偏移。\n\nmesh.position.y = 1;//适当偏移，不与地面重合\n",normalizedContent:"# 矩形mesh+背景透明png贴图(场景标注)\n\nthree.js项目开发中，把一个背景透明的.png图像作为平面矩形网格模型mesh的颜色贴图是一个非常有用的功能，通过这样一个功能，可以对three.js三维场景进行标注。\n\n整体思路：创建一个矩形平面，设置颜色贴图.map,注意选择背景透明的.png图像作为颜色贴图，同时材质设置transparent: true，这样png图片背景完全透明的部分不显示。\n\n// 矩形平面网格模型设置背景透明的png贴图\nconst geometry = new three.planegeometry(60, 60); //默认在xoy平面上\nconst textureloader = new three.textureloader();\nconst material = new three.meshbasicmaterial({\n    map: textureloader.load('./指南针.png'),        \n    transparent: true, //使用背景透明的png贴图，注意开启透明计算\n});\nconst mesh = new three.mesh(geometry, material);\nmesh.rotatex(-math.pi / 2);\n\n\n\n# 网格地面辅助观察gridhelper\n\n// 添加一个辅助网格地面\nconst gridhelper = new three.gridhelper(300, 25, 0x004444, 0x004444);\n\n\n\n# 矩形平面planegeometry设置颜色贴图\n\nconst geometry = new three.planegeometry(60, 60);\nconst textureloader = new three.textureloader();\nconst material = new three.meshbasicmaterial({\n    map: textureloader.load('./指南针.png'),\n});\nconst mesh = new three.mesh(geometry, material);\n\n\n\n# 开启透明transparent: true\n\nconst material = new three.meshbasicmaterial({\n    map: textureloader.load('./指南针.png'),   \n    //transparent: true：使用背景透明的png贴图，注意允许透明   \n    transparent: true, \n});\n\n\n\n# 旋转平移矩形平面\n\nplanegeometry矩形平面默认是在xoy平面上，如果你想平行于xoz平面，就需要手动旋转。\n\nmesh.rotatex(-math.pi/2);//平行地面：矩形mesh默认单面可见，注意旋转-math.pi / 2\n\n\n如果你不想矩形平面mesh与地面网格线重合，可以通过位置属性.position偏移。\n\nmesh.position.y = 1;//适当偏移，不与地面重合\n",charsets:{cjk:!0}},{title:"6. UV动画",frontmatter:{title:"6. UV动画",date:"2023-01-27T14:32:42.000Z",permalink:"/pages/ed1694/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/05.5.%E9%A1%B6%E7%82%B9UV%E5%9D%90%E6%A0%87%E3%80%81%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/06.UV%E5%8A%A8%E7%94%BB.html",relativePath:"01.Three.js教程/05.5.顶点UV坐标、纹理贴图/06.UV动画.md",key:"v-3cd97688",path:"/pages/ed1694/",headers:[{level:3,title:"纹理对象.offset属性",slug:"纹理对象-offset属性",normalizedTitle:"纹理对象.offset属性",charIndex:61},{level:3,title:"纹理对象.wrapS或.wrapT与.offset组合使用",slug:"纹理对象-wraps或-wrapt与-offset组合使用",normalizedTitle:"纹理对象.wraps或.wrapt与.offset组合使用",charIndex:205},{level:3,title:"纹理UV动画",slug:"纹理uv动画",normalizedTitle:"纹理uv动画",charIndex:557},{level:3,title:"纹理贴图阵列 + UV动画",slug:"纹理贴图阵列-uv动画",normalizedTitle:"纹理贴图阵列 + uv动画",charIndex:777}],headersStr:"纹理对象.offset属性 纹理对象.wrapS或.wrapT与.offset组合使用 纹理UV动画 纹理贴图阵列 + UV动画",content:"# UV动画(偏移属性.offset)\n\n本节课通过纹理对象的偏移属性.offset给大家实现一个UV动画效果。\n\n\n# 纹理对象.offset属性\n\n纹理对象Texture的.offset的功能是偏移贴图在Mesh上位置，本质上相当于修改了UV顶点坐标。\n\ntexture.offset.x +=0.5;//纹理U方向偏移\n\n\ntexture.offset.y +=0.5;//纹理V方向偏移\n\n\n\n\n\n# 纹理对象.wrapS或.wrapT与.offset组合使用\n\n你可以对比，当你通过.offset设置了纹理映射偏移后，是否把.wrapS或.wrapT设置为重复映射模式THREE.RepeatWrapping，两种情况的渲染效果差异。\n\ntexture.offset.x +=0.5;//纹理U方向偏移\n// 设置.wrapS也就是U方向，纹理映射模式(包裹模式)\ntexture.wrapS = THREE.RepeatWrapping;//对应offste.x偏移\n\n\ntexture.offset.y +=0.5;//纹理V方向偏移\n// 设置.wrapT也就是V方向，纹理映射模式\ntexture.wrapT = THREE.RepeatWrapping;//对应offste.y偏移\n\n\n\n# 纹理UV动画\n\n纹理对象Texture的.offset的功能是偏移贴图在Mesh上位置。\n\n// 渲染循环\nfunction render() {\n    texture.offset.x +=0.001;//设置纹理动画：偏移量根据纹理和动画需要，设置合适的值\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 纹理贴图阵列 + UV动画\n\n通过阵列纹理贴图设置.map,这样的话贴图像素可以更小一些。\n\n// 设置U方向阵列模式\ntexture.wrapS = THREE.RepeatWrapping;\n// uv两个方向纹理重复数量\ntexture.repeat.x=50;//注意选择合适的阵列数量\n\n\n// 渲染循环\nfunction render() {\n    texture.offset.x +=0.1;//设置纹理动画：偏移量根据纹理和动画需要，设置合适的值\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# uv动画(偏移属性.offset)\n\n本节课通过纹理对象的偏移属性.offset给大家实现一个uv动画效果。\n\n\n# 纹理对象.offset属性\n\n纹理对象texture的.offset的功能是偏移贴图在mesh上位置，本质上相当于修改了uv顶点坐标。\n\ntexture.offset.x +=0.5;//纹理u方向偏移\n\n\ntexture.offset.y +=0.5;//纹理v方向偏移\n\n\n\n\n\n# 纹理对象.wraps或.wrapt与.offset组合使用\n\n你可以对比，当你通过.offset设置了纹理映射偏移后，是否把.wraps或.wrapt设置为重复映射模式three.repeatwrapping，两种情况的渲染效果差异。\n\ntexture.offset.x +=0.5;//纹理u方向偏移\n// 设置.wraps也就是u方向，纹理映射模式(包裹模式)\ntexture.wraps = three.repeatwrapping;//对应offste.x偏移\n\n\ntexture.offset.y +=0.5;//纹理v方向偏移\n// 设置.wrapt也就是v方向，纹理映射模式\ntexture.wrapt = three.repeatwrapping;//对应offste.y偏移\n\n\n\n# 纹理uv动画\n\n纹理对象texture的.offset的功能是偏移贴图在mesh上位置。\n\n// 渲染循环\nfunction render() {\n    texture.offset.x +=0.001;//设置纹理动画：偏移量根据纹理和动画需要，设置合适的值\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 纹理贴图阵列 + uv动画\n\n通过阵列纹理贴图设置.map,这样的话贴图像素可以更小一些。\n\n// 设置u方向阵列模式\ntexture.wraps = three.repeatwrapping;\n// uv两个方向纹理重复数量\ntexture.repeat.x=50;//注意选择合适的阵列数量\n\n\n// 渲染循环\nfunction render() {\n    texture.offset.x +=0.1;//设置纹理动画：偏移量根据纹理和动画需要，设置合适的值\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"1. 建模软件绘制3D场景(Blender)",frontmatter:{title:"1. 建模软件绘制3D场景(Blender)",date:"2023-01-28T16:51:04.000Z",permalink:"/pages/f24993/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/01.%E5%BB%BA%E6%A8%A1%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B63D%E5%9C%BA%E6%99%AF(%E6%AF%94%E5%A6%82Blender).html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/01.建模软件绘制3D场景(比如Blender).md",key:"v-4c46d3c6",path:"/pages/f24993/",headers:[{level:3,title:"三维建模软件作用",slug:"三维建模软件作用",normalizedTitle:"三维建模软件作用",charIndex:63},{level:3,title:"三维建模软件简介",slug:"三维建模软件简介",normalizedTitle:"三维建模软件简介",charIndex:161},{level:3,title:"分工和流程",slug:"分工和流程",normalizedTitle:"分工和流程",charIndex:322},{level:3,title:"程序员学习Blender好处",slug:"程序员学习blender好处",normalizedTitle:"程序员学习blender好处",charIndex:440}],headersStr:"三维建模软件作用 三维建模软件简介 分工和流程 程序员学习Blender好处",content:"# 建模软件绘制3D场景(比如Blender)\n\n这节课主要给大家科普一些三维模型创建、美术和程序员协作的相关问题。\n\n\n# 三维建模软件作用\n\n对于简单的立方体、球体等模型，你可以通过three.js的几何体相关API快速实现，不过复杂的模型，比如一辆轿车、一栋房子、一个仓库，一般需要通过3D建模软件来实现。\n\n\n# 三维建模软件简介\n\n3D美术常用的三维建模软件，比如Blender、3dmax、C4D、maya等等\n\n * Blender(轻量开源)\n * 3dmax\n * C4D\n * maya\n\n特殊行业项目可能涉及到行业软件，比如机械相关、建筑相关\n\n * 机械相关：SW、UG等\n * 建筑相关：草图大师、revit\n\n\n# 分工和流程\n\n * 3D美术：使用三维建模软件绘制3D模型，导出gltf等常见格式\n\n * 程序：加载解析三维软件导出的三维模型\n\n比如使用Blender三维建模软件导出gltf格式模型，然后再通过threejs加载三维模型。\n\n\n# 程序员学习Blender好处\n\n * 3D相关概念，相比较代码，建模软件，更加形象，容易理解\n * Blender与Threejs代码的交互，与美术更好的配合，Blender如何导出模型",normalizedContent:"# 建模软件绘制3d场景(比如blender)\n\n这节课主要给大家科普一些三维模型创建、美术和程序员协作的相关问题。\n\n\n# 三维建模软件作用\n\n对于简单的立方体、球体等模型，你可以通过three.js的几何体相关api快速实现，不过复杂的模型，比如一辆轿车、一栋房子、一个仓库，一般需要通过3d建模软件来实现。\n\n\n# 三维建模软件简介\n\n3d美术常用的三维建模软件，比如blender、3dmax、c4d、maya等等\n\n * blender(轻量开源)\n * 3dmax\n * c4d\n * maya\n\n特殊行业项目可能涉及到行业软件，比如机械相关、建筑相关\n\n * 机械相关：sw、ug等\n * 建筑相关：草图大师、revit\n\n\n# 分工和流程\n\n * 3d美术：使用三维建模软件绘制3d模型，导出gltf等常见格式\n\n * 程序：加载解析三维软件导出的三维模型\n\n比如使用blender三维建模软件导出gltf格式模型，然后再通过threejs加载三维模型。\n\n\n# 程序员学习blender好处\n\n * 3d相关概念，相比较代码，建模软件，更加形象，容易理解\n * blender与threejs代码的交互，与美术更好的配合，blender如何导出模型",charsets:{cjk:!0}},{title:"2. GLTF格式简介 (Web3D领域JPG)",frontmatter:{title:"2. GLTF格式简介 (Web3D领域JPG)",date:"2023-01-28T16:51:14.000Z",permalink:"/pages/2cdb29/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/02.%20GLTF%E6%A0%BC%E5%BC%8F%E7%AE%80%E4%BB%8B%20(Web3D%E9%A2%86%E5%9F%9FJPG).html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/02. GLTF格式简介 (Web3D领域JPG).md",key:"v-54146766",path:"/pages/2cdb29/",headers:[{level:3,title:"gltf格式的重要性",slug:"gltf格式的重要性",normalizedTitle:"gltf格式的重要性",charIndex:61},{level:3,title:"GLTF 2.0",slug:"gltf-2-0",normalizedTitle:"gltf 2.0",charIndex:392},{level:3,title:"gltf包含内容",slug:"gltf包含内容",normalizedTitle:"gltf包含内容",charIndex:525},{level:3,title:"GLTF格式信息",slug:"gltf格式信息",normalizedTitle:"gltf格式信息",charIndex:639},{level:3,title:".bin文件",slug:"bin文件",normalizedTitle:".bin文件",charIndex:1256},{level:3,title:"二进制.glb",slug:"二进制-glb",normalizedTitle:"二进制.glb",charIndex:1610},{level:3,title:"导出gltf",slug:"导出gltf",normalizedTitle:"导出gltf",charIndex:1731},{level:3,title:"Blender导入导出gltf模型文件",slug:"blender导入导出gltf模型文件",normalizedTitle:"blender导入导出gltf模型文件",charIndex:1831}],headersStr:"gltf格式的重要性 GLTF 2.0 gltf包含内容 GLTF格式信息 .bin文件 二进制.glb 导出gltf Blender导入导出gltf模型文件",content:'# GLTF格式简介 (Web3D领域JPG)\n\n本节课算是科普介绍，不用掌握具体的知识细节，大概有个印象即可。\n\n\n# gltf格式的重要性\n\nGLTF格式是新2015发布的三维模型格式，随着物联网、WebGL、5G的进一步发展，会有越来越多的互联网项目Web端引入3D元素，你可以把GLTF格式的三维模型理解为.jpg、.png格式的图片一样，现在的网站，图片基本是标配，对于以后的网站来说如果需要展示一个场景，使用3D来替换图片表达也是很正常的事情。图片有很多格式，对于三维模型自然也是如此，Web开发的时候图片会有常用格式，对于Web3D开发也一样，肯定会根据需要选择一个常见的大家都熟悉的格式，随时时间的发展，GLTF必然称为一个极为重要的标准格式。\n\n不仅three.js，其它的WebGL三维引擎cesium、babylonjs都对gltf格式有良好的的支持。\n\n\n# GLTF 2.0\n\nKhronos Group组织2015发布了GLTF 1.0版本，在2017年又发布了GLTF2.0的版本。\n\n关于glTF的更多介绍和信息，可以查看github：https://github.com/KhronosGroup/glTF\n\n\n# gltf包含内容\n\n相比较obj、stl等格式而言，.gltf格式可以包含更多的模型信息。\n\n.gltf格式文件几乎可以包含所有的三维模型相关信息的数据，比如模型层级关系、PBR材质、纹理贴图、骨骼动画、变形动画...\n\n\n# GLTF格式信息\n\n如果你有一定的前端基础，那么你对JSON一定不陌生，GLTF文件就是通过JSON的键值对方式来表示模型信息，比如meshes表示网格模型信息，materials表示材质信息...\n\n{\n  "asset": {\n    "version": "2.0",\n  },\n...\n// 模型材质信息\n  "materials": [\n    {\n      "pbrMetallicRoughness": {//PBR材质\n        "baseColorFactor": [1,1,0,1],\n        "metallicFactor": 0.5,//金属度\n        "roughnessFactor": 1//粗糙度\n      }\n    }\n  ],\n  // 网格模型数据\n  "meshes": ...\n  // 纹理贴图\n  "images": [\n        {\n            // uri指向外部图像文件\n            "uri": "贴图名称.png"//图像数据也可以直接存储在.gltf文件中\n        }\n   ],\n     "buffers": [\n    // 一个buffer对应一个二进制数据块，可能是顶点位置 、顶点索引等数据\n    {\n      "byteLength": 840,\n     //这里面的顶点数据，也快成单独以.bin文件的形式存在   \n      "uri": "data:application/octet-stream;base64,AAAAPwAAAD8AAAA/AAAAPwAAAD8AAAC/.......\n    }\n  ],\n}\n\n\n\n# .bin文件\n\n有些glTF文件会关联一个或多个.bin文件，.bin文件以二进制形式存储了模型的顶点数据等信息。 .bin文件中的信息其实就是对应gltf文件中的buffers属性，buffers.bin中的模型数据，可以存储在.gltf文件中,也可以单独一个二进制.bin文件。\n\n"buffers": [\n    {\n        "byteLength": 102040,\n        "uri": "文件名.bin"\n    }\n]\n\n\n\n# 二进制.glb\n\ngltf格式文件不一定就是以扩展名.gltf结尾，.glb就是gltf格式的二进制文件。比如你可以把.gltf模型和贴图信息全部合成得到一个.glb文件中，.glb文件相对.gltf文件体积更小，网络传输自然更快。\n\n\n# 导出gltf\n\nblender：最新版本可以直接导出gltf。\n\n3damx gltf相关插件：https://github.com/BabylonJS/Exporters/releases\n\n\n# Blender导入导出gltf模型文件\n\n你可以用Blender软件导出绘制好的三维模型，也可以打开和预览gltf格式文件模型。',normalizedContent:'# gltf格式简介 (web3d领域jpg)\n\n本节课算是科普介绍，不用掌握具体的知识细节，大概有个印象即可。\n\n\n# gltf格式的重要性\n\ngltf格式是新2015发布的三维模型格式，随着物联网、webgl、5g的进一步发展，会有越来越多的互联网项目web端引入3d元素，你可以把gltf格式的三维模型理解为.jpg、.png格式的图片一样，现在的网站，图片基本是标配，对于以后的网站来说如果需要展示一个场景，使用3d来替换图片表达也是很正常的事情。图片有很多格式，对于三维模型自然也是如此，web开发的时候图片会有常用格式，对于web3d开发也一样，肯定会根据需要选择一个常见的大家都熟悉的格式，随时时间的发展，gltf必然称为一个极为重要的标准格式。\n\n不仅three.js，其它的webgl三维引擎cesium、babylonjs都对gltf格式有良好的的支持。\n\n\n# gltf 2.0\n\nkhronos group组织2015发布了gltf 1.0版本，在2017年又发布了gltf2.0的版本。\n\n关于gltf的更多介绍和信息，可以查看github：https://github.com/khronosgroup/gltf\n\n\n# gltf包含内容\n\n相比较obj、stl等格式而言，.gltf格式可以包含更多的模型信息。\n\n.gltf格式文件几乎可以包含所有的三维模型相关信息的数据，比如模型层级关系、pbr材质、纹理贴图、骨骼动画、变形动画...\n\n\n# gltf格式信息\n\n如果你有一定的前端基础，那么你对json一定不陌生，gltf文件就是通过json的键值对方式来表示模型信息，比如meshes表示网格模型信息，materials表示材质信息...\n\n{\n  "asset": {\n    "version": "2.0",\n  },\n...\n// 模型材质信息\n  "materials": [\n    {\n      "pbrmetallicroughness": {//pbr材质\n        "basecolorfactor": [1,1,0,1],\n        "metallicfactor": 0.5,//金属度\n        "roughnessfactor": 1//粗糙度\n      }\n    }\n  ],\n  // 网格模型数据\n  "meshes": ...\n  // 纹理贴图\n  "images": [\n        {\n            // uri指向外部图像文件\n            "uri": "贴图名称.png"//图像数据也可以直接存储在.gltf文件中\n        }\n   ],\n     "buffers": [\n    // 一个buffer对应一个二进制数据块，可能是顶点位置 、顶点索引等数据\n    {\n      "bytelength": 840,\n     //这里面的顶点数据，也快成单独以.bin文件的形式存在   \n      "uri": "data:application/octet-stream;base64,aaaapwaaad8aaaa/aaaapwaaad8aaac/.......\n    }\n  ],\n}\n\n\n\n# .bin文件\n\n有些gltf文件会关联一个或多个.bin文件，.bin文件以二进制形式存储了模型的顶点数据等信息。 .bin文件中的信息其实就是对应gltf文件中的buffers属性，buffers.bin中的模型数据，可以存储在.gltf文件中,也可以单独一个二进制.bin文件。\n\n"buffers": [\n    {\n        "bytelength": 102040,\n        "uri": "文件名.bin"\n    }\n]\n\n\n\n# 二进制.glb\n\ngltf格式文件不一定就是以扩展名.gltf结尾，.glb就是gltf格式的二进制文件。比如你可以把.gltf模型和贴图信息全部合成得到一个.glb文件中，.glb文件相对.gltf文件体积更小，网络传输自然更快。\n\n\n# 导出gltf\n\nblender：最新版本可以直接导出gltf。\n\n3damx gltf相关插件：https://github.com/babylonjs/exporters/releases\n\n\n# blender导入导出gltf模型文件\n\n你可以用blender软件导出绘制好的三维模型，也可以打开和预览gltf格式文件模型。',charsets:{cjk:!0}},{title:"3. 加载.gltf文件(模型加载全流程)",frontmatter:{title:"3. 加载.gltf文件(模型加载全流程)",date:"2023-01-28T16:51:54.000Z",permalink:"/pages/006fcb/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/03.%E5%8A%A0%E8%BD%BD.gltf%E6%96%87%E4%BB%B6(%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD%E5%85%A8%E6%B5%81%E7%A8%8B).html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/03.加载.gltf文件(模型加载全流程).md",key:"v-c0905f02",path:"/pages/006fcb/",headers:[{level:3,title:"1.1.引入GLTFLoader.js",slug:"_1-1-引入gltfloader-js",normalizedTitle:"1.1.引入gltfloader.js",charIndex:187},{level:3,title:"1.2.gltf加载器new GLTFLoader()",slug:"_1-2-gltf加载器new-gltfloader",normalizedTitle:"1.2.gltf加载器new gltfloader()",charIndex:416},{level:3,title:"1.3.gltf加载器方法.load()",slug:"_1-3-gltf加载器方法-load",normalizedTitle:"1.3.gltf加载器方法.load()",charIndex:537},{level:3,title:"相机选择(正投影OrthographicCamera和透视投影PerspectiveCamera)",slug:"相机选择-正投影orthographiccamera和透视投影perspectivecamera",normalizedTitle:"相机选择(正投影orthographiccamera和透视投影perspectivecamera)",charIndex:934},{level:3,title:"尺寸概念",slug:"尺寸概念",normalizedTitle:"尺寸概念",charIndex:1207},{level:3,title:"单位问题",slug:"单位问题",normalizedTitle:"单位问题",charIndex:1331},{level:3,title:"设置合适的相机参数",slug:"设置合适的相机参数",normalizedTitle:"设置合适的相机参数",charIndex:1529},{level:3,title:"2.1.相机位置.position",slug:"_2-1-相机位置-position",normalizedTitle:"2.1.相机位置.position",charIndex:1872},{level:3,title:"2.2 某位置在canvas画布居中",slug:"_2-2-某位置在canvas画布居中",normalizedTitle:"2.2 某位置在canvas画布居中",charIndex:2078},{level:3,title:"2.3.远裁截面far参数",slug:"_2-3-远裁截面far参数",normalizedTitle:"2.3.远裁截面far参数",charIndex:2631},{level:3,title:"3.纹理贴图颜色偏差解决",slug:"_3-纹理贴图颜色偏差解决",normalizedTitle:"3.纹理贴图颜色偏差解决",charIndex:2891}],headersStr:"1.1.引入GLTFLoader.js 1.2.gltf加载器new GLTFLoader() 1.3.gltf加载器方法.load() 相机选择(正投影OrthographicCamera和透视投影PerspectiveCamera) 尺寸概念 单位问题 设置合适的相机参数 2.1.相机位置.position 2.2 某位置在canvas画布居中 2.3.远裁截面far参数 3.纹理贴图颜色偏差解决",content:"# 加载.gltf文件(模型加载全流程)\n\n本节课，以gltf格式为例，给大家讲解加载外部三维模型的整个过程。\n\n场景、光源、渲染器、相机控件等前面说过基础代码，本节课不专门讲解，主要是把下面三部，给大家全流程演示一遍。\n\n 1. gltf模型加载器GLTFLoader.js\n 2. 相机参数根据需要设置\n 3. 加载gltf的时候，webgl渲染器编码方式设置\n\n\n# 1.1.引入GLTFLoader.js\n\n你在three.js官方文件的**examples/jsm/子文件loaders/**目录下，可以找到一个文件GLTFLoader.js，这个文件就是three.js的一个扩展库，专门用来加载gltf格式模型加载器。\n\n// 引入gltf模型加载库GLTFLoader.js\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\n\n\n\n# 1.2.gltf加载器new GLTFLoader()\n\n执行new GLTFLoader()就可以实例化一个gltf的加载器对象。\n\n// 创建GLTF加载器对象\nconst loader = new GLTFLoader();\n\n\n\n# 1.3.gltf加载器方法.load()\n\n通过gltf加载器方法.load()就可以加载外部的gltf模型。\n\n执行方法.load()会返回一个gltf对象，作为参数2函数的参数，改gltf对象可以包含模型、动画等信息，本节课你只需要先了解gltf的场景属性gltf.scene,该属性包含的是模型信息，比如几何体BufferGometry、材质Material、网格模型Mesh。\n\nloader.load( 'gltf模型.gltf', function ( gltf ) {\n  console.log('控制台查看加载gltf文件返回的对象结构',gltf);\n  console.log('gltf对象场景属性',gltf.scene);\n  // 返回的场景对象gltf.scene插入到threejs场景中\n  scene.add( gltf.scene );\n})\n\n\n\n# 相机选择(正投影OrthographicCamera和透视投影PerspectiveCamera)\n\n如果你想预览一个三维场景，一般有正投影相机OrthographicCamera和透视投影相机PerspectiveCamera可供选择。不过大部分3D项目，比如一般都是使用透视投影相机PerspectiveCamera，比如游戏、物联网等项目都会选择透视投影相机PerspectiveCamera。\n\n如果你希望渲染的结果符合人眼的远小近大的规律，毫无疑问要选择透视投影相机，如果不需要模拟人眼远小近大的投影规律，可以选择正投影相机。\n\n\n# 尺寸概念\n\n项目开发的时候，程序员对一个模型或者说一个三维场景要有一个尺寸的概念，不用具体值，要有一个大概印象。\n\n一般通过三维建模软件可以轻松测试测量模型尺寸，比如作为程序员你可以用三维建模软件blender打开gltf模型，测量尺寸。\n\n\n# 单位问题\n\nthree.js的世界并没有任何单位，只有数字大小的运算。\n\nobj、gltf格式的模型信息只有尺寸，并不含单位信息。\n\n不过实际项目开发的时候，一般会定义一个单位，一方面甲方、前端、美术之间更好协调，甚至你自己写代码也要有一个尺寸标准。比如一个园区、工厂，可以m为单位建模，比如建筑、人、相机都用m为尺度去衡量，如果单位不统一，就需要你写代码,通过.scale属性去缩放。\n\n\n# 设置合适的相机参数\n\n通过gltf加载完成，模型后，你还需要根据自身需要，设置合适的相机参数，就好比你拍照，你想拍摄一个石头，肯定要把相机对着石头，如果希望石头在照片上占比大，就要离石头近一些。\n\n相机位置怎么设置，你就类比你的眼睛，如果你想模拟人在3D场景中漫游，那么很简单，你把相机放在地面上，距离地面高度和人身高接近即可。\n\n如果你想看到工厂的全貌，你可以理解为你坐着无人机向下俯瞰，简单说，相比人漫游工厂，整体预览工厂相机距离工厂距离更远一些，否则你也看不到全貌，当然过于远了，你就看不清工厂了。\n\n以课程工厂为例，先设定一个小目标，我们希望工厂能够居中显示在canvas画布上，并且保证可以整体预览。\n\n下面以透视投影相机PerspectiveCamera为例说明。\n\n\n# 2.1.相机位置.position\n\n工厂尺寸范围大概200米数量级，那么如果想整体预览观察工厂所有模型，那很简单，第一步，把camera.position的xyz值统统设置为几百即可，比如(200, 200, 200)。\n\n具体xyz值，你可以通过OrbitControls可视化操作调整，然后浏览器控制台记录相机参数即可。\n\ncamera.position.set(200, 200, 200);\n\n\n\n# 2.2 某位置在canvas画布居中\n\n你需要工厂那个位置在canavs画布上居中，直接把camera.lookAt()指向哪个坐标。\n\n如果美术建模，把工厂整体居中，也就是说模型的几何中心，大概位于世界坐标原点。你设置camera.lookAt(0,0,0),相机视线指向坐标原点。\n\ncamera.lookAt(0, 0, 0);\n\n\n注意相机控件OrbitControls会影响lookAt设置，注意手动设置OrbitControls的目标参数\n\n\ncamera.lookAt(100, 0, 0);\n// 设置相机控件轨道控制器OrbitControls\nconst controls = new OrbitControls(camera, renderer.domElement);\n// 相机控件.target属性在OrbitControls.js内部表示相机目标观察点，默认0,0,0\n// console.log('controls.target', controls.target);\ncontrols.target.set(100, 0, 0);\ncontrols.update();//update()函数内会执行camera.lookAt(controls.targe)\n\n\n\n# 2.3.远裁截面far参数\n\n近裁截面near和远裁截面far，要能包含你想渲染的场景，否则超出视锥体模型会被剪裁掉，简单说near足够小，far足够大，主要是far。\n\nPerspectiveCamera(fov, aspect, near, far)\n\n测量工厂尺寸大概几百的数量级，这里不用测具体尺寸，有个大概数量级即可，然后far设置为3000足够了。\n\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\n\n\n\n# 3.纹理贴图颜色偏差解决\n\nthree.js加载gltf模型的时候，可能会遇到three.js渲染结果颜色偏差，对于这种情况，你只需要修改WebGL渲染器默认的编码方式.outputEncoding即可\n\n//解决加载gltf格式模型纹理贴图和原图不一样问题\nrenderer.outputEncoding = THREE.sRGBEncoding;\n\n\n注意！！！！！！！最新版本属性名字有改变。渲染器属性名.outputEncoding已经变更为.outputColorSpace。\n\n查WebGL渲染器文档，你可以看到.outputColorSpace的默认值就是SRGB颜色空间THREE.SRGBColorSpace，意味着新版本代码中，加载gltf，没有特殊需要，不设置.outputColorSpace也不会引起色差。\n\n//新版本，加载gltf，不需要执行下面代码解决颜色偏差\nrenderer.outputColorSpace = THREE.SRGBColorSpace;//设置为SRGB颜色空间\n",normalizedContent:"# 加载.gltf文件(模型加载全流程)\n\n本节课，以gltf格式为例，给大家讲解加载外部三维模型的整个过程。\n\n场景、光源、渲染器、相机控件等前面说过基础代码，本节课不专门讲解，主要是把下面三部，给大家全流程演示一遍。\n\n 1. gltf模型加载器gltfloader.js\n 2. 相机参数根据需要设置\n 3. 加载gltf的时候，webgl渲染器编码方式设置\n\n\n# 1.1.引入gltfloader.js\n\n你在three.js官方文件的**examples/jsm/子文件loaders/**目录下，可以找到一个文件gltfloader.js，这个文件就是three.js的一个扩展库，专门用来加载gltf格式模型加载器。\n\n// 引入gltf模型加载库gltfloader.js\nimport { gltfloader } from 'three/addons/loaders/gltfloader.js';\n\n\n\n# 1.2.gltf加载器new gltfloader()\n\n执行new gltfloader()就可以实例化一个gltf的加载器对象。\n\n// 创建gltf加载器对象\nconst loader = new gltfloader();\n\n\n\n# 1.3.gltf加载器方法.load()\n\n通过gltf加载器方法.load()就可以加载外部的gltf模型。\n\n执行方法.load()会返回一个gltf对象，作为参数2函数的参数，改gltf对象可以包含模型、动画等信息，本节课你只需要先了解gltf的场景属性gltf.scene,该属性包含的是模型信息，比如几何体buffergometry、材质material、网格模型mesh。\n\nloader.load( 'gltf模型.gltf', function ( gltf ) {\n  console.log('控制台查看加载gltf文件返回的对象结构',gltf);\n  console.log('gltf对象场景属性',gltf.scene);\n  // 返回的场景对象gltf.scene插入到threejs场景中\n  scene.add( gltf.scene );\n})\n\n\n\n# 相机选择(正投影orthographiccamera和透视投影perspectivecamera)\n\n如果你想预览一个三维场景，一般有正投影相机orthographiccamera和透视投影相机perspectivecamera可供选择。不过大部分3d项目，比如一般都是使用透视投影相机perspectivecamera，比如游戏、物联网等项目都会选择透视投影相机perspectivecamera。\n\n如果你希望渲染的结果符合人眼的远小近大的规律，毫无疑问要选择透视投影相机，如果不需要模拟人眼远小近大的投影规律，可以选择正投影相机。\n\n\n# 尺寸概念\n\n项目开发的时候，程序员对一个模型或者说一个三维场景要有一个尺寸的概念，不用具体值，要有一个大概印象。\n\n一般通过三维建模软件可以轻松测试测量模型尺寸，比如作为程序员你可以用三维建模软件blender打开gltf模型，测量尺寸。\n\n\n# 单位问题\n\nthree.js的世界并没有任何单位，只有数字大小的运算。\n\nobj、gltf格式的模型信息只有尺寸，并不含单位信息。\n\n不过实际项目开发的时候，一般会定义一个单位，一方面甲方、前端、美术之间更好协调，甚至你自己写代码也要有一个尺寸标准。比如一个园区、工厂，可以m为单位建模，比如建筑、人、相机都用m为尺度去衡量，如果单位不统一，就需要你写代码,通过.scale属性去缩放。\n\n\n# 设置合适的相机参数\n\n通过gltf加载完成，模型后，你还需要根据自身需要，设置合适的相机参数，就好比你拍照，你想拍摄一个石头，肯定要把相机对着石头，如果希望石头在照片上占比大，就要离石头近一些。\n\n相机位置怎么设置，你就类比你的眼睛，如果你想模拟人在3d场景中漫游，那么很简单，你把相机放在地面上，距离地面高度和人身高接近即可。\n\n如果你想看到工厂的全貌，你可以理解为你坐着无人机向下俯瞰，简单说，相比人漫游工厂，整体预览工厂相机距离工厂距离更远一些，否则你也看不到全貌，当然过于远了，你就看不清工厂了。\n\n以课程工厂为例，先设定一个小目标，我们希望工厂能够居中显示在canvas画布上，并且保证可以整体预览。\n\n下面以透视投影相机perspectivecamera为例说明。\n\n\n# 2.1.相机位置.position\n\n工厂尺寸范围大概200米数量级，那么如果想整体预览观察工厂所有模型，那很简单，第一步，把camera.position的xyz值统统设置为几百即可，比如(200, 200, 200)。\n\n具体xyz值，你可以通过orbitcontrols可视化操作调整，然后浏览器控制台记录相机参数即可。\n\ncamera.position.set(200, 200, 200);\n\n\n\n# 2.2 某位置在canvas画布居中\n\n你需要工厂那个位置在canavs画布上居中，直接把camera.lookat()指向哪个坐标。\n\n如果美术建模，把工厂整体居中，也就是说模型的几何中心，大概位于世界坐标原点。你设置camera.lookat(0,0,0),相机视线指向坐标原点。\n\ncamera.lookat(0, 0, 0);\n\n\n注意相机控件orbitcontrols会影响lookat设置，注意手动设置orbitcontrols的目标参数\n\n\ncamera.lookat(100, 0, 0);\n// 设置相机控件轨道控制器orbitcontrols\nconst controls = new orbitcontrols(camera, renderer.domelement);\n// 相机控件.target属性在orbitcontrols.js内部表示相机目标观察点，默认0,0,0\n// console.log('controls.target', controls.target);\ncontrols.target.set(100, 0, 0);\ncontrols.update();//update()函数内会执行camera.lookat(controls.targe)\n\n\n\n# 2.3.远裁截面far参数\n\n近裁截面near和远裁截面far，要能包含你想渲染的场景，否则超出视锥体模型会被剪裁掉，简单说near足够小，far足够大，主要是far。\n\nperspectivecamera(fov, aspect, near, far)\n\n测量工厂尺寸大概几百的数量级，这里不用测具体尺寸，有个大概数量级即可，然后far设置为3000足够了。\n\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\n\n\n\n# 3.纹理贴图颜色偏差解决\n\nthree.js加载gltf模型的时候，可能会遇到three.js渲染结果颜色偏差，对于这种情况，你只需要修改webgl渲染器默认的编码方式.outputencoding即可\n\n//解决加载gltf格式模型纹理贴图和原图不一样问题\nrenderer.outputencoding = three.srgbencoding;\n\n\n注意！！！！！！！最新版本属性名字有改变。渲染器属性名.outputencoding已经变更为.outputcolorspace。\n\n查webgl渲染器文档，你可以看到.outputcolorspace的默认值就是srgb颜色空间three.srgbcolorspace，意味着新版本代码中，加载gltf，没有特殊需要，不设置.outputcolorspace也不会引起色差。\n\n//新版本，加载gltf，不需要执行下面代码解决颜色偏差\nrenderer.outputcolorspace = three.srgbcolorspace;//设置为srgb颜色空间\n",charsets:{cjk:!0}},{title:"4. OrbitControls辅助设置相机参数",frontmatter:{title:"4. OrbitControls辅助设置相机参数",date:"2023-01-28T14:55:54.000Z",permalink:"/pages/ed32ac/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/04.OrbitControls%E8%BE%85%E5%8A%A9%E8%AE%BE%E7%BD%AE%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0.html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/04.OrbitControls辅助设置相机参数.md",key:"v-0d2bc02d",path:"/pages/ed32ac/",headers:[{level:3,title:"OrbitControls知识点回顾",slug:"orbitcontrols知识点回顾",normalizedTitle:"orbitcontrols知识点回顾",charIndex:89},{level:3,title:"OrbitControls改变相机位置.position",slug:"orbitcontrols改变相机位置-position",normalizedTitle:"orbitcontrols改变相机位置.position",charIndex:197},{level:3,title:"通过OrbitControls设置相机位置.position",slug:"通过orbitcontrols设置相机位置-position",normalizedTitle:"通过orbitcontrols设置相机位置.position",charIndex:492},{level:3,title:"OrbitControls改变相机.lookAt观察目标",slug:"orbitcontrols改变相机-lookat观察目标",normalizedTitle:"orbitcontrols改变相机.lookat观察目标",charIndex:772},{level:3,title:"通过OrbitControls设置.lookAt()参数",slug:"通过orbitcontrols设置-lookat-参数",normalizedTitle:"通过orbitcontrols设置.lookat()参数",charIndex:1066}],headersStr:"OrbitControls知识点回顾 OrbitControls改变相机位置.position 通过OrbitControls设置相机位置.position OrbitControls改变相机.lookAt观察目标 通过OrbitControls设置.lookAt()参数",content:"# OrbitControls辅助设置相机参数\n\n实际开发的时候，一方面可以通过OrbitControls旋转缩放预览3D模型，另一方面也可以辅助你选择合适的相机参数。\n\n\n# OrbitControls知识点回顾\n\n相机控件OrbitControls旋转缩放平移本质上就是在改变相机Camera的参数。\n\n * 旋转：拖动鼠标左键\n * 缩放：滚动鼠标中键\n * 平移：拖动鼠标右键\n\n\n# OrbitControls改变相机位置.position\n\n通过OrbitControls旋转和缩放，本质上就是在改变透视投影相机PerspectiveCamera的位置.position。\n\n渲染循环中不停地打印相机的位置属性，你可以通过相机控件旋转或缩放三维场景，同时通过浏览器控制台观察相机位置变化。\n\nfunction render() {\n  requestAnimationFrame(render);\n  // 浏览器控制台查看相机位置变化\n  console.log('camera.position',camera.position);\n}\nrender();\n\n\n\n# 通过OrbitControls设置相机位置.position\n\n上节课关于相机整体预览三维场景代码设置的时候，第一步是根据渲染范围的数量级，大概设置相机的位置参数，其实第二部，相机位置具体参数，可以借助OrbitControls可视化旋转或缩放，然后选择一个合适的渲染效果，浏览器控制台记录下此时的相机位置。\n\ncamera.position.set(200, 200, 200);//第1步：根据场景渲染范围尺寸设置\ncamera.position.set(-144, 95, 95); //第2步：通过相机控件辅助设置OrbitControls\n\n\n\n# OrbitControls改变相机.lookAt观察目标\n\n通过OrbitControls平移，OrbitControls的.target属性会发生变化，.target属性对应的就是透视投影相机PerspectiveCamera的.lookAt观察目标`。\n\nfunction render() {\n  requestAnimationFrame(render);\n  // 浏览器控制台查看controls.target变化，辅助设置lookAt参数\n  console.log('controls.target',controls.target);\n}\nrender();\n\n\n\n# 通过OrbitControls设置.lookAt()参数\n\n参照OrbitControls设置相机位置.position的过程，你可以平移三维场景，然后选择一个合适的渲染效果，记录下此时相机控件目标属性controls.target的值，然后作为透视投影相机.lookAt()的参数。\n\n注意相机控件OrbitControls会影响lookAt设置，注意手动设置OrbitControls的目标参数\n\n// camera.lookAt(0, 0, 0);\nconst x = -1.2,y = -15,z = 10;//通过OrbitControls辅助设置\ncamera.lookAt(x, y, z);\n\n// 设置相机控件轨道控制器OrbitControls\nconst controls = new OrbitControls(camera, renderer.domElement);\n// 相机控件.target属性在OrbitControls.js内部表示相机目标观察点，默认0,0,0\n// console.log('controls.target', controls.target);\ncontrols.target.set(x, y, z); //与lookAt参数保持一致\ncontrols.update(); //update()函数内会执行camera.lookAt(controls.target)\n",normalizedContent:"# orbitcontrols辅助设置相机参数\n\n实际开发的时候，一方面可以通过orbitcontrols旋转缩放预览3d模型，另一方面也可以辅助你选择合适的相机参数。\n\n\n# orbitcontrols知识点回顾\n\n相机控件orbitcontrols旋转缩放平移本质上就是在改变相机camera的参数。\n\n * 旋转：拖动鼠标左键\n * 缩放：滚动鼠标中键\n * 平移：拖动鼠标右键\n\n\n# orbitcontrols改变相机位置.position\n\n通过orbitcontrols旋转和缩放，本质上就是在改变透视投影相机perspectivecamera的位置.position。\n\n渲染循环中不停地打印相机的位置属性，你可以通过相机控件旋转或缩放三维场景，同时通过浏览器控制台观察相机位置变化。\n\nfunction render() {\n  requestanimationframe(render);\n  // 浏览器控制台查看相机位置变化\n  console.log('camera.position',camera.position);\n}\nrender();\n\n\n\n# 通过orbitcontrols设置相机位置.position\n\n上节课关于相机整体预览三维场景代码设置的时候，第一步是根据渲染范围的数量级，大概设置相机的位置参数，其实第二部，相机位置具体参数，可以借助orbitcontrols可视化旋转或缩放，然后选择一个合适的渲染效果，浏览器控制台记录下此时的相机位置。\n\ncamera.position.set(200, 200, 200);//第1步：根据场景渲染范围尺寸设置\ncamera.position.set(-144, 95, 95); //第2步：通过相机控件辅助设置orbitcontrols\n\n\n\n# orbitcontrols改变相机.lookat观察目标\n\n通过orbitcontrols平移，orbitcontrols的.target属性会发生变化，.target属性对应的就是透视投影相机perspectivecamera的.lookat观察目标`。\n\nfunction render() {\n  requestanimationframe(render);\n  // 浏览器控制台查看controls.target变化，辅助设置lookat参数\n  console.log('controls.target',controls.target);\n}\nrender();\n\n\n\n# 通过orbitcontrols设置.lookat()参数\n\n参照orbitcontrols设置相机位置.position的过程，你可以平移三维场景，然后选择一个合适的渲染效果，记录下此时相机控件目标属性controls.target的值，然后作为透视投影相机.lookat()的参数。\n\n注意相机控件orbitcontrols会影响lookat设置，注意手动设置orbitcontrols的目标参数\n\n// camera.lookat(0, 0, 0);\nconst x = -1.2,y = -15,z = 10;//通过orbitcontrols辅助设置\ncamera.lookat(x, y, z);\n\n// 设置相机控件轨道控制器orbitcontrols\nconst controls = new orbitcontrols(camera, renderer.domelement);\n// 相机控件.target属性在orbitcontrols.js内部表示相机目标观察点，默认0,0,0\n// console.log('controls.target', controls.target);\ncontrols.target.set(x, y, z); //与lookat参数保持一致\ncontrols.update(); //update()函数内会执行camera.lookat(controls.target)\n",charsets:{cjk:!0}},{title:"5. gltf不同文件形式(.glb)",frontmatter:{title:"5. gltf不同文件形式(.glb)",date:"2023-01-28T14:56:51.000Z",permalink:"/pages/24ed9e/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/05.gltf%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E5%BD%A2%E5%BC%8F(.glb%E3%80%81%E8%B4%B4%E5%9B%BE%E3%80%81.bin).html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/05.gltf不同文件形式(.glb、贴图、.bin).md",key:"v-5c2c5da4",path:"/pages/24ed9e/",headers:[{level:3,title:"Blender导出gltf不同形式",slug:"blender导出gltf不同形式",normalizedTitle:"blender导出gltf不同形式",charIndex:224},{level:3,title:".glb文件",slug:"glb文件",normalizedTitle:".glb文件",charIndex:70},{level:3,title:".gltf + .bin + 贴图文件",slug:"gltf-bin-贴图文件",normalizedTitle:".gltf + .bin + 贴图文件",charIndex:80}],headersStr:"Blender导出gltf不同形式 .glb文件 .gltf + .bin + 贴图文件",content:'# .gltf不同文件形式(.glb、贴图、.bin)\n\n.gltf格式模型文件，有不同的组织形式。\n\n * 单独.gltf文件\n * 单独.glb文件\n * .gltf + .bin + 贴图文件\n\n这些不同形式的gltf模型，加载代码其实没啥区别。\n\n// 单独.gltf文件\nloader.load("../../工厂.gltf", function (gltf) { \n    scene.add(gltf.scene);\n})\n\n\n\n# Blender导出gltf不同形式\n\nBlender三维建模软件，可以根据设置，以不同形式导出gltf模型，比如单独导出一个.gltf文件，比如单独导出一个.glb文件，比如导出形式为.gltf + .bin + 贴图多个文件\n\n\n# .glb文件\n\n.glb是gltf格式的二进制形式文件，加载方式和.gltf没啥区别。\n\n// 单独.glb文件\nloader.load("../../工厂.glb", function (gltf) { \n    scene.add(gltf.scene);\n})\n\n\n\n# .gltf + .bin + 贴图文件\n\ngltf模型的一些数据，是可以以单独文件形式存在的，比如纹理贴图单独存在，比如.bin包含gltf的顶点数据。\n\n要注意的就是贴图等数据单独是一个文件的时候，注意不随随意改变子文件相对父文件gltf的目录，以免找不到资源。\n\n// .gltf + .bin + 贴图文件\nloader.load("../../工厂/工厂.gltf", function (gltf) { \n    scene.add(gltf.scene);\n})\n',normalizedContent:'# .gltf不同文件形式(.glb、贴图、.bin)\n\n.gltf格式模型文件，有不同的组织形式。\n\n * 单独.gltf文件\n * 单独.glb文件\n * .gltf + .bin + 贴图文件\n\n这些不同形式的gltf模型，加载代码其实没啥区别。\n\n// 单独.gltf文件\nloader.load("../../工厂.gltf", function (gltf) { \n    scene.add(gltf.scene);\n})\n\n\n\n# blender导出gltf不同形式\n\nblender三维建模软件，可以根据设置，以不同形式导出gltf模型，比如单独导出一个.gltf文件，比如单独导出一个.glb文件，比如导出形式为.gltf + .bin + 贴图多个文件\n\n\n# .glb文件\n\n.glb是gltf格式的二进制形式文件，加载方式和.gltf没啥区别。\n\n// 单独.glb文件\nloader.load("../../工厂.glb", function (gltf) { \n    scene.add(gltf.scene);\n})\n\n\n\n# .gltf + .bin + 贴图文件\n\ngltf模型的一些数据，是可以以单独文件形式存在的，比如纹理贴图单独存在，比如.bin包含gltf的顶点数据。\n\n要注意的就是贴图等数据单独是一个文件的时候，注意不随随意改变子文件相对父文件gltf的目录，以免找不到资源。\n\n// .gltf + .bin + 贴图文件\nloader.load("../../工厂/工厂.gltf", function (gltf) { \n    scene.add(gltf.scene);\n})\n',charsets:{cjk:!0}},{title:"6. 模型命名(程序与美术协作)",frontmatter:{title:"6. 模型命名(程序与美术协作)",date:"2023-01-28T14:56:51.000Z",permalink:"/pages/a4813a/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/06.%E6%A8%A1%E5%9E%8B%E5%91%BD%E5%90%8D(%E7%A8%8B%E5%BA%8F%E4%B8%8E%E7%BE%8E%E6%9C%AF%E5%8D%8F%E4%BD%9C)%E2%80%94%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9.html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/06.模型命名(程序与美术协作)—层级模型节点选择.md",key:"v-54d533e0",path:"/pages/a4813a/",headers:[{level:3,title:"三维软件模型命名",slug:"三维软件模型命名",normalizedTitle:"三维软件模型命名",charIndex:109},{level:3,title:"浏览器控制台查看3D模型树结构",slug:"浏览器控制台查看3d模型树结构",normalizedTitle:"浏览器控制台查看3d模型树结构",charIndex:279},{level:3,title:".getObjectByName()根据.name获取模型节点",slug:"getobjectbyname-根据-name获取模型节点",normalizedTitle:".getobjectbyname()根据.name获取模型节点",charIndex:609},{level:3,title:"分组管理",slug:"分组管理",normalizedTitle:"分组管理",charIndex:908}],headersStr:"三维软件模型命名 浏览器控制台查看3D模型树结构 .getObjectByName()根据.name获取模型节点 分组管理",content:"# 模型命名(程序与美术协作)—层级模型节点选择\n\n开发一些web3d项目，比如一个小区、工厂的可视化，场景中会有多个模型对象，程序员加载三维模型的时候，通过什么方式才能获取到自己想要的某个模型节点是个问题。\n\n\n# 三维软件模型命名\n\n课程提供了一个Blender的模型例子，你可以打开查看。\n\n其实模型节点命名可以类比前后端API接口命名，web3d前端和后端对接需要命名接口，和3D美术对接，同样需要给一些模型节点命名。\n\n * 模型命名可以使用汉字、英文、拼音其他语言形式。\n\n * 如果使用汉字注意，有些三维建模软件可能存在导出乱码问题。\n\n\n# 浏览器控制台查看3D模型树结构\n\n加载gltf模型,通过gltf.scene可以获取模型的数据，你可以通过浏览器控制打印gltf.scene，然后和你三维建模软件中的模型目录树对比，比较两者的结构是否相同。\n\n * 模型父对象节点可以用Object3D对象表示，也可以用组对象Group表示。\n * 通过.children属性可以查看一个父对象模型的的所有子对象。\n * 通过.name属性可以查看模型节点的名称\n\nloader.load(\"./简易小区.glb\", function (gltf) { \n    console.log('场景3D模型树结构', gltf.scene);\n    model.add(gltf.scene);\n})\n\n\n\n# .getObjectByName()根据.name获取模型节点\n\n一般三维建模软件的目录树，都有模型的名称，three.js加载外部模型，外部模型的名称体现为three.js对象的.name属性,three.js可以通过.getObjectByName()方法，把模型节点的名字.name作为改函数参数，快速查找某个模型对象。\n\n// 返回名.name为\"1号楼\"对应的对象\nconst nameNode = gltf.scene.getObjectByName(\"1号楼\");\nnameNode.material.color.set(0xff0000);//改变1号楼Mesh材质颜色\n\n\n\n# 分组管理\n\n对于大类，可以进行分组，这样更好管理，比如高层分为一组，洋房分为一组。如果这样做的好处是，程序员可以通过分类名称，快速获取所有模型，然后进行同样的渲染操作，比如洋房批量改变颜色。\n\n//获得所有'洋房'房子的父对象\nconst obj = gltf.scene.getObjectByName('洋房');\nconsole.log('obj', obj); //控制台查看返回结果\nconsole.log('obj.children', obj.children); \n// obj.children的所有子对象都是Mesh，改变Mesh对应颜色\nobj.children.forEach(function (mesh) {\n    mesh.material.color.set(0xffff00);\n})\n",normalizedContent:"# 模型命名(程序与美术协作)—层级模型节点选择\n\n开发一些web3d项目，比如一个小区、工厂的可视化，场景中会有多个模型对象，程序员加载三维模型的时候，通过什么方式才能获取到自己想要的某个模型节点是个问题。\n\n\n# 三维软件模型命名\n\n课程提供了一个blender的模型例子，你可以打开查看。\n\n其实模型节点命名可以类比前后端api接口命名，web3d前端和后端对接需要命名接口，和3d美术对接，同样需要给一些模型节点命名。\n\n * 模型命名可以使用汉字、英文、拼音其他语言形式。\n\n * 如果使用汉字注意，有些三维建模软件可能存在导出乱码问题。\n\n\n# 浏览器控制台查看3d模型树结构\n\n加载gltf模型,通过gltf.scene可以获取模型的数据，你可以通过浏览器控制打印gltf.scene，然后和你三维建模软件中的模型目录树对比，比较两者的结构是否相同。\n\n * 模型父对象节点可以用object3d对象表示，也可以用组对象group表示。\n * 通过.children属性可以查看一个父对象模型的的所有子对象。\n * 通过.name属性可以查看模型节点的名称\n\nloader.load(\"./简易小区.glb\", function (gltf) { \n    console.log('场景3d模型树结构', gltf.scene);\n    model.add(gltf.scene);\n})\n\n\n\n# .getobjectbyname()根据.name获取模型节点\n\n一般三维建模软件的目录树，都有模型的名称，three.js加载外部模型，外部模型的名称体现为three.js对象的.name属性,three.js可以通过.getobjectbyname()方法，把模型节点的名字.name作为改函数参数，快速查找某个模型对象。\n\n// 返回名.name为\"1号楼\"对应的对象\nconst namenode = gltf.scene.getobjectbyname(\"1号楼\");\nnamenode.material.color.set(0xff0000);//改变1号楼mesh材质颜色\n\n\n\n# 分组管理\n\n对于大类，可以进行分组，这样更好管理，比如高层分为一组，洋房分为一组。如果这样做的好处是，程序员可以通过分类名称，快速获取所有模型，然后进行同样的渲染操作，比如洋房批量改变颜色。\n\n//获得所有'洋房'房子的父对象\nconst obj = gltf.scene.getobjectbyname('洋房');\nconsole.log('obj', obj); //控制台查看返回结果\nconsole.log('obj.children', obj.children); \n// obj.children的所有子对象都是mesh，改变mesh对应颜色\nobj.children.foreach(function (mesh) {\n    mesh.material.color.set(0xffff00);\n})\n",charsets:{cjk:!0}},{title:"7. 递归遍历层级模型修改材质",frontmatter:{title:"7. 递归遍历层级模型修改材质",date:"2023-01-28T14:56:51.000Z",permalink:"/pages/d78052/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/07.%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8.html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/07.递归遍历层级模型修改材质.md",key:"v-3411a9fe",path:"/pages/d78052/",headers:[{level:3,title:"递归遍历方法.traverse()",slug:"递归遍历方法-traverse",normalizedTitle:"递归遍历方法.traverse()",charIndex:67},{level:3,title:"查看gltf默认的材质",slug:"查看gltf默认的材质",normalizedTitle:"查看gltf默认的材质",charIndex:312},{level:3,title:"批量修改gltf所有Mesh的材质",slug:"批量修改gltf所有mesh的材质",normalizedTitle:"批量修改gltf所有mesh的材质",charIndex:666}],headersStr:"递归遍历方法.traverse() 查看gltf默认的材质 批量修改gltf所有Mesh的材质",content:"# 递归遍历层级模型修改材质\n\n加载一个外部模型，比如gltf模型，如果你想批量修改每个Mesh的材质，一个一个设置比较麻烦，可以通过递归遍历方法.traverse()批量操作更加方便。\n\n\n# 递归遍历方法.traverse()\n\n递归遍历gltf所有的模型节点。\n\n// 递归遍历所有模型节点批量修改材质\ngltf.scene.traverse(function(obj) {\n    if (obj.isMesh) {//判断是否是网格模型\n        console.log('模型节点',obj);\n        console.log('模型节点名字',obj.name);\n    }\n});\n\n\n\n# 查看gltf默认的材质\n\n.obj、.gltf、.fbx等不同格式的模型，threejs加载默认的材质可能不同，不过也不用刻意记忆，通过浏览器控制台log打印即可console.log(obj.material)。\n\n\n\nthreejs解析gltf模型默认材质一般是MeshStandardMaterial或MeshPhysicalMaterial，相比较其它网格材质，这两个材质属于PBR物理材质，可以提供更加真实的材质效果\n\n// 递归遍历所有模型节点批量修改材质\ngltf.scene.traverse(function(obj) {\n    if (obj.isMesh) {\n        console.log('gltf默认材质',obj.material);\n    }\n});\n\n\n\n# 批量修改gltf所有Mesh的材质\n\ngltf.scene.traverse(function(obj) {\n    if (obj.isMesh) {\n        // 重新设置材质\n        obj.material = new THREE.MeshLambertMaterial({\n            color:0xffffff,\n        });\n    }\n});\n",normalizedContent:"# 递归遍历层级模型修改材质\n\n加载一个外部模型，比如gltf模型，如果你想批量修改每个mesh的材质，一个一个设置比较麻烦，可以通过递归遍历方法.traverse()批量操作更加方便。\n\n\n# 递归遍历方法.traverse()\n\n递归遍历gltf所有的模型节点。\n\n// 递归遍历所有模型节点批量修改材质\ngltf.scene.traverse(function(obj) {\n    if (obj.ismesh) {//判断是否是网格模型\n        console.log('模型节点',obj);\n        console.log('模型节点名字',obj.name);\n    }\n});\n\n\n\n# 查看gltf默认的材质\n\n.obj、.gltf、.fbx等不同格式的模型，threejs加载默认的材质可能不同，不过也不用刻意记忆，通过浏览器控制台log打印即可console.log(obj.material)。\n\n\n\nthreejs解析gltf模型默认材质一般是meshstandardmaterial或meshphysicalmaterial，相比较其它网格材质，这两个材质属于pbr物理材质，可以提供更加真实的材质效果\n\n// 递归遍历所有模型节点批量修改材质\ngltf.scene.traverse(function(obj) {\n    if (obj.ismesh) {\n        console.log('gltf默认材质',obj.material);\n    }\n});\n\n\n\n# 批量修改gltf所有mesh的材质\n\ngltf.scene.traverse(function(obj) {\n    if (obj.ismesh) {\n        // 重新设置材质\n        obj.material = new three.meshlambertmaterial({\n            color:0xffffff,\n        });\n    }\n});\n",charsets:{cjk:!0}},{title:"8. 外部模型材质是否共享的问题",frontmatter:{title:"8. 外部模型材质是否共享的问题",date:"2023-01-28T14:56:51.000Z",permalink:"/pages/f3c6d0/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/08.%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9E%8B%E6%9D%90%E8%B4%A8%E6%98%AF%E5%90%A6%E5%85%B1%E4%BA%AB%E7%9A%84%E9%97%AE%E9%A2%98.html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/08.外部模型材质是否共享的问题.md",key:"v-88d3b7ec",path:"/pages/f3c6d0/",headers:[{level:3,title:"改变一个模型颜色其它模型跟着变化",slug:"改变一个模型颜色其它模型跟着变化",normalizedTitle:"改变一个模型颜色其它模型跟着变化",charIndex:78},{level:3,title:".name标记材质，判断两个mesh是否共享材质",slug:"name标记材质-判断两个mesh是否共享材质",normalizedTitle:".name标记材质，判断两个mesh是否共享材质",charIndex:275},{level:3,title:"解决问题方向",slug:"解决问题方向",normalizedTitle:"解决问题方向",charIndex:599},{level:3,title:"代码方式解决多个mesh共享材质的问题",slug:"代码方式解决多个mesh共享材质的问题",normalizedTitle:"代码方式解决多个mesh共享材质的问题",charIndex:752}],headersStr:"改变一个模型颜色其它模型跟着变化 .name标记材质，判断两个mesh是否共享材质 解决问题方向 代码方式解决多个mesh共享材质的问题",content:'# 外部模型材质是否共享的问题\n\n美术通过三维建模软件，比如Blender绘制好一个三维场景以后，一些外观一样的Mesh，可能会共享一个材质对象。\n\n\n# 改变一个模型颜色其它模型跟着变化\n\n由于楼房的Mesh共享了1号楼Mesh的材质，当你通过mesh1.material改变mesh1材质，本质上是改变所有楼Mesh的材质。\n\nconst mesh1 = gltf.scene.getObjectByName("1号楼");\n//1. 改变1号楼Mesh材质颜色\nmesh1.material.color.set(0xff0000);\n\n\n\n# .name标记材质，判断两个mesh是否共享材质\n\n通过.name标记材质，测试mesh1和mesh2是否共享了材质\n\nconst mesh1 = gltf.scene.getObjectByName("1号楼");\nmesh1.material.name = \'楼房材质\';//通过name标记mesh1对应材质\nconst mesh2 = gltf.scene.getObjectByName("2号楼");\n//通过name相同，可以判断mesh1.material和mesh2.material共享了同一个材质对象\nconsole.log(\'mesh2.material.name\', mesh2.material.name);\n\n\n\n# 解决问题方向\n\n改变一个模型颜色其它模型跟着变化，是因为多个模型对象共享了材质，如果单独改变一个模型的材质，比如颜色，下面两个方案，可以任选其一。\n\n 1. 三维建模软件中设置，需要代码改变材质的Mesh不要共享材质，要独享材质。\n 2. 代码批量更改：克隆材质对象，重新赋值给mesh的材质属性\n\n\n# 代码方式解决多个mesh共享材质的问题\n\n//用代码方式解决mesh共享材质问题\ngltf.scene.getObjectByName("小区房子").traverse(function (obj) {\n    if (obj.isMesh) {\n        // .material.clone()返回一个新材质对象，和原来一样，重新赋值给.material属性\n        obj.material = obj.material.clone();\n    }\n});\nmesh1.material.color.set(0xffff00);\nmesh2.material.color.set(0x00ff00);\n',normalizedContent:'# 外部模型材质是否共享的问题\n\n美术通过三维建模软件，比如blender绘制好一个三维场景以后，一些外观一样的mesh，可能会共享一个材质对象。\n\n\n# 改变一个模型颜色其它模型跟着变化\n\n由于楼房的mesh共享了1号楼mesh的材质，当你通过mesh1.material改变mesh1材质，本质上是改变所有楼mesh的材质。\n\nconst mesh1 = gltf.scene.getobjectbyname("1号楼");\n//1. 改变1号楼mesh材质颜色\nmesh1.material.color.set(0xff0000);\n\n\n\n# .name标记材质，判断两个mesh是否共享材质\n\n通过.name标记材质，测试mesh1和mesh2是否共享了材质\n\nconst mesh1 = gltf.scene.getobjectbyname("1号楼");\nmesh1.material.name = \'楼房材质\';//通过name标记mesh1对应材质\nconst mesh2 = gltf.scene.getobjectbyname("2号楼");\n//通过name相同，可以判断mesh1.material和mesh2.material共享了同一个材质对象\nconsole.log(\'mesh2.material.name\', mesh2.material.name);\n\n\n\n# 解决问题方向\n\n改变一个模型颜色其它模型跟着变化，是因为多个模型对象共享了材质，如果单独改变一个模型的材质，比如颜色，下面两个方案，可以任选其一。\n\n 1. 三维建模软件中设置，需要代码改变材质的mesh不要共享材质，要独享材质。\n 2. 代码批量更改：克隆材质对象，重新赋值给mesh的材质属性\n\n\n# 代码方式解决多个mesh共享材质的问题\n\n//用代码方式解决mesh共享材质问题\ngltf.scene.getobjectbyname("小区房子").traverse(function (obj) {\n    if (obj.ismesh) {\n        // .material.clone()返回一个新材质对象，和原来一样，重新赋值给.material属性\n        obj.material = obj.material.clone();\n    }\n});\nmesh1.material.color.set(0xffff00);\nmesh2.material.color.set(0x00ff00);\n',charsets:{cjk:!0}},{title:"9. 纹理encoding和渲染器",frontmatter:{title:"9. 纹理encoding和渲染器",date:"2023-01-28T14:56:51.000Z",permalink:"/pages/c2fd5c/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/09.%E7%BA%B9%E7%90%86.encoding%E5%92%8C%E6%B8%B2%E6%9F%93%E5%99%A8.outputEncoding.html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/09.纹理.encoding和渲染器.outputEncoding.md",key:"v-7ca9b8a2",path:"/pages/c2fd5c/",headers:[{level:3,title:"纹理对象Texture颜色空间编码属性.encoding",slug:"纹理对象texture颜色空间编码属性-encoding",normalizedTitle:"纹理对象texture颜色空间编码属性.encoding",charIndex:116},{level:3,title:"浏览器控制台查看Texture.encoding属性值",slug:"浏览器控制台查看texture-encoding属性值",normalizedTitle:"浏览器控制台查看texture.encoding属性值",charIndex:280},{level:3,title:"gltfmap.encoding值",slug:"gltfmap-encoding值",normalizedTitle:"gltfmap.encoding值",charIndex:859},{level:3,title:"WebGL渲染器.outputEncoding",slug:"webgl渲染器-outputencoding",normalizedTitle:"webgl渲染器.outputencoding",charIndex:1254},{level:3,title:"单独加载的颜色贴图设置.encoding = THREE.sRGBEncoding",slug:"单独加载的颜色贴图设置-encoding-three-srgbencoding",normalizedTitle:"单独加载的颜色贴图设置.encoding = three.srgbencoding",charIndex:1581}],headersStr:"纹理对象Texture颜色空间编码属性.encoding 浏览器控制台查看Texture.encoding属性值 gltfmap.encoding值 WebGL渲染器.outputEncoding 单独加载的颜色贴图设置.encoding = THREE.sRGBEncoding",content:"# 纹理.encoding和渲染器.outputEncoding\n\n如果没有特殊需要，一般为了正常渲染，避免颜色偏差，threejs代码中需要颜色贴图.encoding和渲染器.outputEncoding属性值保持一致。\n\n\n# 纹理对象Texture颜色空间编码属性.encoding\n\n纹理对象Texture颜色空间编码属性.encoding有多个属性值，默认值是线性颜色空间THREE.LinearEncoding。\n\n * THREE.LinearEncoding：线性颜色空间\n * THREE.sRGBEncoding：sRGB颜色空间\n\n\n# 浏览器控制台查看Texture.encoding属性值\n\nconst texture = new THREE.TextureLoader().load('./earth.jpg');\ntexture.encoding = THREE.LinearEncoding;//默认值\n// THREE.LinearEncoding变量在threejs内部表示数字3000\nconsole.log('texture.encoding',texture.encoding);\n// 修改为THREE.sRGBEncoding，\ntexture.encoding = THREE.sRGBEncoding;\n// THREE.sRGBEncoding变量在threejs内部表示数字3001\nconsole.log('texture.encoding',texture.encoding);\n\n\nTHREE.LinearEncoding、THREE.sRGBEncoding其实在theeejs内部都表示一个数字,具体可以查看src目录下constants.js的源码文件。\n\n// constants.js源码部分截取\nexport const LinearEncoding = 3000;\nexport const sRGBEncoding = 3001;\n\n\n\n# gltfmap.encoding值\n\nthreejs加载gltf模型，颜色贴图map属性.encoding的默认值是sRGB颜色空间THREE.sRGBEncoding。\n\n// 查看gltf所有颜色贴图的.encoding值\ngltf.scene.traverse(function(obj) {\n    if (obj.isMesh) {\n        if(obj.material.map){//判断是否存在贴图\n            console.log('.encoding',obj.material.map.encoding);\n        }\n    }\n});\n// .encoding显示3001，说明是THREE.sRGBEncoding\nconsole.log('.encoding',mesh.material.map.encoding);\n\n\n\n# WebGL渲染器.outputEncoding\n\n.outputEncoding的默认值是线性空间THREE.LinearEncoding,和纹理对象.encoding默认值一样，如果颜色贴图.encoding的值是THREE.sRGBEncoding，为了避免颜色偏差，.outputEncoding的值也需要设置为THREE.sRGBEncoding。\n\n//解决加载gltf格式模型颜色偏差问题\nrenderer.outputEncoding = THREE.sRGBEncoding;\n\n\n注意！最新版本属性名字有改变。渲染器属性名.outputEncoding已经变更为.outputColorSpace，具体参考6.3小节最后说明。\n\n\n# 单独加载的颜色贴图设置.encoding = THREE.sRGBEncoding\n\n如果webgl渲染器设置了renderer.outputEncoding = THREE.sRGBEncoding;,你单独加载图像返回的纹理对象需要设置 texture.encoding = THREE.sRGBEncoding;\n\n//解决加载gltf格式模型颜色偏差问题\nrenderer.outputEncoding = THREE.sRGBEncoding;\nconst texture = new THREE.TextureLoader().load('./earth.jpg');\n// 和webgl渲染器renderer.outputEncoding一致\ntexture.encoding = THREE.sRGBEncoding;\n\n\n注意！！！最新版本，纹理对象属性名.encoding已经变更为.colorSpace。\n\ntexture.colorSpace  = THREE.SRGBColorSpace;//设置为SRGB颜色空间\n",normalizedContent:"# 纹理.encoding和渲染器.outputencoding\n\n如果没有特殊需要，一般为了正常渲染，避免颜色偏差，threejs代码中需要颜色贴图.encoding和渲染器.outputencoding属性值保持一致。\n\n\n# 纹理对象texture颜色空间编码属性.encoding\n\n纹理对象texture颜色空间编码属性.encoding有多个属性值，默认值是线性颜色空间three.linearencoding。\n\n * three.linearencoding：线性颜色空间\n * three.srgbencoding：srgb颜色空间\n\n\n# 浏览器控制台查看texture.encoding属性值\n\nconst texture = new three.textureloader().load('./earth.jpg');\ntexture.encoding = three.linearencoding;//默认值\n// three.linearencoding变量在threejs内部表示数字3000\nconsole.log('texture.encoding',texture.encoding);\n// 修改为three.srgbencoding，\ntexture.encoding = three.srgbencoding;\n// three.srgbencoding变量在threejs内部表示数字3001\nconsole.log('texture.encoding',texture.encoding);\n\n\nthree.linearencoding、three.srgbencoding其实在theeejs内部都表示一个数字,具体可以查看src目录下constants.js的源码文件。\n\n// constants.js源码部分截取\nexport const linearencoding = 3000;\nexport const srgbencoding = 3001;\n\n\n\n# gltfmap.encoding值\n\nthreejs加载gltf模型，颜色贴图map属性.encoding的默认值是srgb颜色空间three.srgbencoding。\n\n// 查看gltf所有颜色贴图的.encoding值\ngltf.scene.traverse(function(obj) {\n    if (obj.ismesh) {\n        if(obj.material.map){//判断是否存在贴图\n            console.log('.encoding',obj.material.map.encoding);\n        }\n    }\n});\n// .encoding显示3001，说明是three.srgbencoding\nconsole.log('.encoding',mesh.material.map.encoding);\n\n\n\n# webgl渲染器.outputencoding\n\n.outputencoding的默认值是线性空间three.linearencoding,和纹理对象.encoding默认值一样，如果颜色贴图.encoding的值是three.srgbencoding，为了避免颜色偏差，.outputencoding的值也需要设置为three.srgbencoding。\n\n//解决加载gltf格式模型颜色偏差问题\nrenderer.outputencoding = three.srgbencoding;\n\n\n注意！最新版本属性名字有改变。渲染器属性名.outputencoding已经变更为.outputcolorspace，具体参考6.3小节最后说明。\n\n\n# 单独加载的颜色贴图设置.encoding = three.srgbencoding\n\n如果webgl渲染器设置了renderer.outputencoding = three.srgbencoding;,你单独加载图像返回的纹理对象需要设置 texture.encoding = three.srgbencoding;\n\n//解决加载gltf格式模型颜色偏差问题\nrenderer.outputencoding = three.srgbencoding;\nconst texture = new three.textureloader().load('./earth.jpg');\n// 和webgl渲染器renderer.outputencoding一致\ntexture.encoding = three.srgbencoding;\n\n\n注意！！！最新版本，纹理对象属性名.encoding已经变更为.colorspace。\n\ntexture.colorspace  = three.srgbcolorspace;//设置为srgb颜色空间\n",charsets:{cjk:!0}},{title:"10. gltf模型更换.map(纹理.flipY)",frontmatter:{title:"10. gltf模型更换.map(纹理.flipY)",date:"2023-01-28T14:56:00.000Z",permalink:"/pages/cbdb36/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/06.6.%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8%E4%B8%89%E7%BB%B4%E6%A8%A1%E5%9E%8B(gltf)/10.gltf%E6%A8%A1%E5%9E%8B%E6%9B%B4%E6%8D%A2.map(%E7%BA%B9%E7%90%86.flipY%E5%B1%9E%E6%80%A7).html",relativePath:"01.Three.js教程/06.6.加载外部三维模型(gltf)/10.gltf模型更换.map(纹理.flipY属性).md",key:"v-7b3457a0",path:"/pages/cbdb36/",headers:[{level:3,title:"加载颜色贴图.map",slug:"加载颜色贴图-map",normalizedTitle:"加载颜色贴图.map",charIndex:63},{level:3,title:"更换gltf颜色贴图",slug:"更换gltf颜色贴图",normalizedTitle:"更换gltf颜色贴图",charIndex:304},{level:3,title:"纹理对象Texture翻转属性.flipY默认值",slug:"纹理对象texture翻转属性-flipy默认值",normalizedTitle:"纹理对象texture翻转属性.flipy默认值",charIndex:611},{level:3,title:"gltf的贴图翻转属性.flipY默认值",slug:"gltf的贴图翻转属性-flipy默认值",normalizedTitle:"gltf的贴图翻转属性.flipy默认值",charIndex:773}],headersStr:"加载颜色贴图.map 更换gltf颜色贴图 纹理对象Texture翻转属性.flipY默认值 gltf的贴图翻转属性.flipY默认值",content:"# 模型更换.map(纹理.flipY属性)\n\n下面给大家演示如何给gltf的网格模型Mesh更换颜色贴图.map。\n\n\n# 加载颜色贴图.map\n\n注意单独加载的纹理贴图的.encoding和webgl渲染器的.outputEncoding保持一致。\n\nconst texLoader = new THREE.TextureLoader();\nconst texture = texLoader.load('./黑色.png');// 加载手机mesh另一个颜色贴图\ntexture.encoding = THREE.sRGBEncoding; //和渲染器.outputEncoding一样值\n\n\n\n# 更换gltf颜色贴图\n\n执行mesh.material.map = texture;新的纹理对象Texture赋值给.material.map就可以更换材质贴图。\n\nloader.load(\"../手机模型.glb\", function (gltf) {\n    const mesh = gltf.scene.children[0]; //获取Mesh\n    mesh.material.map = texture; //更换不同风格的颜色贴图\n})\n\n\n注意：如果你直接给gltf模型材质设置.map属性更换贴图，会出现纹理贴图错位的问题，这主要和纹理对象Texture的翻转属性.flipY有关。\n\n\n# 纹理对象Texture翻转属性.flipY默认值\n\n.flipY表示是否翻转纹理贴图在Mesh上的显示位置。\n\n纹理对象Texture翻转属性.flipY默认值是true。\n\n// 纹理对象texture.flipY默认值\nconsole.log('texture.flipY', texture.flipY);\n\n\n\n# gltf的贴图翻转属性.flipY默认值\n\ngltf的贴图翻转属性.flipY默认值是false。\n\nloader.load(\"../手机模型.glb\", function (gltf) {\n    const mesh = gltf.scene.children[0]; //获取Mesh\n    console.log('.flipY', mesh.material.map.flipY);\n})\n\n\n如果更换单独加载的纹理贴图，比如颜色贴图.map，注意把纹理贴图.flipY的值设置给gltf中纹理的值false。\n\n//是否翻转纹理贴图\ntexture.flipY = false;\n",normalizedContent:"# 模型更换.map(纹理.flipy属性)\n\n下面给大家演示如何给gltf的网格模型mesh更换颜色贴图.map。\n\n\n# 加载颜色贴图.map\n\n注意单独加载的纹理贴图的.encoding和webgl渲染器的.outputencoding保持一致。\n\nconst texloader = new three.textureloader();\nconst texture = texloader.load('./黑色.png');// 加载手机mesh另一个颜色贴图\ntexture.encoding = three.srgbencoding; //和渲染器.outputencoding一样值\n\n\n\n# 更换gltf颜色贴图\n\n执行mesh.material.map = texture;新的纹理对象texture赋值给.material.map就可以更换材质贴图。\n\nloader.load(\"../手机模型.glb\", function (gltf) {\n    const mesh = gltf.scene.children[0]; //获取mesh\n    mesh.material.map = texture; //更换不同风格的颜色贴图\n})\n\n\n注意：如果你直接给gltf模型材质设置.map属性更换贴图，会出现纹理贴图错位的问题，这主要和纹理对象texture的翻转属性.flipy有关。\n\n\n# 纹理对象texture翻转属性.flipy默认值\n\n.flipy表示是否翻转纹理贴图在mesh上的显示位置。\n\n纹理对象texture翻转属性.flipy默认值是true。\n\n// 纹理对象texture.flipy默认值\nconsole.log('texture.flipy', texture.flipy);\n\n\n\n# gltf的贴图翻转属性.flipy默认值\n\ngltf的贴图翻转属性.flipy默认值是false。\n\nloader.load(\"../手机模型.glb\", function (gltf) {\n    const mesh = gltf.scene.children[0]; //获取mesh\n    console.log('.flipy', mesh.material.map.flipy);\n})\n\n\n如果更换单独加载的纹理贴图，比如颜色贴图.map，注意把纹理贴图.flipy的值设置给gltf中纹理的值false。\n\n//是否翻转纹理贴图\ntexture.flipy = false;\n",charsets:{cjk:!0}},{title:"1. PBR材质简介",frontmatter:{title:"1. PBR材质简介",date:"2023-01-29T14:58:12.000Z",permalink:"/pages/56b66b/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/07.7.PBR%E6%9D%90%E8%B4%A8%E4%B8%8E%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/01.PBR%E6%9D%90%E8%B4%A8%E7%AE%80%E4%BB%8B.html",relativePath:"01.Three.js教程/07.7.PBR材质与纹理贴图/01.PBR材质简介.md",key:"v-fe4e97a4",path:"/pages/56b66b/",headers:[{level:3,title:"光照模型",slug:"光照模型",normalizedTitle:"光照模型",charIndex:220},{level:3,title:"PBR相关理论介绍文章",slug:"pbr相关理论介绍文章",normalizedTitle:"pbr相关理论介绍文章",charIndex:547},{level:3,title:"网格模型材质整体回顾",slug:"网格模型材质整体回顾",normalizedTitle:"网格模型材质整体回顾",charIndex:722},{level:3,title:"渲染占用资源和表现能力",slug:"渲染占用资源和表现能力",normalizedTitle:"渲染占用资源和表现能力",charIndex:1054}],headersStr:"光照模型 PBR相关理论介绍文章 网格模型材质整体回顾 渲染占用资源和表现能力",content:"# Three.js PBR材质简介\n\n本节课没有具体的代码，就是给大家科普一下PBR材质，所谓PBR就是，基于物理的渲染(physically-based rendering)。\n\nThree.js提供了两个PBR材质相关的APIMeshStandardMaterial和MeshPhysicalMaterial,MeshPhysicalMaterial是MeshStandardMaterial扩展的子类，提供了更多功能属性。\n\n\n# 光照模型\n\n如果你有初高中最基本的物理光学知识，应该有折射、镜面反射、漫反射等基本光学概念，对于实际生活中的光学问题，Three.js会提供一些的光照模型来模拟物体表面的光照，光照模型就一种模拟光照的计算方法。MeshPhysicalMaterial和MeshLambertMaterial一样都是渲染网格模型的材质，但是他们用的光照模型不同，具体点说就是材质模拟Mesh反射光照的代码算法不同，算法不同，自然模拟光照的真实程度也不同。\n\n如果你想深入研究光照模型，可以学习下原生WebGL或WebGPU，或者看看计算机图形学相关书籍，使用threejs的大部分情况，用不着你自己实现光照模型算法，毕竟threejs通过网格模型材质帮你实现了。\n\n\n# PBR相关理论介绍文章\n\n * 半小时了解PBR：https://zhuanlan.zhihu.com/p/37639418\n * PBR知识体系整理：https://zhuanlan.zhihu.com/p/100596453\n * PBR核心知识体系总结与概览：https://zhuanlan.zhihu.com/p/53086060\n\n\n# 网格模型材质整体回顾\n\n\n\n * MeshLambertMaterial: Lambert光照模型(漫反射)\n\n * MeshPhongMaterial：Phong光照模型(漫反射、高光反射)\n\n * MeshStandardMaterial和MeshPhysicalMaterial：基于物理的光照模型(微平面理论、能量守恒、菲涅尔反射...)\n\nPBR材质相比MeshLambertMaterial和MeshPhongMaterial可以提供更逼真的、更接近生活中的材质效果，当然也会占用更多的电脑硬件资源。\n\n通过MeshPhysicalMaterial文档，提供的资源，可以查看多个PBR材质的案例效果，系统课程中轿车展示案例也会用到PBR材质。\n\n\n# 渲染占用资源和表现能力\n\n整体上来看，就是渲染表现能力越强，占用的计算机硬件资源更多。\n\n * 占用渲染资源 MeshBasicMaterial < MeshLambertMaterial < MeshPhongMaterial < MeshStandardMaterial < MeshPhysicalMaterial\n\n * 渲染表现能力 MeshBasicMaterial < MeshLambertMaterial < MeshPhongMaterial < MeshStandardMaterial < MeshPhysicalMaterial",normalizedContent:"# three.js pbr材质简介\n\n本节课没有具体的代码，就是给大家科普一下pbr材质，所谓pbr就是，基于物理的渲染(physically-based rendering)。\n\nthree.js提供了两个pbr材质相关的apimeshstandardmaterial和meshphysicalmaterial,meshphysicalmaterial是meshstandardmaterial扩展的子类，提供了更多功能属性。\n\n\n# 光照模型\n\n如果你有初高中最基本的物理光学知识，应该有折射、镜面反射、漫反射等基本光学概念，对于实际生活中的光学问题，three.js会提供一些的光照模型来模拟物体表面的光照，光照模型就一种模拟光照的计算方法。meshphysicalmaterial和meshlambertmaterial一样都是渲染网格模型的材质，但是他们用的光照模型不同，具体点说就是材质模拟mesh反射光照的代码算法不同，算法不同，自然模拟光照的真实程度也不同。\n\n如果你想深入研究光照模型，可以学习下原生webgl或webgpu，或者看看计算机图形学相关书籍，使用threejs的大部分情况，用不着你自己实现光照模型算法，毕竟threejs通过网格模型材质帮你实现了。\n\n\n# pbr相关理论介绍文章\n\n * 半小时了解pbr：https://zhuanlan.zhihu.com/p/37639418\n * pbr知识体系整理：https://zhuanlan.zhihu.com/p/100596453\n * pbr核心知识体系总结与概览：https://zhuanlan.zhihu.com/p/53086060\n\n\n# 网格模型材质整体回顾\n\n\n\n * meshlambertmaterial: lambert光照模型(漫反射)\n\n * meshphongmaterial：phong光照模型(漫反射、高光反射)\n\n * meshstandardmaterial和meshphysicalmaterial：基于物理的光照模型(微平面理论、能量守恒、菲涅尔反射...)\n\npbr材质相比meshlambertmaterial和meshphongmaterial可以提供更逼真的、更接近生活中的材质效果，当然也会占用更多的电脑硬件资源。\n\n通过meshphysicalmaterial文档，提供的资源，可以查看多个pbr材质的案例效果，系统课程中轿车展示案例也会用到pbr材质。\n\n\n# 渲染占用资源和表现能力\n\n整体上来看，就是渲染表现能力越强，占用的计算机硬件资源更多。\n\n * 占用渲染资源 meshbasicmaterial < meshlambertmaterial < meshphongmaterial < meshstandardmaterial < meshphysicalmaterial\n\n * 渲染表现能力 meshbasicmaterial < meshlambertmaterial < meshphongmaterial < meshstandardmaterial < meshphysicalmaterial",charsets:{cjk:!0}},{title:"2. PBR材质金属度和粗糙度",frontmatter:{title:"2. PBR材质金属度和粗糙度",date:"2023-01-29T14:58:12.000Z",permalink:"/pages/ca9079/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/07.7.PBR%E6%9D%90%E8%B4%A8%E4%B8%8E%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/02.PBR%E6%9D%90%E8%B4%A8%E9%87%91%E5%B1%9E%E5%BA%A6%E5%92%8C%E7%B2%97%E7%B3%99%E5%BA%A6(%E9%87%91%E5%B1%9E%E6%95%88%E6%9E%9C).html",relativePath:"01.Three.js教程/07.7.PBR材质与纹理贴图/02.PBR材质金属度和粗糙度(金属效果).md",key:"v-ab57bc80",path:"/pages/ca9079/",headers:[{level:3,title:"金属度metalness",slug:"金属度metalness",normalizedTitle:"金属度metalness",charIndex:55},{level:3,title:"粗糙度roughness",slug:"粗糙度roughness",normalizedTitle:"粗糙度roughness",charIndex:68}],headersStr:"金属度metalness 粗糙度roughness",content:"# PBR材质金属度和粗糙度(金属效果)\n\n本节课给大家介绍PBR材质MeshStandardMaterial金属度metalness和粗糙度roughness,再加上下节课讲解的环境贴图.envMap,给大家呈现一个金属渲染效果。\n\n\n# 金属度metalness\n\n金属度属性.metalness表示材质像金属的程度, 非金属材料,如木材或石材,使用0.0,金属使用1.0。\n\nthreejs的PBR材质，.metalness默认是0.5,0.0到1.0之间的值可用于生锈的金属外观\n\nnew THREE.MeshStandardMaterial({\n    metalness: 1.0,//金属度属性\n})\n\n\nmesh.material.metalness = 1.0;//金属度\n\n\n\n# 粗糙度roughness\n\n生活中不同物体表面的粗糙程度不同，比如地面比较粗糙，比如镜子表面就非常非常光滑。\n\n粗糙度roughness表示模型表面的光滑或者说粗糙程度，越光滑镜面反射能力越强，越粗糙，表面镜面反射能力越弱，更多地表现为漫反射。\n\n粗糙度roughness,0.0表示平滑的镜面反射,1.0表示完全漫反射,默认0.5。\n\nnew THREE.MeshStandardMaterial({\n    roughness: 0.5,//表面粗糙度\n})\n\n\nmesh.material.roughness = 0.5;//表面粗糙度\n",normalizedContent:"# pbr材质金属度和粗糙度(金属效果)\n\n本节课给大家介绍pbr材质meshstandardmaterial金属度metalness和粗糙度roughness,再加上下节课讲解的环境贴图.envmap,给大家呈现一个金属渲染效果。\n\n\n# 金属度metalness\n\n金属度属性.metalness表示材质像金属的程度, 非金属材料,如木材或石材,使用0.0,金属使用1.0。\n\nthreejs的pbr材质，.metalness默认是0.5,0.0到1.0之间的值可用于生锈的金属外观\n\nnew three.meshstandardmaterial({\n    metalness: 1.0,//金属度属性\n})\n\n\nmesh.material.metalness = 1.0;//金属度\n\n\n\n# 粗糙度roughness\n\n生活中不同物体表面的粗糙程度不同，比如地面比较粗糙，比如镜子表面就非常非常光滑。\n\n粗糙度roughness表示模型表面的光滑或者说粗糙程度，越光滑镜面反射能力越强，越粗糙，表面镜面反射能力越弱，更多地表现为漫反射。\n\n粗糙度roughness,0.0表示平滑的镜面反射,1.0表示完全漫反射,默认0.5。\n\nnew three.meshstandardmaterial({\n    roughness: 0.5,//表面粗糙度\n})\n\n\nmesh.material.roughness = 0.5;//表面粗糙度\n",charsets:{cjk:!0}},{title:"3. 环境贴图.envMap(金属效果)",frontmatter:{title:"3. 环境贴图.envMap(金属效果)",date:"2023-01-29T14:58:12.000Z",permalink:"/pages/780376/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/07.7.PBR%E6%9D%90%E8%B4%A8%E4%B8%8E%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/03.%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE.envMap(%E9%87%91%E5%B1%9E%E6%95%88%E6%9E%9C).html",relativePath:"01.Three.js教程/07.7.PBR材质与纹理贴图/03.环境贴图.envMap(金属效果).md",key:"v-11dd13bf",path:"/pages/780376/",headers:[{level:3,title:"立方体纹理加载器CubeTextureLoader",slug:"立方体纹理加载器cubetextureloader",normalizedTitle:"立方体纹理加载器cubetextureloader",charIndex:75},{level:3,title:"CubeTextureLoader加载环境贴图",slug:"cubetextureloader加载环境贴图",normalizedTitle:"cubetextureloader加载环境贴图",charIndex:339},{level:3,title:"MeshStandardMaterial环境贴图属性.envMap",slug:"meshstandardmaterial环境贴图属性-envmap",normalizedTitle:"meshstandardmaterial环境贴图属性.envmap",charIndex:795},{level:3,title:"环境贴图反射率.envMapIntensity",slug:"环境贴图反射率-envmapintensity",normalizedTitle:"环境贴图反射率.envmapintensity",charIndex:1341},{level:3,title:"粗糙度roughness为0",slug:"粗糙度roughness为0",normalizedTitle:"粗糙度roughness为0",charIndex:1604},{level:3,title:"选择合适的环境贴图",slug:"选择合适的环境贴图",normalizedTitle:"选择合适的环境贴图",charIndex:1709},{level:3,title:"纹理和渲染器颜色空间一致",slug:"纹理和渲染器颜色空间一致",normalizedTitle:"纹理和渲染器颜色空间一致",charIndex:1829}],headersStr:"立方体纹理加载器CubeTextureLoader CubeTextureLoader加载环境贴图 MeshStandardMaterial环境贴图属性.envMap 环境贴图反射率.envMapIntensity 粗糙度roughness为0 选择合适的环境贴图 纹理和渲染器颜色空间一致",content:"# 环境贴图.envMap(金属效果)\n\n环境贴图对PBR材质渲染效果影响还是比较大，一般渲染PBR材质的模型，最好设置一个合适的环境贴图。\n\n\n# 立方体纹理加载器CubeTextureLoader\n\n * TextureLoader返回Texture\n * CubeTextureLoader返回CubeTexture\n\n通过前面学习大家知道，通过纹理贴图加载器TextureLoader的.load()方法加载一张图片可以返回一个纹理对象Texture。\n\n立方体纹理加载器CubeTextureLoader的.load()方法是加载6张图片，返回一个立方体纹理对象CubeTexture。\n\n立方体纹理对象CubeTexture的父类是纹理对象Texture。\n\n\n# CubeTextureLoader加载环境贴图\n\n所谓环境贴图，就是一个模型周围的环境的图像，比如一间房子，房子的上下左右前后分别拍摄一张照片，就是3D空间中6个角度方向的照片。\n\n// 加载环境贴图\n// 加载周围环境6个方向贴图\n// 上下左右前后6张贴图构成一个立方体空间\n// 'px.jpg', 'nx.jpg'：x轴正方向、负方向贴图  p:正positive  n:负negative\n// 'py.jpg', 'ny.jpg'：y轴贴图\n// 'pz.jpg', 'nz.jpg'：z轴贴图\nconst textureCube = new THREE.CubeTextureLoader()\n    .setPath('./环境贴图/环境贴图0/')\n    .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);\n    // CubeTexture表示立方体纹理对象，父类是纹理对象Texture \n\n\n\n# MeshStandardMaterial环境贴图属性.envMap\n\n实际生活中，一个物体表面，往往会反射周围的环境。人的眼睛看到的东西，往往反射有周围景物，所以three.js渲染模型，如果想渲染效果更好看，如果想更符合实际生活情况，也需要想办法让模型反射周围景物。\n\nMeshStandardMaterial材质的环境贴图属性是.envMap，通过PBR材质的贴图属性可以实现模型表面反射周围景物，这样渲染效果更好。\n\n// 加载环境贴图\nconst textureCube = new THREE.CubeTextureLoader()\n    .setPath('./环境贴图/环境贴图0/')\n    .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);\nnew THREE.MeshStandardMaterial({\n    metalness: 1.0,\n    roughness: 0.5,\n    envMap: textureCube, //设置pbr材质环境贴图\n})    \n\n\nobj.material.envMap = textureCube; //设置环境贴图 \n\n\n\n# 环境贴图反射率.envMapIntensity\n\nMeshStandardMaterial的.envMapIntensity属性主要用来设置模型表面反射周围环境贴图的能力，或者说环境贴图对模型表面的影响能力。具体说.envMapIntensity相当于环境贴图的系数，环境贴图像素值乘以该系数后，在用于影响模型表面。\n\n// envMapIntensity：控制环境贴图对mesh表面影响程度\n//默认值1, 设置为0.0,相当于没有环境贴图\nobj.material.envMapIntensity = 1.0;\n\n\n\n# 粗糙度roughness为0\n\n你可以尝试把粗糙度roughness设置为0，看看模型对环境贴图的反射效果。\n\nobj.material.roughness = 0.0;//完全镜面反射，像镜子一样\n\n\n\n# 选择合适的环境贴图\n\n不同的明暗或景物的环境贴图对渲染效果的影响是不一样的，所以不仅要设置环境贴图，还要根据需要选择合适的环境贴图，一般实际开发使用美术提供的环境贴图即可。\n\n你可以尝试测试源码中提供多个环境贴图对比渲染效果差异。\n\n\n# 纹理和渲染器颜色空间一致\n\n//如果renderer.outputEncoding=THREE.sRGBEncoding;环境贴图需要保持一致\ntextureCube.encoding = THREE.sRGBEncoding;   \n",normalizedContent:"# 环境贴图.envmap(金属效果)\n\n环境贴图对pbr材质渲染效果影响还是比较大，一般渲染pbr材质的模型，最好设置一个合适的环境贴图。\n\n\n# 立方体纹理加载器cubetextureloader\n\n * textureloader返回texture\n * cubetextureloader返回cubetexture\n\n通过前面学习大家知道，通过纹理贴图加载器textureloader的.load()方法加载一张图片可以返回一个纹理对象texture。\n\n立方体纹理加载器cubetextureloader的.load()方法是加载6张图片，返回一个立方体纹理对象cubetexture。\n\n立方体纹理对象cubetexture的父类是纹理对象texture。\n\n\n# cubetextureloader加载环境贴图\n\n所谓环境贴图，就是一个模型周围的环境的图像，比如一间房子，房子的上下左右前后分别拍摄一张照片，就是3d空间中6个角度方向的照片。\n\n// 加载环境贴图\n// 加载周围环境6个方向贴图\n// 上下左右前后6张贴图构成一个立方体空间\n// 'px.jpg', 'nx.jpg'：x轴正方向、负方向贴图  p:正positive  n:负negative\n// 'py.jpg', 'ny.jpg'：y轴贴图\n// 'pz.jpg', 'nz.jpg'：z轴贴图\nconst texturecube = new three.cubetextureloader()\n    .setpath('./环境贴图/环境贴图0/')\n    .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);\n    // cubetexture表示立方体纹理对象，父类是纹理对象texture \n\n\n\n# meshstandardmaterial环境贴图属性.envmap\n\n实际生活中，一个物体表面，往往会反射周围的环境。人的眼睛看到的东西，往往反射有周围景物，所以three.js渲染模型，如果想渲染效果更好看，如果想更符合实际生活情况，也需要想办法让模型反射周围景物。\n\nmeshstandardmaterial材质的环境贴图属性是.envmap，通过pbr材质的贴图属性可以实现模型表面反射周围景物，这样渲染效果更好。\n\n// 加载环境贴图\nconst texturecube = new three.cubetextureloader()\n    .setpath('./环境贴图/环境贴图0/')\n    .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);\nnew three.meshstandardmaterial({\n    metalness: 1.0,\n    roughness: 0.5,\n    envmap: texturecube, //设置pbr材质环境贴图\n})    \n\n\nobj.material.envmap = texturecube; //设置环境贴图 \n\n\n\n# 环境贴图反射率.envmapintensity\n\nmeshstandardmaterial的.envmapintensity属性主要用来设置模型表面反射周围环境贴图的能力，或者说环境贴图对模型表面的影响能力。具体说.envmapintensity相当于环境贴图的系数，环境贴图像素值乘以该系数后，在用于影响模型表面。\n\n// envmapintensity：控制环境贴图对mesh表面影响程度\n//默认值1, 设置为0.0,相当于没有环境贴图\nobj.material.envmapintensity = 1.0;\n\n\n\n# 粗糙度roughness为0\n\n你可以尝试把粗糙度roughness设置为0，看看模型对环境贴图的反射效果。\n\nobj.material.roughness = 0.0;//完全镜面反射，像镜子一样\n\n\n\n# 选择合适的环境贴图\n\n不同的明暗或景物的环境贴图对渲染效果的影响是不一样的，所以不仅要设置环境贴图，还要根据需要选择合适的环境贴图，一般实际开发使用美术提供的环境贴图即可。\n\n你可以尝试测试源码中提供多个环境贴图对比渲染效果差异。\n\n\n# 纹理和渲染器颜色空间一致\n\n//如果renderer.outputencoding=three.srgbencoding;环境贴图需要保持一致\ntexturecube.encoding = three.srgbencoding;   \n",charsets:{cjk:!0}},{title:"5. MeshPhysicalMaterial清漆层",frontmatter:{title:"5. MeshPhysicalMaterial清漆层",date:"2023-01-29T14:58:12.000Z",permalink:"/pages/121b10/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/07.7.PBR%E6%9D%90%E8%B4%A8%E4%B8%8E%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/05.MeshPhysicalMaterial%E6%B8%85%E6%BC%86%E5%B1%82Clearcoat.html",relativePath:"01.Three.js教程/07.7.PBR材质与纹理贴图/05.MeshPhysicalMaterial清漆层Clearcoat.md",key:"v-054810aa",path:"/pages/121b10/",headers:[{level:3,title:"清漆层属性.clearcoat",slug:"清漆层属性-clearcoat",normalizedTitle:"清漆层属性.clearcoat",charIndex:297},{level:3,title:"清漆层粗糙度.clearcoatRoughness",slug:"清漆层粗糙度-clearcoatroughness",normalizedTitle:"清漆层粗糙度.clearcoatroughness",charIndex:489},{level:3,title:"车外壳PBR材质设置",slug:"车外壳pbr材质设置",normalizedTitle:"车外壳pbr材质设置",charIndex:748},{level:3,title:"车外壳油漆效果",slug:"车外壳油漆效果",normalizedTitle:"车外壳油漆效果",charIndex:1155},{level:3,title:"GUI可视化调试PBR材质属性",slug:"gui可视化调试pbr材质属性",normalizedTitle:"gui可视化调试pbr材质属性",charIndex:1453}],headersStr:"清漆层属性.clearcoat 清漆层粗糙度.clearcoatRoughness 车外壳PBR材质设置 车外壳油漆效果 GUI可视化调试PBR材质属性",content:"# MeshPhysicalMaterial清漆层.clearcoat\n\nMeshPhysicalMaterial和MeshStandardMaterial都是拥有金属度metalness、粗糙度roughness属性的PBR材质，MeshPhysicalMaterial是在MeshStandardMaterial基础上扩展出来的子类，除了继承了MeshStandardMaterial的金属度、粗糙度等属性，还新增了清漆.clearcoat、透光率.transmission、反射率.reflectivity、光泽.sheen、折射率.ior等等各种用于模拟生活中不同材质的属性。\n\n\n# 清漆层属性.clearcoat\n\n清漆层属性.clearcoat可以用来模拟物体表面一层透明图层，就好比你在物体表面刷了一层透明清漆，喷了点水。.clearcoat的范围0到1，默认0。\n\nconst material = new THREE.MeshPhysicalMaterial( {\n\tclearcoat: 1.0,//物体表面清漆层或者说透明涂层的厚度\n} );\n\n\n\n# 清漆层粗糙度.clearcoatRoughness\n\n清漆层粗糙度.clearcoatRoughness属性表示物体表面透明涂层.clearcoat对应的的粗糙度，.clearcoatRoughness的范围是为0.0至1.0。默认值为0.0。\n\nconst material = new THREE.MeshPhysicalMaterial( {\n\tclearcoat: 1.0,//物体表面清漆层或者说透明涂层的厚度\n\tclearcoatRoughness: 0.1,//透明涂层表面的粗糙度\n} );\n\n\n\n# 车外壳PBR材质设置\n\n在设置车外壳清漆层之前，先创建一个MeshPhysicalMaterial材质，并设置好环境贴图、金属度、粗糙度，属性值先根据文档说明给一个大概的值，具体可以通过gui交互界面可视化调试。\n\nconst mesh = gltf.scene.getObjectByName('外壳01');\nmesh.material = new THREE.MeshPhysicalMaterial({\n        color: mesh.material.color, //默认颜色\n        metalness: 0.9,//车外壳金属度\n        roughness: 0.5,//车外壳粗糙度\n        envMap: textureCube, //环境贴图\n        envMapIntensity: 2.5, //环境贴图对Mesh表面影响程度\n})  \n\n\n\n# 车外壳油漆效果\n\n车外壳油漆效果，你可以通过PBR材质的清漆层属性.clearcoat和清漆层粗糙度.clearcoatRoughness属性模拟。\n\n属性值先根据文档说明给一个大概的值，具体可以通过gui交互界面可视化调试。\n\nconst mesh = gltf.scene.getObjectByName('外壳01');\nmesh.material = new THREE.MeshPhysicalMaterial( {\n\tclearcoat: 1.0,//物体表面清漆层或者说透明涂层的厚度\n\tclearcoatRoughness: 0.1,//透明涂层表面的粗糙度\n} );\n\n\n\n# GUI可视化调试PBR材质属性\n\n关于gui的使用，在第一章节入门中详细将结果，具体使用可以参照前面讲解。\n\n// 范围可以参考文档\nmatFolder.add(mesh.material,'metalness',0,1);\nmatFolder.add(mesh.material,'roughness',0,1);\nmatFolder.add(mesh.material,'clearcoat',0,1);\nmatFolder.add(mesh.material,'clearcoatRoughness',0,1);\nmatFolder.add(mesh.material,'envMapIntensity',0,10);\n",normalizedContent:"# meshphysicalmaterial清漆层.clearcoat\n\nmeshphysicalmaterial和meshstandardmaterial都是拥有金属度metalness、粗糙度roughness属性的pbr材质，meshphysicalmaterial是在meshstandardmaterial基础上扩展出来的子类，除了继承了meshstandardmaterial的金属度、粗糙度等属性，还新增了清漆.clearcoat、透光率.transmission、反射率.reflectivity、光泽.sheen、折射率.ior等等各种用于模拟生活中不同材质的属性。\n\n\n# 清漆层属性.clearcoat\n\n清漆层属性.clearcoat可以用来模拟物体表面一层透明图层，就好比你在物体表面刷了一层透明清漆，喷了点水。.clearcoat的范围0到1，默认0。\n\nconst material = new three.meshphysicalmaterial( {\n\tclearcoat: 1.0,//物体表面清漆层或者说透明涂层的厚度\n} );\n\n\n\n# 清漆层粗糙度.clearcoatroughness\n\n清漆层粗糙度.clearcoatroughness属性表示物体表面透明涂层.clearcoat对应的的粗糙度，.clearcoatroughness的范围是为0.0至1.0。默认值为0.0。\n\nconst material = new three.meshphysicalmaterial( {\n\tclearcoat: 1.0,//物体表面清漆层或者说透明涂层的厚度\n\tclearcoatroughness: 0.1,//透明涂层表面的粗糙度\n} );\n\n\n\n# 车外壳pbr材质设置\n\n在设置车外壳清漆层之前，先创建一个meshphysicalmaterial材质，并设置好环境贴图、金属度、粗糙度，属性值先根据文档说明给一个大概的值，具体可以通过gui交互界面可视化调试。\n\nconst mesh = gltf.scene.getobjectbyname('外壳01');\nmesh.material = new three.meshphysicalmaterial({\n        color: mesh.material.color, //默认颜色\n        metalness: 0.9,//车外壳金属度\n        roughness: 0.5,//车外壳粗糙度\n        envmap: texturecube, //环境贴图\n        envmapintensity: 2.5, //环境贴图对mesh表面影响程度\n})  \n\n\n\n# 车外壳油漆效果\n\n车外壳油漆效果，你可以通过pbr材质的清漆层属性.clearcoat和清漆层粗糙度.clearcoatroughness属性模拟。\n\n属性值先根据文档说明给一个大概的值，具体可以通过gui交互界面可视化调试。\n\nconst mesh = gltf.scene.getobjectbyname('外壳01');\nmesh.material = new three.meshphysicalmaterial( {\n\tclearcoat: 1.0,//物体表面清漆层或者说透明涂层的厚度\n\tclearcoatroughness: 0.1,//透明涂层表面的粗糙度\n} );\n\n\n\n# gui可视化调试pbr材质属性\n\n关于gui的使用，在第一章节入门中详细将结果，具体使用可以参照前面讲解。\n\n// 范围可以参考文档\nmatfolder.add(mesh.material,'metalness',0,1);\nmatfolder.add(mesh.material,'roughness',0,1);\nmatfolder.add(mesh.material,'clearcoat',0,1);\nmatfolder.add(mesh.material,'clearcoatroughness',0,1);\nmatfolder.add(mesh.material,'envmapintensity',0,10);\n",charsets:{cjk:!0}},{title:"6. 物理材质透光率.transmission",frontmatter:{title:"6. 物理材质透光率.transmission",date:"2023-01-29T14:58:11.000Z",permalink:"/pages/4f04e6/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/07.7.PBR%E6%9D%90%E8%B4%A8%E4%B8%8E%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/06.%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8%E9%80%8F%E5%85%89%E7%8E%87.transmission.html",relativePath:"01.Three.js教程/07.7.PBR材质与纹理贴图/06.物理材质透光率.transmission.md",key:"v-6cc27f7d",path:"/pages/4f04e6/",headers:[{level:3,title:"透光率(透射度).transmission",slug:"透光率-透射度-transmission",normalizedTitle:"透光率(透射度).transmission",charIndex:102},{level:3,title:"折射率.ior",slug:"折射率-ior",normalizedTitle:"折射率.ior",charIndex:449},{level:3,title:"玻璃透光率.transmission设置",slug:"玻璃透光率-transmission设置",normalizedTitle:"玻璃透光率.transmission设置",charIndex:566},{level:3,title:"GUI可视化调试PBR材质属性",slug:"gui可视化调试pbr材质属性",normalizedTitle:"gui可视化调试pbr材质属性",charIndex:978}],headersStr:"透光率(透射度).transmission 折射率.ior 玻璃透光率.transmission设置 GUI可视化调试PBR材质属性",content:"# 物理材质透光率.transmission\n\n如果你已经掌握上节课内容，可以继续学习物理材质MeshPhysicalMaterial的透光率属性.transmission和折射率属性.ior。\n\n\n# 透光率(透射度).transmission\n\n为了更好的模拟玻璃、半透明塑料一类的视觉效果，可以使用物理透明度.transmission属性代替Mesh普通透明度属性.opacity。\n\n使用.transmission属性设置Mesh透明度,即便完全透射的情况下仍可保持高反射率。\n\n物理光学透明度.transmission的值范围是从0.0到1.0。默认值为0.0。\n\nconst mesh = gltf.scene.getObjectByName('玻璃01')\nmesh.material = new THREE.MeshPhysicalMaterial({\n    transmission: 1.0, //玻璃材质透光率，transmission替代opacity \n})\n\n\n\n# 折射率.ior\n\n非金属材料的折射率从1.0到2.333。默认值为1.5。\n\n不同材质的折射率，你可以百度搜索。\n\nnew THREE.MeshPhysicalMaterial({\n    ior:1.5,//折射率\n})\n\n\n\n# 玻璃透光率.transmission设置\n\n先设置玻璃金属度和粗糙度\n\nconst mesh = gltf.scene.getObjectByName('玻璃01')\nmesh.material = new THREE.MeshPhysicalMaterial({\n    metalness: 0.0,//玻璃非金属 \n    roughness: 0.0,//玻璃表面光滑\n    envMap:textureCube,//环境贴图\n    envMapIntensity: 1.0, //环境贴图对Mesh表面影响程度\n})\n\n\n设置透光率.transmission和折射率.ior。\n\nnew THREE.MeshPhysicalMaterial({\n    transmission: 1.0, //玻璃材质透光率，transmission替代opacity \n    ior:1.5,//折射率\n})\n\n\n\n# GUI可视化调试PBR材质属性\n\n基本参数和代码设置好以后，就是通过GUI可视化交互界面，调试PBR材质或光源的参数，gui.js库的使用参考入门章节介绍。\n\nconst obj = {\n    color: mesh.material.color, // 材质颜色\n};\n// 材质颜色color\nmatFolder.addColor(obj, 'color').onChange(function (value) {\n    mesh.material.color.set(value);\n});\n// 范围可以参考文档\nmatFolder.add(mesh.material,'metalness',0,1);\nmatFolder.add(mesh.material,'roughness',0,1);\nmatFolder.add(mesh.material,'transmission',0,1);\nmatFolder.add(mesh.material,'ior',0,3);\nmatFolder.add(mesh.material,'envMapIntensity',0,10);\n",normalizedContent:"# 物理材质透光率.transmission\n\n如果你已经掌握上节课内容，可以继续学习物理材质meshphysicalmaterial的透光率属性.transmission和折射率属性.ior。\n\n\n# 透光率(透射度).transmission\n\n为了更好的模拟玻璃、半透明塑料一类的视觉效果，可以使用物理透明度.transmission属性代替mesh普通透明度属性.opacity。\n\n使用.transmission属性设置mesh透明度,即便完全透射的情况下仍可保持高反射率。\n\n物理光学透明度.transmission的值范围是从0.0到1.0。默认值为0.0。\n\nconst mesh = gltf.scene.getobjectbyname('玻璃01')\nmesh.material = new three.meshphysicalmaterial({\n    transmission: 1.0, //玻璃材质透光率，transmission替代opacity \n})\n\n\n\n# 折射率.ior\n\n非金属材料的折射率从1.0到2.333。默认值为1.5。\n\n不同材质的折射率，你可以百度搜索。\n\nnew three.meshphysicalmaterial({\n    ior:1.5,//折射率\n})\n\n\n\n# 玻璃透光率.transmission设置\n\n先设置玻璃金属度和粗糙度\n\nconst mesh = gltf.scene.getobjectbyname('玻璃01')\nmesh.material = new three.meshphysicalmaterial({\n    metalness: 0.0,//玻璃非金属 \n    roughness: 0.0,//玻璃表面光滑\n    envmap:texturecube,//环境贴图\n    envmapintensity: 1.0, //环境贴图对mesh表面影响程度\n})\n\n\n设置透光率.transmission和折射率.ior。\n\nnew three.meshphysicalmaterial({\n    transmission: 1.0, //玻璃材质透光率，transmission替代opacity \n    ior:1.5,//折射率\n})\n\n\n\n# gui可视化调试pbr材质属性\n\n基本参数和代码设置好以后，就是通过gui可视化交互界面，调试pbr材质或光源的参数，gui.js库的使用参考入门章节介绍。\n\nconst obj = {\n    color: mesh.material.color, // 材质颜色\n};\n// 材质颜色color\nmatfolder.addcolor(obj, 'color').onchange(function (value) {\n    mesh.material.color.set(value);\n});\n// 范围可以参考文档\nmatfolder.add(mesh.material,'metalness',0,1);\nmatfolder.add(mesh.material,'roughness',0,1);\nmatfolder.add(mesh.material,'transmission',0,1);\nmatfolder.add(mesh.material,'ior',0,3);\nmatfolder.add(mesh.material,'envmapintensity',0,10);\n",charsets:{cjk:!0}},{title:"4. 环境贴图2",frontmatter:{title:"4. 环境贴图2",date:"2023-01-29T14:58:12.000Z",permalink:"/pages/3b2d91/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/07.7.PBR%E6%9D%90%E8%B4%A8%E4%B8%8E%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/04.%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE2.html",relativePath:"01.Three.js教程/07.7.PBR材质与纹理贴图/04.环境贴图2.md",key:"v-e4723f4c",path:"/pages/3b2d91/",headers:[{level:3,title:"环境贴图作用测试",slug:"环境贴图作用测试",normalizedTitle:"环境贴图作用测试",charIndex:30},{level:3,title:"场景环境属性.environment",slug:"场景环境属性-environment",normalizedTitle:"场景环境属性.environment",charIndex:262},{level:3,title:"环境贴图色彩空间编码.encoding",slug:"环境贴图色彩空间编码-encoding",normalizedTitle:"环境贴图色彩空间编码.encoding",charIndex:771}],headersStr:"环境贴图作用测试 场景环境属性.environment 环境贴图色彩空间编码.encoding",content:'# 环境贴图2\n\n接着上节课的环境贴图给大家讲解。\n\n\n# 环境贴图作用测试\n\n实际生活中光源照射到一个物体上，这个物体反射出去的光线也会影响其他的物体，环境贴图就是用一种简单方式，近似模拟一个物体周边环境对物体表面的影响。\n\n测试：对于PBR材质，如果threejs三维场景不添加任何光源，物体就是完全黑色的，你可以不添加任何光源，尝试只使用环境贴图，你会发现物体表面的颜色也能看到，这说明环境贴图其实相当于提供了物体周围环境发射或反射的光线。\n\n测试：更换不同明暗的环境贴图，你会发现场景中模型的明暗也有变化。\n\n\n# 场景环境属性.environment\n\n网格模型可以通过材质的.envMap属性设置环境贴图，如果一个gltf模型中所有的Mesh都要设置环境贴图就需要递归遍历gltf模型，给里面每个Mesh的材质设置.envMap。\n\nloader.load("../工厂.glb", function (gltf) {\n    // 递归遍历批量设置环境贴图\n    gltf.scene.traverse(function (obj) {\n        if (obj.isMesh) { //判断是否是网格模型\n            obj.material.envMap = textureCube; //设置环境贴图\n        }\n    });\n})\n\n\n如果你希望环境贴图影响场景中scene所有Mesh，可以通过Scene的场景环境属性.environment实现,把环境贴图对应纹理对象设置为.environment的属性值即可。\n\n// 环境贴图纹理对象textureCube作为.environment属性值,影响所有模型\nscene.environment = textureCube;\n\n\n\n# 环境贴图色彩空间编码.encoding\n\n//如果renderer.outputEncoding=THREE.sRGBEncoding;环境贴图需要保持一致\ntextureCube.encoding = THREE.sRGBEncoding;   \n',normalizedContent:'# 环境贴图2\n\n接着上节课的环境贴图给大家讲解。\n\n\n# 环境贴图作用测试\n\n实际生活中光源照射到一个物体上，这个物体反射出去的光线也会影响其他的物体，环境贴图就是用一种简单方式，近似模拟一个物体周边环境对物体表面的影响。\n\n测试：对于pbr材质，如果threejs三维场景不添加任何光源，物体就是完全黑色的，你可以不添加任何光源，尝试只使用环境贴图，你会发现物体表面的颜色也能看到，这说明环境贴图其实相当于提供了物体周围环境发射或反射的光线。\n\n测试：更换不同明暗的环境贴图，你会发现场景中模型的明暗也有变化。\n\n\n# 场景环境属性.environment\n\n网格模型可以通过材质的.envmap属性设置环境贴图，如果一个gltf模型中所有的mesh都要设置环境贴图就需要递归遍历gltf模型，给里面每个mesh的材质设置.envmap。\n\nloader.load("../工厂.glb", function (gltf) {\n    // 递归遍历批量设置环境贴图\n    gltf.scene.traverse(function (obj) {\n        if (obj.ismesh) { //判断是否是网格模型\n            obj.material.envmap = texturecube; //设置环境贴图\n        }\n    });\n})\n\n\n如果你希望环境贴图影响场景中scene所有mesh，可以通过scene的场景环境属性.environment实现,把环境贴图对应纹理对象设置为.environment的属性值即可。\n\n// 环境贴图纹理对象texturecube作为.environment属性值,影响所有模型\nscene.environment = texturecube;\n\n\n\n# 环境贴图色彩空间编码.encoding\n\n//如果renderer.outputencoding=three.srgbencoding;环境贴图需要保持一致\ntexturecube.encoding = three.srgbencoding;   \n',charsets:{cjk:!0}},{title:"7. 三维软件导出PBR材质属性",frontmatter:{title:"7. 三维软件导出PBR材质属性",date:"2023-01-29T14:58:06.000Z",permalink:"/pages/41c918/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/07.7.PBR%E6%9D%90%E8%B4%A8%E4%B8%8E%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE/07.%E4%B8%89%E7%BB%B4%E8%BD%AF%E4%BB%B6%E5%AF%BC%E5%87%BAPBR%E6%9D%90%E8%B4%A8%E5%B1%9E%E6%80%A7.html",relativePath:"01.Three.js教程/07.7.PBR材质与纹理贴图/07.三维软件导出PBR材质属性.md",key:"v-1df7f180",path:"/pages/41c918/",headers:[{level:3,title:"threejs与建模软件对接的问题",slug:"threejs与建模软件对接的问题",normalizedTitle:"threejs与建模软件对接的问题",charIndex:154},{level:3,title:"Blender导出PBR材质演示",slug:"blender导出pbr材质演示",normalizedTitle:"blender导出pbr材质演示",charIndex:344},{level:3,title:"Bledner中设置PBR材质",slug:"bledner中设置pbr材质",normalizedTitle:"bledner中设置pbr材质",charIndex:527},{level:3,title:"threejs解析gltf材质规则",slug:"threejs解析gltf材质规则",normalizedTitle:"threejs解析gltf材质规则",charIndex:610},{level:3,title:"设置环境贴图",slug:"设置环境贴图",normalizedTitle:"设置环境贴图",charIndex:1232}],headersStr:"threejs与建模软件对接的问题 Blender导出PBR材质演示 Bledner中设置PBR材质 threejs解析gltf材质规则 设置环境贴图",content:"# 三维建模软件导出PBR材质属性\n\n实际开发的时候PBR材质的属性，很多时候是可以在三维建模软件中设置的，然后通过gltf导出即可，这样就不用在threejs代码设置。\n\n通常美术对三维场景渲染的了解也比大部分前端程序员多的多，只要美术在三维建模软件设置好并导出包含pbr材质属性的gltf即可。\n\n\n# threejs与建模软件对接的问题\n\n 1. gltf能否存储3D建模软件的某个材质属性：有些三维软件特有的材质属性，不一定能通过gltf导出，也谈不上threejs解析\n 2. 三维建模能否导出PBR材质：能导出的话，能导出哪些属性，不能导出哪些属性\n\n如果你的三维建模不能导出pbr材质，或者部分pbr材质属性无法导出，那你通常需要用代码方式添加材质，这样就麻烦些。\n\n\n# Blender导出PBR材质演示\n\n首先Blender最新版导出gltf模型时候，是可以把PBR材质的很多属性导出的，比如金属度metalness、粗糙度roughness、清漆.clearcoat、透光率(透射度).transmission等等。课件源码中提供了blender导出的gltf模型你可以浏览器控制台打印测试，这些PBR材质属性能否解析渲染。\n\n\n# Bledner中设置PBR材质\n\n你可以在Bledner中设置车外壳、车玻璃的材质属性\n\n 1. 车外壳：清漆、清漆粗糙度\n 2. 车玻璃：透光率(透射度)\n\n\n# threejs解析gltf材质规则\n\n大家都知道，MeshPhysicalMaterial是MeshStandardMaterial的子类，具有更多的PBR材质属性和功能。\n\n所以，threejs解析gltf模型，会用两种材质PBR材质去解析，一个是标准网格材质MeshStandardMaterial，一个是物理网格材质MeshPhysicalMaterial，如果能用MeshStandardMaterial表示就用，不能就换MeshPhysicalMaterial。\n\n具体说就是，threejs解析gltf模型材质的时候，一般默认使用标准网格材质MeshStandardMaterial，如果gltf有的材质具有.clearcoat、.transmission等属性，标准网格材质MeshStandardMaterial无法表达的时候，会用物理网格材质MeshPhysicalMaterial来解析gltf材质。\n\n查看threejs解析的PBR材质\n\ngltf.scene.traverse(function(obj) {\n    if (obj.isMesh) {\n        console.log('obj.material',obj.material);\n    }\n});\nconsole.log('外壳',mesh1.material);\nconsole.log('玻璃',mesh2.material);\n\n\n\n# 设置环境贴图\n\n这时候清漆、清漆粗糙度、透光率(透射度)等属性Bledner都已经设置好了，threejs可以自动解析渲染,不用在代码中麻烦设置了，只要配上环境贴图即可。\n\nconst mesh1 = gltf.scene.getObjectByName('外壳01');\nmesh1.material.envMap = textureCube; //环境贴图\nmesh1.material.envMapIntensity = 1.0; ////环境贴图对Mesh表面影响程度\nconst mesh2 = gltf.scene.getObjectByName('玻璃01');\nmesh2.material.envMap = textureCube; //环境贴图\nmesh2.material.envMapIntensity = 1.0; ////环境贴图对Mesh表面影响程度\n",normalizedContent:"# 三维建模软件导出pbr材质属性\n\n实际开发的时候pbr材质的属性，很多时候是可以在三维建模软件中设置的，然后通过gltf导出即可，这样就不用在threejs代码设置。\n\n通常美术对三维场景渲染的了解也比大部分前端程序员多的多，只要美术在三维建模软件设置好并导出包含pbr材质属性的gltf即可。\n\n\n# threejs与建模软件对接的问题\n\n 1. gltf能否存储3d建模软件的某个材质属性：有些三维软件特有的材质属性，不一定能通过gltf导出，也谈不上threejs解析\n 2. 三维建模能否导出pbr材质：能导出的话，能导出哪些属性，不能导出哪些属性\n\n如果你的三维建模不能导出pbr材质，或者部分pbr材质属性无法导出，那你通常需要用代码方式添加材质，这样就麻烦些。\n\n\n# blender导出pbr材质演示\n\n首先blender最新版导出gltf模型时候，是可以把pbr材质的很多属性导出的，比如金属度metalness、粗糙度roughness、清漆.clearcoat、透光率(透射度).transmission等等。课件源码中提供了blender导出的gltf模型你可以浏览器控制台打印测试，这些pbr材质属性能否解析渲染。\n\n\n# bledner中设置pbr材质\n\n你可以在bledner中设置车外壳、车玻璃的材质属性\n\n 1. 车外壳：清漆、清漆粗糙度\n 2. 车玻璃：透光率(透射度)\n\n\n# threejs解析gltf材质规则\n\n大家都知道，meshphysicalmaterial是meshstandardmaterial的子类，具有更多的pbr材质属性和功能。\n\n所以，threejs解析gltf模型，会用两种材质pbr材质去解析，一个是标准网格材质meshstandardmaterial，一个是物理网格材质meshphysicalmaterial，如果能用meshstandardmaterial表示就用，不能就换meshphysicalmaterial。\n\n具体说就是，threejs解析gltf模型材质的时候，一般默认使用标准网格材质meshstandardmaterial，如果gltf有的材质具有.clearcoat、.transmission等属性，标准网格材质meshstandardmaterial无法表达的时候，会用物理网格材质meshphysicalmaterial来解析gltf材质。\n\n查看threejs解析的pbr材质\n\ngltf.scene.traverse(function(obj) {\n    if (obj.ismesh) {\n        console.log('obj.material',obj.material);\n    }\n});\nconsole.log('外壳',mesh1.material);\nconsole.log('玻璃',mesh2.material);\n\n\n\n# 设置环境贴图\n\n这时候清漆、清漆粗糙度、透光率(透射度)等属性bledner都已经设置好了，threejs可以自动解析渲染,不用在代码中麻烦设置了，只要配上环境贴图即可。\n\nconst mesh1 = gltf.scene.getobjectbyname('外壳01');\nmesh1.material.envmap = texturecube; //环境贴图\nmesh1.material.envmapintensity = 1.0; ////环境贴图对mesh表面影响程度\nconst mesh2 = gltf.scene.getobjectbyname('玻璃01');\nmesh2.material.envmap = texturecube; //环境贴图\nmesh2.material.envmapintensity = 1.0; ////环境贴图对mesh表面影响程度\n",charsets:{cjk:!0}},{title:"1. three.js Canvas画布布局",frontmatter:{title:"1. three.js Canvas画布布局",date:"2023-01-27T15:06:51.000Z",permalink:"/pages/12b014/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/08.8.%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%89%8D%E7%AB%AFUI%E7%95%8C%E9%9D%A2/01.three.js%20Canvas%E7%94%BB%E5%B8%83%E5%B8%83%E5%B1%80.html",relativePath:"01.Three.js教程/08.8.渲染器和前端UI界面/01.three.js Canvas画布布局.md",key:"v-39711157",path:"/pages/12b014/",headers:[{level:3,title:"Canvas元素",slug:"canvas元素",normalizedTitle:"canvas元素",charIndex:164},{level:3,title:"threejs渲染结果CSS布局",slug:"threejs渲染结果css布局",normalizedTitle:"threejs渲染结果css布局",charIndex:412},{level:3,title:"案例源码“CSS布局案例.html”",slug:"案例源码-css布局案例-html",normalizedTitle:"案例源码“css布局案例.html”",charIndex:575},{level:3,title:"threejs Canvas画布尺寸设置",slug:"threejs-canvas画布尺寸设置",normalizedTitle:"threejs canvas画布尺寸设置",charIndex:1579},{level:3,title:"Canvas随着窗口变化",slug:"canvas随着窗口变化",normalizedTitle:"canvas随着窗口变化",charIndex:2322}],headersStr:"Canvas元素 threejs渲染结果CSS布局 案例源码“CSS布局案例.html” threejs Canvas画布尺寸设置 Canvas随着窗口变化",content:'# three.js Canvas画布布局\n\n学习本节课之前，可以先回顾下第一章节入门部分的6和12两小节关于threejs Canvas画布布局的讲解。\n\n * 网页上局部特定尺寸：1.6 第一个3D案例—渲染器\n\n * 全屏，随窗口变化:1.12 Canvas画布布局和全屏\n\n * 局部，尺寸随窗口变化：在线案例\n\n\n# Canvas元素\n\nCanvas是HTML的元素之一，Canvas元素的CSS布局规律和div、img等其它HTML元素相似，webgl就是依赖于canvas实现，threejs是基于webgl封装的，自然也要依赖canvas，具体说就是把三场场景渲染到canvas画布上。\n\n\x3c!-- canvas元素默认是行内块元素 --\x3e\n<canvas style="background-color: #ff0000;" width="300" height="180"></canvas>\n\n\n\n# threejs渲染结果CSS布局\n\n浏览器控制台通过元素选项查看threejs输出的cnavas画布，你可以看到threejs默认把canvas设置为块元素display: block;。\n\n既然three.js渲染输出的Canvas画布本质上就是一个HTML元素，那么你布局的时候，直接使用你的前端CSS知识即可。\n\n\n# 案例源码“CSS布局案例.html”\n\n案例源码“CSS布局案例.html”提供了一个CSS的布局案例，你可以把threejs画布插入右下角的div元素中，并完全填充。\n\n案例源码“CSS布局案例.html”的布局效果，你也可以用CSS其它方式实现，不一定和课程中一样，CSS布局是前端知识，这里不展开讲解，咱们把重点放在threejs上面。\n\n<head>\n    <style>\n        body {\n            overflow: hidden;\n            margin: 0px;\n        }\n    </style>\n</head>\n<body style="background: #555555;">\n    <div style="height: 55px;background-color: #444444;">上面布局</div>\n    \x3c!-- 下 --\x3e\n    <div>\n        <div id="left" style="position: absolute;top: 60px;background-color: #444444;width: 195px;">下面左侧布局</div>\n        <div id="webgl" style="position: absolute;top: 60px;left: 200px;background-color: #444444;">下面右侧布局</div>\n    </div>\n    <script>\n        const width = window.innerWidth - 200;\n        const height = window.innerHeight - 60;\n        document.getElementById(\'left\').style.height = height + \'px\';\n        document.getElementById(\'webgl\').style.width = width + \'px\';\n        document.getElementById(\'webgl\').style.height = height + \'px\';\n    <\/script>\n</body>\n\n\n\n# threejs Canvas画布尺寸设置\n\n设置canvas画布的尺寸，注意在浏览器窗口文档区域整体宽高基础上，减掉其他顶部和左侧div元素和布局间隙的尺寸。\n\n * canvas画布的宽度： window.innerWidth减掉左侧div元素宽度195px和布局间距5px\n * canvas画布的高度： window.innerHeight减掉顶部div元素高度55px和布局间距5px\n\n// 200表示左侧div元素宽度195px+间距5px\nconst width = window.innerWidth - 200; //canvas画布高度\n//60表示顶部div元素高度55px+间距5px\nconst height = window.innerHeight - 60; //canvas画布宽度\n...\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\nrenderer.setSize(width, height);\n\n\n// 200表示左侧div元素宽度195+间距5px\nconst width = window.innerWidth - 200; //canvas画布高度\n//60表示顶部div元素高度55px+间距5px\nconst height = window.innerHeight - 60; //canvas画布宽度\n...\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\nrenderer.setSize(width, height);\n\n\n\n# Canvas随着窗口变化\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerWidth - 200; //canvas画布高度\n    const height = window.innerHeight - 60; //canvas画布宽度\n    renderer.setSize(width, height);\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n};\n',normalizedContent:'# three.js canvas画布布局\n\n学习本节课之前，可以先回顾下第一章节入门部分的6和12两小节关于threejs canvas画布布局的讲解。\n\n * 网页上局部特定尺寸：1.6 第一个3d案例—渲染器\n\n * 全屏，随窗口变化:1.12 canvas画布布局和全屏\n\n * 局部，尺寸随窗口变化：在线案例\n\n\n# canvas元素\n\ncanvas是html的元素之一，canvas元素的css布局规律和div、img等其它html元素相似，webgl就是依赖于canvas实现，threejs是基于webgl封装的，自然也要依赖canvas，具体说就是把三场场景渲染到canvas画布上。\n\n\x3c!-- canvas元素默认是行内块元素 --\x3e\n<canvas style="background-color: #ff0000;" width="300" height="180"></canvas>\n\n\n\n# threejs渲染结果css布局\n\n浏览器控制台通过元素选项查看threejs输出的cnavas画布，你可以看到threejs默认把canvas设置为块元素display: block;。\n\n既然three.js渲染输出的canvas画布本质上就是一个html元素，那么你布局的时候，直接使用你的前端css知识即可。\n\n\n# 案例源码“css布局案例.html”\n\n案例源码“css布局案例.html”提供了一个css的布局案例，你可以把threejs画布插入右下角的div元素中，并完全填充。\n\n案例源码“css布局案例.html”的布局效果，你也可以用css其它方式实现，不一定和课程中一样，css布局是前端知识，这里不展开讲解，咱们把重点放在threejs上面。\n\n<head>\n    <style>\n        body {\n            overflow: hidden;\n            margin: 0px;\n        }\n    </style>\n</head>\n<body style="background: #555555;">\n    <div style="height: 55px;background-color: #444444;">上面布局</div>\n    \x3c!-- 下 --\x3e\n    <div>\n        <div id="left" style="position: absolute;top: 60px;background-color: #444444;width: 195px;">下面左侧布局</div>\n        <div id="webgl" style="position: absolute;top: 60px;left: 200px;background-color: #444444;">下面右侧布局</div>\n    </div>\n    <script>\n        const width = window.innerwidth - 200;\n        const height = window.innerheight - 60;\n        document.getelementbyid(\'left\').style.height = height + \'px\';\n        document.getelementbyid(\'webgl\').style.width = width + \'px\';\n        document.getelementbyid(\'webgl\').style.height = height + \'px\';\n    <\/script>\n</body>\n\n\n\n# threejs canvas画布尺寸设置\n\n设置canvas画布的尺寸，注意在浏览器窗口文档区域整体宽高基础上，减掉其他顶部和左侧div元素和布局间隙的尺寸。\n\n * canvas画布的宽度： window.innerwidth减掉左侧div元素宽度195px和布局间距5px\n * canvas画布的高度： window.innerheight减掉顶部div元素高度55px和布局间距5px\n\n// 200表示左侧div元素宽度195px+间距5px\nconst width = window.innerwidth - 200; //canvas画布高度\n//60表示顶部div元素高度55px+间距5px\nconst height = window.innerheight - 60; //canvas画布宽度\n...\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\nrenderer.setsize(width, height);\n\n\n// 200表示左侧div元素宽度195+间距5px\nconst width = window.innerwidth - 200; //canvas画布高度\n//60表示顶部div元素高度55px+间距5px\nconst height = window.innerheight - 60; //canvas画布宽度\n...\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\nrenderer.setsize(width, height);\n\n\n\n# canvas随着窗口变化\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerwidth - 200; //canvas画布高度\n    const height = window.innerheight - 60; //canvas画布宽度\n    renderer.setsize(width, height);\n    camera.aspect = width / height;\n    camera.updateprojectionmatrix();\n};\n',charsets:{cjk:!0}},{title:"2. UI交互界面与Canvas画布叠加",frontmatter:{title:"2. UI交互界面与Canvas画布叠加",date:"2023-01-27T19:07:24.000Z",permalink:"/pages/780ceb/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/08.8.%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%89%8D%E7%AB%AFUI%E7%95%8C%E9%9D%A2/02.UI%E4%BA%A4%E4%BA%92%E7%95%8C%E9%9D%A2%E4%B8%8ECanvas%E7%94%BB%E5%B8%83%E5%8F%A0%E5%8A%A0.html",relativePath:"01.Three.js教程/08.8.渲染器和前端UI界面/02.UI交互界面与Canvas画布叠加.md",key:"v-698761d4",path:"/pages/780ceb/",headers:[{level:3,title:"插入div元素",slug:"插入div元素",normalizedTitle:"插入div元素",charIndex:86},{level:3,title:"canvas画布绝对定位",slug:"canvas画布绝对定位",normalizedTitle:"canvas画布绝对定位",charIndex:185},{level:3,title:"设置z-index",slug:"设置z-index",normalizedTitle:"设置z-index",charIndex:480},{level:3,title:"插入的div元素绝对定位",slug:"插入的div元素绝对定位",normalizedTitle:"插入的div元素绝对定位",charIndex:687}],headersStr:"插入div元素 canvas画布绝对定位 设置z-index 插入的div元素绝对定位",content:"# UI交互界面与Canvas画布叠加\n\n本节课把threejs Cavnas画布和HTML元素叠加布局时候，可能遇到问题演示下，以后遇到类似的问题知道怎么排查。\n\n\n# 插入div元素\n\n在课程课件演示文件.html中插入一个div元素，你会看到地址元素影响canvas元素布局\n\n<div style=\"color: #ff0000;\">红色</div>\n\n\n\n# canvas画布绝对定位\n\n如果你想设置threejs Canvas画布的style属性，可以通过renderer.domElement访问。\n\n// canvas画布绝对定位\nrenderer.domElement.style.position = 'absolute';\nrenderer.domElement.style.top = '0px';\nrenderer.domElement.style.left = '0px';\n\n\n这时候你会发现你插入的div元素看不到了，这涉及到z-index的CSS布局知识点，具体说就是当两个HTML元素位置重合，谁在上谁在下的问题。\n\n\n# 设置z-index\n\n通过z-index改变HTML元素上下叠加关系，如果你忘记了CSS该属性，可以复习下。\n\nrenderer.domElement.style.zIndex = -1;\n\n\n<div style=\"color: #ff0000;z-index:2;position: relative;\">红色</div>\n\n\n注意默认的定位position: static;设置z-index无效。\n\n\n# 插入的div元素绝对定位\n\n不设置three.js Canvas元素style，插入的div元素绝对定位，这样也可以把div元素叠加到threejs Canvas花画布上\n\n<div style=\"color: #ff0000;z-index:2;position: absolute;\">红色</div>\n",normalizedContent:"# ui交互界面与canvas画布叠加\n\n本节课把threejs cavnas画布和html元素叠加布局时候，可能遇到问题演示下，以后遇到类似的问题知道怎么排查。\n\n\n# 插入div元素\n\n在课程课件演示文件.html中插入一个div元素，你会看到地址元素影响canvas元素布局\n\n<div style=\"color: #ff0000;\">红色</div>\n\n\n\n# canvas画布绝对定位\n\n如果你想设置threejs canvas画布的style属性，可以通过renderer.domelement访问。\n\n// canvas画布绝对定位\nrenderer.domelement.style.position = 'absolute';\nrenderer.domelement.style.top = '0px';\nrenderer.domelement.style.left = '0px';\n\n\n这时候你会发现你插入的div元素看不到了，这涉及到z-index的css布局知识点，具体说就是当两个html元素位置重合，谁在上谁在下的问题。\n\n\n# 设置z-index\n\n通过z-index改变html元素上下叠加关系，如果你忘记了css该属性，可以复习下。\n\nrenderer.domelement.style.zindex = -1;\n\n\n<div style=\"color: #ff0000;z-index:2;position: relative;\">红色</div>\n\n\n注意默认的定位position: static;设置z-index无效。\n\n\n# 插入的div元素绝对定位\n\n不设置three.js canvas元素style，插入的div元素绝对定位，这样也可以把div元素叠加到threejs canvas花画布上\n\n<div style=\"color: #ff0000;z-index:2;position: absolute;\">红色</div>\n",charsets:{cjk:!0}},{title:"3. UI交互按钮与3D场景交互",frontmatter:{title:"3. UI交互按钮与3D场景交互",date:"2023-01-27T21:06:41.000Z",permalink:"/pages/2a15e4/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/08.8.%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%89%8D%E7%AB%AFUI%E7%95%8C%E9%9D%A2/03.UI%E4%BA%A4%E4%BA%92%E6%8C%89%E9%92%AE%E4%B8%8E3D%E5%9C%BA%E6%99%AF%E4%BA%A4%E4%BA%92.html",relativePath:"01.Three.js教程/08.8.渲染器和前端UI界面/03.UI交互按钮与3D场景交互.md",key:"v-4e79869f",path:"/pages/2a15e4/",headers:[{level:3,title:"UI按钮改变Mesh颜色",slug:"ui按钮改变mesh颜色",normalizedTitle:"ui按钮改变mesh颜色",charIndex:121}],headersStr:"UI按钮改变Mesh颜色",content:'# UI交互按钮与3D场景交互\n\n实际开发的时候，往往会通过前端的HTML、CSS代码创建按钮等交互界面，用来与3D场景交互。\n\n如果你是用vue或react开发web3d项目，也可以不用HTML、CSS自己写，可以使用UI组件库。\n\n\n# UI按钮改变Mesh颜色\n\n<div  id="red" class="bu">红</div>\n<div  id="green" class="bu" style="margin-left: 10px;">绿</div>\n\n\n通过UI按钮与3D场景交互，改变mesh颜色\n\ndocument.getElementById(\'red\').addEventListener(\'click\',function(){\n    mesh.material.color.set(0xff0000);\n})\ndocument.getElementById(\'green\').addEventListener(\'click\',function(){\n    mesh.material.color.set(0x00ff00);\n})\n',normalizedContent:'# ui交互按钮与3d场景交互\n\n实际开发的时候，往往会通过前端的html、css代码创建按钮等交互界面，用来与3d场景交互。\n\n如果你是用vue或react开发web3d项目，也可以不用html、css自己写，可以使用ui组件库。\n\n\n# ui按钮改变mesh颜色\n\n<div  id="red" class="bu">红</div>\n<div  id="green" class="bu" style="margin-left: 10px;">绿</div>\n\n\n通过ui按钮与3d场景交互，改变mesh颜色\n\ndocument.getelementbyid(\'red\').addeventlistener(\'click\',function(){\n    mesh.material.color.set(0xff0000);\n})\ndocument.getelementbyid(\'green\').addeventlistener(\'click\',function(){\n    mesh.material.color.set(0x00ff00);\n})\n',charsets:{cjk:!0}},{title:"4. Three.js背景透明度",frontmatter:{title:"4. Three.js背景透明度",date:"2023-01-27T21:06:29.000Z",permalink:"/pages/a4febe/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/08.8.%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%89%8D%E7%AB%AFUI%E7%95%8C%E9%9D%A2/04.Three.js%E8%83%8C%E6%99%AF%E9%80%8F%E6%98%8E%E5%BA%A6.html",relativePath:"01.Three.js教程/08.8.渲染器和前端UI界面/04.Three.js背景透明度.md",key:"v-7f3230f8",path:"/pages/a4febe/",headers:[{level:3,title:"threejs canvas画布插入到web页面上",slug:"threejs-canvas画布插入到web页面上",normalizedTitle:"threejs canvas画布插入到web页面上",charIndex:136},{level:3,title:".setClearAlpha()方法",slug:"setclearalpha-方法",normalizedTitle:".setclearalpha()方法",charIndex:260},{level:3,title:"背景透明alpha: true",slug:"背景透明alpha-true",normalizedTitle:"背景透明alpha: true",charIndex:361},{level:3,title:".setClearColor()方法",slug:"setclearcolor-方法",normalizedTitle:".setclearcolor()方法",charIndex:539}],headersStr:"threejs canvas画布插入到web页面上 .setClearAlpha()方法 背景透明alpha: true .setClearColor()方法",content:"# Three.js背景透明度(模型悬浮在网页上)\n\n通过Three.js渲染一个模型的时候，不希望canvas画布有背景颜色，也就是canvas画布完全透明，可以透过canvas画布看到画布后面叠加的HTML元素图文，呈现出来一种三维模型悬浮在网页上面的效果。\n\n\n# threejs canvas画布插入到web页面上\n\n<div id=\"webgl\"></div>\n\n\ndocument.getElementById('webgl').appendChild(renderer.domElement);\n\n\n\n# .setClearAlpha()方法\n\n改变背景透明度值\n\nrenderer.setClearAlpha(0.8);\n\n\n完全透明\n\nrenderer.setClearAlpha(0.0);\n\n\n\n# 背景透明alpha: true\n\n通过Three.js渲染器WebGLRenderer的alpha属性值设置为true就可以，WebGL渲染器的alpha属性默认值是false。\n\n// 在构造函数参数中设置alpha属性的值\nvar renderer = new THREE.WebGLRenderer({\n  alpha: true\n});\n\n\n\n# .setClearColor()方法\n\n.setClearColor()方法的参数2，可以用来设置背景颜色透明度。\n\nrenderer.setClearColor(0xb9d3ff, 0.4); //设置背景颜色和透明度\n",normalizedContent:"# three.js背景透明度(模型悬浮在网页上)\n\n通过three.js渲染一个模型的时候，不希望canvas画布有背景颜色，也就是canvas画布完全透明，可以透过canvas画布看到画布后面叠加的html元素图文，呈现出来一种三维模型悬浮在网页上面的效果。\n\n\n# threejs canvas画布插入到web页面上\n\n<div id=\"webgl\"></div>\n\n\ndocument.getelementbyid('webgl').appendchild(renderer.domelement);\n\n\n\n# .setclearalpha()方法\n\n改变背景透明度值\n\nrenderer.setclearalpha(0.8);\n\n\n完全透明\n\nrenderer.setclearalpha(0.0);\n\n\n\n# 背景透明alpha: true\n\n通过three.js渲染器webglrenderer的alpha属性值设置为true就可以，webgl渲染器的alpha属性默认值是false。\n\n// 在构造函数参数中设置alpha属性的值\nvar renderer = new three.webglrenderer({\n  alpha: true\n});\n\n\n\n# .setclearcolor()方法\n\n.setclearcolor()方法的参数2，可以用来设置背景颜色透明度。\n\nrenderer.setclearcolor(0xb9d3ff, 0.4); //设置背景颜色和透明度\n",charsets:{cjk:!0}},{title:"5. Three.js渲染结果保存为图片",frontmatter:{title:"5. Three.js渲染结果保存为图片",date:"2023-01-29T16:50:12.000Z",permalink:"/pages/a1304b/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/08.8.%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%89%8D%E7%AB%AFUI%E7%95%8C%E9%9D%A2/05.Three.js%E6%B8%B2%E6%9F%93%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E4%B8%BA%E5%9B%BE%E7%89%87.html",relativePath:"01.Three.js教程/08.8.渲染器和前端UI界面/05.Three.js渲染结果保存为图片.md",key:"v-d5d385d8",path:"/pages/a1304b/",headers:[{level:3,title:"超链接元素a下载文件",slug:"超链接元素a下载文件",normalizedTitle:"超链接元素a下载文件",charIndex:99},{level:3,title:"1. 配置webgl渲染器preserveDrawingBuffer:true",slug:"_1-配置webgl渲染器preservedrawingbuffer-true",normalizedTitle:"1. 配置webgl渲染器preservedrawingbuffer:true",charIndex:604},{level:3,title:"2. 按钮绑定鼠标事件",slug:"_2-按钮绑定鼠标事件",normalizedTitle:"2. 按钮绑定鼠标事件",charIndex:778},{level:3,title:"3. 创建超链接元素a：用于保存下载文件",slug:"_3-创建超链接元素a-用于保存下载文件",normalizedTitle:"3. 创建超链接元素a：用于保存下载文件",charIndex:962},{level:3,title:"4. Cavnas方法.toDataURL()",slug:"_4-cavnas方法-todataurl",normalizedTitle:"4. cavnas方法.todataurl()",charIndex:1331}],headersStr:"超链接元素a下载文件 1. 配置webgl渲染器preserveDrawingBuffer:true 2. 按钮绑定鼠标事件 3. 创建超链接元素a：用于保存下载文件 4. Cavnas方法.toDataURL()",content:"# three.js渲染结果保存为图片\n\n保存three.js渲染结果，其实就是保存three.js对应canvas画布上的图像。那么这个问题就转化为如何把canvas画布保存为一个图片。\n\n\n# 超链接元素a下载文件\n\n在学习下面内容之前，如果你有兴趣，可以选择补充下前端相关知识，具体说就是通过超链接元素a合成一个文件，并下载。\n\n你通过下面代码，可以通过点击按钮“下载”，创建一个txt文件，下载到本地，txt文件包含字符串“一些数据”。\n\n<button type=\"button\" name=\"button\" onclick=\"saveFile()\">下载</button>\n<script>\n  function saveFile() {\n    // 创建一个超链接元素，用来下载保存数据的文件\n    const link = document.createElement('a');\n    // 通过超链接herf属性，设置要保存到文件中的数据\n    link.href = window.URL.createObjectURL(new Blob(['一些数据']));\n    link.download = '文件名称.txt';//下载文件名\n    link.click();//js代码触发超链接元素a的鼠标点击事件，开始下载文件到本地\n  }\n<\/script>\n\n\n\n# 1. 配置webgl渲染器preserveDrawingBuffer:true\n\n// WebGL渲染器设置\nconst renderer = new THREE.WebGLRenderer({\n    //想把canvas画布上内容下载到本地，需要设置为true\n    preserveDrawingBuffer:true,\n});\n\n\n\n# 2. 按钮绑定鼠标事件\n\n创建一个UI按钮\"下载\"，绑定一个鼠标单击事件，用于后面点击下载图片。\n\n// 鼠标单击id为download的HTML元素，threejs渲染结果以图片形式下载到本地\ndocument.getElementById('download').addEventListener('click',function(){\n    \n})\n\n\n\n# 3. 创建超链接元素a：用于保存下载文件\n\n// 鼠标单击id为download的HTML元素，threejs渲染结果以图片形式下载到本地\ndocument.getElementById('download').addEventListener('click',function(){\n    // 创建一个超链接元素，用来下载保存数据的文件\n    const link = document.createElement('a');\n    // 通过超链接herf属性，设置要保存到文件中的数据\n    link.href = ;\n    link.download = 'threejs.png'; //下载文件名\n    link.click(); //js代码触发超链接元素a的鼠标点击事件，开始下载文件到本地\n})\n\n\n\n# 4. Cavnas方法.toDataURL()\n\nCanvas画布通过.toDataURL()方法可以获取画布上的像素信息。canvas.toDataURL(\"image/png\");表示以png格式获取像素数据，可以直接赋值给超链接元素a的.herf属性下载到本地。\n\nconst link = document.createElement('a');\n// 通过超链接herf属性，设置要保存到文件中的数据\nconst canvas = renderer.domElement; //获取canvas对象\nlink.href = canvas.toDataURL(\"image/png\");\n\n\n以不同的格式获取像素信息\n\ncanvas.toDataURL(\"image/png\");\ncanvas.toDataURL(\"image/jpeg\");\ncanvas.toDataURL(\"image/bmp\");\n",normalizedContent:"# three.js渲染结果保存为图片\n\n保存three.js渲染结果，其实就是保存three.js对应canvas画布上的图像。那么这个问题就转化为如何把canvas画布保存为一个图片。\n\n\n# 超链接元素a下载文件\n\n在学习下面内容之前，如果你有兴趣，可以选择补充下前端相关知识，具体说就是通过超链接元素a合成一个文件，并下载。\n\n你通过下面代码，可以通过点击按钮“下载”，创建一个txt文件，下载到本地，txt文件包含字符串“一些数据”。\n\n<button type=\"button\" name=\"button\" onclick=\"savefile()\">下载</button>\n<script>\n  function savefile() {\n    // 创建一个超链接元素，用来下载保存数据的文件\n    const link = document.createelement('a');\n    // 通过超链接herf属性，设置要保存到文件中的数据\n    link.href = window.url.createobjecturl(new blob(['一些数据']));\n    link.download = '文件名称.txt';//下载文件名\n    link.click();//js代码触发超链接元素a的鼠标点击事件，开始下载文件到本地\n  }\n<\/script>\n\n\n\n# 1. 配置webgl渲染器preservedrawingbuffer:true\n\n// webgl渲染器设置\nconst renderer = new three.webglrenderer({\n    //想把canvas画布上内容下载到本地，需要设置为true\n    preservedrawingbuffer:true,\n});\n\n\n\n# 2. 按钮绑定鼠标事件\n\n创建一个ui按钮\"下载\"，绑定一个鼠标单击事件，用于后面点击下载图片。\n\n// 鼠标单击id为download的html元素，threejs渲染结果以图片形式下载到本地\ndocument.getelementbyid('download').addeventlistener('click',function(){\n    \n})\n\n\n\n# 3. 创建超链接元素a：用于保存下载文件\n\n// 鼠标单击id为download的html元素，threejs渲染结果以图片形式下载到本地\ndocument.getelementbyid('download').addeventlistener('click',function(){\n    // 创建一个超链接元素，用来下载保存数据的文件\n    const link = document.createelement('a');\n    // 通过超链接herf属性，设置要保存到文件中的数据\n    link.href = ;\n    link.download = 'threejs.png'; //下载文件名\n    link.click(); //js代码触发超链接元素a的鼠标点击事件，开始下载文件到本地\n})\n\n\n\n# 4. cavnas方法.todataurl()\n\ncanvas画布通过.todataurl()方法可以获取画布上的像素信息。canvas.todataurl(\"image/png\");表示以png格式获取像素数据，可以直接赋值给超链接元素a的.herf属性下载到本地。\n\nconst link = document.createelement('a');\n// 通过超链接herf属性，设置要保存到文件中的数据\nconst canvas = renderer.domelement; //获取canvas对象\nlink.href = canvas.todataurl(\"image/png\");\n\n\n以不同的格式获取像素信息\n\ncanvas.todataurl(\"image/png\");\ncanvas.todataurl(\"image/jpeg\");\ncanvas.todataurl(\"image/bmp\");\n",charsets:{cjk:!0}},{title:"6. 深度冲突(模型闪烁)",frontmatter:{title:"6. 深度冲突(模型闪烁)",date:"2023-01-29T16:50:27.000Z",permalink:"/pages/e8f727/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/08.8.%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%89%8D%E7%AB%AFUI%E7%95%8C%E9%9D%A2/06.%E6%B7%B1%E5%BA%A6%E5%86%B2%E7%AA%81(%E6%A8%A1%E5%9E%8B%E9%97%AA%E7%83%81).html",relativePath:"01.Three.js教程/08.8.渲染器和前端UI界面/06.深度冲突(模型闪烁).md",key:"v-544a2f3c",path:"/pages/e8f727/",headers:[{level:3,title:"Mesh面重合渲染测试",slug:"mesh面重合渲染测试",normalizedTitle:"mesh面重合渲染测试",charIndex:108},{level:3,title:"两个矩形Mesh拉开距离",slug:"两个矩形mesh拉开距离",normalizedTitle:"两个矩形mesh拉开距离",charIndex:709},{level:3,title:"建模注意",slug:"建模注意",normalizedTitle:"建模注意",charIndex:794},{level:3,title:"间隙很小，深度冲突",slug:"间隙很小-深度冲突",normalizedTitle:"间隙很小，深度冲突",charIndex:858},{level:3,title:"透视投影相机对距离影响(深度冲突)",slug:"透视投影相机对距离影响-深度冲突",normalizedTitle:"透视投影相机对距离影响(深度冲突)",charIndex:1015},{level:3,title:"webgl渲染器设置对数深度缓冲区",slug:"webgl渲染器设置对数深度缓冲区",normalizedTitle:"webgl渲染器设置对数深度缓冲区",charIndex:1417}],headersStr:"Mesh面重合渲染测试 两个矩形Mesh拉开距离 建模注意 间隙很小，深度冲突 透视投影相机对距离影响(深度冲突) webgl渲染器设置对数深度缓冲区",content:"# 深度冲突(模型闪烁)\n\n本节课通过一个比较简单的案例，来给大家展示一下，实际开发的过程中，你可能会遇到的模型闪烁问题。\n\n对于模型闪烁的原因简单地说就是深度冲突，对应的英文关键词是Z-fighting。\n\n\n# Mesh面重合渲染测试\n\n下面代码创建两个重合的矩形平面Mesh，通过浏览器预览，当你旋转三维场景的时候，你会发现模型渲染的时候产生闪烁。\n\n这种现象，主要是两个Mesh重合，电脑GPU分不清谁在前谁在后，这种现象，可以称为深度冲突Z-fighting。\n\n// 两个矩形平面Mesh重合，产生闪烁\n// 闪烁原因：两个矩形面位置重合，GPU无法分清谁在前谁在后\nconst geometry = new THREE.PlaneGeometry(250, 250);\nconst material = new THREE.MeshLambertMaterial({\n    color: 0x00ffff,\n    side: THREE.DoubleSide,\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\n\nconst geometry2 = new THREE.PlaneGeometry(300, 300); \nconst material2 = new THREE.MeshLambertMaterial({\n    color: 0xff6666,\n    side: THREE.DoubleSide,\n});\nconst mesh2 = new THREE.Mesh(geometry2, material2);\n\n\n\n# 两个矩形Mesh拉开距离\n\n适当偏移，解决深度冲突，偏移尺寸相对模型尺寸比较小，视觉上两个平面近似还是重合效果。\n\nmesh2.position.z = 1;\n\n\n\n# 建模注意\n\n上面代码测试提醒我们，在三维软件中建模的的时候，尽量避免两个Mesh完全重合，可以考虑适当偏移一定的距离。\n\n\n# 间隙很小，深度冲突\n\n当两个面间隙很小，也可能出现深度冲突。从纯理论的角度，你能分清0和0.0000...0000001的大小，但是实际上，电脑GPU精度是有限的。\n\n// 当两个面间隙很小，也可能出现深度冲突。\nmesh2.position.z = 0.0000000000000000000001;\n\n\n\n# 透视投影相机对距离影响(深度冲突)\n\n第1步：设置两个Mesh平面的距离相差0.1，课件中案例源码你可以看到，没有深度冲突导致的模型闪烁问题\n\nmesh2.position.z = 0;\nmesh2.position.z = 0.1;\ncamera.position.set(292, 223, 185);\n\n\n第2步：改变相机.position属性，你会发现当相机距离三维模型较远的时候，两个面也可能出现深度冲突，当然你也可以通过相机控件OrbitControls缩放功能，改变相机与模型的距离，进行观察。\n\ncamera.position.set(292*5, 223*5, 185*5)\n\n\n透视投影相机的投影规律是远小近大，和人眼观察世界一样，模型距离相机越远，模型渲染的效果越小，两个mesh之间的间距同样也会变小。当两个Mesh和相机距离远到一定程度，两个模型的距离也会无限接近0。\n\n\n# webgl渲染器设置对数深度缓冲区\n\n两个矩形平面距离比较近，相差0.1\n\nmesh2.position.z = 0;\nmesh2.position.z = 0.1;\ncamera.position.set(292*5, 223*5, 185*5);\n\n\n当一个三维场景中有一些面距离比较近，有深度冲突，你可以尝试设置webgl渲染器设置对数深度缓冲区logarithmicDepthBuffer: true来优化或解决。logarithmicDepthBuffer: true作用简单来说，就是两个面间距比较小的时候，让threejs更容易区分两个面，谁在前，谁在后。\n\n// WebGL渲染器设置\nconst renderer = new THREE.WebGLRenderer({\n    // 设置对数深度缓冲区，优化深度冲突问题\n    logarithmicDepthBuffer: true\n});\n\n\n有一点要注意，当两个面间隙过小，或者重合，你设置webgl渲染器对数深度缓冲区也是无效的。\n\nmesh2.position.z = 0;\n//当两个面重合，logarithmicDepthBuffer: true无效\nmesh2.position.z = 0;\n//当两个面间隙过小，logarithmicDepthBuffer: true无效\nmesh2.position.z = 0.00001;\ncamera.position.set(292*5, 223*5, 185*5);\n",normalizedContent:"# 深度冲突(模型闪烁)\n\n本节课通过一个比较简单的案例，来给大家展示一下，实际开发的过程中，你可能会遇到的模型闪烁问题。\n\n对于模型闪烁的原因简单地说就是深度冲突，对应的英文关键词是z-fighting。\n\n\n# mesh面重合渲染测试\n\n下面代码创建两个重合的矩形平面mesh，通过浏览器预览，当你旋转三维场景的时候，你会发现模型渲染的时候产生闪烁。\n\n这种现象，主要是两个mesh重合，电脑gpu分不清谁在前谁在后，这种现象，可以称为深度冲突z-fighting。\n\n// 两个矩形平面mesh重合，产生闪烁\n// 闪烁原因：两个矩形面位置重合，gpu无法分清谁在前谁在后\nconst geometry = new three.planegeometry(250, 250);\nconst material = new three.meshlambertmaterial({\n    color: 0x00ffff,\n    side: three.doubleside,\n});\nconst mesh = new three.mesh(geometry, material);\n\n\nconst geometry2 = new three.planegeometry(300, 300); \nconst material2 = new three.meshlambertmaterial({\n    color: 0xff6666,\n    side: three.doubleside,\n});\nconst mesh2 = new three.mesh(geometry2, material2);\n\n\n\n# 两个矩形mesh拉开距离\n\n适当偏移，解决深度冲突，偏移尺寸相对模型尺寸比较小，视觉上两个平面近似还是重合效果。\n\nmesh2.position.z = 1;\n\n\n\n# 建模注意\n\n上面代码测试提醒我们，在三维软件中建模的的时候，尽量避免两个mesh完全重合，可以考虑适当偏移一定的距离。\n\n\n# 间隙很小，深度冲突\n\n当两个面间隙很小，也可能出现深度冲突。从纯理论的角度，你能分清0和0.0000...0000001的大小，但是实际上，电脑gpu精度是有限的。\n\n// 当两个面间隙很小，也可能出现深度冲突。\nmesh2.position.z = 0.0000000000000000000001;\n\n\n\n# 透视投影相机对距离影响(深度冲突)\n\n第1步：设置两个mesh平面的距离相差0.1，课件中案例源码你可以看到，没有深度冲突导致的模型闪烁问题\n\nmesh2.position.z = 0;\nmesh2.position.z = 0.1;\ncamera.position.set(292, 223, 185);\n\n\n第2步：改变相机.position属性，你会发现当相机距离三维模型较远的时候，两个面也可能出现深度冲突，当然你也可以通过相机控件orbitcontrols缩放功能，改变相机与模型的距离，进行观察。\n\ncamera.position.set(292*5, 223*5, 185*5)\n\n\n透视投影相机的投影规律是远小近大，和人眼观察世界一样，模型距离相机越远，模型渲染的效果越小，两个mesh之间的间距同样也会变小。当两个mesh和相机距离远到一定程度，两个模型的距离也会无限接近0。\n\n\n# webgl渲染器设置对数深度缓冲区\n\n两个矩形平面距离比较近，相差0.1\n\nmesh2.position.z = 0;\nmesh2.position.z = 0.1;\ncamera.position.set(292*5, 223*5, 185*5);\n\n\n当一个三维场景中有一些面距离比较近，有深度冲突，你可以尝试设置webgl渲染器设置对数深度缓冲区logarithmicdepthbuffer: true来优化或解决。logarithmicdepthbuffer: true作用简单来说，就是两个面间距比较小的时候，让threejs更容易区分两个面，谁在前，谁在后。\n\n// webgl渲染器设置\nconst renderer = new three.webglrenderer({\n    // 设置对数深度缓冲区，优化深度冲突问题\n    logarithmicdepthbuffer: true\n});\n\n\n有一点要注意，当两个面间隙过小，或者重合，你设置webgl渲染器对数深度缓冲区也是无效的。\n\nmesh2.position.z = 0;\n//当两个面重合，logarithmicdepthbuffer: true无效\nmesh2.position.z = 0;\n//当两个面间隙过小，logarithmicdepthbuffer: true无效\nmesh2.position.z = 0.00001;\ncamera.position.set(292*5, 223*5, 185*5);\n",charsets:{cjk:!0}},{title:"7. 模型加载进度条",frontmatter:{title:"7. 模型加载进度条",date:"2023-01-29T16:50:42.000Z",permalink:"/pages/71ed82/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/08.8.%E6%B8%B2%E6%9F%93%E5%99%A8%E5%92%8C%E5%89%8D%E7%AB%AFUI%E7%95%8C%E9%9D%A2/07.%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1.html",relativePath:"01.Three.js教程/08.8.渲染器和前端UI界面/07.模型加载进度条.md",key:"v-d79514d0",path:"/pages/71ed82/",headers:[{level:3,title:"进度条HTML、CSS、JavaScript代码",slug:"进度条html、css、javascript代码",normalizedTitle:"进度条html、css、javascript代码",charIndex:90},{level:3,title:"加载器查看模型加载进度",slug:"加载器查看模型加载进度",normalizedTitle:"加载器查看模型加载进度",charIndex:1271},{level:3,title:"加载进度控制进度条",slug:"加载进度控制进度条",normalizedTitle:"加载进度控制进度条",charIndex:1744},{level:3,title:"加载完成隐藏进度条",slug:"加载完成隐藏进度条",normalizedTitle:"加载完成隐藏进度条",charIndex:2234}],headersStr:"进度条HTML、CSS、JavaScript代码 加载器查看模型加载进度 加载进度控制进度条 加载完成隐藏进度条",content:'# 模型加载进度条\n\nweb3d可视化项目开发，很多时候，3D模型的大小要比普通前端项目的文件大得多，这时候往往需要设置一个进度条，表示模型的加载进度。\n\n在线进度条案例\n\n\n# 进度条HTML、CSS、JavaScript代码\n\n课件中提供的是用原生HTML、CSS、JavaScript代码写的一个进度条，当然实际开发的时候，你可以不自己写，选择成熟的UI组件库，比如你使用vue技术栈的Element-ui进度条组件。\n\n建议：正式学习后面threejs代码之前，你可以先自己把下面进度条CSS代码写一遍，然后再学习后面内容。\n\n<head>\n    <style>\n        /* 进度条css样式 */\n        #container {\n            position: absolute;\n            width: 400px;\n            height: 16px;\n            top: 50%;\n            left:50%;\n            margin-left: -200px;\n            margin-top: -8px;\n            border-radius: 8px;           \n            border: 1px solid #009999;          \n            overflow: hidden;\n        }\n        #per {\n            height: 100%;\n            width: 0px;\n            background: #00ffff;\n            color: #00ffff;\n            line-height: 15px;          \n        }\n    </style>\n</head>\n<body style="background-color: #001111;">\n    <div id="container">\n        \x3c!-- 进度条 --\x3e\n        <div id="per"> </div>\n    </div>\n    <script>        \n        const percentDiv = document.getElementById("per");// 获取进度条元素\n        percentDiv.style.width = 0.8*400 + "px";//进度条元素长度\n        percentDiv.style.textIndent = 0.8*400 + 5 +"px";//缩进元素中的首行文本\n        percentDiv.innerHTML =  "80%";//进度百分比\n    <\/script>\n</body>\n\n\n\n# 加载器查看模型加载进度\n\ngltf模型加载进度具体语法可以查看GLTFLoader文档。\n\nloader.load(模型路径,加载完成函数,加载过程函数)\n\n\n模型本身是有大小的，通过浏览器从服务器加载的时候，本身网络传输是需要时间的。\n\n.load()方法的参数2是一个函数，参数2函数是模型加载完成以后才会被调用执行。\n\n.load()方法的参数3是一个函数，通过函数的参数获取模型加载信息,每当模型加载部分内容，该函数就会被调用，一次加载过程中一般会被调用多次，直到模型加载完成。\n\nloader.load("../工厂.glb", function (gltf) {\n    model.add(gltf.scene);\n}, function (xhr) {\n    // 控制台查看加载进度xhr\n    // 通过加载进度xhr可以控制前端进度条进度   \n    const percent = xhr.loaded / xhr.total;\n    console.log(\'加载进度\' + percent);\n})\n\n\n\n# 加载进度控制进度条\n\n把案例源码原生HTML、CSS进度条.html中进度条的HTML、CSS、JavaScript代码复制到threejs代码中，修改即可。\n\nloader.load("../工厂.glb", function (gltf) {\n    model.add(gltf.scene);\n}, function (xhr) {\n    const percent = xhr.loaded / xhr.total;\n    // console.log(\'加载进度\' + percent);\n    percentDiv.style.width = percent * 400 + "px"; //进度条元素长度\n    percentDiv.style.textIndent = percent * 400 + 5 + "px"; //缩进元素中的首行文本\n    // Math.floor:小数加载进度取整\n    percentDiv.innerHTML = Math.floor(percent * 100) + \'%\'; //进度百分比\n})\n\n\n\n# 加载完成隐藏进度条\n\nthreejs模型加载完成后，就不需要显示进度条，可以通过.style.display属性设置，也可以通过.style.visibility属性隐藏进度条。\n\nloader.load("../工厂.glb", function (gltf) {\n    model.add(gltf.scene);\n    // 加载完成，隐藏进度条\n    // document.getElementById("container").style.visibility =\'hidden\';\n    document.getElementById("container").style.display = \'none\';\n}, function (xhr) { \n    const percent = xhr.loaded / xhr.total;\n    console.log(\'加载进度\' + percent);\n})\n',normalizedContent:'# 模型加载进度条\n\nweb3d可视化项目开发，很多时候，3d模型的大小要比普通前端项目的文件大得多，这时候往往需要设置一个进度条，表示模型的加载进度。\n\n在线进度条案例\n\n\n# 进度条html、css、javascript代码\n\n课件中提供的是用原生html、css、javascript代码写的一个进度条，当然实际开发的时候，你可以不自己写，选择成熟的ui组件库，比如你使用vue技术栈的element-ui进度条组件。\n\n建议：正式学习后面threejs代码之前，你可以先自己把下面进度条css代码写一遍，然后再学习后面内容。\n\n<head>\n    <style>\n        /* 进度条css样式 */\n        #container {\n            position: absolute;\n            width: 400px;\n            height: 16px;\n            top: 50%;\n            left:50%;\n            margin-left: -200px;\n            margin-top: -8px;\n            border-radius: 8px;           \n            border: 1px solid #009999;          \n            overflow: hidden;\n        }\n        #per {\n            height: 100%;\n            width: 0px;\n            background: #00ffff;\n            color: #00ffff;\n            line-height: 15px;          \n        }\n    </style>\n</head>\n<body style="background-color: #001111;">\n    <div id="container">\n        \x3c!-- 进度条 --\x3e\n        <div id="per"> </div>\n    </div>\n    <script>        \n        const percentdiv = document.getelementbyid("per");// 获取进度条元素\n        percentdiv.style.width = 0.8*400 + "px";//进度条元素长度\n        percentdiv.style.textindent = 0.8*400 + 5 +"px";//缩进元素中的首行文本\n        percentdiv.innerhtml =  "80%";//进度百分比\n    <\/script>\n</body>\n\n\n\n# 加载器查看模型加载进度\n\ngltf模型加载进度具体语法可以查看gltfloader文档。\n\nloader.load(模型路径,加载完成函数,加载过程函数)\n\n\n模型本身是有大小的，通过浏览器从服务器加载的时候，本身网络传输是需要时间的。\n\n.load()方法的参数2是一个函数，参数2函数是模型加载完成以后才会被调用执行。\n\n.load()方法的参数3是一个函数，通过函数的参数获取模型加载信息,每当模型加载部分内容，该函数就会被调用，一次加载过程中一般会被调用多次，直到模型加载完成。\n\nloader.load("../工厂.glb", function (gltf) {\n    model.add(gltf.scene);\n}, function (xhr) {\n    // 控制台查看加载进度xhr\n    // 通过加载进度xhr可以控制前端进度条进度   \n    const percent = xhr.loaded / xhr.total;\n    console.log(\'加载进度\' + percent);\n})\n\n\n\n# 加载进度控制进度条\n\n把案例源码原生html、css进度条.html中进度条的html、css、javascript代码复制到threejs代码中，修改即可。\n\nloader.load("../工厂.glb", function (gltf) {\n    model.add(gltf.scene);\n}, function (xhr) {\n    const percent = xhr.loaded / xhr.total;\n    // console.log(\'加载进度\' + percent);\n    percentdiv.style.width = percent * 400 + "px"; //进度条元素长度\n    percentdiv.style.textindent = percent * 400 + 5 + "px"; //缩进元素中的首行文本\n    // math.floor:小数加载进度取整\n    percentdiv.innerhtml = math.floor(percent * 100) + \'%\'; //进度百分比\n})\n\n\n\n# 加载完成隐藏进度条\n\nthreejs模型加载完成后，就不需要显示进度条，可以通过.style.display属性设置，也可以通过.style.visibility属性隐藏进度条。\n\nloader.load("../工厂.glb", function (gltf) {\n    model.add(gltf.scene);\n    // 加载完成，隐藏进度条\n    // document.getelementbyid("container").style.visibility =\'hidden\';\n    document.getelementbyid("container").style.display = \'none\';\n}, function (xhr) { \n    const percent = xhr.loaded / xhr.total;\n    console.log(\'加载进度\' + percent);\n})\n',charsets:{cjk:!0}},{title:"1. 生成圆弧顶点",frontmatter:{title:"1. 生成圆弧顶点",date:"2023-01-29T16:47:53.000Z",permalink:"/pages/8868a1/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/01.%E7%94%9F%E6%88%90%E5%9C%86%E5%BC%A7%E9%A1%B6%E7%82%B9.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/01.生成圆弧顶点.md",key:"v-5f9a68e8",path:"/pages/8868a1/",headers:[{level:3,title:"生成圆弧顶点数据",slug:"生成圆弧顶点数据",normalizedTitle:"生成圆弧顶点数据",charIndex:903},{level:3,title:"线模型渲染圆弧线",slug:"线模型渲染圆弧线",normalizedTitle:"线模型渲染圆弧线",charIndex:1360},{level:3,title:"绘制半圆弧",slug:"绘制半圆弧",normalizedTitle:"绘制半圆弧",charIndex:1782},{level:3,title:"圆弧设置圆心坐标",slug:"圆弧设置圆心坐标",normalizedTitle:"圆弧设置圆心坐标",charIndex:1861}],headersStr:"生成圆弧顶点数据 线模型渲染圆弧线 绘制半圆弧 圆弧设置圆心坐标",content:"# 生成圆弧顶点\n\n通过代码算法生成圆弧线上的顶点坐标，并最后绘制一个圆弧效果。\n\n学习本节课之前，确保你已经掌握章节2中，关于几何体顶点数据的讲解。\n\nconst geometry = new THREE.BufferGeometry(); //创建一个几何体对象\nconst R = 100; //圆弧半径\nconst N = 50; //分段数量\nconst sp = 2 * Math.PI / N;//两个相邻点间隔弧度\n// 批量生成圆弧上的顶点数据\nconst arr = [];\nfor (let i = 0; i < N; i++) {\n    const angle =  sp * i;//当前点弧度\n    // 以坐标原点为中心，在XOY平面上生成圆弧上的顶点数据\n    const x = R * Math.cos(angle);\n    const y = R * Math.sin(angle);\n    arr.push(x, y, 0);\n}\n//类型数组创建顶点数据\nconst vertices = new Float32Array(arr);\n// 创建属性缓冲区对象\n//3个为一组，表示一个顶点的xyz坐标\nconst attribue = new THREE.BufferAttribute(vertices, 3); \n// 设置几何体attributes属性的位置属性\ngeometry.attributes.position = attribue;\n\n// 线材质\nconst material = new THREE.LineBasicMaterial({\n    color: 0xff0000 //线条颜色\n});\n// 创建线模型对象   构造函数：Line、LineLoop、LineSegments\n// const line = new THREE.Line(geometry, material); \nconst line = new THREE.LineLoop(geometry, material);//线条模型对象\n\n\n\n# 生成圆弧顶点数据\n\n以坐标原点为中心，在XOY平面上生成圆弧上的顶点数据。\n\n绘制圆弧线，本质就是绘制一个正n边形，n越大，圆弧细分数或者说精度越高。\n\n通过for循环沿着圆弧线，通过三角函数计算顶点坐标，批量生成圆弧上顶点数据。\n\nconst R = 100; //圆弧半径\nconst N = 50; //分段数量\nconst sp = 2 * Math.PI / N;//两个相邻点间隔弧度\n// 批量生成圆弧上的顶点数据\nconst arr = [];\n// N控制圆弧精度：就是创建多少个顶点\nfor (let i = 0; i < N; i++) {\n    const angle =  sp * i;//当前点弧度\n    // 以坐标原点为中心，在XOY平面上生成圆弧上的顶点数据\n    const x = R * Math.cos(angle);\n    const y = R * Math.sin(angle);\n    arr.push(x, y, 0);//xyz坐标\n}\n\n\n\n# 线模型渲染圆弧线\n\n使用Line渲染圆弧线会有一个缺口，不完全闭合，使用LineLoop可以封闭最后缺口。\n\n// 线材质\nconst material = new THREE.LineBasicMaterial({\n    color: 0xff0000 //线条颜色\n});\n// 创建线模型对象   构造函数：Line、LineLoop、LineSegments\n// const line = new THREE.Line(geometry, material); \nconst line = new THREE.LineLoop(geometry, material);//线条模型对象\n\n\n使用Line渲染，也可以修改for循环条件多增加一个点绘制圆弧。\n\nfor (let i = 0; i < N; i++) {\n\n}\n\n\n// 多绘制一个点\nfor (let i = 0; i < N + 1; i++) {\n\n}\n\n\n\n# 绘制半圆弧\n\nconst sp = 2 * Math.PI / N;//完整圆弧\nconst sp = 1 * Math.PI / N;//半圆弧\n\n\n\n# 圆弧设置圆心坐标\n\nconst R = 100; //圆弧半径\nconst N = 50; //分段数量\nconst sp = 2 * Math.PI / N;//两个相邻点间隔弧度\n// 设置圆心坐标\nconst cx = 200;\nconst cy = 100;\nfor (let i = 0; i < N+1; i++) {\n    const angle = sp * i;//当前点弧度\n    const x = cx + R * Math.cos(angle);\n    const y = cy + R * Math.sin(angle);\n    arr.push(x, y, 0);\n}\n",normalizedContent:"# 生成圆弧顶点\n\n通过代码算法生成圆弧线上的顶点坐标，并最后绘制一个圆弧效果。\n\n学习本节课之前，确保你已经掌握章节2中，关于几何体顶点数据的讲解。\n\nconst geometry = new three.buffergeometry(); //创建一个几何体对象\nconst r = 100; //圆弧半径\nconst n = 50; //分段数量\nconst sp = 2 * math.pi / n;//两个相邻点间隔弧度\n// 批量生成圆弧上的顶点数据\nconst arr = [];\nfor (let i = 0; i < n; i++) {\n    const angle =  sp * i;//当前点弧度\n    // 以坐标原点为中心，在xoy平面上生成圆弧上的顶点数据\n    const x = r * math.cos(angle);\n    const y = r * math.sin(angle);\n    arr.push(x, y, 0);\n}\n//类型数组创建顶点数据\nconst vertices = new float32array(arr);\n// 创建属性缓冲区对象\n//3个为一组，表示一个顶点的xyz坐标\nconst attribue = new three.bufferattribute(vertices, 3); \n// 设置几何体attributes属性的位置属性\ngeometry.attributes.position = attribue;\n\n// 线材质\nconst material = new three.linebasicmaterial({\n    color: 0xff0000 //线条颜色\n});\n// 创建线模型对象   构造函数：line、lineloop、linesegments\n// const line = new three.line(geometry, material); \nconst line = new three.lineloop(geometry, material);//线条模型对象\n\n\n\n# 生成圆弧顶点数据\n\n以坐标原点为中心，在xoy平面上生成圆弧上的顶点数据。\n\n绘制圆弧线，本质就是绘制一个正n边形，n越大，圆弧细分数或者说精度越高。\n\n通过for循环沿着圆弧线，通过三角函数计算顶点坐标，批量生成圆弧上顶点数据。\n\nconst r = 100; //圆弧半径\nconst n = 50; //分段数量\nconst sp = 2 * math.pi / n;//两个相邻点间隔弧度\n// 批量生成圆弧上的顶点数据\nconst arr = [];\n// n控制圆弧精度：就是创建多少个顶点\nfor (let i = 0; i < n; i++) {\n    const angle =  sp * i;//当前点弧度\n    // 以坐标原点为中心，在xoy平面上生成圆弧上的顶点数据\n    const x = r * math.cos(angle);\n    const y = r * math.sin(angle);\n    arr.push(x, y, 0);//xyz坐标\n}\n\n\n\n# 线模型渲染圆弧线\n\n使用line渲染圆弧线会有一个缺口，不完全闭合，使用lineloop可以封闭最后缺口。\n\n// 线材质\nconst material = new three.linebasicmaterial({\n    color: 0xff0000 //线条颜色\n});\n// 创建线模型对象   构造函数：line、lineloop、linesegments\n// const line = new three.line(geometry, material); \nconst line = new three.lineloop(geometry, material);//线条模型对象\n\n\n使用line渲染，也可以修改for循环条件多增加一个点绘制圆弧。\n\nfor (let i = 0; i < n; i++) {\n\n}\n\n\n// 多绘制一个点\nfor (let i = 0; i < n + 1; i++) {\n\n}\n\n\n\n# 绘制半圆弧\n\nconst sp = 2 * math.pi / n;//完整圆弧\nconst sp = 1 * math.pi / n;//半圆弧\n\n\n\n# 圆弧设置圆心坐标\n\nconst r = 100; //圆弧半径\nconst n = 50; //分段数量\nconst sp = 2 * math.pi / n;//两个相邻点间隔弧度\n// 设置圆心坐标\nconst cx = 200;\nconst cy = 100;\nfor (let i = 0; i < n+1; i++) {\n    const angle = sp * i;//当前点弧度\n    const x = cx + r * math.cos(angle);\n    const y = cy + r * math.sin(angle);\n    arr.push(x, y, 0);\n}\n",charsets:{cjk:!0}},{title:"2. 几何体方法.setFromPoints()",frontmatter:{title:"2. 几何体方法.setFromPoints()",date:"2023-01-29T16:48:23.000Z",permalink:"/pages/e28594/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/02.%E5%87%A0%E4%BD%95%E4%BD%93%E6%96%B9%E6%B3%95.setFromPoints().html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/02.几何体方法.setFromPoints().md",key:"v-4c63bba6",path:"/pages/e28594/",headers:[{level:3,title:"三维向量Vector3表示顶点坐标",slug:"三维向量vector3表示顶点坐标",normalizedTitle:"三维向量vector3表示顶点坐标",charIndex:103},{level:3,title:"几何体方法.setFromPoints()",slug:"几何体方法-setfrompoints-2",normalizedTitle:"几何体方法.setfrompoints()",charIndex:2},{level:3,title:"二维向量Vector2表示顶点坐标",slug:"二维向量vector2表示顶点坐标",normalizedTitle:"二维向量vector2表示顶点坐标",charIndex:658}],headersStr:"三维向量Vector3表示顶点坐标 几何体方法.setFromPoints() 二维向量Vector2表示顶点坐标",content:"# 几何体方法.setFromPoints()\n\n章节2给大家介绍过几何体BufferGeometry顶点数据，本节课在章节2基础上，给大家介绍该几何体的一个方法.setFromPoints()。\n\n\n# 三维向量Vector3表示顶点坐标\n\n用三维向量Vector3表示顶点的x、y、z坐标，作为数组元素创建一组顶点坐标。\n\nconst pointsArr = [\n    // 三维向量Vector3表示的坐标值\n    new THREE.Vector3(0,0,0),\n    new THREE.Vector3(0,100,0),\n    new THREE.Vector3(0,100,100),\n    new THREE.Vector3(0,0,100),\n];\n\n\n\n# 几何体方法.setFromPoints()\n\n.setFromPoints()是几何体BufferGeometry的一个方法，通过该方法可以把数组pointsArr中坐标数据提取出来赋值给几何体。具体说就是把pointsArr里面坐标数据提取出来，赋值给geometry.attributes.position属性\n\n// 把数组pointsArr里面的坐标数据提取出来，赋值给`geometry.attributes.position`属性\ngeometry.setFromPoints(pointsArr);\nconsole.log('几何体变化',geometry.attributes.position);\n\n\n\n# 二维向量Vector2表示顶点坐标\n\n用二维向量Vector2表示顶点的x、y坐标，作为数组元素创建一组顶点坐标。\n\nconst pointsArr = [\n    // 三维向量Vector2表示的坐标值\n    new THREE.Vector2(0,0),\n    new THREE.Vector2(100,0),\n    new THREE.Vector2(100,100),\n    new THREE.Vector2(0,100),\n];\n\n\n二维向量Vector2构成的数组作为.setFromPoints()的参数\n\ngeometry.setFromPoints(pointsArr);\n",normalizedContent:"# 几何体方法.setfrompoints()\n\n章节2给大家介绍过几何体buffergeometry顶点数据，本节课在章节2基础上，给大家介绍该几何体的一个方法.setfrompoints()。\n\n\n# 三维向量vector3表示顶点坐标\n\n用三维向量vector3表示顶点的x、y、z坐标，作为数组元素创建一组顶点坐标。\n\nconst pointsarr = [\n    // 三维向量vector3表示的坐标值\n    new three.vector3(0,0,0),\n    new three.vector3(0,100,0),\n    new three.vector3(0,100,100),\n    new three.vector3(0,0,100),\n];\n\n\n\n# 几何体方法.setfrompoints()\n\n.setfrompoints()是几何体buffergeometry的一个方法，通过该方法可以把数组pointsarr中坐标数据提取出来赋值给几何体。具体说就是把pointsarr里面坐标数据提取出来，赋值给geometry.attributes.position属性\n\n// 把数组pointsarr里面的坐标数据提取出来，赋值给`geometry.attributes.position`属性\ngeometry.setfrompoints(pointsarr);\nconsole.log('几何体变化',geometry.attributes.position);\n\n\n\n# 二维向量vector2表示顶点坐标\n\n用二维向量vector2表示顶点的x、y坐标，作为数组元素创建一组顶点坐标。\n\nconst pointsarr = [\n    // 三维向量vector2表示的坐标值\n    new three.vector2(0,0),\n    new three.vector2(100,0),\n    new three.vector2(100,100),\n    new three.vector2(0,100),\n];\n\n\n二维向量vector2构成的数组作为.setfrompoints()的参数\n\ngeometry.setfrompoints(pointsarr);\n",charsets:{cjk:!0}},{title:"3. 曲线Curve简介",frontmatter:{title:"3. 曲线Curve简介",date:"2023-01-29T16:46:57.000Z",permalink:"/pages/564039/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/03.%E6%9B%B2%E7%BA%BFCurve%E7%AE%80%E4%BB%8B.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/03.曲线Curve简介.md",key:"v-04bb1726",path:"/pages/564039/",headers:[{level:3,title:"椭圆EllipseCurve例子",slug:"椭圆ellipsecurve例子",normalizedTitle:"椭圆ellipsecurve例子",charIndex:96},{level:3,title:"曲线Curve方法.getPoints()",slug:"曲线curve方法-getpoints",normalizedTitle:"曲线curve方法.getpoints()",charIndex:247},{level:3,title:".setFromPoints()提取曲线坐标数据",slug:"setfrompoints-提取曲线坐标数据",normalizedTitle:".setfrompoints()提取曲线坐标数据",charIndex:656},{level:3,title:"点模型查看曲线上顶点坐标",slug:"点模型查看曲线上顶点坐标",normalizedTitle:"点模型查看曲线上顶点坐标",charIndex:882},{level:3,title:"曲线Curve方法.getSpacedPoints()",slug:"曲线curve方法-getspacedpoints",normalizedTitle:"曲线curve方法.getspacedpoints()",charIndex:1063},{level:3,title:"线模型绘制曲线",slug:"线模型绘制曲线",normalizedTitle:"线模型绘制曲线",charIndex:1512}],headersStr:"椭圆EllipseCurve例子 曲线Curve方法.getPoints() .setFromPoints()提取曲线坐标数据 点模型查看曲线上顶点坐标 曲线Curve方法.getSpacedPoints() 线模型绘制曲线",content:"# 曲线Curve简介\n\n上节课程绘制一个圆弧线是自己通过算法实现，其实threejs提供了很多常用的曲线或直线API，可以直接使用。这些API曲线都有一个共同的父类Curve。\n\n\n\n\n# 椭圆EllipseCurve例子\n\n曲线API的使用，具体语法可以查询文档，下面以椭圆为例，给大家绘制一个椭圆曲线效果。\n\n// 参数1和2表示椭圆中心坐标  参数3和4表示x和y方向半径\nconst arc = new THREE.EllipseCurve(0, 0, 100, 50);\n\n\n\n# 曲线Curve方法.getPoints()\n\n椭圆弧线EllipseCurve的父类是曲线Curve,自然会继承父类曲线.getPoints()方法，通过.getPoints()可以从曲线上获取顶点数据。\n\n通过方法.getPoints()可以从曲线上按照一定的细分精度返回沿着曲线分布的顶点坐标。细分数越高返回的顶点数量越多，自然轮廓越接近于曲线形状。方法.getPoints()的返回值是一个由二维向量Vector2或三维向量Vector3构成的数组，Vector2表示位于同一平面内的点，Vector3表示三维空间中一点。\n\n//getPoints是基类Curve的方法，平面曲线会返回一个vector2对象作为元素组成的数组\nconst pointsArr = arc.getPoints(50); //分段数50，返回51个顶点\nconsole.log('曲线上获取坐标',pointsArr);\n\n\n\n# .setFromPoints()提取曲线坐标数据\n\n把数组pointsArr里面的坐标数据提取出来，赋值给geometry.attributes.position属性\n\nconst geometry = new THREE.BufferGeometry();\ngeometry.setFromPoints(pointsArr);\nconsole.log('geometry.attributes',geometry.attributes);\n\n\n\n# 点模型查看曲线上顶点坐标\n\n// 点材质\nconst material = new THREE.PointsMaterial({\n    color: 0xffff00,\n    size: 10.0 //点对象像素尺寸\n}); \n// 点模型\nconst points = new THREE.Points(geometry, material);\n\n\n\n# 曲线Curve方法.getSpacedPoints()\n\n通过.getSpacedPoints()和.getPoints()一样也可以从曲线Curve上返回一系列曲线上的顶点坐标。\n\n通过.getSpacedPoints()是按照曲线长度等间距返回顶点数据，.getPoints()获取点的方式并不是按照曲线等间距的方式，而是会考虑曲线斜率变化，斜率变化快的位置返回的顶点更密集。\n\n你可以通过案例源码测试对比，分别两种获取顶点方式曲线坐标，然后使用点模型渲染，观察点的分布规律。\n\nconst geometry = new THREE.BufferGeometry();\ngeometry.getSpacedPoints(pointsArr);\nconsole.log('geometry.attributes',geometry.attributes);\n\n\n如果你有等间距取点的需求，可以选择.getSpacedPoints()方法，如果没有，就可以使用.getPoints()方法\n\n\n# 线模型绘制曲线\n\n// 线材质\nconst material = new THREE.LineBasicMaterial({\n    color: 0x00fffff\n});\n// 线模型\nconst line = new THREE.Line(geometry, material);\n",normalizedContent:"# 曲线curve简介\n\n上节课程绘制一个圆弧线是自己通过算法实现，其实threejs提供了很多常用的曲线或直线api，可以直接使用。这些api曲线都有一个共同的父类curve。\n\n\n\n\n# 椭圆ellipsecurve例子\n\n曲线api的使用，具体语法可以查询文档，下面以椭圆为例，给大家绘制一个椭圆曲线效果。\n\n// 参数1和2表示椭圆中心坐标  参数3和4表示x和y方向半径\nconst arc = new three.ellipsecurve(0, 0, 100, 50);\n\n\n\n# 曲线curve方法.getpoints()\n\n椭圆弧线ellipsecurve的父类是曲线curve,自然会继承父类曲线.getpoints()方法，通过.getpoints()可以从曲线上获取顶点数据。\n\n通过方法.getpoints()可以从曲线上按照一定的细分精度返回沿着曲线分布的顶点坐标。细分数越高返回的顶点数量越多，自然轮廓越接近于曲线形状。方法.getpoints()的返回值是一个由二维向量vector2或三维向量vector3构成的数组，vector2表示位于同一平面内的点，vector3表示三维空间中一点。\n\n//getpoints是基类curve的方法，平面曲线会返回一个vector2对象作为元素组成的数组\nconst pointsarr = arc.getpoints(50); //分段数50，返回51个顶点\nconsole.log('曲线上获取坐标',pointsarr);\n\n\n\n# .setfrompoints()提取曲线坐标数据\n\n把数组pointsarr里面的坐标数据提取出来，赋值给geometry.attributes.position属性\n\nconst geometry = new three.buffergeometry();\ngeometry.setfrompoints(pointsarr);\nconsole.log('geometry.attributes',geometry.attributes);\n\n\n\n# 点模型查看曲线上顶点坐标\n\n// 点材质\nconst material = new three.pointsmaterial({\n    color: 0xffff00,\n    size: 10.0 //点对象像素尺寸\n}); \n// 点模型\nconst points = new three.points(geometry, material);\n\n\n\n# 曲线curve方法.getspacedpoints()\n\n通过.getspacedpoints()和.getpoints()一样也可以从曲线curve上返回一系列曲线上的顶点坐标。\n\n通过.getspacedpoints()是按照曲线长度等间距返回顶点数据，.getpoints()获取点的方式并不是按照曲线等间距的方式，而是会考虑曲线斜率变化，斜率变化快的位置返回的顶点更密集。\n\n你可以通过案例源码测试对比，分别两种获取顶点方式曲线坐标，然后使用点模型渲染，观察点的分布规律。\n\nconst geometry = new three.buffergeometry();\ngeometry.getspacedpoints(pointsarr);\nconsole.log('geometry.attributes',geometry.attributes);\n\n\n如果你有等间距取点的需求，可以选择.getspacedpoints()方法，如果没有，就可以使用.getpoints()方法\n\n\n# 线模型绘制曲线\n\n// 线材质\nconst material = new three.linebasicmaterial({\n    color: 0x00fffff\n});\n// 线模型\nconst line = new three.line(geometry, material);\n",charsets:{cjk:!0}},{title:"4. 椭圆、圆",frontmatter:{title:"4. 椭圆、圆",date:"2023-01-29T16:46:57.000Z",permalink:"/pages/c64602/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/04.%E6%A4%AD%E5%9C%86%E3%80%81%E5%9C%86.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/04.椭圆、圆.md",key:"v-f58673ce",path:"/pages/c64602/",headers:[{level:3,title:"椭圆弧线EllipseCurve",slug:"椭圆弧线ellipsecurve",normalizedTitle:"椭圆弧线ellipsecurve",charIndex:32},{level:3,title:"圆弧线ArcCurve",slug:"圆弧线arccurve",normalizedTitle:"圆弧线arccurve",charIndex:528},{level:3,title:"曲线精度",slug:"曲线精度",normalizedTitle:"曲线精度",charIndex:1019},{level:3,title:"弧线起始角度",slug:"弧线起始角度",normalizedTitle:"弧线起始角度",charIndex:1159},{level:3,title:"顺逆时针",slug:"顺逆时针",normalizedTitle:"顺逆时针",charIndex:1423}],headersStr:"椭圆弧线EllipseCurve 圆弧线ArcCurve 曲线精度 弧线起始角度 顺逆时针",content:"# 椭圆和圆\n\n接着上节课内容给大家介绍椭圆和圆曲线。\n\n\n# 椭圆弧线EllipseCurve\n\nEllipseCurve( aX, aY, xRadius,yRadius, aStartAngle, aEndAngle, aClockwise )\n\n\n参数            含义\naX, aY        椭圆中心坐标\nxRadius       椭圆x轴半径\nyRadius       椭圆y轴半径\naStartAngle   弧线开始角度，从x轴正半轴开始，默认0，弧度单位\naEndAngle     弧线结束角度，从x轴正半轴算起，默认2 x Math.PI，弧度单位\naClockwise    是否顺时针绘制，默认值为false\n\n// 参数1和2表示椭圆中心坐标  参数3和4表示x和y方向半径\nconst arc = new THREE.EllipseCurve(0, 0, 100, 50);\n\n\n椭圆曲线x和y方向半径相同，就是一个圆的效果。\n\n// 参数1和2表示椭圆中心坐标  参数3和4表示x和y方向半径\nconst arc = new THREE.EllipseCurve(0, 0, 50, 50);\n\n\n\n# 圆弧线ArcCurve\n\n圆弧线ArcCurve的父类是椭圆弧线EllipseCurve,语法和椭圆弧线EllipseCurve相似，区别是参数3和参数4不同，椭圆需要定义xRadius和yRadius两个半径，圆只需要通过参数3定义半径aRadius即可。\n\n//参数：0, 0圆弧坐标原点x，y  100：圆弧半径    0, 2 * Math.PI：圆弧起始角度\nconst arc = new THREE.ArcCurve(0, 0, 100, 0, 2 * Math.PI);\n\n\nArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise )\n\n\n参数            含义\naX, aY        圆心坐标\naRadius       圆弧半径\naStartAngle   弧线开始角度，从x轴正半轴开始，默认0，弧度单位\naEndAngle     弧线结束角度，从x轴正半轴算起，默认2 x Math.PI，弧度单位\naClockwise    是否顺时针绘制，默认值为false\n\n\n# 曲线精度\n\n//曲线上取点，参数表示取点细分精度\nconst pointsArr = arc.getPoints(50); //分段数50，返回51个顶点\n// const pointsArr = arc.getPoints(10);//取点数比较少，圆弧线不那么光滑\n\n\n\n# 弧线起始角度\n\n参数4和5表示圆弧线的起始角度，three.js默认是一个完整的圆弧，其实你也可以绘制一个半圆弧。\n\n// 完整圆弧\nconst arc = new THREE.ArcCurve(0, 0, 100, 0, 2 * Math.PI);\n\n\n// 半圆弧\nconst arc = new THREE.ArcCurve(0, 0, 100, 0, Math.PI);\n\n\n// 四分之一圆弧\nconst arc = new THREE.ArcCurve(0, 0, 100, 0, Math.PI/2);\n\n\n\n# 顺逆时针\n\n参数6默认false，逆时针绘制圆弧\n\nconst arc = new THREE.ArcCurve(0, 0, 100, 0, Math.PI/2,false);\n\n\n参数6设置为true，顺时针绘制圆弧\n\nconst arc = new THREE.ArcCurve(0, 0, 100, 0, Math.PI/2,true);\n",normalizedContent:"# 椭圆和圆\n\n接着上节课内容给大家介绍椭圆和圆曲线。\n\n\n# 椭圆弧线ellipsecurve\n\nellipsecurve( ax, ay, xradius,yradius, astartangle, aendangle, aclockwise )\n\n\n参数            含义\nax, ay        椭圆中心坐标\nxradius       椭圆x轴半径\nyradius       椭圆y轴半径\nastartangle   弧线开始角度，从x轴正半轴开始，默认0，弧度单位\naendangle     弧线结束角度，从x轴正半轴算起，默认2 x math.pi，弧度单位\naclockwise    是否顺时针绘制，默认值为false\n\n// 参数1和2表示椭圆中心坐标  参数3和4表示x和y方向半径\nconst arc = new three.ellipsecurve(0, 0, 100, 50);\n\n\n椭圆曲线x和y方向半径相同，就是一个圆的效果。\n\n// 参数1和2表示椭圆中心坐标  参数3和4表示x和y方向半径\nconst arc = new three.ellipsecurve(0, 0, 50, 50);\n\n\n\n# 圆弧线arccurve\n\n圆弧线arccurve的父类是椭圆弧线ellipsecurve,语法和椭圆弧线ellipsecurve相似，区别是参数3和参数4不同，椭圆需要定义xradius和yradius两个半径，圆只需要通过参数3定义半径aradius即可。\n\n//参数：0, 0圆弧坐标原点x，y  100：圆弧半径    0, 2 * math.pi：圆弧起始角度\nconst arc = new three.arccurve(0, 0, 100, 0, 2 * math.pi);\n\n\narccurve( ax, ay, aradius, astartangle, aendangle, aclockwise )\n\n\n参数            含义\nax, ay        圆心坐标\naradius       圆弧半径\nastartangle   弧线开始角度，从x轴正半轴开始，默认0，弧度单位\naendangle     弧线结束角度，从x轴正半轴算起，默认2 x math.pi，弧度单位\naclockwise    是否顺时针绘制，默认值为false\n\n\n# 曲线精度\n\n//曲线上取点，参数表示取点细分精度\nconst pointsarr = arc.getpoints(50); //分段数50，返回51个顶点\n// const pointsarr = arc.getpoints(10);//取点数比较少，圆弧线不那么光滑\n\n\n\n# 弧线起始角度\n\n参数4和5表示圆弧线的起始角度，three.js默认是一个完整的圆弧，其实你也可以绘制一个半圆弧。\n\n// 完整圆弧\nconst arc = new three.arccurve(0, 0, 100, 0, 2 * math.pi);\n\n\n// 半圆弧\nconst arc = new three.arccurve(0, 0, 100, 0, math.pi);\n\n\n// 四分之一圆弧\nconst arc = new three.arccurve(0, 0, 100, 0, math.pi/2);\n\n\n\n# 顺逆时针\n\n参数6默认false，逆时针绘制圆弧\n\nconst arc = new three.arccurve(0, 0, 100, 0, math.pi/2,false);\n\n\n参数6设置为true，顺时针绘制圆弧\n\nconst arc = new three.arccurve(0, 0, 100, 0, math.pi/2,true);\n",charsets:{cjk:!0}},{title:"5. 样条曲线",frontmatter:{title:"5. 样条曲线",date:"2023-01-30T17:22:20.000Z",permalink:"/pages/717f0f/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/05.%E6%A0%B7%E6%9D%A1%E6%9B%B2%E7%BA%BF.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/05.样条曲线.md",key:"v-ab1a91e8",path:"/pages/717f0f/",headers:[{level:3,title:"三维样条曲线CatmullRomCurve3",slug:"三维样条曲线catmullromcurve3",normalizedTitle:"三维样条曲线catmullromcurve3",charIndex:98},{level:3,title:"从曲线获取顶点坐标，绘制线条",slug:"从曲线获取顶点坐标-绘制线条",normalizedTitle:"从曲线获取顶点坐标，绘制线条",charIndex:505},{level:3,title:"点模型可视化曲线经过的点",slug:"点模型可视化曲线经过的点",normalizedTitle:"点模型可视化曲线经过的点",charIndex:860},{level:3,title:"2D样条曲线",slug:"_2d样条曲线",normalizedTitle:"2d样条曲线",charIndex:1165}],headersStr:"三维样条曲线CatmullRomCurve3 从曲线获取顶点坐标，绘制线条 点模型可视化曲线经过的点 2D样条曲线",content:"# 样条曲线\n\n对于一些不规则的曲线，很难用一个圆、椭圆或抛物线函数去描述，这时候，可以使用threejs提供的样条曲线或贝塞尔曲线去表达。\n\n下面就给大家演示下样条曲线的使用特点。\n\n\n\n\n# 三维样条曲线CatmullRomCurve3\n\n在三维空间中随意设置几个顶点坐标，然后作为三维样条曲线CatmullRomCurve3的参数，你就可以生成一条穿过这几个点的光滑曲线。\n\nCatmullRomCurve3的参数是三维向量对象Vector3构成的数组。\n\n// 三维向量Vector3创建一组顶点坐标\nconst arr = [\n    new THREE.Vector3(-50, 20, 90),\n    new THREE.Vector3(-10, 40, 40),\n    new THREE.Vector3(0, 0, 0),\n    new THREE.Vector3(60, -60, 0),\n    new THREE.Vector3(70, 0, 80)\n]\n// 三维样条曲线\nconst curve = new THREE.CatmullRomCurve3(arr);\n\n\n\n# 从曲线获取顶点坐标，绘制线条\n\n从曲线获取一定量顶点数据，用于绘制线模型Line，一般来说获取顶点数量越多，渲染的曲线相对越光滑。\n\n//曲线上获取点\nconst pointsArr = curve.getPoints(100); \nconst geometry = new THREE.BufferGeometry();\n//读取坐标数据赋值给几何体顶点\ngeometry.setFromPoints(pointsArr); \n// 线材质\nconst material = new THREE.LineBasicMaterial({\n    color: 0x00fffff\n});\n// 线模型\nconst line = new THREE.Line(geometry, material);\n\n\n\n# 点模型可视化曲线经过的点\n\n点模型可视化曲线经过的点，验证样条曲线是否经过数数组arr表示的几个顶点坐标。\n\n// 用点模型可视化样条曲线经过的顶点位置\nconst geometry2 = new THREE.BufferGeometry();\ngeometry2.setFromPoints(arr);\nconst material2 = new THREE.PointsMaterial({\n    color: 0xff00ff,\n    size: 10,\n});\n//点模型对象\nconst points = new THREE.Points(geometry2, material2);\n\n\n\n# 2D样条曲线\n\nCatmullRomCurve3是3D样条曲线API，曲线经过的点可以在3D空间中任何一个位置，二维样条曲线SplineCurve默认情况下就是在XOY平面生成一个平面的样条曲线。\n\nSplineCurve的参数是二维向量对象Vector2构成的数组。\n\n// 二维向量Vector2创建一组顶点坐标\nconst arr = [\n    new THREE.Vector2(-100, 0),\n    new THREE.Vector2(0, 30),\n    new THREE.Vector2(100, 0),\n];\n// 二维样条曲线\nconst curve = new THREE.SplineCurve(arr);\n",normalizedContent:"# 样条曲线\n\n对于一些不规则的曲线，很难用一个圆、椭圆或抛物线函数去描述，这时候，可以使用threejs提供的样条曲线或贝塞尔曲线去表达。\n\n下面就给大家演示下样条曲线的使用特点。\n\n\n\n\n# 三维样条曲线catmullromcurve3\n\n在三维空间中随意设置几个顶点坐标，然后作为三维样条曲线catmullromcurve3的参数，你就可以生成一条穿过这几个点的光滑曲线。\n\ncatmullromcurve3的参数是三维向量对象vector3构成的数组。\n\n// 三维向量vector3创建一组顶点坐标\nconst arr = [\n    new three.vector3(-50, 20, 90),\n    new three.vector3(-10, 40, 40),\n    new three.vector3(0, 0, 0),\n    new three.vector3(60, -60, 0),\n    new three.vector3(70, 0, 80)\n]\n// 三维样条曲线\nconst curve = new three.catmullromcurve3(arr);\n\n\n\n# 从曲线获取顶点坐标，绘制线条\n\n从曲线获取一定量顶点数据，用于绘制线模型line，一般来说获取顶点数量越多，渲染的曲线相对越光滑。\n\n//曲线上获取点\nconst pointsarr = curve.getpoints(100); \nconst geometry = new three.buffergeometry();\n//读取坐标数据赋值给几何体顶点\ngeometry.setfrompoints(pointsarr); \n// 线材质\nconst material = new three.linebasicmaterial({\n    color: 0x00fffff\n});\n// 线模型\nconst line = new three.line(geometry, material);\n\n\n\n# 点模型可视化曲线经过的点\n\n点模型可视化曲线经过的点，验证样条曲线是否经过数数组arr表示的几个顶点坐标。\n\n// 用点模型可视化样条曲线经过的顶点位置\nconst geometry2 = new three.buffergeometry();\ngeometry2.setfrompoints(arr);\nconst material2 = new three.pointsmaterial({\n    color: 0xff00ff,\n    size: 10,\n});\n//点模型对象\nconst points = new three.points(geometry2, material2);\n\n\n\n# 2d样条曲线\n\ncatmullromcurve3是3d样条曲线api，曲线经过的点可以在3d空间中任何一个位置，二维样条曲线splinecurve默认情况下就是在xoy平面生成一个平面的样条曲线。\n\nsplinecurve的参数是二维向量对象vector2构成的数组。\n\n// 二维向量vector2创建一组顶点坐标\nconst arr = [\n    new three.vector2(-100, 0),\n    new three.vector2(0, 30),\n    new three.vector2(100, 0),\n];\n// 二维样条曲线\nconst curve = new three.splinecurve(arr);\n",charsets:{cjk:!0}},{title:"6. 贝塞尔曲线",frontmatter:{title:"6. 贝塞尔曲线",date:"2023-01-30T20:41:30.000Z",permalink:"/pages/15ba8d/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/06.%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/06.贝塞尔曲线.md",key:"v-4505f054",path:"/pages/15ba8d/",headers:[{level:3,title:"二维二次贝塞尔曲线QuadraticBezierCurve",slug:"二维二次贝塞尔曲线quadraticbeziercurve",normalizedTitle:"二维二次贝塞尔曲线quadraticbeziercurve",charIndex:75},{level:3,title:"观察贝塞尔曲线规则",slug:"观察贝塞尔曲线规则",normalizedTitle:"观察贝塞尔曲线规则",charIndex:686},{level:3,title:"三维二次贝赛尔曲线QuadraticBezierCurve3",slug:"三维二次贝赛尔曲线quadraticbeziercurve3",normalizedTitle:"三维二次贝赛尔曲线quadraticbeziercurve3",charIndex:1109},{level:3,title:"二维三次贝塞尔曲线CubicBezierCurve",slug:"二维三次贝塞尔曲线cubicbeziercurve",normalizedTitle:"二维三次贝塞尔曲线cubicbeziercurve",charIndex:1452},{level:3,title:"三维三次贝赛尔曲线CubicBezierCurve3",slug:"三维三次贝赛尔曲线cubicbeziercurve3",normalizedTitle:"三维三次贝赛尔曲线cubicbeziercurve3",charIndex:1827}],headersStr:"二维二次贝塞尔曲线QuadraticBezierCurve 观察贝塞尔曲线规则 三维二次贝赛尔曲线QuadraticBezierCurve3 二维三次贝塞尔曲线CubicBezierCurve 三维三次贝赛尔曲线CubicBezierCurve3",content:"# 贝塞尔曲线\n\n上节课讲解过，threejs可以通过样条曲线或贝塞尔曲线去表达生活中不规则的曲线，下面给大家介绍贝塞尔曲线有关的知识。\n\n\n\n\n# 二维二次贝塞尔曲线QuadraticBezierCurve\n\n// p1、p2、p3表示三个点坐标\n// p1、p3是曲线起始点，p2是曲线的控制点\nconst p1 = new THREE.Vector2(-80, 0);\nconst p2 = new THREE.Vector2(20, 100);\nconst p3 = new THREE.Vector2(80, 0);\n\n\n二维二次贝赛尔曲线QuadraticBezierCurve的前面三个参数是二维向量对象Vector2。\n\n// 二维二次贝赛尔曲线\nconst curve = new THREE.QuadraticBezierCurve(p1, p2, p3);\n\n\n曲线上获取一定数量点，线模型line渲染贝塞尔曲线。\n\nconst pointsArr = curve.getPoints(100); //曲线上获取点\nconst geometry = new THREE.BufferGeometry();\ngeometry.setFromPoints(pointsArr); //读取坐标数据赋值给几何体顶点\nconst material = new THREE.LineBasicMaterial({color: 0x00fffff});\nconst line = new THREE.Line(geometry, material);\n\n\n\n# 观察贝塞尔曲线规则\n\n可视化p1、p2、p3三个点的位置，并用直线相连接，便于观察贝塞尔曲线的绘制规律。\n\n你可以发现贝塞尔曲线经过p1、p3两个点，但是不经过p2点，贝塞尔曲线与直线p12和p23相切。\n\nconst geometry2 = new THREE.BufferGeometry();\ngeometry2.setFromPoints([p1,p2,p3]);\nconst material2 = new THREE.PointsMaterial({\n    color: 0xff00ff,\n    size: 10,\n});\n//点模型对象\nconst points = new THREE.Points(geometry2, material2);\n// 三个点构成的线条\nconst line2 = new THREE.Line(geometry2, new THREE.LineBasicMaterial());\n\n\n\n# 三维二次贝赛尔曲线QuadraticBezierCurve3\n\n三维二次贝赛尔曲线QuadraticBezierCurve3与二维二次贝赛尔曲线QuadraticBezierCurve区别就是多了一个维度，参数是三维向量对象Vector3。\n\n// p1、p2、p3表示三个点坐标\nconst p1 = new THREE.Vector3(-80, 0, 0);\nconst p2 = new THREE.Vector3(20, 100, 0);\nconst p3 = new THREE.Vector3(80, 0, 100);\n// 三维二次贝赛尔曲线\nconst curve = new THREE.QuadraticBezierCurve3(p1, p2, p3);\n\n\n\n# 二维三次贝塞尔曲线CubicBezierCurve\n\n二维三次贝塞尔曲线CubicBezierCurve与二维二次贝赛尔曲线QuadraticBezierCurve区别就是多了一个控制点。\n\n// p1、p2、p3、p4表示4个点坐标\n// p1、p4是曲线起始点，p2、p3是曲线的控制点\nconst p1 = new THREE.Vector2(-80, 0);\nconst p2 = new THREE.Vector2(-40, 50);\nconst p3 = new THREE.Vector2(50, 50);\nconst p4 = new THREE.Vector2(80, 0);\n\n// 二维三次贝赛尔曲线\nconst curve = new THREE.CubicBezierCurve(p1, p2, p3, p4);\n\n\n\n# 三维三次贝赛尔曲线CubicBezierCurve3\n\n三维三次贝赛尔曲线CubicBezierCurve3与二维三次贝塞尔曲线CubicBezierCurve区别就是多了一个维度，参数是三维向量对象Vector3。\n\nconst p1 = new THREE.Vector3(-80, 0, 0);\nconst p2 = new THREE.Vector3(-40, 50, 0);\nconst p3 = new THREE.Vector3(50, 50, 0);\nconst p4 = new THREE.Vector3(80, 0, 100);\n// 三维三次贝赛尔曲线\nconst curve = new THREE.CubicBezierCurve3(p1, p2, p3, p4);\n",normalizedContent:"# 贝塞尔曲线\n\n上节课讲解过，threejs可以通过样条曲线或贝塞尔曲线去表达生活中不规则的曲线，下面给大家介绍贝塞尔曲线有关的知识。\n\n\n\n\n# 二维二次贝塞尔曲线quadraticbeziercurve\n\n// p1、p2、p3表示三个点坐标\n// p1、p3是曲线起始点，p2是曲线的控制点\nconst p1 = new three.vector2(-80, 0);\nconst p2 = new three.vector2(20, 100);\nconst p3 = new three.vector2(80, 0);\n\n\n二维二次贝赛尔曲线quadraticbeziercurve的前面三个参数是二维向量对象vector2。\n\n// 二维二次贝赛尔曲线\nconst curve = new three.quadraticbeziercurve(p1, p2, p3);\n\n\n曲线上获取一定数量点，线模型line渲染贝塞尔曲线。\n\nconst pointsarr = curve.getpoints(100); //曲线上获取点\nconst geometry = new three.buffergeometry();\ngeometry.setfrompoints(pointsarr); //读取坐标数据赋值给几何体顶点\nconst material = new three.linebasicmaterial({color: 0x00fffff});\nconst line = new three.line(geometry, material);\n\n\n\n# 观察贝塞尔曲线规则\n\n可视化p1、p2、p3三个点的位置，并用直线相连接，便于观察贝塞尔曲线的绘制规律。\n\n你可以发现贝塞尔曲线经过p1、p3两个点，但是不经过p2点，贝塞尔曲线与直线p12和p23相切。\n\nconst geometry2 = new three.buffergeometry();\ngeometry2.setfrompoints([p1,p2,p3]);\nconst material2 = new three.pointsmaterial({\n    color: 0xff00ff,\n    size: 10,\n});\n//点模型对象\nconst points = new three.points(geometry2, material2);\n// 三个点构成的线条\nconst line2 = new three.line(geometry2, new three.linebasicmaterial());\n\n\n\n# 三维二次贝赛尔曲线quadraticbeziercurve3\n\n三维二次贝赛尔曲线quadraticbeziercurve3与二维二次贝赛尔曲线quadraticbeziercurve区别就是多了一个维度，参数是三维向量对象vector3。\n\n// p1、p2、p3表示三个点坐标\nconst p1 = new three.vector3(-80, 0, 0);\nconst p2 = new three.vector3(20, 100, 0);\nconst p3 = new three.vector3(80, 0, 100);\n// 三维二次贝赛尔曲线\nconst curve = new three.quadraticbeziercurve3(p1, p2, p3);\n\n\n\n# 二维三次贝塞尔曲线cubicbeziercurve\n\n二维三次贝塞尔曲线cubicbeziercurve与二维二次贝赛尔曲线quadraticbeziercurve区别就是多了一个控制点。\n\n// p1、p2、p3、p4表示4个点坐标\n// p1、p4是曲线起始点，p2、p3是曲线的控制点\nconst p1 = new three.vector2(-80, 0);\nconst p2 = new three.vector2(-40, 50);\nconst p3 = new three.vector2(50, 50);\nconst p4 = new three.vector2(80, 0);\n\n// 二维三次贝赛尔曲线\nconst curve = new three.cubicbeziercurve(p1, p2, p3, p4);\n\n\n\n# 三维三次贝赛尔曲线cubicbeziercurve3\n\n三维三次贝赛尔曲线cubicbeziercurve3与二维三次贝塞尔曲线cubicbeziercurve区别就是多了一个维度，参数是三维向量对象vector3。\n\nconst p1 = new three.vector3(-80, 0, 0);\nconst p2 = new three.vector3(-40, 50, 0);\nconst p3 = new three.vector3(50, 50, 0);\nconst p4 = new three.vector3(80, 0, 100);\n// 三维三次贝赛尔曲线\nconst curve = new three.cubicbeziercurve3(p1, p2, p3, p4);\n",charsets:{cjk:!0}},{title:"7. 样条、贝塞尔曲线应用",frontmatter:{title:"7. 样条、贝塞尔曲线应用",date:"2023-01-30T20:42:50.000Z",permalink:"/pages/a8cc3a/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/07.%E6%A0%B7%E6%9D%A1%E3%80%81%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%BA%94%E7%94%A8.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/07.样条、贝塞尔曲线应用.md",key:"v-56bb56bc",path:"/pages/a8cc3a/",headers:[{level:3,title:"三维样条曲线CatmullRomCurve3实现飞线轨迹",slug:"三维样条曲线catmullromcurve3实现飞线轨迹",normalizedTitle:"三维样条曲线catmullromcurve3实现飞线轨迹",charIndex:164},{level:3,title:"三维二次贝赛尔曲线QuadraticBezierCurve3实现飞线轨迹",slug:"三维二次贝赛尔曲线quadraticbeziercurve3实现飞线轨迹",normalizedTitle:"三维二次贝赛尔曲线quadraticbeziercurve3实现飞线轨迹",charIndex:546}],headersStr:"三维样条曲线CatmullRomCurve3实现飞线轨迹 三维二次贝赛尔曲线QuadraticBezierCurve3实现飞线轨迹",content:"# 样条、贝塞尔曲线应用\n\n曲线API在大屏可视化中的应用:地图大屏可视化、地球大屏可视化\n\n表示一个飞线曲线轨迹有多重方案，圆弧、椭圆弧、贝塞尔、样条...\n\n比如你有一个项目，已知平面上两个点坐标(-100,-100)、(100,100)，需要生成一条飞线轨迹线，要求轨迹线把这两个点作为起始点,曲线有一定的高度。\n\n\n# 三维样条曲线CatmullRomCurve3实现飞线轨迹\n\n下面曲线的起始点设置在XOZ平面上，y方向为曲线高度方向。\n\n// p1、p3轨迹线起始点坐标\nconst p1 = new THREE.Vector3(-100, 0, -100);\nconst p3 = new THREE.Vector3(100, 0, 100);\n// 计算p1和p3的中点坐标\nconst x2 = (p1.x + p3.x)/2;\nconst z2 = (p1.z + p3.z)/2;\nconst h = 50;\nconst p2 = new THREE.Vector3(x2, h, z2);\n\nconst arr = [p1, p2, p3];\n// 三维样条曲线\nconst curve = new THREE.CatmullRomCurve3(arr);\n\n\n\n# 三维二次贝赛尔曲线QuadraticBezierCurve3实现飞线轨迹\n\n下面曲线的起始点设置在XOZ平面上，y方向为曲线高度方向。\n\n// p1、p3轨迹线起始点坐标\nconst p1 = new THREE.Vector3(-100, 0, -100);\nconst p3 = new THREE.Vector3(100, 0, 100);\n// 计算p1和p3的中点坐标\nconst x2 = (p1.x + p3.x)/2;\nconst z2 = (p1.z + p3.z)/2;\nconst h = 100;\nconst p2 = new THREE.Vector3(x2, h, z2);\n// 三维二次贝赛尔曲线\nconst curve = new THREE.QuadraticBezierCurve3(p1, p2, p3);\n",normalizedContent:"# 样条、贝塞尔曲线应用\n\n曲线api在大屏可视化中的应用:地图大屏可视化、地球大屏可视化\n\n表示一个飞线曲线轨迹有多重方案，圆弧、椭圆弧、贝塞尔、样条...\n\n比如你有一个项目，已知平面上两个点坐标(-100,-100)、(100,100)，需要生成一条飞线轨迹线，要求轨迹线把这两个点作为起始点,曲线有一定的高度。\n\n\n# 三维样条曲线catmullromcurve3实现飞线轨迹\n\n下面曲线的起始点设置在xoz平面上，y方向为曲线高度方向。\n\n// p1、p3轨迹线起始点坐标\nconst p1 = new three.vector3(-100, 0, -100);\nconst p3 = new three.vector3(100, 0, 100);\n// 计算p1和p3的中点坐标\nconst x2 = (p1.x + p3.x)/2;\nconst z2 = (p1.z + p3.z)/2;\nconst h = 50;\nconst p2 = new three.vector3(x2, h, z2);\n\nconst arr = [p1, p2, p3];\n// 三维样条曲线\nconst curve = new three.catmullromcurve3(arr);\n\n\n\n# 三维二次贝赛尔曲线quadraticbeziercurve3实现飞线轨迹\n\n下面曲线的起始点设置在xoz平面上，y方向为曲线高度方向。\n\n// p1、p3轨迹线起始点坐标\nconst p1 = new three.vector3(-100, 0, -100);\nconst p3 = new three.vector3(100, 0, 100);\n// 计算p1和p3的中点坐标\nconst x2 = (p1.x + p3.x)/2;\nconst z2 = (p1.z + p3.z)/2;\nconst h = 100;\nconst p2 = new three.vector3(x2, h, z2);\n// 三维二次贝赛尔曲线\nconst curve = new three.quadraticbeziercurve3(p1, p2, p3);\n",charsets:{cjk:!0}},{title:"8. 组合曲线CurvePath拼接曲线",frontmatter:{title:"8. 组合曲线CurvePath拼接曲线",date:"2023-01-31T16:26:26.000Z",permalink:"/pages/e11f54/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/08.%E7%BB%84%E5%90%88%E6%9B%B2%E7%BA%BFCurvePath%E6%8B%BC%E6%8E%A5%E4%B8%8D%E5%90%8C%E6%9B%B2%E7%BA%BF.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/08.组合曲线CurvePath拼接不同曲线.md",key:"v-c60820fa",path:"/pages/e11f54/",headers:[{level:3,title:"直线线段简介",slug:"直线线段简介",normalizedTitle:"直线线段简介",charIndex:109},{level:3,title:"整体思路CurvePath.curves",slug:"整体思路curvepath-curves",normalizedTitle:"整体思路curvepath.curves",charIndex:411},{level:3,title:"注意：曲线首尾相接",slug:"注意-曲线首尾相接",normalizedTitle:"注意：曲线首尾相接",charIndex:965},{level:3,title:"组合曲线CurvePath取点",slug:"组合曲线curvepath取点",normalizedTitle:"组合曲线curvepath取点",charIndex:1541},{level:3,title:"点模型可视化组合曲线返回的顶点",slug:"点模型可视化组合曲线返回的顶点",normalizedTitle:"点模型可视化组合曲线返回的顶点",charIndex:1780},{level:3,title:".getSpacedPoints()取点测试",slug:"getspacedpoints-取点测试",normalizedTitle:".getspacedpoints()取点测试",charIndex:2218}],headersStr:"直线线段简介 整体思路CurvePath.curves 注意：曲线首尾相接 组合曲线CurvePath取点 点模型可视化组合曲线返回的顶点 .getSpacedPoints()取点测试",content:"# 组合曲线CurvePath拼接不同曲线\n\n通过threejs组合曲线CurvePath对象，你可以把直线、圆弧、贝塞尔等线条拼接为一条曲线。\n\n课件案例源码为大家提供了一个圆弧和直线组合拼接的的U形效果。\n\n\n# 直线线段简介\n\n本节课用到的圆弧前面讲解过，下面给大家说下直线相关API，three.js提供了3D直线LineCurve3和2D直线LineCurve。\n\n3D直线线段LineCurve3，参数是表示x、y、z坐标的三维向量Vector3对象。\n\nnew THREE.LineCurve3(new THREE.Vector3(), new THREE.Vector3());\n\n\n2D直线线段LineCurve，参数是表示x、y坐标的二维向量Vector2对象。\n\nnew THREE.LineCurve(new THREE.Vector2(), new THREE.Vector2());\n\n\n\n# 整体思路CurvePath.curves\n\n整体思路很简单，LineCurve创建两条直线线段，ArcCurve绘制一段圆弧线，然后把两段直线和一段圆弧线，通过组合曲线的CurvePath.curves属性拼接起来。\n\nconst R = 80;//圆弧半径\nconst H = 200;//直线部分高度\n// 直线1\nconst line1 = new THREE.LineCurve(new THREE.Vector2(R, H), new THREE.Vector2(R, 0));\n// 圆弧\nconst arc = new THREE.ArcCurve(0, 0, R, 0, Math.PI, true);\n// 直线2\nconst line2 = new THREE.LineCurve(new THREE.Vector2(-R, 0), new THREE.Vector2(-R, H));\n\n// CurvePath创建一个组合曲线对象\nconst CurvePath = new THREE.CurvePath();\n//line1, arc, line2拼接出来一个U型轮廓曲线，注意顺序\nCurvePath.curves.push(line1, arc, line2);\n\n\n\n\n# 注意：曲线首尾相接\n\n有一点要注意，组合曲线的坐标顺序和线条组合顺序不能随意写，总的方向，就是先确定整个曲线的起点，然后沿着一个方向依次绘制不同曲线，确保不同曲线首尾相接。\n\n * 直线的起点是直线的第一个参数\n * 圆弧线的起点，默认就是从x轴正半轴开始\n\n\n\nconst R = 80;//圆弧半径\nconst H = 200;//直线部分高度\n// 直线1\nconst line1 = new THREE.LineCurve(new THREE.Vector2(R, H), new THREE.Vector2(R, 0));\n// 圆弧\nconst arc = new THREE.ArcCurve(0, 0, R, 0, Math.PI, true);\n// 直线2\nconst line2 = new THREE.LineCurve(new THREE.Vector2(-R, 0), new THREE.Vector2(-R, H));\n\n// CurvePath创建一个组合曲线对象\nconst CurvePath = new THREE.CurvePath();\n//line1, arc, line2拼接出来一个U型轮廓曲线，注意顺序\nCurvePath.curves.push(line1, arc, line2);\n\n\n\n\n# 组合曲线CurvePath取点\n\n组合曲线CurvePath和它的父类Curve一样具有.getPoints()和.getSpacedPoints()取点方法。\n\n//组合曲线上获取点\nconst pointsArr = CurvePath.getPoints(16); \nconst geometry = new THREE.BufferGeometry();\ngeometry.setFromPoints(pointsArr); //读取坐标数据赋值给几何体顶点\n\n\n\n# 点模型可视化组合曲线返回的顶点\n\n执行.getPoints()，直线部分不会像曲线返回中间多余点，只需要起始点即可。\n\n// 执行.getPoints()，直线部分不会像曲线返回中间多余点，只需要起始点即可。\nconst pointsArr = CurvePath.getPoints(16); //曲线上获取点\nconst geometry = new THREE.BufferGeometry();\ngeometry.setFromPoints(pointsArr); //读取坐标数据赋值给几何体顶点\n\n// 可视化curve.getPoints从曲线上获取的点坐标\nconst material2 = new THREE.PointsMaterial({\n    color: 0xff00ff,\n    size: 10,\n});\n//点模型对象\nconst points = new THREE.Points(geometry, material2);\n\n\n\n# .getSpacedPoints()取点测试\n\n复习前面知识，你可以通过测试曲线Curve方法.getSpacedPoints()从组合曲线获取点坐标。\n\n这时候你会发现直线部分会按照等间距方式返回顶点数据，需要把.getSpacedPoints()的精度参数提升，圆弧部分才会更加圆滑。\n\nconst pointsArr = CurvePath.getSpacedPoints(16); //圆弧不够光滑\n",normalizedContent:"# 组合曲线curvepath拼接不同曲线\n\n通过threejs组合曲线curvepath对象，你可以把直线、圆弧、贝塞尔等线条拼接为一条曲线。\n\n课件案例源码为大家提供了一个圆弧和直线组合拼接的的u形效果。\n\n\n# 直线线段简介\n\n本节课用到的圆弧前面讲解过，下面给大家说下直线相关api，three.js提供了3d直线linecurve3和2d直线linecurve。\n\n3d直线线段linecurve3，参数是表示x、y、z坐标的三维向量vector3对象。\n\nnew three.linecurve3(new three.vector3(), new three.vector3());\n\n\n2d直线线段linecurve，参数是表示x、y坐标的二维向量vector2对象。\n\nnew three.linecurve(new three.vector2(), new three.vector2());\n\n\n\n# 整体思路curvepath.curves\n\n整体思路很简单，linecurve创建两条直线线段，arccurve绘制一段圆弧线，然后把两段直线和一段圆弧线，通过组合曲线的curvepath.curves属性拼接起来。\n\nconst r = 80;//圆弧半径\nconst h = 200;//直线部分高度\n// 直线1\nconst line1 = new three.linecurve(new three.vector2(r, h), new three.vector2(r, 0));\n// 圆弧\nconst arc = new three.arccurve(0, 0, r, 0, math.pi, true);\n// 直线2\nconst line2 = new three.linecurve(new three.vector2(-r, 0), new three.vector2(-r, h));\n\n// curvepath创建一个组合曲线对象\nconst curvepath = new three.curvepath();\n//line1, arc, line2拼接出来一个u型轮廓曲线，注意顺序\ncurvepath.curves.push(line1, arc, line2);\n\n\n\n\n# 注意：曲线首尾相接\n\n有一点要注意，组合曲线的坐标顺序和线条组合顺序不能随意写，总的方向，就是先确定整个曲线的起点，然后沿着一个方向依次绘制不同曲线，确保不同曲线首尾相接。\n\n * 直线的起点是直线的第一个参数\n * 圆弧线的起点，默认就是从x轴正半轴开始\n\n\n\nconst r = 80;//圆弧半径\nconst h = 200;//直线部分高度\n// 直线1\nconst line1 = new three.linecurve(new three.vector2(r, h), new three.vector2(r, 0));\n// 圆弧\nconst arc = new three.arccurve(0, 0, r, 0, math.pi, true);\n// 直线2\nconst line2 = new three.linecurve(new three.vector2(-r, 0), new three.vector2(-r, h));\n\n// curvepath创建一个组合曲线对象\nconst curvepath = new three.curvepath();\n//line1, arc, line2拼接出来一个u型轮廓曲线，注意顺序\ncurvepath.curves.push(line1, arc, line2);\n\n\n\n\n# 组合曲线curvepath取点\n\n组合曲线curvepath和它的父类curve一样具有.getpoints()和.getspacedpoints()取点方法。\n\n//组合曲线上获取点\nconst pointsarr = curvepath.getpoints(16); \nconst geometry = new three.buffergeometry();\ngeometry.setfrompoints(pointsarr); //读取坐标数据赋值给几何体顶点\n\n\n\n# 点模型可视化组合曲线返回的顶点\n\n执行.getpoints()，直线部分不会像曲线返回中间多余点，只需要起始点即可。\n\n// 执行.getpoints()，直线部分不会像曲线返回中间多余点，只需要起始点即可。\nconst pointsarr = curvepath.getpoints(16); //曲线上获取点\nconst geometry = new three.buffergeometry();\ngeometry.setfrompoints(pointsarr); //读取坐标数据赋值给几何体顶点\n\n// 可视化curve.getpoints从曲线上获取的点坐标\nconst material2 = new three.pointsmaterial({\n    color: 0xff00ff,\n    size: 10,\n});\n//点模型对象\nconst points = new three.points(geometry, material2);\n\n\n\n# .getspacedpoints()取点测试\n\n复习前面知识，你可以通过测试曲线curve方法.getspacedpoints()从组合曲线获取点坐标。\n\n这时候你会发现直线部分会按照等间距方式返回顶点数据，需要把.getspacedpoints()的精度参数提升，圆弧部分才会更加圆滑。\n\nconst pointsarr = curvepath.getspacedpoints(16); //圆弧不够光滑\n",charsets:{cjk:!0}},{title:"10. 旋转成型LatheGeometry",frontmatter:{title:"10. 旋转成型LatheGeometry",date:"2023-01-31T23:04:54.000Z",permalink:"/pages/4f1012/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/10.%E6%97%8B%E8%BD%AC%E6%88%90%E5%9E%8BLatheGeometry.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/10.旋转成型LatheGeometry.md",key:"v-7ab36901",path:"/pages/4f1012/",headers:[{level:3,title:"旋转LatheGeometry案例",slug:"旋转lathegeometry案例",normalizedTitle:"旋转lathegeometry案例",charIndex:120},{level:3,title:"旋转细分精度",slug:"旋转细分精度",normalizedTitle:"旋转细分精度",charIndex:689},{level:3,title:"旋转角度",slug:"旋转角度",normalizedTitle:"旋转角度",charIndex:301},{level:3,title:"曲线生成旋转轮廓",slug:"曲线生成旋转轮廓",normalizedTitle:"曲线生成旋转轮廓",charIndex:885}],headersStr:"旋转LatheGeometry案例 旋转细分精度 旋转角度 曲线生成旋转轮廓",content:"# 旋转成型LatheGeometry\n\n生活中有很多的几何体具备旋转特征， three.js提供了一个类LatheGeometry()， LatheGeometry可以利用一个2D轮廓，经过旋转变换生成一个3D的几何体曲面。\n\n\n\n\n# 旋转LatheGeometry案例\n\n格式：LatheGeometry(points, segments, phiStart, phiLength)\n\n\n参数          值\npoints      Vector2表示的坐标数据组成的数组\nsegments    圆周方向细分数，默认12\nphiStart    开始角度,默认0\nphiLength   旋转角度，默认2π\n\n * LatheGeometry类第一个参数就是旋转轮廓，旋转轮廓使用多个二维向量Vector2表示的xy坐标去描述。\n\n * LatheGeometry的旋转轮廓默认绕y轴旋转生成曲面几何体。\n\n// Vector2表示的三个点坐标，三个点构成的轮廓相当于两端直线相连接\nconst pointsArr = [\n    new THREE.Vector2(50, 60),\n    new THREE.Vector2(25, 0),\n    new THREE.Vector2(50, -60)\n];\n// LatheGeometry：pointsArr轮廓绕y轴旋转生成几何体曲面\n// pointsArr：旋转几何体的旋转轮廓形状\nconst geometry = new THREE.LatheGeometry(pointsArr);\n\n\n\n# 旋转细分精度\n\n// 30：旋转圆周方向几何体细分精度\nconst geometry = new THREE.LatheGeometry(pointsArr, 30);\n\n\n\n# 旋转角度\n\n// 0, Math.PI：旋转的开始角度和结束角度\nconst geometry = new THREE.LatheGeometry(pointsArr, 30,0, Math.PI);\n\n\n\n# 曲线生成旋转轮廓\n\n通过二维样条曲线SplineCurve生成一个光滑的曲线旋转轮廓。\n\n// 通过三个点定义一个二维样条曲线\nconst curve = new THREE.SplineCurve([\n    new THREE.Vector2(50, 60),\n    new THREE.Vector2(25, 0),\n    new THREE.Vector2(50, -60)\n]);\n//曲线上获取点,作为旋转几何体的旋转轮廓\nconst pointsArr = curve.getPoints(50); \nconsole.log('旋转轮廓数据',pointsArr);\n// LatheGeometry：pointsArr轮廓绕y轴旋转生成几何体曲面\nconst geometry = new THREE.LatheGeometry(pointsArr, 30);\n",normalizedContent:"# 旋转成型lathegeometry\n\n生活中有很多的几何体具备旋转特征， three.js提供了一个类lathegeometry()， lathegeometry可以利用一个2d轮廓，经过旋转变换生成一个3d的几何体曲面。\n\n\n\n\n# 旋转lathegeometry案例\n\n格式：lathegeometry(points, segments, phistart, philength)\n\n\n参数          值\npoints      vector2表示的坐标数据组成的数组\nsegments    圆周方向细分数，默认12\nphistart    开始角度,默认0\nphilength   旋转角度，默认2π\n\n * lathegeometry类第一个参数就是旋转轮廓，旋转轮廓使用多个二维向量vector2表示的xy坐标去描述。\n\n * lathegeometry的旋转轮廓默认绕y轴旋转生成曲面几何体。\n\n// vector2表示的三个点坐标，三个点构成的轮廓相当于两端直线相连接\nconst pointsarr = [\n    new three.vector2(50, 60),\n    new three.vector2(25, 0),\n    new three.vector2(50, -60)\n];\n// lathegeometry：pointsarr轮廓绕y轴旋转生成几何体曲面\n// pointsarr：旋转几何体的旋转轮廓形状\nconst geometry = new three.lathegeometry(pointsarr);\n\n\n\n# 旋转细分精度\n\n// 30：旋转圆周方向几何体细分精度\nconst geometry = new three.lathegeometry(pointsarr, 30);\n\n\n\n# 旋转角度\n\n// 0, math.pi：旋转的开始角度和结束角度\nconst geometry = new three.lathegeometry(pointsarr, 30,0, math.pi);\n\n\n\n# 曲线生成旋转轮廓\n\n通过二维样条曲线splinecurve生成一个光滑的曲线旋转轮廓。\n\n// 通过三个点定义一个二维样条曲线\nconst curve = new three.splinecurve([\n    new three.vector2(50, 60),\n    new three.vector2(25, 0),\n    new three.vector2(50, -60)\n]);\n//曲线上获取点,作为旋转几何体的旋转轮廓\nconst pointsarr = curve.getpoints(50); \nconsole.log('旋转轮廓数据',pointsarr);\n// lathegeometry：pointsarr轮廓绕y轴旋转生成几何体曲面\nconst geometry = new three.lathegeometry(pointsarr, 30);\n",charsets:{cjk:!0}},{title:"9. 曲线路径管道TubeGeometry",frontmatter:{title:"9. 曲线路径管道TubeGeometry",date:"2023-01-31T16:26:40.000Z",permalink:"/pages/f36362/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/09.%E6%9B%B2%E7%BA%BF%E8%B7%AF%E5%BE%84%E7%AE%A1%E9%81%93TubeGeometry.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/09.曲线路径管道TubeGeometry.md",key:"v-7f63d78b",path:"/pages/f36362/",headers:[{level:3,title:"管道TubeGeometry",slug:"管道tubegeometry",normalizedTitle:"管道tubegeometry",charIndex:2},{level:3,title:"样条曲线生成圆管案例",slug:"样条曲线生成圆管案例",normalizedTitle:"样条曲线生成圆管案例",charIndex:318},{level:3,title:"观察管道内壁",slug:"观察管道内壁",normalizedTitle:"观察管道内壁",charIndex:668},{level:3,title:"测试其他曲线",slug:"测试其他曲线",normalizedTitle:"测试其他曲线",charIndex:833},{level:3,title:"CurvePath多段路径生成管道案例",slug:"curvepath多段路径生成管道案例",normalizedTitle:"curvepath多段路径生成管道案例",charIndex:1225}],headersStr:"管道TubeGeometry 样条曲线生成圆管案例 观察管道内壁 测试其他曲线 CurvePath多段路径生成管道案例",content:"# 管道TubeGeometry\n\n管道TubeGeometry几何体的功能就是基于一个3D曲线路径，生成一个管道几何体。\n\n构造函数格式：TubeGeometry(path, tubularSegments, radius, radiusSegments, closed)\n\n\n参数                值\npath              扫描路径，路径要用三维曲线\ntubularSegments   路径方向细分数，默认64\nradius            管道半径，默认1\nradiusSegments    管道圆弧细分数，默认8\nclosed            Boolean值，管道是否闭合\n\n\n# 样条曲线生成圆管案例\n\n// 三维样条曲线\nconst path = new THREE.CatmullRomCurve3([\n    new THREE.Vector3(-50, 20, 90),\n    new THREE.Vector3(-10, 40, 40),\n    new THREE.Vector3(0, 0, 0),\n    new THREE.Vector3(60, -60, 0),\n    new THREE.Vector3(70, 0, 80)\n]);\n\n// path:路径   40：沿着轨迹细分数  2：管道半径   25：管道截面圆细分数\nconst geometry = new THREE.TubeGeometry(path, 40, 2, 25);\n\n\n\n# 观察管道内壁\n\nthreejs默认只渲染mesh三角形的正面，如果想看到管道内壁，可以设置双面渲染THREE.DoubleSide。\n\nconst material = new THREE.MeshLambertMaterial({\n    side:THREE.DoubleSide,//双面显示看到管道内壁\n});\n\n\n\n# 测试其他曲线\n\n你也可以使用下面直线替换上面的样条曲线查看圆管生成效果。\n\n// LineCurve3创建直线段路径\nconst path = new THREE.LineCurve3(new THREE.Vector3(0, 100, 0), new THREE.Vector3(0, 0, 0));\n\n\n三维二次贝塞尔曲线生成管道几何体\n\n// p1、p2、p3表示三个点坐标\nconst p1 = new THREE.Vector3(-80, 0, 0);\nconst p2 = new THREE.Vector3(20, 100, 0);\nconst p3 = new THREE.Vector3(80, 0, 100);\n// 三维二次贝赛尔曲线\nconst path = new THREE.QuadraticBezierCurve3(p1, p2, p3);\n\n\n\n# CurvePath多段路径生成管道案例\n\nCurvePath组合曲线，也可以作为TubeGeometry的参数1，用于生成管道几何体。\n\n下面组合曲线CurvePath是由一段三维贝塞尔曲线QuadraticBezierCurve3加上两段3D直线LineCurve3拼接组成。\n\n// 创建多段线条的顶点数据\nconst p1 = new THREE.Vector3(0, 0,100)\nconst p2 = new THREE.Vector3(0, 0,30);\nconst p3 = new THREE.Vector3(0, 0,0);\nconst p4 = new THREE.Vector3(30, 0, 0);\nconst p5 = new THREE.Vector3(100, 0, 0);\n// 1. 3D直线线段\nconst line1 = new THREE.LineCurve3(p1, p2);\n// 2. 三维二次贝塞尔曲线\nconst curve = new THREE.QuadraticBezierCurve3(p2, p3, p4);\n// 3. 3D直线线段\nconst line2 = new THREE.LineCurve3(p4, p5);\n\nconst CurvePath = new THREE.CurvePath(); \n// 三条线拼接为一条曲线\nCurvePath.curves.push(line1, curve, line2); \n\n// CurvePath:路径   40：沿着轨迹细分数  2：管道半径   25：管道截面圆细分数\nconst geometry = new THREE.TubeGeometry(CurvePath, 50, 2, 25);\n",normalizedContent:"# 管道tubegeometry\n\n管道tubegeometry几何体的功能就是基于一个3d曲线路径，生成一个管道几何体。\n\n构造函数格式：tubegeometry(path, tubularsegments, radius, radiussegments, closed)\n\n\n参数                值\npath              扫描路径，路径要用三维曲线\ntubularsegments   路径方向细分数，默认64\nradius            管道半径，默认1\nradiussegments    管道圆弧细分数，默认8\nclosed            boolean值，管道是否闭合\n\n\n# 样条曲线生成圆管案例\n\n// 三维样条曲线\nconst path = new three.catmullromcurve3([\n    new three.vector3(-50, 20, 90),\n    new three.vector3(-10, 40, 40),\n    new three.vector3(0, 0, 0),\n    new three.vector3(60, -60, 0),\n    new three.vector3(70, 0, 80)\n]);\n\n// path:路径   40：沿着轨迹细分数  2：管道半径   25：管道截面圆细分数\nconst geometry = new three.tubegeometry(path, 40, 2, 25);\n\n\n\n# 观察管道内壁\n\nthreejs默认只渲染mesh三角形的正面，如果想看到管道内壁，可以设置双面渲染three.doubleside。\n\nconst material = new three.meshlambertmaterial({\n    side:three.doubleside,//双面显示看到管道内壁\n});\n\n\n\n# 测试其他曲线\n\n你也可以使用下面直线替换上面的样条曲线查看圆管生成效果。\n\n// linecurve3创建直线段路径\nconst path = new three.linecurve3(new three.vector3(0, 100, 0), new three.vector3(0, 0, 0));\n\n\n三维二次贝塞尔曲线生成管道几何体\n\n// p1、p2、p3表示三个点坐标\nconst p1 = new three.vector3(-80, 0, 0);\nconst p2 = new three.vector3(20, 100, 0);\nconst p3 = new three.vector3(80, 0, 100);\n// 三维二次贝赛尔曲线\nconst path = new three.quadraticbeziercurve3(p1, p2, p3);\n\n\n\n# curvepath多段路径生成管道案例\n\ncurvepath组合曲线，也可以作为tubegeometry的参数1，用于生成管道几何体。\n\n下面组合曲线curvepath是由一段三维贝塞尔曲线quadraticbeziercurve3加上两段3d直线linecurve3拼接组成。\n\n// 创建多段线条的顶点数据\nconst p1 = new three.vector3(0, 0,100)\nconst p2 = new three.vector3(0, 0,30);\nconst p3 = new three.vector3(0, 0,0);\nconst p4 = new three.vector3(30, 0, 0);\nconst p5 = new three.vector3(100, 0, 0);\n// 1. 3d直线线段\nconst line1 = new three.linecurve3(p1, p2);\n// 2. 三维二次贝塞尔曲线\nconst curve = new three.quadraticbeziercurve3(p2, p3, p4);\n// 3. 3d直线线段\nconst line2 = new three.linecurve3(p4, p5);\n\nconst curvepath = new three.curvepath(); \n// 三条线拼接为一条曲线\ncurvepath.curves.push(line1, curve, line2); \n\n// curvepath:路径   40：沿着轨迹细分数  2：管道半径   25：管道截面圆细分数\nconst geometry = new three.tubegeometry(curvepath, 50, 2, 25);\n",charsets:{cjk:!0}},{title:"11. 轮廓填充ShapeGeometry",frontmatter:{title:"11. 轮廓填充ShapeGeometry",date:"2023-02-01T00:04:29.000Z",permalink:"/pages/29f885/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/11.%E8%BD%AE%E5%BB%93%E5%A1%AB%E5%85%85ShapeGeometry.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/11.轮廓填充ShapeGeometry.md",key:"v-0d6eb080",path:"/pages/29f885/",headers:[{level:3,title:"多边形轮廓Shape",slug:"多边形轮廓shape",normalizedTitle:"多边形轮廓shape",charIndex:108},{level:3,title:"轮廓填充几何体ShapeGeometry",slug:"轮廓填充几何体shapegeometry",normalizedTitle:"轮廓填充几何体shapegeometry",charIndex:509},{level:3,title:"查看ShapeGeometry生成的三角形",slug:"查看shapegeometry生成的三角形",normalizedTitle:"查看shapegeometry生成的三角形",charIndex:630}],headersStr:"多边形轮廓Shape 轮廓填充几何体ShapeGeometry 查看ShapeGeometry生成的三角形",content:"# 轮廓填充ShapeGeometry\n\n有些时候已知一个多边形的外轮廓坐标，想通过这些外轮廓坐标生成一个多边形几何体平面，这时候你可以借助threejs提供的轮廓填充ShapeGeometry几何体实现。\n\n\n# 多边形轮廓Shape\n\n通过下面代码定义了5个点坐标，构成一个五边形区域，注意顺序问题，随意选择一个点作为起点都行，然后按照顺时针或逆时针依次写下点的坐标。\n\n// 一组二维向量表示一个多边形轮廓坐标\nconst pointsArr = [\n    new THREE.Vector2(-50, -50),\n    new THREE.Vector2(-60, 0),\n    new THREE.Vector2(0, 50),\n    new THREE.Vector2(60, 0),\n    new THREE.Vector2(50, -50),\n]\n\n\n这一组二维顶点坐标作为Shape的参数构成一个多边形轮廓。\n\n// Shape表示一个平面多边形轮廓,参数是二维向量构成的数组pointsArr\nconst shape = new THREE.Shape(pointsArr);\n\n\n\n# 轮廓填充几何体ShapeGeometry\n\n把五边形轮廓Shape作为ShapeGeometry的参数，形成一个多边形平面几何体。\n\nconst geometry = new THREE.ShapeGeometry(shape);\n\n\n\n# 查看ShapeGeometry生成的三角形\n\nShapeGeometry形成一个多边形平面几何体,本质上就是根据轮廓坐标计算出一系列三角形面填充多边形，关于三角形的概念可以回一下章节2关于三角形概念的讲解。有了ShapeGeometry，计算三角形的算法就不用自己写了。\n\nconst material = new THREE.MeshLambertMaterial({\n    wireframe:true,\n});\n",normalizedContent:"# 轮廓填充shapegeometry\n\n有些时候已知一个多边形的外轮廓坐标，想通过这些外轮廓坐标生成一个多边形几何体平面，这时候你可以借助threejs提供的轮廓填充shapegeometry几何体实现。\n\n\n# 多边形轮廓shape\n\n通过下面代码定义了5个点坐标，构成一个五边形区域，注意顺序问题，随意选择一个点作为起点都行，然后按照顺时针或逆时针依次写下点的坐标。\n\n// 一组二维向量表示一个多边形轮廓坐标\nconst pointsarr = [\n    new three.vector2(-50, -50),\n    new three.vector2(-60, 0),\n    new three.vector2(0, 50),\n    new three.vector2(60, 0),\n    new three.vector2(50, -50),\n]\n\n\n这一组二维顶点坐标作为shape的参数构成一个多边形轮廓。\n\n// shape表示一个平面多边形轮廓,参数是二维向量构成的数组pointsarr\nconst shape = new three.shape(pointsarr);\n\n\n\n# 轮廓填充几何体shapegeometry\n\n把五边形轮廓shape作为shapegeometry的参数，形成一个多边形平面几何体。\n\nconst geometry = new three.shapegeometry(shape);\n\n\n\n# 查看shapegeometry生成的三角形\n\nshapegeometry形成一个多边形平面几何体,本质上就是根据轮廓坐标计算出一系列三角形面填充多边形，关于三角形的概念可以回一下章节2关于三角形概念的讲解。有了shapegeometry，计算三角形的算法就不用自己写了。\n\nconst material = new three.meshlambertmaterial({\n    wireframe:true,\n});\n",charsets:{cjk:!0}},{title:"12. 拉伸ExtrudeGeometry",frontmatter:{title:"12. 拉伸ExtrudeGeometry",date:"2023-02-02T10:23:48.000Z",permalink:"/pages/4ac668/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/12.%E6%8B%89%E4%BC%B8ExtrudeGeometry.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/12.拉伸ExtrudeGeometry.md",key:"v-b870ab44",path:"/pages/4ac668/",headers:[{level:3,title:"定义一个Shape轮廓",slug:"定义一个shape轮廓",normalizedTitle:"定义一个shape轮廓",charIndex:150},{level:3,title:"拉伸成型",slug:"拉伸成型",normalizedTitle:"拉伸成型",charIndex:2},{level:3,title:"拉伸倒角",slug:"拉伸倒角",normalizedTitle:"拉伸倒角",charIndex:633},{level:3,title:"拉伸取消默认倒角",slug:"拉伸取消默认倒角",normalizedTitle:"拉伸取消默认倒角",charIndex:956}],headersStr:"定义一个Shape轮廓 拉伸成型 拉伸倒角 拉伸取消默认倒角",content:"# 拉伸成型ExtrudeGeometry\n\n拉伸几何体ExtrudeGeometry和上节课讲到的轮廓填充几何体ShapeGeometry一样，都是基于一个基础的平面轮廓Shape进行变换，生成一个几何体。\n\n查看案例源码，你可以看到ExtrudeGeometry的一个拉伸变换案例。\n\n\n\n\n# 定义一个Shape轮廓\n\n使用拉伸扫描ExtrudeGeometry和轮廓填充ShapeGeometry一样，需要首先定义一个用于拉伸或扫描的平面轮廓Shape。\n\n多边形上随意选择一个点，作为起点，也就是Shape的第一个坐标，然后按照逆时针或顺时针方向依次书写坐标。\n\n// Shape表示一个平面多边形轮廓\nconst shape = new THREE.Shape([\n    // 按照特定顺序，依次书写多边形顶点坐标\n    new THREE.Vector2(-50, -50), //多边形起点\n    new THREE.Vector2(-50, 50),\n    new THREE.Vector2(50, 50),\n    new THREE.Vector2(50, -50),\n]);\n\n\n\n# 拉伸成型\n\n\n\n//拉伸造型\nconst geometry = new THREE.ExtrudeGeometry(\n    shape, //二维轮廓\n    {\n        depth: 20, //拉伸长度\n    }\n);\n\n\n\n# 拉伸倒角\n\n倒圆角\n\nconst geometry = new THREE.ExtrudeGeometry(\n    shape,{\n        depth: 20,\n        bevelThickness: 5, //倒角尺寸:拉伸方向\n        bevelSize: 5, //倒角尺寸:垂直拉伸方向\n        bevelSegments: 20, //倒圆角：倒角细分精度，默认3\n    }\n);\n\n\n倒直角\n\nconst geometry = new THREE.ExtrudeGeometry(\n    shape,{\n        bevelSegments: 1, //倒直角\n    }\n);\n\n\n\n# 拉伸取消默认倒角\n\n//拉伸造型\nconst geometry = new THREE.ExtrudeGeometry(\n    shape, //二维轮廓\n    {\n        depth: 20, //拉伸长度\n        bevelEnabled: false, //禁止倒角,默认true\n    }\n);\n",normalizedContent:"# 拉伸成型extrudegeometry\n\n拉伸几何体extrudegeometry和上节课讲到的轮廓填充几何体shapegeometry一样，都是基于一个基础的平面轮廓shape进行变换，生成一个几何体。\n\n查看案例源码，你可以看到extrudegeometry的一个拉伸变换案例。\n\n\n\n\n# 定义一个shape轮廓\n\n使用拉伸扫描extrudegeometry和轮廓填充shapegeometry一样，需要首先定义一个用于拉伸或扫描的平面轮廓shape。\n\n多边形上随意选择一个点，作为起点，也就是shape的第一个坐标，然后按照逆时针或顺时针方向依次书写坐标。\n\n// shape表示一个平面多边形轮廓\nconst shape = new three.shape([\n    // 按照特定顺序，依次书写多边形顶点坐标\n    new three.vector2(-50, -50), //多边形起点\n    new three.vector2(-50, 50),\n    new three.vector2(50, 50),\n    new three.vector2(50, -50),\n]);\n\n\n\n# 拉伸成型\n\n\n\n//拉伸造型\nconst geometry = new three.extrudegeometry(\n    shape, //二维轮廓\n    {\n        depth: 20, //拉伸长度\n    }\n);\n\n\n\n# 拉伸倒角\n\n倒圆角\n\nconst geometry = new three.extrudegeometry(\n    shape,{\n        depth: 20,\n        bevelthickness: 5, //倒角尺寸:拉伸方向\n        bevelsize: 5, //倒角尺寸:垂直拉伸方向\n        bevelsegments: 20, //倒圆角：倒角细分精度，默认3\n    }\n);\n\n\n倒直角\n\nconst geometry = new three.extrudegeometry(\n    shape,{\n        bevelsegments: 1, //倒直角\n    }\n);\n\n\n\n# 拉伸取消默认倒角\n\n//拉伸造型\nconst geometry = new three.extrudegeometry(\n    shape, //二维轮廓\n    {\n        depth: 20, //拉伸长度\n        bevelenabled: false, //禁止倒角,默认true\n    }\n);\n",charsets:{cjk:!0}},{title:"13. 扫描ExtrudeGeometry",frontmatter:{title:"13. 扫描ExtrudeGeometry",date:"2023-02-02T10:24:10.000Z",permalink:"/pages/a06aed/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/13.%E6%89%AB%E6%8F%8FExtrudeGeometry.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/13.扫描ExtrudeGeometry.md",key:"v-09e41a95",path:"/pages/a06aed/",headers:[{level:3,title:"1.扫描轮廓",slug:"_1-扫描轮廓",normalizedTitle:"1.扫描轮廓",charIndex:121},{level:3,title:"2.扫描轨迹",slug:"_2-扫描轨迹",normalizedTitle:"2.扫描轨迹",charIndex:345},{level:3,title:"3.扫描造型",slug:"_3-扫描造型",normalizedTitle:"3.扫描造型",charIndex:580}],headersStr:"1.扫描轮廓 2.扫描轨迹 3.扫描造型",content:"# 扫描成型ExtrudeGeometry\n\n通过ExtrudeGeometry除了可以实现拉伸成型，也可以让一个平面轮廓Shape沿着曲线扫描成型。\n\n查看案例源码，你可以看到ExtrudeGeometry的一个扫描变换案例。\n\n\n\n\n# 1.扫描轮廓\n\n// 扫描轮廓：Shape表示一个平面多边形轮廓\nconst shape = new THREE.Shape([\n    // 按照特定顺序，依次书写多边形顶点坐标\n    new THREE.Vector2(0,0), //多边形起点\n    new THREE.Vector2(0,10),\n    new THREE.Vector2(10,10),\n    new THREE.Vector2(10,0),\n]);\n\n\n\n# 2.扫描轨迹\n\n// 扫描轨迹：创建轮廓的扫描轨迹(3D样条曲线)\nconst curve = new THREE.CatmullRomCurve3([\n    new THREE.Vector3( -10, -50, -50 ),\n    new THREE.Vector3( 10, 0, 0 ),\n    new THREE.Vector3( 8, 50, 50 ),\n    new THREE.Vector3( -5, 0, 100)\n]);\n\n\n\n\n\n\n# 3.扫描造型\n\n//扫描造型：扫描默认没有倒角\nconst geometry = new THREE.ExtrudeGeometry(\n    shape, //扫描轮廓\n    {\n        extrudePath:curve,//扫描轨迹\n        steps:100//沿着路径细分精度，越大越光滑\n    }\n);\n",normalizedContent:"# 扫描成型extrudegeometry\n\n通过extrudegeometry除了可以实现拉伸成型，也可以让一个平面轮廓shape沿着曲线扫描成型。\n\n查看案例源码，你可以看到extrudegeometry的一个扫描变换案例。\n\n\n\n\n# 1.扫描轮廓\n\n// 扫描轮廓：shape表示一个平面多边形轮廓\nconst shape = new three.shape([\n    // 按照特定顺序，依次书写多边形顶点坐标\n    new three.vector2(0,0), //多边形起点\n    new three.vector2(0,10),\n    new three.vector2(10,10),\n    new three.vector2(10,0),\n]);\n\n\n\n# 2.扫描轨迹\n\n// 扫描轨迹：创建轮廓的扫描轨迹(3d样条曲线)\nconst curve = new three.catmullromcurve3([\n    new three.vector3( -10, -50, -50 ),\n    new three.vector3( 10, 0, 0 ),\n    new three.vector3( 8, 50, 50 ),\n    new three.vector3( -5, 0, 100)\n]);\n\n\n\n\n\n\n# 3.扫描造型\n\n//扫描造型：扫描默认没有倒角\nconst geometry = new three.extrudegeometry(\n    shape, //扫描轮廓\n    {\n        extrudepath:curve,//扫描轨迹\n        steps:100//沿着路径细分精度，越大越光滑\n    }\n);\n",charsets:{cjk:!0}},{title:"14. 多边形轮廓Shape简介",frontmatter:{title:"14. 多边形轮廓Shape简介",date:"2023-02-02T21:41:52.000Z",permalink:"/pages/4b70af/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/14.%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%BD%AE%E5%BB%93Shape%E7%AE%80%E4%BB%8B.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/14.多边形轮廓Shape简介.md",key:"v-19d3bbba",path:"/pages/4b70af/",headers:[{level:3,title:"多边形轮廓Shape的父类Path",slug:"多边形轮廓shape的父类path",normalizedTitle:"多边形轮廓shape的父类path",charIndex:318},{level:3,title:".currentPoint属性",slug:"currentpoint属性",normalizedTitle:".currentpoint属性",charIndex:457},{level:3,title:".moveTo()方法",slug:"moveto-方法",normalizedTitle:".moveto()方法",charIndex:675},{level:3,title:"绘制直线.lineTo()",slug:"绘制直线-lineto",normalizedTitle:"绘制直线.lineto()",charIndex:882},{level:3,title:"创建好的多边形轮廓Shape作为几何体的参数",slug:"创建好的多边形轮廓shape作为几何体的参数",normalizedTitle:"创建好的多边形轮廓shape作为几何体的参数",charIndex:1514}],headersStr:"多边形轮廓Shape的父类Path .currentPoint属性 .moveTo()方法 绘制直线.lineTo() 创建好的多边形轮廓Shape作为几何体的参数",content:"# 多边形轮廓Shape简介\n\n上节课提到多边形轮廓Shape,是直接通过一组二维向量Vector2表示的xy点坐标创建。下面给大家讲解通过Shape的一些2D绘图API表达多边形轮廓。\n\n// Shape表示一个平面多边形轮廓\nconst shape = new THREE.Shape([\n    // 按照特定顺序，依次书写多边形顶点坐标\n    new THREE.Vector2(-50, -50), //多边形起点\n    new THREE.Vector2(-50, 50),\n    new THREE.Vector2(50, 50),\n    new THREE.Vector2(50, -50),\n]);\n\n\n\n# 多边形轮廓Shape的父类Path\n\nShape的父类是Path,Path提供了直线、圆弧、贝塞尔、样条等绘制方法，Shape也会从父类是Path继承这些图形绘制方法。\n\n如何使用Path的直线、圆弧等绘制方法，可以参考原来学习过的各种曲线API和Path的文档。\n\n\n\n\n# .currentPoint属性\n\n.currentPoint属性字面意思是当前点，默认值Vector2(0,0)。\n\n实例化一个Shape或Path对象，查看.currentPoint属性的默认值。\n\nconst shape = new THREE.Shape();\nconst path = new THREE.Path();\nconsole.log('currentPoint',shape.currentPoint);\n\n\n\n# .moveTo()方法\n\n执行和.moveTo()方法查看.currentPoint属性变化。\n\nconst shape = new THREE.Shape();\nshape.moveTo(10,0);\nconsole.log('currentPoint',shape.currentPoint);\n\n\n除了.moveTo()方法，Path其他的直线、圆弧等方法也可能会改变.currentPoint属性\n\n\n# 绘制直线.lineTo()\n\n.lineTo()绘制直线线段，直线线段的起点是当前点属性.currentPoint表示的位置，结束点是.lineTo()的参数表示的坐标。\n\nconst shape = new THREE.Shape();\nshape.moveTo(10,0);//.currentPoint变为(10,0)\n// 绘制直线线段，起点(10,0)，结束点(100,0)\nshape.lineTo(100,0);\n\n\n.lineTo()方法和.moveTo()方法，一样会改变.currentPoint属性\n\nshape.lineTo(100,0);//.currentPoint变为(100,0)\nconsole.log('currentPoint',shape.currentPoint);\n\n\n绘制一个矩形轮廓Shape\n\nconst shape = new THREE.Shape();\nshape.moveTo(10, 0); //.currentPoint变为(10,0)\n// 绘制直线线段，起点(10,0)，结束点(100,0)\nshape.lineTo(100, 0);//.currentPoint变为(100, 0)\nshape.lineTo(100, 100);//.currentPoint变为(100, 100)\nshape.lineTo(10, 100);//.currentPoint变为(10, 100)\n\n\n\n# 创建好的多边形轮廓Shape作为几何体的参数\n\n// ShapeGeometry填充Shape获得一个平面几何体\nconst geometry = new THREE.ShapeGeometry(shape);\n\n\n// ExtrudeGeometry拉伸Shape获得一个长方体几何体\nconst geometry = new THREE.ExtrudeGeometry(shape, {\n    depth:20,//拉伸长度\n    bevelEnabled:false,//禁止倒角\n});\n",normalizedContent:"# 多边形轮廓shape简介\n\n上节课提到多边形轮廓shape,是直接通过一组二维向量vector2表示的xy点坐标创建。下面给大家讲解通过shape的一些2d绘图api表达多边形轮廓。\n\n// shape表示一个平面多边形轮廓\nconst shape = new three.shape([\n    // 按照特定顺序，依次书写多边形顶点坐标\n    new three.vector2(-50, -50), //多边形起点\n    new three.vector2(-50, 50),\n    new three.vector2(50, 50),\n    new three.vector2(50, -50),\n]);\n\n\n\n# 多边形轮廓shape的父类path\n\nshape的父类是path,path提供了直线、圆弧、贝塞尔、样条等绘制方法，shape也会从父类是path继承这些图形绘制方法。\n\n如何使用path的直线、圆弧等绘制方法，可以参考原来学习过的各种曲线api和path的文档。\n\n\n\n\n# .currentpoint属性\n\n.currentpoint属性字面意思是当前点，默认值vector2(0,0)。\n\n实例化一个shape或path对象，查看.currentpoint属性的默认值。\n\nconst shape = new three.shape();\nconst path = new three.path();\nconsole.log('currentpoint',shape.currentpoint);\n\n\n\n# .moveto()方法\n\n执行和.moveto()方法查看.currentpoint属性变化。\n\nconst shape = new three.shape();\nshape.moveto(10,0);\nconsole.log('currentpoint',shape.currentpoint);\n\n\n除了.moveto()方法，path其他的直线、圆弧等方法也可能会改变.currentpoint属性\n\n\n# 绘制直线.lineto()\n\n.lineto()绘制直线线段，直线线段的起点是当前点属性.currentpoint表示的位置，结束点是.lineto()的参数表示的坐标。\n\nconst shape = new three.shape();\nshape.moveto(10,0);//.currentpoint变为(10,0)\n// 绘制直线线段，起点(10,0)，结束点(100,0)\nshape.lineto(100,0);\n\n\n.lineto()方法和.moveto()方法，一样会改变.currentpoint属性\n\nshape.lineto(100,0);//.currentpoint变为(100,0)\nconsole.log('currentpoint',shape.currentpoint);\n\n\n绘制一个矩形轮廓shape\n\nconst shape = new three.shape();\nshape.moveto(10, 0); //.currentpoint变为(10,0)\n// 绘制直线线段，起点(10,0)，结束点(100,0)\nshape.lineto(100, 0);//.currentpoint变为(100, 0)\nshape.lineto(100, 100);//.currentpoint变为(100, 100)\nshape.lineto(10, 100);//.currentpoint变为(10, 100)\n\n\n\n# 创建好的多边形轮廓shape作为几何体的参数\n\n// shapegeometry填充shape获得一个平面几何体\nconst geometry = new three.shapegeometry(shape);\n\n\n// extrudegeometry拉伸shape获得一个长方体几何体\nconst geometry = new three.extrudegeometry(shape, {\n    depth:20,//拉伸长度\n    bevelenabled:false,//禁止倒角\n});\n",charsets:{cjk:!0}},{title:"15. 多边形轮廓Shape(圆弧)",frontmatter:{title:"15. 多边形轮廓Shape(圆弧)",date:"2023-02-02T21:42:13.000Z",permalink:"/pages/ccc74f/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/15.%E5%A4%9A%E8%BE%B9%E5%BD%A2%E8%BD%AE%E5%BB%93Shape(%E5%9C%86%E5%BC%A7).html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/15.多边形轮廓Shape(圆弧).md",key:"v-50cd75e2",path:"/pages/ccc74f/",headers:[{level:3,title:"圆弧方法.arc()",slug:"圆弧方法-arc",normalizedTitle:"圆弧方法.arc()",charIndex:62},{level:3,title:"Shape作为几何体参数",slug:"shape作为几何体参数",normalizedTitle:"shape作为几何体参数",charIndex:918},{level:3,title:"绝对圆弧方法.absarc()",slug:"绝对圆弧方法-absarc",normalizedTitle:"绝对圆弧方法.absarc()",charIndex:1187}],headersStr:"圆弧方法.arc() Shape作为几何体参数 绝对圆弧方法.absarc()",content:"# 多边形轮廓Shape(圆弧)\n\n先掌握上节课关于Shape内容，再继续学习本节课关于Shape圆弧的介绍。\n\n\n\n\n# 圆弧方法.arc()\n\n圆弧方法.arc()使用方式和原来学习过的圆弧曲线ArcCurve整体相似，区别在于圆心定位方式有差异。\n\n圆弧.arc()参数的圆心坐标是相对当前.currentPoint而言,而不是坐标原点。\n\n下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。\n\n// 下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。\nconst shape = new THREE.Shape();\nshape.lineTo(100+50, 0); //.currentPoint变为(100+50,0)\n// 圆弧.arc参数的圆心0,0坐标是相对当前.currentPoint而言，而不是坐标原点\nshape.arc(-50,0,50,0,Math.PI/2); //.currentPoint变为圆弧线结束点坐标\nconsole.log('currentPoint',shape.currentPoint);\n// 绘制直线，直线起点：圆弧绘制结束的点  直线结束点：(0, 0)\nshape.lineTo(0, 50);\n\n\n另一种写法：直线和圆弧起点之间的缺口threejs内部会自动补上\n\n// 下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。\nconst shape = new THREE.Shape();\nshape.lineTo(100, 0); //.currentPoint变为(100,0)\n// 圆弧.arc参数的圆心0,0坐标是相对当前.currentPoint而言，而不是坐标原点\nshape.arc(0,0,50,0,Math.PI/2); //.currentPoint变为圆弧线结束点坐标\nconsole.log('currentPoint',shape.currentPoint);\n// 绘制直线，直线起点：圆弧绘制结束的点  直线结束点：(0, 0)\nshape.lineTo(0, 50);\n\n\n\n# Shape作为几何体参数\n\nShape有直线之外的曲线，如果默认渲染不光滑，可以设置参数2提升\n\n// shape:填充轮廓  \nconst geometry = new THREE.ShapeGeometry(shape, 20);\n\n\nconst geometry = new THREE.ExtrudeGeometry(shape, {\n    depth:20,//拉伸长度\n    bevelEnabled:false,//禁止倒角\n    curveSegments:20,//shape曲线对应曲线细分数\n});\n\n\n\n# 绝对圆弧方法.absarc()\n\n.absarc()圆心坐标不受到.currentPoint影响，以坐标原点作为参考，这一点和圆弧方法.arc()不同。\n\n下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。\n\nconst shape = new THREE.Shape();\nshape.lineTo(100, 0); //.currentPoint变为(100,0)\n// absarc圆心坐标不受到.currentPoint影响，以坐标原点作为参考\nshape.absarc(100,0,50,0,Math.PI/2); //.currentPoint变为圆弧线结束点坐标\nconsole.log('currentPoint',shape.currentPoint);\nshape.lineTo(0, 50);\n\n\n另一种写法：直线和圆弧起点之间的缺口threejs内部会自动补上\n\nconst shape = new THREE.Shape();\nshape.lineTo(100+50, 0); //.currentPoint变为(100+50,0)\n// absarc圆心坐标不受到.currentPoint影响，以坐标原点作为参考\nshape.absarc(100,0,50,0,Math.PI/2); //.currentPoint变为圆弧线结束点坐标\nconsole.log('currentPoint',shape.currentPoint);\nshape.lineTo(0, 50);\n",normalizedContent:"# 多边形轮廓shape(圆弧)\n\n先掌握上节课关于shape内容，再继续学习本节课关于shape圆弧的介绍。\n\n\n\n\n# 圆弧方法.arc()\n\n圆弧方法.arc()使用方式和原来学习过的圆弧曲线arccurve整体相似，区别在于圆心定位方式有差异。\n\n圆弧.arc()参数的圆心坐标是相对当前.currentpoint而言,而不是坐标原点。\n\n下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。\n\n// 下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。\nconst shape = new three.shape();\nshape.lineto(100+50, 0); //.currentpoint变为(100+50,0)\n// 圆弧.arc参数的圆心0,0坐标是相对当前.currentpoint而言，而不是坐标原点\nshape.arc(-50,0,50,0,math.pi/2); //.currentpoint变为圆弧线结束点坐标\nconsole.log('currentpoint',shape.currentpoint);\n// 绘制直线，直线起点：圆弧绘制结束的点  直线结束点：(0, 0)\nshape.lineto(0, 50);\n\n\n另一种写法：直线和圆弧起点之间的缺口threejs内部会自动补上\n\n// 下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。\nconst shape = new three.shape();\nshape.lineto(100, 0); //.currentpoint变为(100,0)\n// 圆弧.arc参数的圆心0,0坐标是相对当前.currentpoint而言，而不是坐标原点\nshape.arc(0,0,50,0,math.pi/2); //.currentpoint变为圆弧线结束点坐标\nconsole.log('currentpoint',shape.currentpoint);\n// 绘制直线，直线起点：圆弧绘制结束的点  直线结束点：(0, 0)\nshape.lineto(0, 50);\n\n\n\n# shape作为几何体参数\n\nshape有直线之外的曲线，如果默认渲染不光滑，可以设置参数2提升\n\n// shape:填充轮廓  \nconst geometry = new three.shapegeometry(shape, 20);\n\n\nconst geometry = new three.extrudegeometry(shape, {\n    depth:20,//拉伸长度\n    bevelenabled:false,//禁止倒角\n    curvesegments:20,//shape曲线对应曲线细分数\n});\n\n\n\n# 绝对圆弧方法.absarc()\n\n.absarc()圆心坐标不受到.currentpoint影响，以坐标原点作为参考，这一点和圆弧方法.arc()不同。\n\n下面代码绘制了一个矩形+扇形的轮廓，圆心在(100, 0),半径50。\n\nconst shape = new three.shape();\nshape.lineto(100, 0); //.currentpoint变为(100,0)\n// absarc圆心坐标不受到.currentpoint影响，以坐标原点作为参考\nshape.absarc(100,0,50,0,math.pi/2); //.currentpoint变为圆弧线结束点坐标\nconsole.log('currentpoint',shape.currentpoint);\nshape.lineto(0, 50);\n\n\n另一种写法：直线和圆弧起点之间的缺口threejs内部会自动补上\n\nconst shape = new three.shape();\nshape.lineto(100+50, 0); //.currentpoint变为(100+50,0)\n// absarc圆心坐标不受到.currentpoint影响，以坐标原点作为参考\nshape.absarc(100,0,50,0,math.pi/2); //.currentpoint变为圆弧线结束点坐标\nconsole.log('currentpoint',shape.currentpoint);\nshape.lineto(0, 50);\n",charsets:{cjk:!0}},{title:"16. 多边形Shape(内孔.holes)",frontmatter:{title:"16. 多边形Shape(内孔.holes)",date:"2023-02-02T23:50:14.000Z",permalink:"/pages/875c74/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/16.%E5%A4%9A%E8%BE%B9%E5%BD%A2Shape(%E5%86%85%E5%AD%94.holes).html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/16.多边形Shape(内孔.holes).md",key:"v-2eff5cbc",path:"/pages/875c74/",headers:[{level:3,title:"外轮廓",slug:"外轮廓",normalizedTitle:"外轮廓",charIndex:84},{level:3,title:".holes设置内孔的轮廓",slug:"holes设置内孔的轮廓",normalizedTitle:".holes设置内孔的轮廓",charIndex:270},{level:3,title:"Shape拉伸的效果图",slug:"shape拉伸的效果图",normalizedTitle:"shape拉伸的效果图",charIndex:636}],headersStr:"外轮廓 .holes设置内孔的轮廓 Shape拉伸的效果图",content:"# 多边形Shape(内孔.holes)\n\n有些多边形Shape内部是有孔洞的，这时候就需要借助多边形Shape的内孔.holes属性和Path对象实现。\n\n\n\n\n# 外轮廓\n\n先创建Shape的矩形外轮廓。\n\nconst shape = new THREE.Shape();\n// .lineTo(100, 0)绘制直线线段，线段起点：.currentPoint，线段结束点：(100,0)\nshape.lineTo(100, 0);\nshape.lineTo(100, 100);\nshape.lineTo(0, 100);\n\n\n\n# .holes设置内孔的轮廓\n\nPath对象创建内部多个轮廓。\n\n// Shape内孔轮廓\nconst path1 = new THREE.Path();// 圆孔1\npath1.absarc(20, 20, 10);\nconst path2 = new THREE.Path();// 圆孔2\npath2.absarc(80, 20, 10);\nconst path3 = new THREE.Path();// 方形孔\npath3.moveTo(50, 50);\npath3.lineTo(80, 50);\npath3.lineTo(80, 80);\npath3.lineTo(50, 80);\n\n\n//三个内孔轮廓分别插入到holes属性中\nshape.holes.push(path1, path2,path3);\n\n\n\n# Shape拉伸的效果图\n\n上面代码定义的Shape，通过ExtrudeGeometry拉伸的效果图。\n\n\n\nconst geometry = new THREE.ExtrudeGeometry(shape, {\n    depth:20,//拉伸长度\n    bevelEnabled:false,//禁止倒角\n    curveSegments:50,\n});\n",normalizedContent:"# 多边形shape(内孔.holes)\n\n有些多边形shape内部是有孔洞的，这时候就需要借助多边形shape的内孔.holes属性和path对象实现。\n\n\n\n\n# 外轮廓\n\n先创建shape的矩形外轮廓。\n\nconst shape = new three.shape();\n// .lineto(100, 0)绘制直线线段，线段起点：.currentpoint，线段结束点：(100,0)\nshape.lineto(100, 0);\nshape.lineto(100, 100);\nshape.lineto(0, 100);\n\n\n\n# .holes设置内孔的轮廓\n\npath对象创建内部多个轮廓。\n\n// shape内孔轮廓\nconst path1 = new three.path();// 圆孔1\npath1.absarc(20, 20, 10);\nconst path2 = new three.path();// 圆孔2\npath2.absarc(80, 20, 10);\nconst path3 = new three.path();// 方形孔\npath3.moveto(50, 50);\npath3.lineto(80, 50);\npath3.lineto(80, 80);\npath3.lineto(50, 80);\n\n\n//三个内孔轮廓分别插入到holes属性中\nshape.holes.push(path1, path2,path3);\n\n\n\n# shape拉伸的效果图\n\n上面代码定义的shape，通过extrudegeometry拉伸的效果图。\n\n\n\nconst geometry = new three.extrudegeometry(shape, {\n    depth:20,//拉伸长度\n    bevelenabled:false,//禁止倒角\n    curvesegments:50,\n});\n",charsets:{cjk:!0}},{title:"17. 模型边界线EdgesGeometry",frontmatter:{title:"17. 模型边界线EdgesGeometry",date:"2023-02-02T23:49:57.000Z",permalink:"/pages/5fe984/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/17.%E6%A8%A1%E5%9E%8B%E8%BE%B9%E7%95%8C%E7%BA%BFEdgesGeometry.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/17.模型边界线EdgesGeometry.md",key:"v-40cdcbcf",path:"/pages/5fe984/",headers:[{level:3,title:"长方体边线",slug:"长方体边线",normalizedTitle:"长方体边线",charIndex:59},{level:3,title:"圆柱边线",slug:"圆柱边线",normalizedTitle:"圆柱边线",charIndex:585},{level:3,title:"外部gltf模型设置材质和边线",slug:"外部gltf模型设置材质和边线",normalizedTitle:"外部gltf模型设置材质和边线",charIndex:786}],headersStr:"长方体边线 圆柱边线 外部gltf模型设置材质和边线",content:'# 模型边界线EdgesGeometry\n\n借助EdgesGeometry可以给模型设置一个模型边界线。\n\n\n\n\n# 长方体边线\n\n先用EdgesGeometry重新计算长方体几何体，返回一个新的几何体，然后用线模型LineSegments模型渲染新的几何体即可。\n\nconst geometry = new THREE.BoxGeometry(50, 50, 50);\nconst material = new THREE.MeshLambertMaterial({\n    color: 0x004444,\n    transparent:true,\n    opacity:0.5,\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\n// 长方体作为EdgesGeometry参数创建一个新的几何体\nconst edges = new THREE.EdgesGeometry(geometry);\nconst edgesMaterial = new THREE.LineBasicMaterial({\n  color: 0x00ffff,\n})\nconst line = new THREE.LineSegments(edges, edgesMaterial);\nmesh.add(line);\n\n\n\n# 圆柱边线\n\nconst geometry = new THREE.CylinderGeometry(60, 60, 100, 30);\nconst edges = new THREE.EdgesGeometry(geometry);\n\n\n\n\n相邻面法线夹角大于30度，才会显示线条\n\nconst edges = new THREE.EdgesGeometry(geometry,30);\n\n\n\n\n\n# 外部gltf模型设置材质和边线\n\n\n\nloader.load("../建筑模型.gltf", function (gltf) {\n    // 递归遍历设置每个模型的材质，同时设置每个模型的边线\n    gltf.scene.traverse(function (obj) {\n        if (obj.isMesh) {\n            // 模型材质重新设置\n            obj.material = new THREE.MeshLambertMaterial({\n                color: 0x004444,\n                transparent: true,\n                opacity: 0.5,\n            });\n            // 模型边线设置\n            const edges = new THREE.EdgesGeometry(obj.geometry);\n            const edgesMaterial = new THREE.LineBasicMaterial({\n                color: 0x00ffff,\n            })\n            const line = new THREE.LineSegments(edges, edgesMaterial);\n            obj.add(line);\n        }\n    });\n    model.add(gltf.scene);\n})\n',normalizedContent:'# 模型边界线edgesgeometry\n\n借助edgesgeometry可以给模型设置一个模型边界线。\n\n\n\n\n# 长方体边线\n\n先用edgesgeometry重新计算长方体几何体，返回一个新的几何体，然后用线模型linesegments模型渲染新的几何体即可。\n\nconst geometry = new three.boxgeometry(50, 50, 50);\nconst material = new three.meshlambertmaterial({\n    color: 0x004444,\n    transparent:true,\n    opacity:0.5,\n});\nconst mesh = new three.mesh(geometry, material);\n\n// 长方体作为edgesgeometry参数创建一个新的几何体\nconst edges = new three.edgesgeometry(geometry);\nconst edgesmaterial = new three.linebasicmaterial({\n  color: 0x00ffff,\n})\nconst line = new three.linesegments(edges, edgesmaterial);\nmesh.add(line);\n\n\n\n# 圆柱边线\n\nconst geometry = new three.cylindergeometry(60, 60, 100, 30);\nconst edges = new three.edgesgeometry(geometry);\n\n\n\n\n相邻面法线夹角大于30度，才会显示线条\n\nconst edges = new three.edgesgeometry(geometry,30);\n\n\n\n\n\n# 外部gltf模型设置材质和边线\n\n\n\nloader.load("../建筑模型.gltf", function (gltf) {\n    // 递归遍历设置每个模型的材质，同时设置每个模型的边线\n    gltf.scene.traverse(function (obj) {\n        if (obj.ismesh) {\n            // 模型材质重新设置\n            obj.material = new three.meshlambertmaterial({\n                color: 0x004444,\n                transparent: true,\n                opacity: 0.5,\n            });\n            // 模型边线设置\n            const edges = new three.edgesgeometry(obj.geometry);\n            const edgesmaterial = new three.linebasicmaterial({\n                color: 0x00ffff,\n            })\n            const line = new three.linesegments(edges, edgesmaterial);\n            obj.add(line);\n        }\n    });\n    model.add(gltf.scene);\n})\n',charsets:{cjk:!0}},{title:"18. 几何体顶点颜色数数据",frontmatter:{title:"18. 几何体顶点颜色数数据",date:"2023-02-03T23:04:49.000Z",permalink:"/pages/92ea15/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/18.%E5%87%A0%E4%BD%95%E4%BD%93%E9%A1%B6%E7%82%B9%E9%A2%9C%E8%89%B2%E6%95%B0%E6%95%B0%E6%8D%AE.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/18.几何体顶点颜色数数据.md",key:"v-63702f6b",path:"/pages/92ea15/",headers:[{level:3,title:"几何体顶点颜色.attributes.color",slug:"几何体顶点颜色-attributes-color",normalizedTitle:"几何体顶点颜色.attributes.color",charIndex:213},{level:3,title:"点模型Points渲染顶点颜色数据",slug:"点模型points渲染顶点颜色数据",normalizedTitle:"点模型points渲染顶点颜色数据",charIndex:855},{level:3,title:"颜色渐变(颜色插值)",slug:"颜色渐变-颜色插值",normalizedTitle:"颜色渐变(颜色插值)",charIndex:1245},{level:3,title:"网格模型颜色渐变",slug:"网格模型颜色渐变",normalizedTitle:"网格模型颜色渐变",charIndex:1679}],headersStr:"几何体顶点颜色.attributes.color 点模型Points渲染顶点颜色数据 颜色渐变(颜色插值) 网格模型颜色渐变",content:"# 几何体顶点颜色数数据\n\n章节2中介绍过顶点位置、顶点法向量数据，下面给大家介绍顶点颜色.attributes.color数据。\n\n * 顶点位置数据geometry.attributes.position\n * 顶点法向量数据geometry.attributes.normal\n * 顶点UV数据geometry.attributes.uv\n * 顶点颜色数据geometry.attributes.color\n\n\n# 几何体顶点颜色.attributes.color\n\n几何体BufferGeometry顶点位置数据.attributes.position。\n\nconst geometry = new THREE.BufferGeometry(); //创建一个几何体对象\nconst vertices = new Float32Array([\n    0, 0, 0, //顶点1坐标\n    50, 0, 0, //顶点2坐标\n    0, 25, 0, //顶点3坐标\n]);\n// 顶点位置\ngeometry.attributes.position = new THREE.BufferAttribute(vertices, 3);\n\n\n与几何体BufferGeometry顶点位置数据.attributes.position一一对应的顶点颜色数据.attributes.color。\n\n每个点对应一个位置数据，同时对应一个颜色数据。\n\nconst colors = new Float32Array([\n    1, 0, 0, //顶点1颜色\n    0, 0, 1, //顶点2颜色\n    0, 1, 0, //顶点3颜色\n]);\n// 设置几何体attributes属性的颜色color属性\n//3个为一组,表示一个顶点的颜色数据RGB\ngeometry.attributes.color = new THREE.BufferAttribute(colors, 3); \n\n\n\n# 点模型Points渲染顶点颜色数据\n\n通过点、线、网格模型渲染几何体Geometry，如果希望顶点颜色.attributes.color起作用，需要设置材质属性vertexColors:true，下面以以点模型为例给大家演示，你可以看到geometry的不同点被你设置为了不同颜色。\n\n// 点渲染模式\nconst material = new THREE.PointsMaterial({\n    // color: 0x333333,//使用顶点颜色数据，color属性可以不用设置\n    vertexColors:true,//默认false，设置为true表示使用顶点颜色渲染\n    size: 20.0, //点对象像素尺寸\n});\nconst points = new THREE.Points(geometry, material); //点模型对象\n\n\n\n# 颜色渐变(颜色插值)\n\n自定几何体顶点颜色数据，然后用线模型Line渲染，你可以看到直线的颜色是渐变的。\n\n下面代码两端直线，分别是红色到蓝色渐变、蓝色到绿色渐变。\n\nconst colors = new Float32Array([\n    1, 0, 0, //顶点1颜色 \n    0, 0, 1, //顶点2颜色\n    0, 1, 0, //顶点3颜色\n]);\ngeometry.attributes.color = new THREE.BufferAttribute(colors, 3); \n\n\nconst material = new THREE.LineBasicMaterial({\n    vertexColors:true,//使用顶点颜色渲染\n});\nconst line = new THREE.Line(geometry, material);\n\n\n几何体顶点颜色.attributes.color设置的直线颜色渐变效果\n\n\n\n\n\n\n# 网格模型颜色渐变\n\n自定几何体顶点颜色数据，然后用网格模型Mesh渲染，和Line一样，也会产生颜色渐变效果。\n\nconst material = new THREE.MeshBasicMaterial({\n    // color: 0x333333,//使用顶点颜色数据，color属性可以不用设置\n    vertexColors:true,//默认false，设置为true表示使用顶点颜色渲染\n    side: THREE.DoubleSide,\n});\nconst mesh = new THREE.Mesh(geometry, material); \n\n\n\n",normalizedContent:"# 几何体顶点颜色数数据\n\n章节2中介绍过顶点位置、顶点法向量数据，下面给大家介绍顶点颜色.attributes.color数据。\n\n * 顶点位置数据geometry.attributes.position\n * 顶点法向量数据geometry.attributes.normal\n * 顶点uv数据geometry.attributes.uv\n * 顶点颜色数据geometry.attributes.color\n\n\n# 几何体顶点颜色.attributes.color\n\n几何体buffergeometry顶点位置数据.attributes.position。\n\nconst geometry = new three.buffergeometry(); //创建一个几何体对象\nconst vertices = new float32array([\n    0, 0, 0, //顶点1坐标\n    50, 0, 0, //顶点2坐标\n    0, 25, 0, //顶点3坐标\n]);\n// 顶点位置\ngeometry.attributes.position = new three.bufferattribute(vertices, 3);\n\n\n与几何体buffergeometry顶点位置数据.attributes.position一一对应的顶点颜色数据.attributes.color。\n\n每个点对应一个位置数据，同时对应一个颜色数据。\n\nconst colors = new float32array([\n    1, 0, 0, //顶点1颜色\n    0, 0, 1, //顶点2颜色\n    0, 1, 0, //顶点3颜色\n]);\n// 设置几何体attributes属性的颜色color属性\n//3个为一组,表示一个顶点的颜色数据rgb\ngeometry.attributes.color = new three.bufferattribute(colors, 3); \n\n\n\n# 点模型points渲染顶点颜色数据\n\n通过点、线、网格模型渲染几何体geometry，如果希望顶点颜色.attributes.color起作用，需要设置材质属性vertexcolors:true，下面以以点模型为例给大家演示，你可以看到geometry的不同点被你设置为了不同颜色。\n\n// 点渲染模式\nconst material = new three.pointsmaterial({\n    // color: 0x333333,//使用顶点颜色数据，color属性可以不用设置\n    vertexcolors:true,//默认false，设置为true表示使用顶点颜色渲染\n    size: 20.0, //点对象像素尺寸\n});\nconst points = new three.points(geometry, material); //点模型对象\n\n\n\n# 颜色渐变(颜色插值)\n\n自定几何体顶点颜色数据，然后用线模型line渲染，你可以看到直线的颜色是渐变的。\n\n下面代码两端直线，分别是红色到蓝色渐变、蓝色到绿色渐变。\n\nconst colors = new float32array([\n    1, 0, 0, //顶点1颜色 \n    0, 0, 1, //顶点2颜色\n    0, 1, 0, //顶点3颜色\n]);\ngeometry.attributes.color = new three.bufferattribute(colors, 3); \n\n\nconst material = new three.linebasicmaterial({\n    vertexcolors:true,//使用顶点颜色渲染\n});\nconst line = new three.line(geometry, material);\n\n\n几何体顶点颜色.attributes.color设置的直线颜色渐变效果\n\n\n\n\n\n\n# 网格模型颜色渐变\n\n自定几何体顶点颜色数据，然后用网格模型mesh渲染，和line一样，也会产生颜色渐变效果。\n\nconst material = new three.meshbasicmaterial({\n    // color: 0x333333,//使用顶点颜色数据，color属性可以不用设置\n    vertexcolors:true,//默认false，设置为true表示使用顶点颜色渲染\n    side: three.doubleside,\n});\nconst mesh = new three.mesh(geometry, material); \n\n\n\n",charsets:{cjk:!0}},{title:"19. 一段曲线颜色渐变",frontmatter:{title:"19. 一段曲线颜色渐变",date:"2023-02-04T20:46:08.000Z",permalink:"/pages/ace64e/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/19.%E4%B8%80%E6%AE%B5%E6%9B%B2%E7%BA%BF%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/19.一段曲线颜色渐变.md",key:"v-a9c900fe",path:"/pages/ace64e/",headers:[{level:3,title:"样条曲线几何体",slug:"样条曲线几何体",normalizedTitle:"样条曲线几何体",charIndex:61},{level:3,title:"设置几何体顶点颜色.attributes.color",slug:"设置几何体顶点颜色-attributes-color",normalizedTitle:"设置几何体顶点颜色.attributes.color",charIndex:496},{level:3,title:"线模型渲染渐变色曲线",slug:"线模型渲染渐变色曲线",normalizedTitle:"线模型渲染渐变色曲线",charIndex:1039}],headersStr:"样条曲线几何体 设置几何体顶点颜色.attributes.color 线模型渲染渐变色曲线",content:"# 一段曲线颜色渐变\n\n可以通过几何体顶点颜色.attributes.color数据，实现一段曲线颜色渐变效果。\n\n\n# 样条曲线几何体\n\n首先提供一个样条曲线生成的几何体。\n\nconst geometry = new THREE.BufferGeometry(); //创建一个几何体对象\n// 三维样条曲线\nconst curve = new THREE.CatmullRomCurve3([\n    new THREE.Vector3(-50, 20, 90),\n    new THREE.Vector3(-10, 40, 40),\n    new THREE.Vector3(0, 0, 0),\n    new THREE.Vector3(60, -60, 0),\n    new THREE.Vector3(70, 0, 80)\n]);\nconst pointsArr = curve.getSpacedPoints(100); //曲线取点      \ngeometry.setFromPoints(pointsArr); //pointsArr赋值给顶点位置属性 \n\n\n\n# 设置几何体顶点颜色.attributes.color\n\n曲线上不同位置设置不同的颜色，你可以按照点在曲线上索引值顺序来计算每个点对应的颜色数据。\n\nconst pos = geometry.attributes.position;\nconst count = pos.count; //顶点数量\n// 计算每个顶点的颜色值\nconst colorsArr = [];\nfor (let i = 0; i < count; i++) {\n    const percent = i / count; //点索引值相对所有点数量的百分比\n    //根据顶点位置顺序大小设置颜色渐变\n    // 红色分量从0到1变化，蓝色分量从1到0变化\n    colorsArr.push(percent, 0, 1 - percent); //蓝色到红色渐变色\n}\n//类型数组创建顶点颜色color数据\nconst colors = new Float32Array(colorsArr);\n// 设置几何体attributes属性的颜色color属性\ngeometry.attributes.color = new THREE.BufferAttribute(colors, 3);\n\n\n\n# 线模型渲染渐变色曲线\n\nconst material = new THREE.LineBasicMaterial({\n    vertexColors: true, //使用顶点颜色渲染\n});\nconst line = new THREE.Line(geometry, material);\n",normalizedContent:"# 一段曲线颜色渐变\n\n可以通过几何体顶点颜色.attributes.color数据，实现一段曲线颜色渐变效果。\n\n\n# 样条曲线几何体\n\n首先提供一个样条曲线生成的几何体。\n\nconst geometry = new three.buffergeometry(); //创建一个几何体对象\n// 三维样条曲线\nconst curve = new three.catmullromcurve3([\n    new three.vector3(-50, 20, 90),\n    new three.vector3(-10, 40, 40),\n    new three.vector3(0, 0, 0),\n    new three.vector3(60, -60, 0),\n    new three.vector3(70, 0, 80)\n]);\nconst pointsarr = curve.getspacedpoints(100); //曲线取点      \ngeometry.setfrompoints(pointsarr); //pointsarr赋值给顶点位置属性 \n\n\n\n# 设置几何体顶点颜色.attributes.color\n\n曲线上不同位置设置不同的颜色，你可以按照点在曲线上索引值顺序来计算每个点对应的颜色数据。\n\nconst pos = geometry.attributes.position;\nconst count = pos.count; //顶点数量\n// 计算每个顶点的颜色值\nconst colorsarr = [];\nfor (let i = 0; i < count; i++) {\n    const percent = i / count; //点索引值相对所有点数量的百分比\n    //根据顶点位置顺序大小设置颜色渐变\n    // 红色分量从0到1变化，蓝色分量从1到0变化\n    colorsarr.push(percent, 0, 1 - percent); //蓝色到红色渐变色\n}\n//类型数组创建顶点颜色color数据\nconst colors = new float32array(colorsarr);\n// 设置几何体attributes属性的颜色color属性\ngeometry.attributes.color = new three.bufferattribute(colors, 3);\n\n\n\n# 线模型渲染渐变色曲线\n\nconst material = new three.linebasicmaterial({\n    vertexcolors: true, //使用顶点颜色渲染\n});\nconst line = new three.line(geometry, material);\n",charsets:{cjk:!0}},{title:"20. Color颜色渐变插值",frontmatter:{title:"20. Color颜色渐变插值",date:"2023-02-04T20:46:21.000Z",permalink:"/pages/05ca12/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/20.Color%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98%E6%8F%92%E5%80%BC.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/20.Color颜色渐变插值.md",key:"v-5e7950d8",path:"/pages/05ca12/",headers:[{level:3,title:"颜色对象Color颜色插值方法.lerpColors()",slug:"颜色对象color颜色插值方法-lerpcolors",normalizedTitle:"颜色对象color颜色插值方法.lerpcolors()",charIndex:68},{level:3,title:"颜色对象Color颜色插值方法.lerp()",slug:"颜色对象color颜色插值方法-lerp",normalizedTitle:"颜色对象color颜色插值方法.lerp()",charIndex:637},{level:3,title:"颜色克隆.clone()",slug:"颜色克隆-clone",normalizedTitle:"颜色克隆.clone()",charIndex:851},{level:3,title:"Color颜色插值应用",slug:"color颜色插值应用",normalizedTitle:"color颜色插值应用",charIndex:1140}],headersStr:"颜色对象Color颜色插值方法.lerpColors() 颜色对象Color颜色插值方法.lerp() 颜色克隆.clone() Color颜色插值应用",content:"# Color颜色渐变插值\n\n下面给大家介绍一个颜色对象Color颜色渐变插值方法.lerpColors()和.lerp()。\n\n\n# 颜色对象Color颜色插值方法.lerpColors()\n\n通过浏览器控制台测试.lerpColors()方法颜色插值的规律。\n\n执行.lerpColors(Color1,Color2, percent)通过一个百分比参数percent，可以控制Color1和Color2两种颜色混合的百分比，Color1对应1-percent，Color2对应percent。\n\nconst c1 = new THREE.Color(0xff0000); //红色\nconst c2 = new THREE.Color(0x0000ff); //蓝色\nconst c = new THREE.Color();\n\n\n颜色插值结果，和c1一样rgb(1,0,0),100% c1 + 0% c2混合\n\nc.lerpColors(c1,c2, 0);\nconsole.log('颜色插值结果',c);\n\n\n颜色插值结果rgb(0.5,0,0.5)，c1和c2各取50%：\n\nc.lerpColors(c1,c2, 0.5);\nconsole.log('颜色插值结果',c);\n\n\n和c2一样rgb(0,0,1) 0% c1 + 100% c2混合\n\nc.lerpColors(c1,c2, 1);\nconsole.log('颜色插值结果',c);\n\n\n\n# 颜色对象Color颜色插值方法.lerp()\n\n.lerp()和.lerpColors()功能一样，只是具体语法细节不同。\n\nc1与c2颜色混合，混合后的rgb值，赋值给c1的.r、.g、.b属性。\n\nconst c1 = new THREE.Color(0xff0000); //红色\nconst c2 = new THREE.Color(0x0000ff); //蓝色\nc1.lerp(c2, percent);\n\n\n\n# 颜色克隆.clone()\n\n通过颜色对象克隆方法.clone()可以返回一个新的颜色对象。\n\n注意c1.clone().lerp()和c1.lerp()写法是不同的，执行c1.clone().lerp()，c1和c2颜色混合后，不会改变c1的颜色值，改变的是c1.clone()返回的新颜色对象。\n\nconst c1 = new THREE.Color(0xff0000); //红色\nconst c2 = new THREE.Color(0x0000ff); //蓝色\nconst c = c1.clone().lerp(c2, percent);//颜色插值计算\n\n\n\n# Color颜色插值应用\n\n上节课\"19.一段曲线颜色渐变\"中颜色渐变是自己写的规则，这样比较麻烦，可以借助颜色插值方法Color.lerp()快速实现颜色渐变的计算。\n\nconst pos = geometry.attributes.position;\nconst count = pos.count; //顶点数量\n// 计算每个顶点的颜色值\nconst colorsArr = [];\nfor (let i = 0; i < count; i++) {\n    const percent = i / count; \n    // 红色分量从0到1变化，蓝色分量从1到0变化\n    colorsArr.push(percent, 0, 1 - percent); //蓝色到红色渐变色\n}\n\n\n// 根据顶点距离起点远近进行颜色插值计算\nconst c1 = new THREE.Color(0x00ffff); //曲线起点颜色 青色\nconst c2 = new THREE.Color(0xffff00); //曲线结束点颜色 黄色\nfor (let i = 0; i < count; i++) {\n    const percent = i / count; //点索引值相对所有点数量的百分比\n    //根据顶点位置顺序大小设置颜色渐变\n    const c = c1.clone().lerp(c2, percent);//颜色插值计算\n    colorsArr.push(c.r, c.g, c.b); \n}\n",normalizedContent:"# color颜色渐变插值\n\n下面给大家介绍一个颜色对象color颜色渐变插值方法.lerpcolors()和.lerp()。\n\n\n# 颜色对象color颜色插值方法.lerpcolors()\n\n通过浏览器控制台测试.lerpcolors()方法颜色插值的规律。\n\n执行.lerpcolors(color1,color2, percent)通过一个百分比参数percent，可以控制color1和color2两种颜色混合的百分比，color1对应1-percent，color2对应percent。\n\nconst c1 = new three.color(0xff0000); //红色\nconst c2 = new three.color(0x0000ff); //蓝色\nconst c = new three.color();\n\n\n颜色插值结果，和c1一样rgb(1,0,0),100% c1 + 0% c2混合\n\nc.lerpcolors(c1,c2, 0);\nconsole.log('颜色插值结果',c);\n\n\n颜色插值结果rgb(0.5,0,0.5)，c1和c2各取50%：\n\nc.lerpcolors(c1,c2, 0.5);\nconsole.log('颜色插值结果',c);\n\n\n和c2一样rgb(0,0,1) 0% c1 + 100% c2混合\n\nc.lerpcolors(c1,c2, 1);\nconsole.log('颜色插值结果',c);\n\n\n\n# 颜色对象color颜色插值方法.lerp()\n\n.lerp()和.lerpcolors()功能一样，只是具体语法细节不同。\n\nc1与c2颜色混合，混合后的rgb值，赋值给c1的.r、.g、.b属性。\n\nconst c1 = new three.color(0xff0000); //红色\nconst c2 = new three.color(0x0000ff); //蓝色\nc1.lerp(c2, percent);\n\n\n\n# 颜色克隆.clone()\n\n通过颜色对象克隆方法.clone()可以返回一个新的颜色对象。\n\n注意c1.clone().lerp()和c1.lerp()写法是不同的，执行c1.clone().lerp()，c1和c2颜色混合后，不会改变c1的颜色值，改变的是c1.clone()返回的新颜色对象。\n\nconst c1 = new three.color(0xff0000); //红色\nconst c2 = new three.color(0x0000ff); //蓝色\nconst c = c1.clone().lerp(c2, percent);//颜色插值计算\n\n\n\n# color颜色插值应用\n\n上节课\"19.一段曲线颜色渐变\"中颜色渐变是自己写的规则，这样比较麻烦，可以借助颜色插值方法color.lerp()快速实现颜色渐变的计算。\n\nconst pos = geometry.attributes.position;\nconst count = pos.count; //顶点数量\n// 计算每个顶点的颜色值\nconst colorsarr = [];\nfor (let i = 0; i < count; i++) {\n    const percent = i / count; \n    // 红色分量从0到1变化，蓝色分量从1到0变化\n    colorsarr.push(percent, 0, 1 - percent); //蓝色到红色渐变色\n}\n\n\n// 根据顶点距离起点远近进行颜色插值计算\nconst c1 = new three.color(0x00ffff); //曲线起点颜色 青色\nconst c2 = new three.color(0xffff00); //曲线结束点颜色 黄色\nfor (let i = 0; i < count; i++) {\n    const percent = i / count; //点索引值相对所有点数量的百分比\n    //根据顶点位置顺序大小设置颜色渐变\n    const c = c1.clone().lerp(c2, percent);//颜色插值计算\n    colorsarr.push(c.r, c.g, c.b); \n}\n",charsets:{cjk:!0}},{title:"21. 查看或设置gltf几何体顶点",frontmatter:{title:"21. 查看或设置gltf几何体顶点",date:"2023-02-04T20:46:34.000Z",permalink:"/pages/fde9a0/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/21.%E6%9F%A5%E7%9C%8B%E6%88%96%E8%AE%BE%E7%BD%AEgltf%E5%87%A0%E4%BD%95%E4%BD%93%E9%A1%B6%E7%82%B9.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/21.查看或设置gltf几何体顶点.md",key:"v-083e2755",path:"/pages/fde9a0/",headers:[{level:3,title:"获取gltf模型几何体顶点数据",slug:"获取gltf模型几何体顶点数据",normalizedTitle:"获取gltf模型几何体顶点数据",charIndex:459},{level:3,title:"几何体顶点索引属性geometry.index",slug:"几何体顶点索引属性geometry-index",normalizedTitle:"几何体顶点索引属性geometry.index",charIndex:828},{level:3,title:"顶点数量BufferAttribute.count",slug:"顶点数量bufferattribute-count",normalizedTitle:"顶点数量bufferattribute.count",charIndex:986},{level:3,title:".getX()、.getY()和.getZ()",slug:"getx-、-gety-和-getz",normalizedTitle:".getx()、.gety()和.getz()",charIndex:1082},{level:3,title:".setX()、.setY()和.setZ()",slug:"setx-、-sety-和-setz",normalizedTitle:".setx()、.sety()和.setz()",charIndex:1405},{level:3,title:"批量重置几何体顶点y坐标",slug:"批量重置几何体顶点y坐标",normalizedTitle:"批量重置几何体顶点y坐标",charIndex:1579}],headersStr:"获取gltf模型几何体顶点数据 几何体顶点索引属性geometry.index 顶点数量BufferAttribute.count .getX()、.getY()和.getZ() .setX()、.setY()和.setZ() 批量重置几何体顶点y坐标",content:"# 查看或设置gltf几何体顶点\n\n前面给大家介绍过几何体BufferGeometry对象，以及用来表示BufferGeometry顶点数据的属性缓冲对象BufferAttribute。\n\ngeometry.attributes.position = new THREE.BufferAttribute();\ngeometry.attributes.normal = new THREE.BufferAttribute(); \ngeometry.attributes.color = new THREE.BufferAttribute(); \ngeometry.attributes.uv = new THREE.BufferAttribute(); \ngeometry.index = new THREE.BufferAttribute(); \n\n\n下面通过加载一个外部gltf模型为例，给大家演示如何获取、修改外部模型的几何体顶点数据，也就是说获取、修改BufferAttribute对象里面的顶点数据。\n\n\n# 获取gltf模型几何体顶点数据\n\nloader.load(\"../地形.glb\", function (gltf) { //gltf加载成功后返回一个对象\n    model.add(gltf.scene); //三维场景添加到model组对象中\n    //mesh表示地形网格模型\n    const mesh = gltf.scene.children[0];\n    // 顶点数据\n    const att = mesh.geometry.attributes;\n    console.log('att', att);\n    // 顶点位置数据\n    const pos = mesh.geometry.attributes.position;\n    console.log('pos', pos);\n})\n\n\n\n# 几何体顶点索引属性geometry.index\n\nthree.js大部分自带的几何体API默认有.index属性，不过外部加载的gltf等模型，geometry.index数据可能有，也可能没有，具体看外部模型情况。\n\nconsole.log('index', mesh.geometry.index);\n\n\n\n# 顶点数量BufferAttribute.count\n\nconst count = pos.count; //几何体顶点数量\nconsole.log('count', count);\n\n\n\n# .getX()、.getY()和.getZ()\n\nBufferAttribute对象具有.getX()、.getY()和.getZ()方法。\n\nBufferAttribute共有顶点数量count，通过.getX(i)方法可以获取第i+1个点的x分量，i的范围就是[0,count-1]。\n\nconst pos = mesh.geometry.attributes.position;\n// 获取几何体第一个顶点的x坐标\nconst x = pos.getX(0);\nconsole.log('x', x);\n\n\n.getY()、.getZ()是获取顶点数据BufferAttribute的y、z分量,使用方式和.getX()方法一样。\n\n\n# .setX()、.setY()和.setZ()\n\n通过.getY()是获取顶点y坐标，通过.setY()是设置顶点y坐标。\n\npos.setY(0,100)把索引为0，也就是第一个顶点的y坐标设置为100.\n\nconst pos = mesh.geometry.attributes.position;\npos.setX(0,100);\n\n\n\n# 批量重置几何体顶点y坐标\n\nloader.load(\"../地形.glb\", function (gltf) { \n    model.add(gltf.scene); \n    //mesh表示地形网格模型\n    const mesh = gltf.scene.children[0];\n    // 顶点位置数据\n    const pos = mesh.geometry.attributes.position;\n    const count = pos.count; //几何体顶点数量\n    // 批量设置所有几何体顶点位置的y坐标\n    for (let i = 0; i < count; i++) {\n        const y = pos.getY(i);//获取第i+1个顶点y坐标\n        pos.setY(i,y*2)//设置第i+1个顶点y坐标为自身2倍\n    }\n})\n",normalizedContent:"# 查看或设置gltf几何体顶点\n\n前面给大家介绍过几何体buffergeometry对象，以及用来表示buffergeometry顶点数据的属性缓冲对象bufferattribute。\n\ngeometry.attributes.position = new three.bufferattribute();\ngeometry.attributes.normal = new three.bufferattribute(); \ngeometry.attributes.color = new three.bufferattribute(); \ngeometry.attributes.uv = new three.bufferattribute(); \ngeometry.index = new three.bufferattribute(); \n\n\n下面通过加载一个外部gltf模型为例，给大家演示如何获取、修改外部模型的几何体顶点数据，也就是说获取、修改bufferattribute对象里面的顶点数据。\n\n\n# 获取gltf模型几何体顶点数据\n\nloader.load(\"../地形.glb\", function (gltf) { //gltf加载成功后返回一个对象\n    model.add(gltf.scene); //三维场景添加到model组对象中\n    //mesh表示地形网格模型\n    const mesh = gltf.scene.children[0];\n    // 顶点数据\n    const att = mesh.geometry.attributes;\n    console.log('att', att);\n    // 顶点位置数据\n    const pos = mesh.geometry.attributes.position;\n    console.log('pos', pos);\n})\n\n\n\n# 几何体顶点索引属性geometry.index\n\nthree.js大部分自带的几何体api默认有.index属性，不过外部加载的gltf等模型，geometry.index数据可能有，也可能没有，具体看外部模型情况。\n\nconsole.log('index', mesh.geometry.index);\n\n\n\n# 顶点数量bufferattribute.count\n\nconst count = pos.count; //几何体顶点数量\nconsole.log('count', count);\n\n\n\n# .getx()、.gety()和.getz()\n\nbufferattribute对象具有.getx()、.gety()和.getz()方法。\n\nbufferattribute共有顶点数量count，通过.getx(i)方法可以获取第i+1个点的x分量，i的范围就是[0,count-1]。\n\nconst pos = mesh.geometry.attributes.position;\n// 获取几何体第一个顶点的x坐标\nconst x = pos.getx(0);\nconsole.log('x', x);\n\n\n.gety()、.getz()是获取顶点数据bufferattribute的y、z分量,使用方式和.getx()方法一样。\n\n\n# .setx()、.sety()和.setz()\n\n通过.gety()是获取顶点y坐标，通过.sety()是设置顶点y坐标。\n\npos.sety(0,100)把索引为0，也就是第一个顶点的y坐标设置为100.\n\nconst pos = mesh.geometry.attributes.position;\npos.setx(0,100);\n\n\n\n# 批量重置几何体顶点y坐标\n\nloader.load(\"../地形.glb\", function (gltf) { \n    model.add(gltf.scene); \n    //mesh表示地形网格模型\n    const mesh = gltf.scene.children[0];\n    // 顶点位置数据\n    const pos = mesh.geometry.attributes.position;\n    const count = pos.count; //几何体顶点数量\n    // 批量设置所有几何体顶点位置的y坐标\n    for (let i = 0; i < count; i++) {\n        const y = pos.gety(i);//获取第i+1个顶点y坐标\n        pos.sety(i,y*2)//设置第i+1个顶点y坐标为自身2倍\n    }\n})\n",charsets:{cjk:!0}},{title:"22. 山脉地形高度可视化",frontmatter:{title:"22. 山脉地形高度可视化",date:"2023-02-04T20:47:36.000Z",permalink:"/pages/dbd776/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/09.9.%E7%94%9F%E6%88%90%E6%9B%B2%E7%BA%BF%E3%80%81%E5%87%A0%E4%BD%95%E4%BD%93/22.%E5%B1%B1%E8%84%89%E5%9C%B0%E5%BD%A2%E9%AB%98%E5%BA%A6%E5%8F%AF%E8%A7%86%E5%8C%96.html",relativePath:"01.Three.js教程/09.9.生成曲线、几何体/22.山脉地形高度可视化.md",key:"v-d8c63b20",path:"/pages/dbd776/",headers:[{level:3,title:"1. 山脉几何体y坐标范围",slug:"_1-山脉几何体y坐标范围",normalizedTitle:"1. 山脉几何体y坐标范围",charIndex:156},{level:3,title:"2.根据山脉顶点高度设置渐变颜色",slug:"_2-根据山脉顶点高度设置渐变颜色",normalizedTitle:"2.根据山脉顶点高度设置渐变颜色",charIndex:674},{level:3,title:"3. Mesh渲染山脉顶点颜色",slug:"_3-mesh渲染山脉顶点颜色",normalizedTitle:"3. mesh渲染山脉顶点颜色",charIndex:1201}],headersStr:"1. 山脉几何体y坐标范围 2.根据山脉顶点高度设置渐变颜色 3. Mesh渲染山脉顶点颜色",content:'# 山脉地形高度可视化\n\n一个山脉地形的高度可视化，具体说就是地形不同的高度设置不同的颜色值。有多种方式，下面就举一个设置顶点颜色.attributes.color的例子\n\n\n\n本节课算是一个练习题，用到的知识点前面几节都将讲解过，所以视频主要把思路给大家说一遍，然后大家根据课程课程思路自己手写一遍。\n\n\n# 1. 山脉几何体y坐标范围\n\nloader.load("../地形.glb", function (gltf) { \n    model.add(gltf.scene);\n    const mesh = gltf.scene.children[0];\n    const pos = mesh.geometry.attributes.position;\n    const count = pos.count;\n\n    // 1. 计算模型y坐标高度差\n    const yArr = [];//顶点所有y坐标，也就是地形高度\n    for (let i = 0; i < count; i++) {\n        yArr.push(pos.getY(i));//获取顶点y坐标，也就是地形高度\n    }\n    yArr.sort();//数组元素排序，从小到大\n    const miny = yArr[0];//y最小值\n    const maxy = yArr[yArr.length - 1];//y最大值\n    const height = maxy - miny; //山脉整体高度 \n})\n\n\n\n# 2.根据山脉顶点高度设置渐变颜色\n\n借助颜色对象的颜色插值方法.lerp(),计算山脉不同高度位置点的颜色。\n\n// 2. 计算每个顶点的颜色值\nconst colorsArr = [];\nconst c1 = new THREE.Color(0x0000ff);//山谷颜色\nconst c2 = new THREE.Color(0xff0000);//山顶颜色\nfor (let i = 0; i < count; i++) {\n    //当前高度和整体高度比值\n    const percent = (pos.getY(i) - miny) / height;\n    const c = c1.clone().lerp(c2, percent);//颜色插值计算\n    colorsArr.push(c.r, c.g, c.b); \n}\nconst colors = new Float32Array(colorsArr);\n// 设置几何体attributes属性的颜色color属性\nmesh.geometry.attributes.color = new THREE.BufferAttribute(colors, 3);\n\n\n\n# 3. Mesh渲染山脉顶点颜色\n\n// 3. 设置材质，使用顶点颜色渲染\nmesh.material = new THREE.MeshLambertMaterial({\n    vertexColors:true,\n});\n',normalizedContent:'# 山脉地形高度可视化\n\n一个山脉地形的高度可视化，具体说就是地形不同的高度设置不同的颜色值。有多种方式，下面就举一个设置顶点颜色.attributes.color的例子\n\n\n\n本节课算是一个练习题，用到的知识点前面几节都将讲解过，所以视频主要把思路给大家说一遍，然后大家根据课程课程思路自己手写一遍。\n\n\n# 1. 山脉几何体y坐标范围\n\nloader.load("../地形.glb", function (gltf) { \n    model.add(gltf.scene);\n    const mesh = gltf.scene.children[0];\n    const pos = mesh.geometry.attributes.position;\n    const count = pos.count;\n\n    // 1. 计算模型y坐标高度差\n    const yarr = [];//顶点所有y坐标，也就是地形高度\n    for (let i = 0; i < count; i++) {\n        yarr.push(pos.gety(i));//获取顶点y坐标，也就是地形高度\n    }\n    yarr.sort();//数组元素排序，从小到大\n    const miny = yarr[0];//y最小值\n    const maxy = yarr[yarr.length - 1];//y最大值\n    const height = maxy - miny; //山脉整体高度 \n})\n\n\n\n# 2.根据山脉顶点高度设置渐变颜色\n\n借助颜色对象的颜色插值方法.lerp(),计算山脉不同高度位置点的颜色。\n\n// 2. 计算每个顶点的颜色值\nconst colorsarr = [];\nconst c1 = new three.color(0x0000ff);//山谷颜色\nconst c2 = new three.color(0xff0000);//山顶颜色\nfor (let i = 0; i < count; i++) {\n    //当前高度和整体高度比值\n    const percent = (pos.gety(i) - miny) / height;\n    const c = c1.clone().lerp(c2, percent);//颜色插值计算\n    colorsarr.push(c.r, c.g, c.b); \n}\nconst colors = new float32array(colorsarr);\n// 设置几何体attributes属性的颜色color属性\nmesh.geometry.attributes.color = new three.bufferattribute(colors, 3);\n\n\n\n# 3. mesh渲染山脉顶点颜色\n\n// 3. 设置材质，使用顶点颜色渲染\nmesh.material = new three.meshlambertmaterial({\n    vertexcolors:true,\n});\n',charsets:{cjk:!0}},{title:"1. 正投影相机",frontmatter:{title:"1. 正投影相机",date:"2023-02-02T10:27:24.000Z",permalink:"/pages/1c3a1a/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/01.%E6%AD%A3%E6%8A%95%E5%BD%B1%E7%9B%B8%E6%9C%BA.html",relativePath:"01.Three.js教程/10.10.相机基础/01.正投影相机.md",key:"v-cfd35e92",path:"/pages/1c3a1a/",headers:[{level:3,title:"正投影长方体可视空间",slug:"正投影长方体可视空间",normalizedTitle:"正投影长方体可视空间",charIndex:113},{level:3,title:"渲染范围设置",slug:"渲染范围设置",normalizedTitle:"渲染范围设置",charIndex:460},{level:3,title:"相机位置和观察目标设置",slug:"相机位置和观察目标设置",normalizedTitle:"相机位置和观察目标设置",charIndex:761},{level:3,title:"调整left, right, top, bottom范围大小",slug:"调整left-right-top-bottom范围大小",normalizedTitle:"调整left, right, top, bottom范围大小",charIndex:1094},{level:3,title:"改变位置参数",slug:"改变位置参数",normalizedTitle:"改变位置参数",charIndex:1272},{level:3,title:"改变观察目标.lookAt()",slug:"改变观察目标-lookat",normalizedTitle:"改变观察目标.lookat()",charIndex:1452},{level:3,title:"正投影相机和透视投影相机区别",slug:"正投影相机和透视投影相机区别",normalizedTitle:"正投影相机和透视投影相机区别",charIndex:1615},{level:3,title:"对比透视投影和正投影预览工厂视觉差异",slug:"对比透视投影和正投影预览工厂视觉差异",normalizedTitle:"对比透视投影和正投影预览工厂视觉差异",charIndex:1723},{level:3,title:"相机选择",slug:"相机选择",normalizedTitle:"相机选择",charIndex:1808}],headersStr:"正投影长方体可视空间 渲染范围设置 相机位置和观察目标设置 调整left, right, top, bottom范围大小 改变位置参数 改变观察目标.lookAt() 正投影相机和透视投影相机区别 对比透视投影和正投影预览工厂视觉差异 相机选择",content:"# 正投影相机OrthographicCamera\n\n在入门阶段给大家介绍过比较常用的透视投影相机PerspectiveCamera，下面给大家介绍另外一个相机对象正投影相机OrthographicCamera。\n\n\n\n\n# 正投影长方体可视空间\n\n正投影相机的长方体可视化空间和透视投影PerspectiveCamera视锥体相似，只是形状不同。\n\n\n\n正投影相机\n\n// 构造函数格式\nOrthographicCamera( left, right, top, bottom, near, far )\n\n\n参数(属性)   含义\nleft     渲染空间的左边界\nright    渲染空间的右边界\ntop      渲染空间的上边界\nbottom   渲染空间的下边界\nnear     near属性表示的是从距离相机多远的位置开始渲染，一般情况会设置一个很小的值。 默认值0.1\nfar      far属性表示的是距离相机多远的位置截止渲染，如果设置的值偏小小，会有部分场景看不到。 默认值2000\n\n\n# 渲染范围设置\n\n设置正投影相机长方体可视化空间的渲染范围\n\n// 正投影相机\nconst width = window.innerWidth; //canvas画布宽度\nconst height = window.innerHeight; //canvas画布高度\nconst k = width / height; //canvas画布宽高比\nconst s = 600;//控制left, right, top, bottom范围大小\nconst camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 8000);\n\n\n\n# 相机位置和观察目标设置\n\n相当于相机放在y轴上，向下观察地面上阵列的长方体。\n\ncamera.position.set(0, 2000, 0);//相机放在了y轴上\ncamera.lookAt(0, 0, 0);//指向坐标原点\n\n\n注意.position位置和far参数的设置，确保你想看到的物体能够包含在far之内，超出far的不会渲染。\n\n测试：far减小,物体不在可视化空间之内，看不到\n\nnew THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 500)\n\n\n测试：.position.y增大,物体不在可视化空间之内，看不到\n\ncamera.position.set(0, 10000, 0);\n\n\n\n# 调整left, right, top, bottom范围大小\n\n如果你想整体预览全部立方体，就需要调整相机的渲染范围，比如设置上下左右的范围。\n\ns设置为2000，上下方向top, bottom渲染范围大概4000左右，三维场景中的立方体分布范围也是大约4000左右，沿着y轴观察，刚好近似可以看到全部长方体。\n\nconst s = 2000;\n\n\n\n# 改变位置参数\n\n改变位置参数，改变了观察视角，渲染效果也跟着改变。\n\ncamera.position.set(800, 800, 800);\n\n\n上面位置你会发现部分立方体会被剪裁掉，其实很简单，有些物体在相机的后面，相机自然看不到，你可以改变相机参数渲染全部立方体。\n\ncamera.position.set(1500, 1500, 1500);\n\n\n\n# 改变观察目标.lookAt()\n\n指向坐标原点，坐标原点出现在canvas画布中间\n\ncamera.lookAt(0, 0, 0);\n\n\n指向坐标(2000, 0, 2000)，(2000, 0, 2000)对应的场景中位置出现在canvas画布中间。\n\ncamera.lookAt(2000, 0, 2000);\n\n\n\n# 正投影相机和透视投影相机区别\n\n一句话描述，正投影相机OrthographicCamera和透视投影相机PerspectiveCamera的区别就是，透视投影可以模拟人眼观察世界的视觉效果，正投影相机不会。\n\n\n# 对比透视投影和正投影预览工厂视觉差异\n\n比如前面工厂的gltf模型加载案例，就是用透视投影相机模拟人在空中俯视地面的效果，如果使用正投影相机渲染效果就不太自然。\n\n\n# 相机选择\n\n对于大部分需要模拟人眼观察效果的场景，需要使用透视投影相机，比如人在场景中漫游，或是在高处俯瞰整个园区或工厂。\n\n正投影没有透视效果,也就是不会模拟人眼观察世界的效果。在一些不需要透视的场景你可以选择使用正投影相机，比如整体预览一个中国地图的效果，或者一个2D可视化的效果。",normalizedContent:"# 正投影相机orthographiccamera\n\n在入门阶段给大家介绍过比较常用的透视投影相机perspectivecamera，下面给大家介绍另外一个相机对象正投影相机orthographiccamera。\n\n\n\n\n# 正投影长方体可视空间\n\n正投影相机的长方体可视化空间和透视投影perspectivecamera视锥体相似，只是形状不同。\n\n\n\n正投影相机\n\n// 构造函数格式\northographiccamera( left, right, top, bottom, near, far )\n\n\n参数(属性)   含义\nleft     渲染空间的左边界\nright    渲染空间的右边界\ntop      渲染空间的上边界\nbottom   渲染空间的下边界\nnear     near属性表示的是从距离相机多远的位置开始渲染，一般情况会设置一个很小的值。 默认值0.1\nfar      far属性表示的是距离相机多远的位置截止渲染，如果设置的值偏小小，会有部分场景看不到。 默认值2000\n\n\n# 渲染范围设置\n\n设置正投影相机长方体可视化空间的渲染范围\n\n// 正投影相机\nconst width = window.innerwidth; //canvas画布宽度\nconst height = window.innerheight; //canvas画布高度\nconst k = width / height; //canvas画布宽高比\nconst s = 600;//控制left, right, top, bottom范围大小\nconst camera = new three.orthographiccamera(-s * k, s * k, s, -s, 1, 8000);\n\n\n\n# 相机位置和观察目标设置\n\n相当于相机放在y轴上，向下观察地面上阵列的长方体。\n\ncamera.position.set(0, 2000, 0);//相机放在了y轴上\ncamera.lookat(0, 0, 0);//指向坐标原点\n\n\n注意.position位置和far参数的设置，确保你想看到的物体能够包含在far之内，超出far的不会渲染。\n\n测试：far减小,物体不在可视化空间之内，看不到\n\nnew three.orthographiccamera(-s * k, s * k, s, -s, 1, 500)\n\n\n测试：.position.y增大,物体不在可视化空间之内，看不到\n\ncamera.position.set(0, 10000, 0);\n\n\n\n# 调整left, right, top, bottom范围大小\n\n如果你想整体预览全部立方体，就需要调整相机的渲染范围，比如设置上下左右的范围。\n\ns设置为2000，上下方向top, bottom渲染范围大概4000左右，三维场景中的立方体分布范围也是大约4000左右，沿着y轴观察，刚好近似可以看到全部长方体。\n\nconst s = 2000;\n\n\n\n# 改变位置参数\n\n改变位置参数，改变了观察视角，渲染效果也跟着改变。\n\ncamera.position.set(800, 800, 800);\n\n\n上面位置你会发现部分立方体会被剪裁掉，其实很简单，有些物体在相机的后面，相机自然看不到，你可以改变相机参数渲染全部立方体。\n\ncamera.position.set(1500, 1500, 1500);\n\n\n\n# 改变观察目标.lookat()\n\n指向坐标原点，坐标原点出现在canvas画布中间\n\ncamera.lookat(0, 0, 0);\n\n\n指向坐标(2000, 0, 2000)，(2000, 0, 2000)对应的场景中位置出现在canvas画布中间。\n\ncamera.lookat(2000, 0, 2000);\n\n\n\n# 正投影相机和透视投影相机区别\n\n一句话描述，正投影相机orthographiccamera和透视投影相机perspectivecamera的区别就是，透视投影可以模拟人眼观察世界的视觉效果，正投影相机不会。\n\n\n# 对比透视投影和正投影预览工厂视觉差异\n\n比如前面工厂的gltf模型加载案例，就是用透视投影相机模拟人在空中俯视地面的效果，如果使用正投影相机渲染效果就不太自然。\n\n\n# 相机选择\n\n对于大部分需要模拟人眼观察效果的场景，需要使用透视投影相机，比如人在场景中漫游，或是在高处俯瞰整个园区或工厂。\n\n正投影没有透视效果,也就是不会模拟人眼观察世界的效果。在一些不需要透视的场景你可以选择使用正投影相机，比如整体预览一个中国地图的效果，或者一个2d可视化的效果。",charsets:{cjk:!0}},{title:"2. 正投影相机-Canvas尺寸变化",frontmatter:{title:"2. 正投影相机-Canvas尺寸变化",date:"2023-02-11T10:37:38.000Z",permalink:"/pages/6f9387/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/02.%E6%AD%A3%E6%8A%95%E5%BD%B1%E7%9B%B8%E6%9C%BA-Canvas%E5%B0%BA%E5%AF%B8%E5%8F%98%E5%8C%96.html",relativePath:"01.Three.js教程/10.10.相机基础/02.正投影相机-Canvas尺寸变化.md",key:"v-28edb3fc",path:"/pages/6f9387/",headers:[{level:3,title:"WebGL渲染器更新Canvas画布尺寸",slug:"webgl渲染器更新canvas画布尺寸",normalizedTitle:"webgl渲染器更新canvas画布尺寸",charIndex:213},{level:3,title:"相机参数更新",slug:"相机参数更新",normalizedTitle:"相机参数更新",charIndex:699}],headersStr:"WebGL渲染器更新Canvas画布尺寸 相机参数更新",content:"# 正投影相机-Canvas画布尺寸变化\n\n前面给大家讲解过(1.12、8.1两小节)，一些应用场景Cnavas画布可能不是固定尺寸，而是变化的。这时候就需要重新设置WebGL渲染器、相机等参数。\n\n前面给大家演示的时候，相机是用的透视投影，下面主要演示下，正投影相机的参数如何随着Canvas画布尺寸的变化而变化。\n\n * 1.12.Canvas画布尺寸变化\n\n * 8.1.three.js Canvas画布布局\n\n\n# WebGL渲染器更新Canvas画布尺寸\n\n// onresize 事件会在窗口被调整大小时发生\nwindow.onresize = function () {\n    const width = window.innerWidth; //canvas画布宽度\n    const height = window.innerHeight; //canvas画布高度\n    // 重置渲染器输出画布canvas尺寸\n    renderer.setSize(width, height);\n};\n\n\nwindow.onresize = function () {\n    const width = window.innerWidth-200; //canvas画布宽度\n    const height = window.innerHeight-200; //canvas画布高度\n    // 重置渲染器输出画布canvas尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight);\n};\n\n\n\n# 相机参数更新\n\n.aspect属性受到canvas画布宽高度影响，当canvas画布尺寸发生变化的时候，需要更新透视投影相机PerspectiveCamera的.aspect属性。\n\nwindow.onresize = function () {\n    // width、height表示canvas画布宽高度\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n};\n\n\n你预览案例源码中正投影相机代码，可以看到，正投影相机OrthographicCamera的left、 right属性受到canvas画布宽高比影响，所以需要随着canvas画布更新。\n\nconst k = width / height; //canvas画布宽高比\nconst s = 50; \n//控制left, right, top, bottom范围大小\nconst camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 8000);\n\n\n// Canvas画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerWidth; //canvas画布宽度\n    const height = window.innerHeight; //canvas画布高度\n    // 1. WebGL渲染器渲染的Cnavas画布尺寸更新\n    renderer.setSize(width, height);\n    // 2.1.更新相机参数\n    const k = width / height; //canvas画布宽高比\n    camera.left = -s*k;\n    camera.right = s*k;\n    // 2.2.相机的left, right, top, bottom属性变化了，通知threejs系统\n    camera.updateProjectionMatrix();\n};\n",normalizedContent:"# 正投影相机-canvas画布尺寸变化\n\n前面给大家讲解过(1.12、8.1两小节)，一些应用场景cnavas画布可能不是固定尺寸，而是变化的。这时候就需要重新设置webgl渲染器、相机等参数。\n\n前面给大家演示的时候，相机是用的透视投影，下面主要演示下，正投影相机的参数如何随着canvas画布尺寸的变化而变化。\n\n * 1.12.canvas画布尺寸变化\n\n * 8.1.three.js canvas画布布局\n\n\n# webgl渲染器更新canvas画布尺寸\n\n// onresize 事件会在窗口被调整大小时发生\nwindow.onresize = function () {\n    const width = window.innerwidth; //canvas画布宽度\n    const height = window.innerheight; //canvas画布高度\n    // 重置渲染器输出画布canvas尺寸\n    renderer.setsize(width, height);\n};\n\n\nwindow.onresize = function () {\n    const width = window.innerwidth-200; //canvas画布宽度\n    const height = window.innerheight-200; //canvas画布高度\n    // 重置渲染器输出画布canvas尺寸\n    renderer.setsize(window.innerwidth, window.innerheight);\n};\n\n\n\n# 相机参数更新\n\n.aspect属性受到canvas画布宽高度影响，当canvas画布尺寸发生变化的时候，需要更新透视投影相机perspectivecamera的.aspect属性。\n\nwindow.onresize = function () {\n    // width、height表示canvas画布宽高度\n    camera.aspect = width / height;\n    camera.updateprojectionmatrix();\n};\n\n\n你预览案例源码中正投影相机代码，可以看到，正投影相机orthographiccamera的left、 right属性受到canvas画布宽高比影响，所以需要随着canvas画布更新。\n\nconst k = width / height; //canvas画布宽高比\nconst s = 50; \n//控制left, right, top, bottom范围大小\nconst camera = new three.orthographiccamera(-s * k, s * k, s, -s, 1, 8000);\n\n\n// canvas画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerwidth; //canvas画布宽度\n    const height = window.innerheight; //canvas画布高度\n    // 1. webgl渲染器渲染的cnavas画布尺寸更新\n    renderer.setsize(width, height);\n    // 2.1.更新相机参数\n    const k = width / height; //canvas画布宽高比\n    camera.left = -s*k;\n    camera.right = s*k;\n    // 2.2.相机的left, right, top, bottom属性变化了，通知threejs系统\n    camera.updateprojectionmatrix();\n};\n",charsets:{cjk:!0}},{title:"3. 包围盒Box3",frontmatter:{title:"3. 包围盒Box3",date:"2023-02-11T10:28:59.000Z",permalink:"/pages/13d359/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/03.%E5%8C%85%E5%9B%B4%E7%9B%92Box3.html",relativePath:"01.Three.js教程/10.10.相机基础/03.包围盒Box3.md",key:"v-48577124",path:"/pages/13d359/",headers:[{level:3,title:"包围盒Box3",slug:"包围盒box3-2",normalizedTitle:"包围盒box3",charIndex:2},{level:3,title:"计算模型最小包围盒.expandByObject()",slug:"计算模型最小包围盒-expandbyobject",normalizedTitle:"计算模型最小包围盒.expandbyobject()",charIndex:452},{level:3,title:"包围盒尺寸.getSize()",slug:"包围盒尺寸-getsize",normalizedTitle:"包围盒尺寸.getsize()",charIndex:671},{level:3,title:"包围盒几何中心.getCenter()",slug:"包围盒几何中心-getcenter",normalizedTitle:"包围盒几何中心.getcenter()",charIndex:847}],headersStr:"包围盒Box3 计算模型最小包围盒.expandByObject() 包围盒尺寸.getSize() 包围盒几何中心.getCenter()",content:"# 包围盒Box3\n\n所谓包围盒Box3，就是一个长方体空间，把模型的所有顶点数据包围在一个最小的长方体空间中，这个最小长方体空间就是该模型的包围盒Box3。\n\n\n\n\n# 包围盒Box3\n\n包围盒Box3表示三维长方体包围区域，使用min和max两个属性来描述该包围区域，Box3的min和max属性值都是三维向量对象Vector3。\n\n描述一个长方体包围盒需要通过xyz坐标来表示，X范围[Xmin,Xmax],Y范围[Ymin,Ymax],Z范围[Zmin,Zmax],.min属性值是Vector3(Xmin, Ymin, Zmin),.max属性值是Vector3(Xmax, Ymax, Zmax).\n\nconst box3 = new THREE.Box3()\nconsole.log('box3',box3);\nbox3.min = new THREE.Vector3(-10, -10,0);\nbox3.max = new THREE.Vector3(100, 20,50);\n\n\n\n# 计算模型最小包围盒.expandByObject()\n\n模型对象，比如mesh或group，作为.expandByObject()的参数，可以计算该模型的包围盒。\n\nconst box3 = new THREE.Box3();\nbox3.expandByObject(mesh); // 计算模型包围盒\nconsole.log('查看包围盒',box3);\n\n\n浏览器控制台你可以通过.min和.max属性查看模型的包围盒信息。\n\n\n# 包围盒尺寸.getSize()\n\n返回包围盒具体的长宽高尺寸\n\nconst scale = new THREE.Vector3()\n// getSize()计算包围盒尺寸\n// 获得包围盒长宽高尺寸，结果保存在参数三维向量对象scale中\nbox3.getSize(scale)\nconsole.log('模型包围盒尺寸', scale);\n\n\n\n# 包围盒几何中心.getCenter()\n\nBox3方法.getCenter()计算返回包围盒几何中心\n\n// 计算包围盒中心坐标\nconst center = new THREE.Vector3()\nbox3.getCenter(center)\nconsole.log('模型中心坐标', center);\n",normalizedContent:"# 包围盒box3\n\n所谓包围盒box3，就是一个长方体空间，把模型的所有顶点数据包围在一个最小的长方体空间中，这个最小长方体空间就是该模型的包围盒box3。\n\n\n\n\n# 包围盒box3\n\n包围盒box3表示三维长方体包围区域，使用min和max两个属性来描述该包围区域，box3的min和max属性值都是三维向量对象vector3。\n\n描述一个长方体包围盒需要通过xyz坐标来表示，x范围[xmin,xmax],y范围[ymin,ymax],z范围[zmin,zmax],.min属性值是vector3(xmin, ymin, zmin),.max属性值是vector3(xmax, ymax, zmax).\n\nconst box3 = new three.box3()\nconsole.log('box3',box3);\nbox3.min = new three.vector3(-10, -10,0);\nbox3.max = new three.vector3(100, 20,50);\n\n\n\n# 计算模型最小包围盒.expandbyobject()\n\n模型对象，比如mesh或group，作为.expandbyobject()的参数，可以计算该模型的包围盒。\n\nconst box3 = new three.box3();\nbox3.expandbyobject(mesh); // 计算模型包围盒\nconsole.log('查看包围盒',box3);\n\n\n浏览器控制台你可以通过.min和.max属性查看模型的包围盒信息。\n\n\n# 包围盒尺寸.getsize()\n\n返回包围盒具体的长宽高尺寸\n\nconst scale = new three.vector3()\n// getsize()计算包围盒尺寸\n// 获得包围盒长宽高尺寸，结果保存在参数三维向量对象scale中\nbox3.getsize(scale)\nconsole.log('模型包围盒尺寸', scale);\n\n\n\n# 包围盒几何中心.getcenter()\n\nbox3方法.getcenter()计算返回包围盒几何中心\n\n// 计算包围盒中心坐标\nconst center = new three.vector3()\nbox3.getcenter(center)\nconsole.log('模型中心坐标', center);\n",charsets:{cjk:!0}},{title:"4. 地图案例(包围盒、正投影)",frontmatter:{title:"4. 地图案例(包围盒、正投影)",date:"2023-02-11T10:29:16.000Z",permalink:"/pages/747cf1/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/04.%E5%9C%B0%E5%9B%BE%E6%A1%88%E4%BE%8B(%E5%8C%85%E5%9B%B4%E7%9B%92%E3%80%81%E6%AD%A3%E6%8A%95%E5%BD%B1).html",relativePath:"01.Three.js教程/10.10.相机基础/04.地图案例(包围盒、正投影).md",key:"v-33f176a4",path:"/pages/747cf1/",headers:[{level:3,title:"地图案例(包围盒、正投影)",slug:"地图案例-包围盒、正投影",normalizedTitle:"地图案例(包围盒、正投影)",charIndex:2},{level:3,title:"ShapeGeometry渲染河南省地图轮廓",slug:"shapegeometry渲染河南省地图轮廓",normalizedTitle:"shapegeometry渲染河南省地图轮廓",charIndex:113},{level:3,title:"选择相机",slug:"选择相机",normalizedTitle:"选择相机",charIndex:605},{level:3,title:"包围盒Box3计算模型的中心位置和尺寸",slug:"包围盒box3计算模型的中心位置和尺寸",normalizedTitle:"包围盒box3计算模型的中心位置和尺寸",charIndex:1087},{level:3,title:"地图居中显示",slug:"地图居中显示",normalizedTitle:"地图居中显示",charIndex:1426},{level:3,title:"地图基本填充cnavas画布",slug:"地图基本填充cnavas画布",normalizedTitle:"地图基本填充cnavas画布",charIndex:1750},{level:3,title:"地图平行于canvas画布",slug:"地图平行于canvas画布",normalizedTitle:"地图平行于canvas画布",charIndex:2007}],headersStr:"地图案例(包围盒、正投影) ShapeGeometry渲染河南省地图轮廓 选择相机 包围盒Box3计算模型的中心位置和尺寸 地图居中显示 地图基本填充cnavas画布 地图平行于canvas画布",content:"# 地图案例(包围盒、正投影)\n\n地图案例会涉及到几何体、包围盒、正投影相机三方面知识点。\n\n * 平面填充几何体ShapeGeometry\n * 包围盒Box3\n * 正投影相机OrthographicCamera\n\n\n# ShapeGeometry渲染河南省地图轮廓\n\n\n\nconst data = [// 河南边界轮廓边界经纬度坐标\n  [110.3906, 34.585],\n  [110.8301, 34.6289],\n  ...\n  ...\n  [111.7969, 35.0684]\n]\nconst pointsArr = [];// 一组二维向量表示一个多边形轮廓坐标\ndata.forEach(function(e){\n    // data坐标数据转化为Vector2构成的顶点数组\n    const v2 = new THREE.Vector2(e[0],e[1])\n    pointsArr.push(v2);\n})\n// Shape表示一个平面多边形轮廓,参数是二维向量构成的数组pointsArr\nconst shape = new THREE.Shape(pointsArr);\n// 多边形shape轮廓作为ShapeGeometry参数，生成一个多边形平面几何体\nconst geometry = new THREE.ShapeGeometry(shape);\n\n\n\n# 选择相机\n\n地图案例可以不使用透视投影相机模拟人眼的透视观察效果，选择正投影相机即可。\n\n// 正投影相机\nconst width = window.innerWidth; //canvas画布宽度\nconst height = window.innerHeight; //canvas画布高度\nconst k = width / height; //canvas画布宽高比\nconst s = 50; //控制left, right, top, bottom范围大小\nconst camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 8000);\ncamera.position.set(300, 300, 300); \ncamera.lookAt(0, 0, 0); //指向坐标原点\n\n\n使用上面相机参数，默认情况下，你运行案例源码，可以看到河南地图并没有居中显示，在canvas画布上显示的效果也比较小。\n\n如果你想地图全屏最大化居中显示，可以通过包围盒来辅助设置计算参数。\n\n\n# 包围盒Box3计算模型的中心位置和尺寸\n\n包围盒Box3计算模型的中心位置和尺寸。\n\n// 包围盒计算模型对象的大小和位置\nconst box3 = new THREE.Box3();\nbox3.expandByObject(mesh); // 计算模型包围盒\nconst size = new THREE.Vector3();\nbox3.getSize(size); // 计算包围盒尺寸\n// console.log('模型包围盒尺寸',size);\nconst center = new THREE.Vector3();\nbox3.getCenter(center); // 计算包围盒中心坐标\n// console.log('模型中心坐标',center);\n\n\n\n# 地图居中显示\n\n设置相机.lookAt()参数指向包围盒几何中心即可。\n\nconst x = 113.51,y = 33.88;\ncamera.lookAt(x, y, 0);\n\n\n注意如果使用了OrbitControls，需要设置.target和.lookAt()参数是相同坐标。\n\nconst controls = new OrbitControls(camera, renderer.domElement);\ncontrols.target.set(x, y, 0); //与lookAt参数保持一致\ncontrols.update();//update()函数内会执行camera.lookAt(controls.target)\n\n\n\n# 地图基本填充cnavas画布\n\n地图显示效果更大，尽量使地图基本填充整个canvas画布。\n\n把正投影相机控制上下左右的变量s，设置为地图模型整体尺寸的一半左右即可。\n\n// const s = 50; //控制left, right, top, bottom范围大小\nconst s = 2.5;//根据包围盒大小调整s，包围盒y方向尺寸的一半左右\nconst camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 8000);\n\n\n\n# 地图平行于canvas画布\n\n把相机的位置和观察目标的xy坐标设置为一样，这样相机的视线方向就垂直地图平面，这样地图就平行于canvas画布，或者说平行于显示器屏幕。\n\nconst x = 113.51,y = 33.88;\n//与观察点x、y一样，地图平行与canvas画布\ncamera.position.set(x, y, 300);\ncamera.lookAt(x, y, 0);\n",normalizedContent:"# 地图案例(包围盒、正投影)\n\n地图案例会涉及到几何体、包围盒、正投影相机三方面知识点。\n\n * 平面填充几何体shapegeometry\n * 包围盒box3\n * 正投影相机orthographiccamera\n\n\n# shapegeometry渲染河南省地图轮廓\n\n\n\nconst data = [// 河南边界轮廓边界经纬度坐标\n  [110.3906, 34.585],\n  [110.8301, 34.6289],\n  ...\n  ...\n  [111.7969, 35.0684]\n]\nconst pointsarr = [];// 一组二维向量表示一个多边形轮廓坐标\ndata.foreach(function(e){\n    // data坐标数据转化为vector2构成的顶点数组\n    const v2 = new three.vector2(e[0],e[1])\n    pointsarr.push(v2);\n})\n// shape表示一个平面多边形轮廓,参数是二维向量构成的数组pointsarr\nconst shape = new three.shape(pointsarr);\n// 多边形shape轮廓作为shapegeometry参数，生成一个多边形平面几何体\nconst geometry = new three.shapegeometry(shape);\n\n\n\n# 选择相机\n\n地图案例可以不使用透视投影相机模拟人眼的透视观察效果，选择正投影相机即可。\n\n// 正投影相机\nconst width = window.innerwidth; //canvas画布宽度\nconst height = window.innerheight; //canvas画布高度\nconst k = width / height; //canvas画布宽高比\nconst s = 50; //控制left, right, top, bottom范围大小\nconst camera = new three.orthographiccamera(-s * k, s * k, s, -s, 1, 8000);\ncamera.position.set(300, 300, 300); \ncamera.lookat(0, 0, 0); //指向坐标原点\n\n\n使用上面相机参数，默认情况下，你运行案例源码，可以看到河南地图并没有居中显示，在canvas画布上显示的效果也比较小。\n\n如果你想地图全屏最大化居中显示，可以通过包围盒来辅助设置计算参数。\n\n\n# 包围盒box3计算模型的中心位置和尺寸\n\n包围盒box3计算模型的中心位置和尺寸。\n\n// 包围盒计算模型对象的大小和位置\nconst box3 = new three.box3();\nbox3.expandbyobject(mesh); // 计算模型包围盒\nconst size = new three.vector3();\nbox3.getsize(size); // 计算包围盒尺寸\n// console.log('模型包围盒尺寸',size);\nconst center = new three.vector3();\nbox3.getcenter(center); // 计算包围盒中心坐标\n// console.log('模型中心坐标',center);\n\n\n\n# 地图居中显示\n\n设置相机.lookat()参数指向包围盒几何中心即可。\n\nconst x = 113.51,y = 33.88;\ncamera.lookat(x, y, 0);\n\n\n注意如果使用了orbitcontrols，需要设置.target和.lookat()参数是相同坐标。\n\nconst controls = new orbitcontrols(camera, renderer.domelement);\ncontrols.target.set(x, y, 0); //与lookat参数保持一致\ncontrols.update();//update()函数内会执行camera.lookat(controls.target)\n\n\n\n# 地图基本填充cnavas画布\n\n地图显示效果更大，尽量使地图基本填充整个canvas画布。\n\n把正投影相机控制上下左右的变量s，设置为地图模型整体尺寸的一半左右即可。\n\n// const s = 50; //控制left, right, top, bottom范围大小\nconst s = 2.5;//根据包围盒大小调整s，包围盒y方向尺寸的一半左右\nconst camera = new three.orthographiccamera(-s * k, s * k, s, -s, 1, 8000);\n\n\n\n# 地图平行于canvas画布\n\n把相机的位置和观察目标的xy坐标设置为一样，这样相机的视线方向就垂直地图平面，这样地图就平行于canvas画布，或者说平行于显示器屏幕。\n\nconst x = 113.51,y = 33.88;\n//与观察点x、y一样，地图平行与canvas画布\ncamera.position.set(x, y, 300);\ncamera.lookat(x, y, 0);\n",charsets:{cjk:!0}},{title:"5. 相机动画(.position和.lookAt())",frontmatter:{title:"5. 相机动画(.position和.lookAt())",date:"2023-02-11T10:29:45.000Z",permalink:"/pages/ca57bd/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/05.%E7%9B%B8%E6%9C%BA%E5%8A%A8%E7%94%BB(%20.position%20%E5%92%8C%20.lookAt()%20).html",relativePath:"01.Three.js教程/10.10.相机基础/05.相机动画( .position 和 .lookAt() ).md",key:"v-6d7a8eb7",path:"/pages/ca57bd/",headers:[{level:3,title:"相机运动动画",slug:"相机运动动画",normalizedTitle:"相机运动动画",charIndex:88},{level:3,title:"相机圆周运动",slug:"相机圆周运动",normalizedTitle:"相机圆周运动",charIndex:398},{level:3,title:"执行lookAt()计算相机视线方向",slug:"执行lookat-计算相机视线方向",normalizedTitle:"执行lookat()计算相机视线方向",charIndex:748}],headersStr:"相机运动动画 相机圆周运动 执行lookAt()计算相机视线方向",content:"# 相机动画(.position和.lookAt())\n\n下面给大家讲解，通过相机对象Camera的.position属性和.lookAt()方法，实现一段相机动画。\n\n\n# 相机运动动画\n\n改变相机的位置.position，三维场景在canvas画布上呈现不同的效果，如果连续改变相机的位置.position，就可以获得一个动画效果。\n\n课件案例源码是一个工厂模型，相机在空中俯视工厂，如果在渲染循环中不停地改变相机位置，这时候产生的视觉效果，就好比你在天上运动，看地面的效果。\n\n// 渲染循环\nfunction render() {\n    camera.position.z -= 0.3;//相机直线运动动画\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 相机圆周运动\n\n在渲染循环中，改变相机位置，在XOZ平面上绕着y轴圆周运动。\n\n// 渲染循环\nlet angle = 0; //用于圆周运动计算的角度值\nconst R = 100; //相机圆周运动的半径\nfunction render() {\n    angle += 0.01;\n    // 相机y坐标不变，在XOZ平面上做圆周运动\n    camera.position.x = R * Math.cos(angle);\n    camera.position.z = R * Math.sin(angle);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 执行lookAt()计算相机视线方向\n\n改变.position属性后，如果不执行.lookAt()方法，相机的观察方向默认不变。\n\n如果你希望相机圆周运动的同时，改变相机视线方向，保持相机镜头始终指向坐标原点或其它位置，需要每次改变.position属性后，重新执行一遍.lookAt()方法\n\nfunction render() {\n    angle += 0.01;\n    camera.position.x = R * Math.cos(angle);\n    camera.position.z = R * Math.sin(angle);\n    // .position改变，重新执行lookAt(0,0,0)计算相机视线方向\n    camera.lookAt(0,0,0);\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# 相机动画(.position和.lookat())\n\n下面给大家讲解，通过相机对象camera的.position属性和.lookat()方法，实现一段相机动画。\n\n\n# 相机运动动画\n\n改变相机的位置.position，三维场景在canvas画布上呈现不同的效果，如果连续改变相机的位置.position，就可以获得一个动画效果。\n\n课件案例源码是一个工厂模型，相机在空中俯视工厂，如果在渲染循环中不停地改变相机位置，这时候产生的视觉效果，就好比你在天上运动，看地面的效果。\n\n// 渲染循环\nfunction render() {\n    camera.position.z -= 0.3;//相机直线运动动画\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 相机圆周运动\n\n在渲染循环中，改变相机位置，在xoz平面上绕着y轴圆周运动。\n\n// 渲染循环\nlet angle = 0; //用于圆周运动计算的角度值\nconst r = 100; //相机圆周运动的半径\nfunction render() {\n    angle += 0.01;\n    // 相机y坐标不变，在xoz平面上做圆周运动\n    camera.position.x = r * math.cos(angle);\n    camera.position.z = r * math.sin(angle);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 执行lookat()计算相机视线方向\n\n改变.position属性后，如果不执行.lookat()方法，相机的观察方向默认不变。\n\n如果你希望相机圆周运动的同时，改变相机视线方向，保持相机镜头始终指向坐标原点或其它位置，需要每次改变.position属性后，重新执行一遍.lookat()方法\n\nfunction render() {\n    angle += 0.01;\n    camera.position.x = r * math.cos(angle);\n    camera.position.z = r * math.sin(angle);\n    // .position改变，重新执行lookat(0,0,0)计算相机视线方向\n    camera.lookat(0,0,0);\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"6. 不同方向的投影视图",frontmatter:{title:"6. 不同方向的投影视图",date:"2023-02-11T10:29:55.000Z",permalink:"/pages/3153bf/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/06.%E4%B8%8D%E5%90%8C%E6%96%B9%E5%90%91%E7%9A%84%E6%8A%95%E5%BD%B1%E8%A7%86%E5%9B%BE.html",relativePath:"01.Three.js教程/10.10.相机基础/06.不同方向的投影视图.md",key:"v-18a3e02e",path:"/pages/3153bf/",headers:[{level:3,title:"x轴方向观察",slug:"x轴方向观察",normalizedTitle:"x轴方向观察",charIndex:56},{level:3,title:"y轴方向观察",slug:"y轴方向观察",normalizedTitle:"y轴方向观察",charIndex:245},{level:3,title:"z轴方向观察",slug:"z轴方向观察",normalizedTitle:"z轴方向观察",charIndex:434}],headersStr:"x轴方向观察 y轴方向观察 z轴方向观察",content:"# 相机不同方向的投影视图\n\n本节课给大家讲解，通过UI按钮界面交互改变threejs相机的观察视角。\n\n\n# x轴方向观察\n\n// 通过UI按钮改变相机观察角度\ndocument.getElementById('x').addEventListener('click', function () {\n    camera.position.set(500, 0, 0); //x轴方向观察\n    camera.lookAt(0, 0, 0); //重新计算相机视线方向\n})\n\n\n\n# y轴方向观察\n\n// 通过UI按钮改变相机观察角度\ndocument.getElementById('y').addEventListener('click', function () {\n    camera.position.set(0, 500, 0); //y轴方向观察\n    camera.lookAt(0, 0, 0); //重新计算相机视线方向\n})\n\n\n\n# z轴方向观察\n\n// 通过UI按钮改变相机观察角度\ndocument.getElementById('z').addEventListener('click', function () {\n    camera.position.set(0, 0, 500); //z轴方向观察\n    camera.lookAt(0, 0, 0); //重新计算相机视线方向\n})\n",normalizedContent:"# 相机不同方向的投影视图\n\n本节课给大家讲解，通过ui按钮界面交互改变threejs相机的观察视角。\n\n\n# x轴方向观察\n\n// 通过ui按钮改变相机观察角度\ndocument.getelementbyid('x').addeventlistener('click', function () {\n    camera.position.set(500, 0, 0); //x轴方向观察\n    camera.lookat(0, 0, 0); //重新计算相机视线方向\n})\n\n\n\n# y轴方向观察\n\n// 通过ui按钮改变相机观察角度\ndocument.getelementbyid('y').addeventlistener('click', function () {\n    camera.position.set(0, 500, 0); //y轴方向观察\n    camera.lookat(0, 0, 0); //重新计算相机视线方向\n})\n\n\n\n# z轴方向观察\n\n// 通过ui按钮改变相机观察角度\ndocument.getelementbyid('z').addeventlistener('click', function () {\n    camera.position.set(0, 0, 500); //z轴方向观察\n    camera.lookat(0, 0, 0); //重新计算相机视线方向\n})\n",charsets:{cjk:!0}},{title:"7. 旋转渲染结果(.up相机上方向)",frontmatter:{title:"7. 旋转渲染结果(.up相机上方向)",date:"2023-02-11T10:30:24.000Z",permalink:"/pages/3bcff1/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/07.%E6%97%8B%E8%BD%AC%E6%B8%B2%E6%9F%93%E7%BB%93%E6%9E%9C(.up%E7%9B%B8%E6%9C%BA%E4%B8%8A%E6%96%B9%E5%90%91).html",relativePath:"01.Three.js教程/10.10.相机基础/07.旋转渲染结果(.up相机上方向).md",key:"v-0732c0e2",path:"/pages/3bcff1/",headers:[{level:3,title:"测试改变上方向.up",slug:"测试改变上方向-up",normalizedTitle:"测试改变上方向.up",charIndex:178},{level:3,title:"注意执行顺序问题",slug:"注意执行顺序问题",normalizedTitle:"注意执行顺序问题",charIndex:516}],headersStr:"测试改变上方向.up 注意执行顺序问题",content:"# .up相机上方向(旋转渲染结果)\n\n.up是相机对象的上方向属性，当你改变.up属性时候，就好比你生活中拍照时候，扭转你的相机姿态角度进行拍照，这时候你的照片也会跟着相机姿态旋转。\n\n.up属性默认值是new THREE.Vector3(0,1,0),意思是沿着y轴朝上。\n\nconsole.log('.up默认值',camera.up);\n\n\n\n# 测试改变上方向.up\n\n你可以改变相机的上方向.up属性值，然后观察canvas画布上模型渲染的效果有什么变化，还可以观察三维坐标轴new THREE.AxesHelper()的变化。\n\n把相机对象.up属性默认值new THREE.Vector3(0,1,0)改为相反方向new THREE.Vector3(0,-1,0)，沿着y轴负方向，up改变后的渲染效果你可以看到，绿色y轴向下，与原来方向相反。\n\n// 你可以看到模型相比原来上下颠倒  y坐标轴朝下\ncamera.up.set(0,-1,0)\n\n\n//渲染效果：红色x轴向上\ncamera.up.set(1, 0, 0);\n\n\n//渲染效果：蓝色z轴向上\ncamera.up.set(0, 0, 1);\n\n\n\n# 注意执行顺序问题\n\n注意.up属性和.position属性一样，如果在.lookAt()执行之后改变,需要重新执行.lookAt()。\n\ncamera.lookAt(0,0,0);\ncamera.up.set(0, 0, 1);//改变up\ncamera.lookAt(0,0,0);//执行lookAt重新计算相机姿态\n",normalizedContent:"# .up相机上方向(旋转渲染结果)\n\n.up是相机对象的上方向属性，当你改变.up属性时候，就好比你生活中拍照时候，扭转你的相机姿态角度进行拍照，这时候你的照片也会跟着相机姿态旋转。\n\n.up属性默认值是new three.vector3(0,1,0),意思是沿着y轴朝上。\n\nconsole.log('.up默认值',camera.up);\n\n\n\n# 测试改变上方向.up\n\n你可以改变相机的上方向.up属性值，然后观察canvas画布上模型渲染的效果有什么变化，还可以观察三维坐标轴new three.axeshelper()的变化。\n\n把相机对象.up属性默认值new three.vector3(0,1,0)改为相反方向new three.vector3(0,-1,0)，沿着y轴负方向，up改变后的渲染效果你可以看到，绿色y轴向下，与原来方向相反。\n\n// 你可以看到模型相比原来上下颠倒  y坐标轴朝下\ncamera.up.set(0,-1,0)\n\n\n//渲染效果：红色x轴向上\ncamera.up.set(1, 0, 0);\n\n\n//渲染效果：蓝色z轴向上\ncamera.up.set(0, 0, 1);\n\n\n\n# 注意执行顺序问题\n\n注意.up属性和.position属性一样，如果在.lookat()执行之后改变,需要重新执行.lookat()。\n\ncamera.lookat(0,0,0);\ncamera.up.set(0, 0, 1);//改变up\ncamera.lookat(0,0,0);//执行lookat重新计算相机姿态\n",charsets:{cjk:!0}},{title:"8. 管道漫游案例",frontmatter:{title:"8. 管道漫游案例",date:"2023-02-11T22:11:27.000Z",permalink:"/pages/188907/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/08.%E7%AE%A1%E9%81%93%E6%BC%AB%E6%B8%B8%E6%A1%88%E4%BE%8B.html",relativePath:"01.Three.js教程/10.10.相机基础/08.管道漫游案例.md",key:"v-8afc710a",path:"/pages/188907/",headers:[{level:3,title:"管道模型",slug:"管道模型",normalizedTitle:"管道模型",charIndex:146},{level:3,title:"相机选择",slug:"相机选择",normalizedTitle:"相机选择",charIndex:975},{level:3,title:"获得运动轨迹上的顶点",slug:"获得运动轨迹上的顶点",normalizedTitle:"获得运动轨迹上的顶点",charIndex:1022},{level:3,title:"相机放在管道内轨迹线上",slug:"相机放在管道内轨迹线上",normalizedTitle:"相机放在管道内轨迹线上",charIndex:1176},{level:3,title:"改变视场角度fov调节渲染效果",slug:"改变视场角度fov调节渲染效果",normalizedTitle:"改变视场角度fov调节渲染效果",charIndex:1626},{level:3,title:"相机控件.target和.lookAt()参数一致",slug:"相机控件-target和-lookat-参数一致",normalizedTitle:"相机控件.target和.lookat()参数一致",charIndex:1847},{level:3,title:"相机动画完整代码",slug:"相机动画完整代码",normalizedTitle:"相机动画完整代码",charIndex:2045},{level:3,title:"渲染方式",slug:"渲染方式",normalizedTitle:"渲染方式",charIndex:2564}],headersStr:"管道模型 相机选择 获得运动轨迹上的顶点 相机放在管道内轨迹线上 改变视场角度fov调节渲染效果 相机控件.target和.lookAt()参数一致 相机动画完整代码 渲染方式",content:"# 管道漫游案例\n\n通过一个轨迹线生成一个管道几何体，然后相机沿着该轨迹线移动，注意相机的方向要沿着轨迹线的切线方向，这样会形成一个管道漫游的效果。\n\n * 管道几何体TubeGeometry、纹理贴图\n * 相机对象Camera的.position属性和.lookAt()方法\n\n\n\n\n# 管道模型\n\n课件源码“演示”文件中提前给大家提供了一个管道模型，大家可以在此基础上写代码，生成相机在管道内漫游移动的动画。\n\n你可以尝试自己利用前面学习过的知识，创建这样一个管道模型，再学习下面相机动画的讲解。\n\n// 三维样条曲线\nconst path = new THREE.CatmullRomCurve3([\n    new THREE.Vector3(-50, 20, 90),\n    new THREE.Vector3(-10, 40, 40),\n    new THREE.Vector3(0, 0, 0),\n    new THREE.Vector3(60, -60, 0),\n    new THREE.Vector3(90, -40, 60),\n    new THREE.Vector3(120, 30, 30),\n]);\n// 样条曲线path作为TubeGeometry参数生成管道\nconst geometry = new THREE.TubeGeometry(path, 200, 5, 30);\nconst texLoader = new THREE.TextureLoader(); \n//纹理贴图\nconst texture = texLoader.load('./diffuse.jpg');\n//UV坐标U方向阵列模式\ntexture.wrapS = THREE.RepeatWrapping;\n//纹理沿着管道方向阵列(UV坐标U方向)\ntexture.repeat.x = 10;\nconst material = new THREE.MeshLambertMaterial({\n    map:texture,\n    side: THREE.DoubleSide, //双面显示看到管道内壁\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n\n# 相机选择\n\n为了模拟人眼观察世界的规律，管道漫游选择透视投影相机，而不是正投影相机。\n\n\n# 获得运动轨迹上的顶点\n\n通过曲线的.getSpacedPoints()方法可以从轨迹线上均匀的获得一系列顶点坐标数据，然后你可以用这些轨迹线上顶点坐标设置相机位置。\n\n// 从曲线上等间距获取一定数量点坐标\nconst pointsArr = path.getSpacedPoints(500);\n\n\n\n# 相机放在管道内轨迹线上\n\n相机放在管道内轨迹线上任意一个位置,并控制相机视线和曲线切线重合。\n\n * 曲线当前点pointsArr[i]\n * 曲线下一个点pointsArr[i + 1]\n\n曲线上当前点pointsArr[i]和下一个点pointsArr[i+1]近似模拟当前点曲线切线，两点间距越小，模拟精度越高。\n\n.lookAt()设置相机观察点为当前点pointsArr[i]的下一个点pointsArr[i + 1]，使相机视线和曲线上当前点切线重合。\n\n// 从曲线上等间距获取一定数量点坐标\nconst pointsArr = path.getSpacedPoints(500);\nconst i = 100;\n// 相机位置：曲线上当前点pointsArr[i]\ncamera.position.copy(pointsArr[i]);\n// 相机观察目标：当前点的下一个点pointsArr[i + 1]\ncamera.lookAt(pointsArr[i + 1]);\n\n\n\n# 改变视场角度fov调节渲染效果\n\n你可以比较相机视锥体不同视场角度fov对应的视觉效果。\n\n// fov:90度\nconst camera = new THREE.PerspectiveCamera(90, width / height, 1, 3000);\n\n\n// fov:30度\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\n\n\n\n# 相机控件.target和.lookAt()参数一致\n\n相机控件.target和.lookAt()参数同步，这样你可以旋转相机观察管道内部。\n\nconst controls = new OrbitControls(camera, renderer.domElement);\ncontrols.target.copy(pointsArr[i+1]);\ncontrols.update();\n\n\n\n# 相机动画完整代码\n\n// 从曲线上等间距获取一定数量点坐标\nconst pointsArr = path.getSpacedPoints(500);\n// 渲染循环\nlet i = 0; //在渲染循环中累加变化\nfunction render() {\n    if (i < pointsArr.length - 1) {\n        // 相机位置设置在当前点位置\n        camera.position.copy(pointsArr[i]);\n        // 曲线上当前点pointsArr[i]和下一个点pointsArr[i+1]近似模拟当前点曲线切线\n        // 设置相机观察点为当前点的下一个点，相机视线和当前点曲线切线重合\n        camera.lookAt(pointsArr[i + 1]);\n        i += 1; //调节速度\n    } else {\n        i = 0\n    }\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 渲染方式\n\n可以使用点模型Points渲染，也可以使用网格模型Mesh渲染。 使用网格的话可以实现一个相机在管道内部漫游的效果，使用点模式渲染，可以看到一个虫洞特效，当然你也可以从管道几何体获得顶点数据来设置精灵的位置，多少个顶点，多少个精灵模型对象，也可以实现一个虫洞效果。",normalizedContent:"# 管道漫游案例\n\n通过一个轨迹线生成一个管道几何体，然后相机沿着该轨迹线移动，注意相机的方向要沿着轨迹线的切线方向，这样会形成一个管道漫游的效果。\n\n * 管道几何体tubegeometry、纹理贴图\n * 相机对象camera的.position属性和.lookat()方法\n\n\n\n\n# 管道模型\n\n课件源码“演示”文件中提前给大家提供了一个管道模型，大家可以在此基础上写代码，生成相机在管道内漫游移动的动画。\n\n你可以尝试自己利用前面学习过的知识，创建这样一个管道模型，再学习下面相机动画的讲解。\n\n// 三维样条曲线\nconst path = new three.catmullromcurve3([\n    new three.vector3(-50, 20, 90),\n    new three.vector3(-10, 40, 40),\n    new three.vector3(0, 0, 0),\n    new three.vector3(60, -60, 0),\n    new three.vector3(90, -40, 60),\n    new three.vector3(120, 30, 30),\n]);\n// 样条曲线path作为tubegeometry参数生成管道\nconst geometry = new three.tubegeometry(path, 200, 5, 30);\nconst texloader = new three.textureloader(); \n//纹理贴图\nconst texture = texloader.load('./diffuse.jpg');\n//uv坐标u方向阵列模式\ntexture.wraps = three.repeatwrapping;\n//纹理沿着管道方向阵列(uv坐标u方向)\ntexture.repeat.x = 10;\nconst material = new three.meshlambertmaterial({\n    map:texture,\n    side: three.doubleside, //双面显示看到管道内壁\n});\nconst mesh = new three.mesh(geometry, material);\n\n\n\n# 相机选择\n\n为了模拟人眼观察世界的规律，管道漫游选择透视投影相机，而不是正投影相机。\n\n\n# 获得运动轨迹上的顶点\n\n通过曲线的.getspacedpoints()方法可以从轨迹线上均匀的获得一系列顶点坐标数据，然后你可以用这些轨迹线上顶点坐标设置相机位置。\n\n// 从曲线上等间距获取一定数量点坐标\nconst pointsarr = path.getspacedpoints(500);\n\n\n\n# 相机放在管道内轨迹线上\n\n相机放在管道内轨迹线上任意一个位置,并控制相机视线和曲线切线重合。\n\n * 曲线当前点pointsarr[i]\n * 曲线下一个点pointsarr[i + 1]\n\n曲线上当前点pointsarr[i]和下一个点pointsarr[i+1]近似模拟当前点曲线切线，两点间距越小，模拟精度越高。\n\n.lookat()设置相机观察点为当前点pointsarr[i]的下一个点pointsarr[i + 1]，使相机视线和曲线上当前点切线重合。\n\n// 从曲线上等间距获取一定数量点坐标\nconst pointsarr = path.getspacedpoints(500);\nconst i = 100;\n// 相机位置：曲线上当前点pointsarr[i]\ncamera.position.copy(pointsarr[i]);\n// 相机观察目标：当前点的下一个点pointsarr[i + 1]\ncamera.lookat(pointsarr[i + 1]);\n\n\n\n# 改变视场角度fov调节渲染效果\n\n你可以比较相机视锥体不同视场角度fov对应的视觉效果。\n\n// fov:90度\nconst camera = new three.perspectivecamera(90, width / height, 1, 3000);\n\n\n// fov:30度\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\n\n\n\n# 相机控件.target和.lookat()参数一致\n\n相机控件.target和.lookat()参数同步，这样你可以旋转相机观察管道内部。\n\nconst controls = new orbitcontrols(camera, renderer.domelement);\ncontrols.target.copy(pointsarr[i+1]);\ncontrols.update();\n\n\n\n# 相机动画完整代码\n\n// 从曲线上等间距获取一定数量点坐标\nconst pointsarr = path.getspacedpoints(500);\n// 渲染循环\nlet i = 0; //在渲染循环中累加变化\nfunction render() {\n    if (i < pointsarr.length - 1) {\n        // 相机位置设置在当前点位置\n        camera.position.copy(pointsarr[i]);\n        // 曲线上当前点pointsarr[i]和下一个点pointsarr[i+1]近似模拟当前点曲线切线\n        // 设置相机观察点为当前点的下一个点，相机视线和当前点曲线切线重合\n        camera.lookat(pointsarr[i + 1]);\n        i += 1; //调节速度\n    } else {\n        i = 0\n    }\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 渲染方式\n\n可以使用点模型points渲染，也可以使用网格模型mesh渲染。 使用网格的话可以实现一个相机在管道内部漫游的效果，使用点模式渲染，可以看到一个虫洞特效，当然你也可以从管道几何体获得顶点数据来设置精灵的位置，多少个顶点，多少个精灵模型对象，也可以实现一个虫洞效果。",charsets:{cjk:!0}},{title:"9. OrbitControls旋转缩放限制",frontmatter:{title:"9. OrbitControls旋转缩放限制",date:"2023-02-11T22:11:51.000Z",permalink:"/pages/17b6dc/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/09.OrbitControls%E6%97%8B%E8%BD%AC%E7%BC%A9%E6%94%BE%E9%99%90%E5%88%B6.html",relativePath:"01.Three.js教程/10.10.相机基础/09.OrbitControls旋转缩放限制.md",key:"v-0ab635d8",path:"/pages/17b6dc/",headers:[{level:3,title:"禁止右键平移.enablePan属性",slug:"禁止右键平移-enablepan属性",normalizedTitle:"禁止右键平移.enablepan属性",charIndex:164},{level:3,title:"禁止缩放或旋转",slug:"禁止缩放或旋转",normalizedTitle:"禁止缩放或旋转",charIndex:343},{level:3,title:"OrbitControls.target属性",slug:"orbitcontrols-target属性",normalizedTitle:"orbitcontrols.target属性",charIndex:546},{level:3,title:"透视投影相机缩放范围",slug:"透视投影相机缩放范围",normalizedTitle:"透视投影相机缩放范围",charIndex:804},{level:3,title:"正投影缩放范围",slug:"正投影缩放范围",normalizedTitle:"正投影缩放范围",charIndex:1237},{level:3,title:"相机位置与目标观察点距离.getDistance()",slug:"相机位置与目标观察点距离-getdistance",normalizedTitle:"相机位置与目标观察点距离.getdistance()",charIndex:1378},{level:3,title:"可视化设置相机缩放范围",slug:"可视化设置相机缩放范围",normalizedTitle:"可视化设置相机缩放范围",charIndex:1556},{level:3,title:"设置旋转范围",slug:"设置旋转范围",normalizedTitle:"设置旋转范围",charIndex:1905}],headersStr:"禁止右键平移.enablePan属性 禁止缩放或旋转 OrbitControls.target属性 透视投影相机缩放范围 正投影缩放范围 相机位置与目标观察点距离.getDistance() 可视化设置相机缩放范围 设置旋转范围",content:"# OrbitControls旋转缩放限制\n\n课程中经常会用到相机控件OrbitControls的不同功能,本节课就会大家补充新的知识点，比如控制缩放的最大最小范围，比如限制旋转的角度范围，比如禁止平移。\n\n * 1.9. 相机控件OrbitControls\n * 6.4. OrbitControls辅助设置相机参数\n\n\n# 禁止右键平移.enablePan属性\n\n比如一个展示一个三维场景，你不希望鼠标右键拖动会产生一个平移效果。可以通过设置相机空间对象OrbitControls的.enablePan属性，查看OrbitControls源码可以看到.enablePan属性的默认值是true。\n\ncontrols.enablePan = false; //禁止右键拖拽\n\n\n\n# 禁止缩放或旋转\n\n通过.enableZoom属性可以控制是否允许鼠标中键缩放场景，.enableZoom属性默认值true。\n\ncontrols.enableZoom = false;//禁止缩放\n\n\n通过.enableRotate属性可以控制是否允许鼠标左键旋转场景，.enableRotate属性默认值true。\n\ncontrols.enableRotate = false; //禁止旋转\n\n\n\n# OrbitControls.target属性\n\n相机控件OrbitControls.target属性对应的就是相机的.lookAt()观察目标。\n\n执行controls.update();,相机控件内部会执行camera.lookAt(controls.target)。\n\n// controls.target默认值是坐标原点\ncontrols.target.set(x, y, z);\n//update()函数内会执行camera.lookAt(x, y, z)\ncontrols.update(); \n\n\n\n# 透视投影相机缩放范围\n\n在实际应用中，透视投影相机的规则是远小近大，相机距离目标观察点距离越远，目标模型显示越小，距离越近显示越大\n\n前面给大家讲解过，对于透视投影相机而言，OrbitControls缩放，本质上就是改变相机的位置属性.position。\n\n这就是说如果你想控制缩放范围，就是约束相机位置.position的变化范围，OrbitControls提供了两个属性.minDistance和.maxDistance可以帮助你实现。\n\n.minDistance表示相机位置.position和相机目标观察点controls.target的最小距离。\n\n//相机位置与观察目标点最小值\ncontrols.minDistance = 200;\n\n\n.maxDistance表示相机位置.position和相机目标观察点controls.target的最大距离。\n\n//相机位置与观察目标点最大值\ncontrols.maxDistance = 500;\n\n\n\n# 正投影缩放范围\n\n对于正投影相机对象OrthographicCamera，可以通过相机控件OrbitControls的.minZoom和.maxZoom属性实现\n\n// 缩放范围\ncontrols.minZoom = 0.5;\ncontrols.maxZoom = 2;\n\n\n\n# 相机位置与目标观察点距离.getDistance()\n\ncontrols.getDistance()可以计算出来相机位置.position和相机目标观察点controls.target的距离。\n\n//相机位置与目标观察点距离\nconst dis = controls.getDistance();\nconsole.log('dis',dis);\n\n\n\n# 可视化设置相机缩放范围\n\n如果你直接凭感觉设置minDistance和maxDistance，不太好把握具体范围，这时候通过.getDistance()辅助解决。\n\n在canvas画布上，你用鼠标缩放三维场景，这时候会改变透视投影相机位置，那么相机与目标观察点的距离也会改变，这时候可以通过.getDistance()计算出来此刻相机与目标观察点的距离，用于设置minDistance和maxDistance。\n\ncontrols.addEventListener('change',function(){\n    //相机位置与目标观察点距离\n    const dis = controls.getDistance();\n    console.log('dis',dis);\n})\n\n\n\n# 设置旋转范围\n\n展示一个三维场景，你想控制360度旋转范围，比如一个工厂，你不希望用户看到工厂的底部，你可以通过设置相机的旋转范围属性来实现。\n\n通过.minPolarAngle和.maxPolarAngle属性控制上下的旋转范围，默认从0到180度，默认情况下0度，XOZ平面平行canvas画布，y轴垂直指向屏幕外，90度时候，渲染结果y轴竖直向上，180度，XOZ平面平行canvas画布，y轴垂直指向屏幕内。\n\n// 上下旋转范围\ncontrols.minPolarAngle = 0;//默认值0\ncontrols.maxPolarAngle = Math.PI;//默认值Math.PI\n\n\n.maxPolarAngle属性设置为90度，这样不能看到工厂模型底部\n\ncontrols.maxPolarAngle = Math.PI/2;\n\n\n通过.minAzimuthAngle和.maxAzimuthAngle属性控制左右的旋转范围。\n\n// 左右旋转范围\ncontrols.minAzimuthAngle = -Math.PI/2;\ncontrols.maxAzimuthAngle = Math.PI/2;\n",normalizedContent:"# orbitcontrols旋转缩放限制\n\n课程中经常会用到相机控件orbitcontrols的不同功能,本节课就会大家补充新的知识点，比如控制缩放的最大最小范围，比如限制旋转的角度范围，比如禁止平移。\n\n * 1.9. 相机控件orbitcontrols\n * 6.4. orbitcontrols辅助设置相机参数\n\n\n# 禁止右键平移.enablepan属性\n\n比如一个展示一个三维场景，你不希望鼠标右键拖动会产生一个平移效果。可以通过设置相机空间对象orbitcontrols的.enablepan属性，查看orbitcontrols源码可以看到.enablepan属性的默认值是true。\n\ncontrols.enablepan = false; //禁止右键拖拽\n\n\n\n# 禁止缩放或旋转\n\n通过.enablezoom属性可以控制是否允许鼠标中键缩放场景，.enablezoom属性默认值true。\n\ncontrols.enablezoom = false;//禁止缩放\n\n\n通过.enablerotate属性可以控制是否允许鼠标左键旋转场景，.enablerotate属性默认值true。\n\ncontrols.enablerotate = false; //禁止旋转\n\n\n\n# orbitcontrols.target属性\n\n相机控件orbitcontrols.target属性对应的就是相机的.lookat()观察目标。\n\n执行controls.update();,相机控件内部会执行camera.lookat(controls.target)。\n\n// controls.target默认值是坐标原点\ncontrols.target.set(x, y, z);\n//update()函数内会执行camera.lookat(x, y, z)\ncontrols.update(); \n\n\n\n# 透视投影相机缩放范围\n\n在实际应用中，透视投影相机的规则是远小近大，相机距离目标观察点距离越远，目标模型显示越小，距离越近显示越大\n\n前面给大家讲解过，对于透视投影相机而言，orbitcontrols缩放，本质上就是改变相机的位置属性.position。\n\n这就是说如果你想控制缩放范围，就是约束相机位置.position的变化范围，orbitcontrols提供了两个属性.mindistance和.maxdistance可以帮助你实现。\n\n.mindistance表示相机位置.position和相机目标观察点controls.target的最小距离。\n\n//相机位置与观察目标点最小值\ncontrols.mindistance = 200;\n\n\n.maxdistance表示相机位置.position和相机目标观察点controls.target的最大距离。\n\n//相机位置与观察目标点最大值\ncontrols.maxdistance = 500;\n\n\n\n# 正投影缩放范围\n\n对于正投影相机对象orthographiccamera，可以通过相机控件orbitcontrols的.minzoom和.maxzoom属性实现\n\n// 缩放范围\ncontrols.minzoom = 0.5;\ncontrols.maxzoom = 2;\n\n\n\n# 相机位置与目标观察点距离.getdistance()\n\ncontrols.getdistance()可以计算出来相机位置.position和相机目标观察点controls.target的距离。\n\n//相机位置与目标观察点距离\nconst dis = controls.getdistance();\nconsole.log('dis',dis);\n\n\n\n# 可视化设置相机缩放范围\n\n如果你直接凭感觉设置mindistance和maxdistance，不太好把握具体范围，这时候通过.getdistance()辅助解决。\n\n在canvas画布上，你用鼠标缩放三维场景，这时候会改变透视投影相机位置，那么相机与目标观察点的距离也会改变，这时候可以通过.getdistance()计算出来此刻相机与目标观察点的距离，用于设置mindistance和maxdistance。\n\ncontrols.addeventlistener('change',function(){\n    //相机位置与目标观察点距离\n    const dis = controls.getdistance();\n    console.log('dis',dis);\n})\n\n\n\n# 设置旋转范围\n\n展示一个三维场景，你想控制360度旋转范围，比如一个工厂，你不希望用户看到工厂的底部，你可以通过设置相机的旋转范围属性来实现。\n\n通过.minpolarangle和.maxpolarangle属性控制上下的旋转范围，默认从0到180度，默认情况下0度，xoz平面平行canvas画布，y轴垂直指向屏幕外，90度时候，渲染结果y轴竖直向上，180度，xoz平面平行canvas画布，y轴垂直指向屏幕内。\n\n// 上下旋转范围\ncontrols.minpolarangle = 0;//默认值0\ncontrols.maxpolarangle = math.pi;//默认值math.pi\n\n\n.maxpolarangle属性设置为90度，这样不能看到工厂模型底部\n\ncontrols.maxpolarangle = math.pi/2;\n\n\n通过.minazimuthangle和.maxazimuthangle属性控制左右的旋转范围。\n\n// 左右旋转范围\ncontrols.minazimuthangle = -math.pi/2;\ncontrols.maxazimuthangle = math.pi/2;\n",charsets:{cjk:!0}},{title:"10. 相机控件MapControls",frontmatter:{title:"10. 相机控件MapControls",date:"2023-02-11T22:12:04.000Z",permalink:"/pages/76953b/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/10.10.%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/10.%E7%9B%B8%E6%9C%BA%E6%8E%A7%E4%BB%B6MapControls.html",relativePath:"01.Three.js教程/10.10.相机基础/10.相机控件MapControls.md",key:"v-26ffe15a",path:"/pages/76953b/",headers:[{level:3,title:"MapControls使用操作",slug:"mapcontrols使用操作",normalizedTitle:"mapcontrols使用操作",charIndex:64},{level:3,title:"引入相机控件MapControls",slug:"引入相机控件mapcontrols",normalizedTitle:"引入相机控件mapcontrols",charIndex:143},{level:3,title:"使用MapControls",slug:"使用mapcontrols",normalizedTitle:"使用mapcontrols",charIndex:524},{level:3,title:"MapControls本质",slug:"mapcontrols本质",normalizedTitle:"mapcontrols本质",charIndex:654},{level:3,title:"缩放、旋转或平移禁止",slug:"缩放、旋转或平移禁止",normalizedTitle:"缩放、旋转或平移禁止",charIndex:949},{level:3,title:"透视投影相机缩放范围",slug:"透视投影相机缩放范围",normalizedTitle:"透视投影相机缩放范围",charIndex:1123},{level:3,title:"设置旋转范围",slug:"设置旋转范围",normalizedTitle:"设置旋转范围",charIndex:1253}],headersStr:"MapControls使用操作 引入相机控件MapControls 使用MapControls MapControls本质 缩放、旋转或平移禁止 透视投影相机缩放范围 设置旋转范围",content:"# 相机控件MapControls\n\n地图导航相机控件MapControls，你可实现一个类似百度地图的3D导航功能。\n\n\n# MapControls使用操作\n\n你可以打开课件案例源码测试下效果。\n\n * 平移：鼠标左键拖动\n * 旋转：鼠标右键拖动\n * 缩放：鼠标中键滚动\n\n\n# 引入相机控件MapControls\n\n引入相机控件MapControls类，旧版本是通过扩展库文件MapControls.js实现,不过新版本MapControls类和OrbitControls类一样通过 \\examples\\jsm\\controls目录下的OrbitControls.js文件引入。\n\n// 引入相机控件`MapControls`\nimport { MapControls } from 'three/addons/controls/OrbitControls.js';\n\n\n注意：如果你在原生.html文件中，使用import { MapControls } from 'three/addons/controls/OrbitControls.js';方式引入，注意通过<script type=\"importmap\">配置好路径。\n\n\n# 使用MapControls\n\n参数1是地图导航控件要改变的相机对象，参数2是three.js渲染对应的canvas画布。\n\nconst controls = new MapControls(camera, renderer.domElement);\n\n\n\n# MapControls本质\n\nMapControls本质上就是改变相机的参数，比如相机的位置属性、相机目标观察点。\n\ncontrols.addEventListener('change', function () {\n    // 鼠标右键旋转时候，查看.position变化\n    // 鼠标左键拖动的时候，查看.position、.target的位置会变化\n    console.log('camera.position',camera.position);\n    console.log('controls.target',controls.target);\n});\n\n\n\n# 缩放、旋转或平移禁止\n\n参考上节课关于OrbitControls的介绍，整体思路是一样的，只是鼠标操作有差异。\n\ncontrols.enablePan = false; //禁止平移\n\n\ncontrols.enableZoom = false;//禁止缩放\n\n\ncontrols.enableRotate = false; //禁止旋转\n\n\n\n# 透视投影相机缩放范围\n\n参考上节课关于OrbitControls的介绍\n\n//相机位置与观察目标点最小值\ncontrols.minDistance = 200;\n//相机位置与观察目标点最大值\ncontrols.maxDistance = 500;\n\n\n\n# 设置旋转范围\n\n参考上节课关于OrbitControls的介绍\n\n// 上下旋转范围\ncontrols.minPolarAngle = 0;\ncontrols.maxPolarAngle = Math.PI/2;\n\n\n// 左右旋转范围\ncontrols.minAzimuthAngle = -Math.PI/2;\ncontrols.maxAzimuthAngle = Math.PI/2;\n",normalizedContent:"# 相机控件mapcontrols\n\n地图导航相机控件mapcontrols，你可实现一个类似百度地图的3d导航功能。\n\n\n# mapcontrols使用操作\n\n你可以打开课件案例源码测试下效果。\n\n * 平移：鼠标左键拖动\n * 旋转：鼠标右键拖动\n * 缩放：鼠标中键滚动\n\n\n# 引入相机控件mapcontrols\n\n引入相机控件mapcontrols类，旧版本是通过扩展库文件mapcontrols.js实现,不过新版本mapcontrols类和orbitcontrols类一样通过 \\examples\\jsm\\controls目录下的orbitcontrols.js文件引入。\n\n// 引入相机控件`mapcontrols`\nimport { mapcontrols } from 'three/addons/controls/orbitcontrols.js';\n\n\n注意：如果你在原生.html文件中，使用import { mapcontrols } from 'three/addons/controls/orbitcontrols.js';方式引入，注意通过<script type=\"importmap\">配置好路径。\n\n\n# 使用mapcontrols\n\n参数1是地图导航控件要改变的相机对象，参数2是three.js渲染对应的canvas画布。\n\nconst controls = new mapcontrols(camera, renderer.domelement);\n\n\n\n# mapcontrols本质\n\nmapcontrols本质上就是改变相机的参数，比如相机的位置属性、相机目标观察点。\n\ncontrols.addeventlistener('change', function () {\n    // 鼠标右键旋转时候，查看.position变化\n    // 鼠标左键拖动的时候，查看.position、.target的位置会变化\n    console.log('camera.position',camera.position);\n    console.log('controls.target',controls.target);\n});\n\n\n\n# 缩放、旋转或平移禁止\n\n参考上节课关于orbitcontrols的介绍，整体思路是一样的，只是鼠标操作有差异。\n\ncontrols.enablepan = false; //禁止平移\n\n\ncontrols.enablezoom = false;//禁止缩放\n\n\ncontrols.enablerotate = false; //禁止旋转\n\n\n\n# 透视投影相机缩放范围\n\n参考上节课关于orbitcontrols的介绍\n\n//相机位置与观察目标点最小值\ncontrols.mindistance = 200;\n//相机位置与观察目标点最大值\ncontrols.maxdistance = 500;\n\n\n\n# 设置旋转范围\n\n参考上节课关于orbitcontrols的介绍\n\n// 上下旋转范围\ncontrols.minpolarangle = 0;\ncontrols.maxpolarangle = math.pi/2;\n\n\n// 左右旋转范围\ncontrols.minazimuthangle = -math.pi/2;\ncontrols.maxazimuthangle = math.pi/2;\n",charsets:{cjk:!0}},{title:"1. 聚光源SpotLight",frontmatter:{title:"1. 聚光源SpotLight",date:"2023-02-11T22:12:52.000Z",permalink:"/pages/344c05/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/11.11.%E5%85%89%E6%BA%90%E5%92%8C%E9%98%B4%E5%BD%B1/01.%E8%81%9A%E5%85%89%E6%BA%90SpotLight.html",relativePath:"01.Three.js教程/11.11.光源和阴影/01.聚光源SpotLight.md",key:"v-347f5f9f",path:"/pages/344c05/",headers:[{level:3,title:"创建聚广源SpotLight",slug:"创建聚广源spotlight",normalizedTitle:"创建聚广源spotlight",charIndex:151},{level:3,title:"聚光源发散角度.angle",slug:"聚光源发散角度-angle",normalizedTitle:"聚光源发散角度.angle",charIndex:439},{level:3,title:"光源衰减",slug:"光源衰减",normalizedTitle:"光源衰减",charIndex:557},{level:3,title:"聚光源位置.position",slug:"聚光源位置-position",normalizedTitle:"聚光源位置.position",charIndex:862},{level:3,title:"聚广源目标对象.target",slug:"聚广源目标对象-target",normalizedTitle:"聚广源目标对象.target",charIndex:1011},{level:3,title:"聚光源辅助对象SpotLightHelper",slug:"聚光源辅助对象spotlighthelper",normalizedTitle:"聚光源辅助对象spotlighthelper",charIndex:1367}],headersStr:"创建聚广源SpotLight 聚光源发散角度.angle 光源衰减 聚光源位置.position 聚广源目标对象.target 聚光源辅助对象SpotLightHelper",content:"# 聚光源SpotLight\n\n入门部分给大家介绍过平行光DirectionalLight、点光源PointLight、环境光AmbientLight,下面给大家介绍一个新的光源对象，也就是聚广源SpotLight。\n\n * 1.8. 光源对物体表面影响\n * 1.10. 平行光与环境光\n\n\n\n\n# 创建聚广源SpotLight\n\n聚光源可以认为是一个沿着特定方会逐渐发散的光源，照射范围在三维空间中构成一个圆锥体。\n\n\n\n// 聚光源\n// 0xffffff:光源颜色\n// 1.0：光照强度intensity\nconst spotLight = new THREE.SpotLight(0xffffff,1.0);\nscene.add(spotLight);//光源添加到场景中\n\n\n光照强度也可以不通过THREE.SpotLight参数2设置，直接通过光照强度属性.intensity设置。\n\nspotLight.intensity = 1.0;//光照强度\n\n\n\n# 聚光源发散角度.angle\n\n通过属性.angle可以设置聚光源发散角度，和目标.target两个属性来实现。\n\n// 设置聚光光源发散角度\nspotLight.angle = Math.PI / 6;//光锥角度的二分之一\n\n\n\n# 光源衰减\n\n生活中聚光源，比如台灯、手电筒之类，随机距离的改变，光线会衰减，越来越弱，.decay默认值是2.0，如果你不希望衰减可以设置为0.0。\n\nspotLight.decay = 0.0;//设置光源不随距离衰减\n\n\n如果使用默认衰减2.0，对于部分threejs新版本，有时候你可能看不到光源效果，这时候可以把光照强度加强,如果你的版本不影响，就不用加强光照强度(根据版本情况灵活对应)。\n\n// 你可以对比不同光照强度明暗差异(传播同样距离)\nspotLight.intensity = 1000.0;//光照强度\nspotLight.intensity = 5000.0;//光照强度\n\n\n\n# 聚光源位置.position\n\n聚光源SpotLight的父类是Light，Light的父类是Object3D，聚光源SpotLight会继承父类Object3D的位置属性.position。\n\n// 设置聚光光源位置\nspotLight.position.set(0, 50, 0);\n\n\n\n# 聚广源目标对象.target\n\n聚广源目标对象.target和光源的位置.position共同确定聚广源照射方向。\n\n浏览器控制台打印聚广源目标对象.target属性，可以看到属性值是一个模型对象Object3D。\n\nconsole.log('聚广源指向目标',spotLight.target);\n\n\n聚广源目标对象属性的位置通过属性值Object3D的.position属性设置。\n\n// spotLight.target是一个模型对象Object3D，默认在坐标原点\nspotLight.target.position.set(50,0,0);\n//spotLight.target添加到场景中.target.position才会起作用\nscene.add(spotLight.target);\n\n\n\n# 聚光源辅助对象SpotLightHelper\n\n// 聚广源辅助对象，可视化聚广源\nconst spotLightHelper = new THREE.SpotLightHelper(spotLight,0xffffff)\nscene.add(spotLightHelper);\n",normalizedContent:"# 聚光源spotlight\n\n入门部分给大家介绍过平行光directionallight、点光源pointlight、环境光ambientlight,下面给大家介绍一个新的光源对象，也就是聚广源spotlight。\n\n * 1.8. 光源对物体表面影响\n * 1.10. 平行光与环境光\n\n\n\n\n# 创建聚广源spotlight\n\n聚光源可以认为是一个沿着特定方会逐渐发散的光源，照射范围在三维空间中构成一个圆锥体。\n\n\n\n// 聚光源\n// 0xffffff:光源颜色\n// 1.0：光照强度intensity\nconst spotlight = new three.spotlight(0xffffff,1.0);\nscene.add(spotlight);//光源添加到场景中\n\n\n光照强度也可以不通过three.spotlight参数2设置，直接通过光照强度属性.intensity设置。\n\nspotlight.intensity = 1.0;//光照强度\n\n\n\n# 聚光源发散角度.angle\n\n通过属性.angle可以设置聚光源发散角度，和目标.target两个属性来实现。\n\n// 设置聚光光源发散角度\nspotlight.angle = math.pi / 6;//光锥角度的二分之一\n\n\n\n# 光源衰减\n\n生活中聚光源，比如台灯、手电筒之类，随机距离的改变，光线会衰减，越来越弱，.decay默认值是2.0，如果你不希望衰减可以设置为0.0。\n\nspotlight.decay = 0.0;//设置光源不随距离衰减\n\n\n如果使用默认衰减2.0，对于部分threejs新版本，有时候你可能看不到光源效果，这时候可以把光照强度加强,如果你的版本不影响，就不用加强光照强度(根据版本情况灵活对应)。\n\n// 你可以对比不同光照强度明暗差异(传播同样距离)\nspotlight.intensity = 1000.0;//光照强度\nspotlight.intensity = 5000.0;//光照强度\n\n\n\n# 聚光源位置.position\n\n聚光源spotlight的父类是light，light的父类是object3d，聚光源spotlight会继承父类object3d的位置属性.position。\n\n// 设置聚光光源位置\nspotlight.position.set(0, 50, 0);\n\n\n\n# 聚广源目标对象.target\n\n聚广源目标对象.target和光源的位置.position共同确定聚广源照射方向。\n\n浏览器控制台打印聚广源目标对象.target属性，可以看到属性值是一个模型对象object3d。\n\nconsole.log('聚广源指向目标',spotlight.target);\n\n\n聚广源目标对象属性的位置通过属性值object3d的.position属性设置。\n\n// spotlight.target是一个模型对象object3d，默认在坐标原点\nspotlight.target.position.set(50,0,0);\n//spotlight.target添加到场景中.target.position才会起作用\nscene.add(spotlight.target);\n\n\n\n# 聚光源辅助对象spotlighthelper\n\n// 聚广源辅助对象，可视化聚广源\nconst spotlighthelper = new three.spotlighthelper(spotlight,0xffffff)\nscene.add(spotlighthelper);\n",charsets:{cjk:!0}},{title:"2. 平行光阴影计算",frontmatter:{title:"2. 平行光阴影计算",date:"2023-02-18T20:29:33.000Z",permalink:"/pages/1dbe9d/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/11.11.%E5%85%89%E6%BA%90%E5%92%8C%E9%98%B4%E5%BD%B1/02.%E5%B9%B3%E8%A1%8C%E5%85%89%E9%98%B4%E5%BD%B1%E8%AE%A1%E7%AE%97.html",relativePath:"01.Three.js教程/11.11.光源和阴影/02.平行光阴影计算.md",key:"v-5c3633ad",path:"/pages/1dbe9d/",headers:[{level:3,title:"平行光DirectionalLight阴影步骤",slug:"平行光directionallight阴影步骤",normalizedTitle:"平行光directionallight阴影步骤",charIndex:157},{level:3,title:"1. 模型阴影投射.castShadow",slug:"_1-模型阴影投射-castshadow",normalizedTitle:"1. 模型阴影投射.castshadow",charIndex:370},{level:3,title:"2. 光源阴影投射属性.castShadow",slug:"_2-光源阴影投射属性-castshadow",normalizedTitle:"2. 光源阴影投射属性.castshadow",charIndex:468},{level:3,title:"3.模型阴影接收属性.receiveShadow",slug:"_3-模型阴影接收属性-receiveshadow",normalizedTitle:"3.模型阴影接收属性.receiveshadow",charIndex:690},{level:3,title:"4. .shadowMap.enabled允许渲染器渲染阴影",slug:"_4-shadowmap-enabled允许渲染器渲染阴影",normalizedTitle:"4. .shadowmap.enabled允许渲染器渲染阴影",charIndex:799},{level:3,title:"5. 平行光阴影相机属性.shadow.camera(阴影渲染范围)",slug:"_5-平行光阴影相机属性-shadow-camera-阴影渲染范围",normalizedTitle:"5. 平行光阴影相机属性.shadow.camera(阴影渲染范围)",charIndex:1e3},{level:3,title:"CameraHelper可视化.shadow.camera",slug:"camerahelper可视化-shadow-camera",normalizedTitle:"camerahelper可视化.shadow.camera",charIndex:1258},{level:3,title:"5. .shadow.camera设置阴影渲染范围",slug:"_5-shadow-camera设置阴影渲染范围",normalizedTitle:"5. .shadow.camera设置阴影渲染范围",charIndex:1607},{level:3,title:"测试：改变平行光位置.position观察阴影变化",slug:"测试-改变平行光位置-position观察阴影变化",normalizedTitle:"测试：改变平行光位置.position观察阴影变化",charIndex:2235}],headersStr:"平行光DirectionalLight阴影步骤 1. 模型阴影投射.castShadow 2. 光源阴影投射属性.castShadow 3.模型阴影接收属性.receiveShadow 4. .shadowMap.enabled允许渲染器渲染阴影 5. 平行光阴影相机属性.shadow.camera(阴影渲染范围) CameraHelper可视化.shadow.camera 5. .shadow.camera设置阴影渲染范围 测试：改变平行光位置.position观察阴影变化",content:"# 平行光阴影计算\n\n点光源PointLight、聚光源SpotLight、平行光DirectionalLight等都可以产生阴影，就像实际生活中的影子。\n\n\n\n环境光AmbientLight这种没有方向的光源，不会产生阴影。\n\n本节课给大家讲解平行光DirectionalLight的阴影效果如何实现。\n\n\n# 平行光DirectionalLight阴影步骤\n\n平行光DirectionalLight阴影计算最少设置\n\n * 1..castShadow设置产生阴影的模型对象\n * 2..castShadow设置产生阴影的光源对象\n * 3..receiveShadow设置接收阴影效果的模型\n * 4..shadowMap.enabledWebGl渲染器允许阴影渲染\n * 5..shadow.camera设置光源阴影渲染范围\n\n\n# 1. 模型阴影投射.castShadow\n\n模型阴影投射属性.castShadow设置产生阴影的模型对象\n\n// 设置产生投影的网格模型\nmesh.castShadow = true;\n\n\n\n# 2. 光源阴影投射属性.castShadow\n\n和产生阴影的模型一样，光源也有阴影投射属性.castShadow属性，光源默认不产生阴影，需要代码开启。\n\n// 平行光\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n// 平行光设置产生阴影的光源对象,开启光源阴影的计算功能\ndirectionalLight.castShadow = true;\n\n\n\n# 3.模型阴影接收属性.receiveShadow\n\n模型阴影接收属性.castShadow设置接收阴影的模型对象\n\n// 设置接收阴影的投影面\nplaneMesh.receiveShadow = true;\n\n\n\n# 4. .shadowMap.enabled允许渲染器渲染阴影\n\nWebGL的渲染器的阴影贴图属性.shadowMap的属性值是一个对象，.shadowMap具有.enabled、.type等属性。\n\n设置.shadowMap.enabled=true允许WebGL渲染器渲染阴影。\n\n// 设置渲染器，允许光源阴影渲染\nrenderer.shadowMap.enabled = true; \n\n\n\n# 5. 平行光阴影相机属性.shadow.camera(阴影渲染范围)\n\n平行光DirectionalLight的.shadow属性是平行光阴影对象DirectionalLightShadow,平行光阴影对象有一个相机属性shadow.camera。\n\n平行光阴影相机属性.shadow.camera的属性值是一个正投影相机对象OrthographicCamera。\n\n// 查看平行光阴影相机属性\nconsole.log('阴影相机属性',directionalLight.shadow.camera);\n\n\n\n# CameraHelper可视化.shadow.camera\n\nTHREE.CameraHelper可以用来可视化正投影相机、透视投影相机对象。\n\n// 可视化平行光阴影对应的正投影相机对象\nconst cameraHelper = new THREE.CameraHelper(directionalLight.shadow.camera);\nscene.add(cameraHelper);\n\n\n平行光阴影相机的位置.shadow.camera.position默认就是平行光的位置属性directionalLight.position。\n\nconsole.log('shadow.camera位置',directionalLight.shadow.camera.position);\n\n\n\n# 5. .shadow.camera设置阴影渲染范围\n\n.shadow.camera属性值是正投影相机OrthographicCamera，所以.shadow.camera属性的用法可以参考前面讲解过的正投影相机OrthographicCamera。\n\nOrthographicCamera( left, right, top, bottom, near, far )\n\n\n\n\n.shadow.camera作用是约束三维场景阴影计算范围，上下左右前后六个属性定义了一个长方体空间，在这个长方体空间内容的模型进行阴影计算。\n\n// 设置三维场景计算阴影的范围\ndirectionalLight.shadow.camera.left = -50;\ndirectionalLight.shadow.camera.right = 50;\ndirectionalLight.shadow.camera.top = 200;\ndirectionalLight.shadow.camera.bottom = -100;\ndirectionalLight.shadow.camera.near = 0.5;\ndirectionalLight.shadow.camera.far = 600;\n\n\n如果.shadow.camera的渲染范围设置不合理，可能会出现看不到阴影或者阴影不完整的现象。比如你把代码中.far、.right等相机属性设置小一些，观察阴影变化。\n\n\n# 测试：改变平行光位置.position观察阴影变化\n\n你可以改变平行光位置.position属性，观察光源阴影相机属性.shadow.camera变化，观察平行光的阴影变化。",normalizedContent:"# 平行光阴影计算\n\n点光源pointlight、聚光源spotlight、平行光directionallight等都可以产生阴影，就像实际生活中的影子。\n\n\n\n环境光ambientlight这种没有方向的光源，不会产生阴影。\n\n本节课给大家讲解平行光directionallight的阴影效果如何实现。\n\n\n# 平行光directionallight阴影步骤\n\n平行光directionallight阴影计算最少设置\n\n * 1..castshadow设置产生阴影的模型对象\n * 2..castshadow设置产生阴影的光源对象\n * 3..receiveshadow设置接收阴影效果的模型\n * 4..shadowmap.enabledwebgl渲染器允许阴影渲染\n * 5..shadow.camera设置光源阴影渲染范围\n\n\n# 1. 模型阴影投射.castshadow\n\n模型阴影投射属性.castshadow设置产生阴影的模型对象\n\n// 设置产生投影的网格模型\nmesh.castshadow = true;\n\n\n\n# 2. 光源阴影投射属性.castshadow\n\n和产生阴影的模型一样，光源也有阴影投射属性.castshadow属性，光源默认不产生阴影，需要代码开启。\n\n// 平行光\nconst directionallight = new three.directionallight(0xffffff, 1);\n// 平行光设置产生阴影的光源对象,开启光源阴影的计算功能\ndirectionallight.castshadow = true;\n\n\n\n# 3.模型阴影接收属性.receiveshadow\n\n模型阴影接收属性.castshadow设置接收阴影的模型对象\n\n// 设置接收阴影的投影面\nplanemesh.receiveshadow = true;\n\n\n\n# 4. .shadowmap.enabled允许渲染器渲染阴影\n\nwebgl的渲染器的阴影贴图属性.shadowmap的属性值是一个对象，.shadowmap具有.enabled、.type等属性。\n\n设置.shadowmap.enabled=true允许webgl渲染器渲染阴影。\n\n// 设置渲染器，允许光源阴影渲染\nrenderer.shadowmap.enabled = true; \n\n\n\n# 5. 平行光阴影相机属性.shadow.camera(阴影渲染范围)\n\n平行光directionallight的.shadow属性是平行光阴影对象directionallightshadow,平行光阴影对象有一个相机属性shadow.camera。\n\n平行光阴影相机属性.shadow.camera的属性值是一个正投影相机对象orthographiccamera。\n\n// 查看平行光阴影相机属性\nconsole.log('阴影相机属性',directionallight.shadow.camera);\n\n\n\n# camerahelper可视化.shadow.camera\n\nthree.camerahelper可以用来可视化正投影相机、透视投影相机对象。\n\n// 可视化平行光阴影对应的正投影相机对象\nconst camerahelper = new three.camerahelper(directionallight.shadow.camera);\nscene.add(camerahelper);\n\n\n平行光阴影相机的位置.shadow.camera.position默认就是平行光的位置属性directionallight.position。\n\nconsole.log('shadow.camera位置',directionallight.shadow.camera.position);\n\n\n\n# 5. .shadow.camera设置阴影渲染范围\n\n.shadow.camera属性值是正投影相机orthographiccamera，所以.shadow.camera属性的用法可以参考前面讲解过的正投影相机orthographiccamera。\n\northographiccamera( left, right, top, bottom, near, far )\n\n\n\n\n.shadow.camera作用是约束三维场景阴影计算范围，上下左右前后六个属性定义了一个长方体空间，在这个长方体空间内容的模型进行阴影计算。\n\n// 设置三维场景计算阴影的范围\ndirectionallight.shadow.camera.left = -50;\ndirectionallight.shadow.camera.right = 50;\ndirectionallight.shadow.camera.top = 200;\ndirectionallight.shadow.camera.bottom = -100;\ndirectionallight.shadow.camera.near = 0.5;\ndirectionallight.shadow.camera.far = 600;\n\n\n如果.shadow.camera的渲染范围设置不合理，可能会出现看不到阴影或者阴影不完整的现象。比如你把代码中.far、.right等相机属性设置小一些，观察阴影变化。\n\n\n# 测试：改变平行光位置.position观察阴影变化\n\n你可以改变平行光位置.position属性，观察光源阴影相机属性.shadow.camera变化，观察平行光的阴影变化。",charsets:{cjk:!0}},{title:"3. 阴影范围.shadow.camera",frontmatter:{title:"3. 阴影范围.shadow.camera",date:"2023-02-18T20:30:40.000Z",permalink:"/pages/68e9fd/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/11.11.%E5%85%89%E6%BA%90%E5%92%8C%E9%98%B4%E5%BD%B1/03.%E9%98%B4%E5%BD%B1%E8%8C%83%E5%9B%B4.shadow.camera.html",relativePath:"01.Three.js教程/11.11.光源和阴影/03.阴影范围.shadow.camera.md",key:"v-a5dd4774",path:"/pages/68e9fd/",headers:[{level:3,title:"平行光阴影相机属性.shadow.camera回顾",slug:"平行光阴影相机属性-shadow-camera回顾",normalizedTitle:"平行光阴影相机属性.shadow.camera回顾",charIndex:103},{level:3,title:"CameraHelper可视化.shadow.camera",slug:"camerahelper可视化-shadow-camera",normalizedTitle:"camerahelper可视化.shadow.camera",charIndex:290},{level:3,title:"参数测试",slug:"参数测试",normalizedTitle:"参数测试",charIndex:431},{level:3,title:"设置相机.shadow.camera长方体范围",slug:"设置相机-shadow-camera长方体范围",normalizedTitle:"设置相机.shadow.camera长方体范围",charIndex:513},{level:3,title:"调节光源位置",slug:"调节光源位置",normalizedTitle:"调节光源位置",charIndex:834},{level:3,title:"确定阴影计算范围",slug:"确定阴影计算范围",normalizedTitle:"确定阴影计算范围",charIndex:1021},{level:3,title:"根据尺寸数量级设置阴影渲染范围",slug:"根据尺寸数量级设置阴影渲染范围",normalizedTitle:"根据尺寸数量级设置阴影渲染范围",charIndex:1442}],headersStr:"平行光阴影相机属性.shadow.camera回顾 CameraHelper可视化.shadow.camera 参数测试 设置相机.shadow.camera长方体范围 调节光源位置 确定阴影计算范围 根据尺寸数量级设置阴影渲染范围",content:"# 阴影范围.shadow.camera\n\n上节课2.平行光阴影计算讲解过，通过光源的阴影相机属性.shadow.camera,来控制阴影的渲染范围，本节课继续.shadow.camera的讲解。\n\n\n# 平行光阴影相机属性.shadow.camera回顾\n\n * 平行光DirectionalLight的.shadow属性是平行光阴影对象DirectionalLightShadow\n * 平行光阴影对象DirectionalLightShadow有一个相机属性.camera\n * .shadow.camera属性值(正投影相机OrthographicCamera)\n\n\n# CameraHelper可视化.shadow.camera\n\n为了方便观察阴影渲染的范围，需要把平行光对应的阴影相机.shadow.camera可视化显示。\n\nnew THREE.CameraHelper(directionalLight.shadow.camera);\n\n\n\n# 参数测试\n\n下面先在上节课代码基础上给大家改参数体验下相机渲染范围参数对阴影的影响。\n\n课件演示文件中，提供了批量创建了多个长方体，用于阴影范围设置测试。\n\n\n# 设置相机.shadow.camera长方体范围\n\n根据3D场景渲染范围，去设置.shadow.camera长方体尺寸参数，一般比你要渲染的范围稍微大一些即可，过小阴影不显示或显示不完整，过大很多可能阴影偏模糊，你可以比较下面两个参数的阴影渲染差异。\n\ndirectionalLight.shadow.camera.left = -50*10;\ndirectionalLight.shadow.camera.right = 50*10;\n\n\ndirectionalLight.shadow.camera.left = -50*100;\ndirectionalLight.shadow.camera.right = 50*100;\n\n\n\n\n\n# 调节光源位置\n\n光源位置影响平行光阴影相机.shadow.camera的位置，所以要根据渲染范围调整光源的位置。\n\n你可以比较测试两个不同的光源位置，对应阴影渲染效果。\n\ndirectionalLight.position.set(100, 60, 50);\n\n\ndirectionalLight.position.set(100*2, 60*2, 50*2);\n\n\n\n# 确定阴影计算范围\n\n其实平行光阴影范围的设置，你可以类比以前正投影机位置、长方体可视化空间的设置。\n\n * 1.先大概确定下3D场景中需要阴影计算范围，不用精确，有一个数量级就行，比如几百、几千。\n * 2..shadow.camera的.left、.right、.top、.bottom、.near、.far属性定义的长方体空间\n * 3..shadow.camera的位置(光源位置影响.shadow.camera的位置)\n\n需要阴影范围数量级：z方向尺寸1000左右，xy方向100左右。\n\nfor (let i = -3; i < 4; i++) {\n    const mesh2 = mesh.clone();\n    // 设置产生投影的网格模型\n    mesh2.castShadow = true;\n    mesh2.position.z = 100 * i;\n    group.add(mesh2);\n}\n\n\n\n# 根据尺寸数量级设置阴影渲染范围\n\n比如光线是从斜上方照射下来，模型y方向高度100左右，这时候y可以设置为100左右，xz也可以根据渲染范围先给个大概尺寸。\n\ndirectionalLight.position.set(100, 100, 100);\n// 平行光默认从.position指向坐标原点\n\n\n光线方向，你可以改变xz坐标来调整\n\ndirectionalLight.position.set(-100, 100, -100);\n\n\n渲染范围可以都先给个几百量级的值，不用精准，先设置，在微调。\n\n// 设置三维场景计算阴影的范围\ndirectionalLight.shadow.camera.left = -100;\ndirectionalLight.shadow.camera.right = 100;\ndirectionalLight.shadow.camera.top = 100;\ndirectionalLight.shadow.camera.bottom = -100;\ndirectionalLight.shadow.camera.near = 0.5;\ndirectionalLight.shadow.camera.far = 100;\n",normalizedContent:"# 阴影范围.shadow.camera\n\n上节课2.平行光阴影计算讲解过，通过光源的阴影相机属性.shadow.camera,来控制阴影的渲染范围，本节课继续.shadow.camera的讲解。\n\n\n# 平行光阴影相机属性.shadow.camera回顾\n\n * 平行光directionallight的.shadow属性是平行光阴影对象directionallightshadow\n * 平行光阴影对象directionallightshadow有一个相机属性.camera\n * .shadow.camera属性值(正投影相机orthographiccamera)\n\n\n# camerahelper可视化.shadow.camera\n\n为了方便观察阴影渲染的范围，需要把平行光对应的阴影相机.shadow.camera可视化显示。\n\nnew three.camerahelper(directionallight.shadow.camera);\n\n\n\n# 参数测试\n\n下面先在上节课代码基础上给大家改参数体验下相机渲染范围参数对阴影的影响。\n\n课件演示文件中，提供了批量创建了多个长方体，用于阴影范围设置测试。\n\n\n# 设置相机.shadow.camera长方体范围\n\n根据3d场景渲染范围，去设置.shadow.camera长方体尺寸参数，一般比你要渲染的范围稍微大一些即可，过小阴影不显示或显示不完整，过大很多可能阴影偏模糊，你可以比较下面两个参数的阴影渲染差异。\n\ndirectionallight.shadow.camera.left = -50*10;\ndirectionallight.shadow.camera.right = 50*10;\n\n\ndirectionallight.shadow.camera.left = -50*100;\ndirectionallight.shadow.camera.right = 50*100;\n\n\n\n\n\n# 调节光源位置\n\n光源位置影响平行光阴影相机.shadow.camera的位置，所以要根据渲染范围调整光源的位置。\n\n你可以比较测试两个不同的光源位置，对应阴影渲染效果。\n\ndirectionallight.position.set(100, 60, 50);\n\n\ndirectionallight.position.set(100*2, 60*2, 50*2);\n\n\n\n# 确定阴影计算范围\n\n其实平行光阴影范围的设置，你可以类比以前正投影机位置、长方体可视化空间的设置。\n\n * 1.先大概确定下3d场景中需要阴影计算范围，不用精确，有一个数量级就行，比如几百、几千。\n * 2..shadow.camera的.left、.right、.top、.bottom、.near、.far属性定义的长方体空间\n * 3..shadow.camera的位置(光源位置影响.shadow.camera的位置)\n\n需要阴影范围数量级：z方向尺寸1000左右，xy方向100左右。\n\nfor (let i = -3; i < 4; i++) {\n    const mesh2 = mesh.clone();\n    // 设置产生投影的网格模型\n    mesh2.castshadow = true;\n    mesh2.position.z = 100 * i;\n    group.add(mesh2);\n}\n\n\n\n# 根据尺寸数量级设置阴影渲染范围\n\n比如光线是从斜上方照射下来，模型y方向高度100左右，这时候y可以设置为100左右，xz也可以根据渲染范围先给个大概尺寸。\n\ndirectionallight.position.set(100, 100, 100);\n// 平行光默认从.position指向坐标原点\n\n\n光线方向，你可以改变xz坐标来调整\n\ndirectionallight.position.set(-100, 100, -100);\n\n\n渲染范围可以都先给个几百量级的值，不用精准，先设置，在微调。\n\n// 设置三维场景计算阴影的范围\ndirectionallight.shadow.camera.left = -100;\ndirectionallight.shadow.camera.right = 100;\ndirectionallight.shadow.camera.top = 100;\ndirectionallight.shadow.camera.bottom = -100;\ndirectionallight.shadow.camera.near = 0.5;\ndirectionallight.shadow.camera.far = 100;\n",charsets:{cjk:!0}},{title:"4. 阴影.mapSize和.radius",frontmatter:{title:"4. 阴影.mapSize和.radius",date:"2023-02-18T20:31:00.000Z",permalink:"/pages/547403/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/11.11.%E5%85%89%E6%BA%90%E5%92%8C%E9%98%B4%E5%BD%B1/04.%E9%98%B4%E5%BD%B1.mapSize%E5%92%8C.radius.html",relativePath:"01.Three.js教程/11.11.光源和阴影/04.阴影.mapSize和.radius.md",key:"v-f6b64df4",path:"/pages/547403/",headers:[{level:3,title:"light.shadow.mapSize阴影贴图尺寸属性",slug:"light-shadow-mapsize阴影贴图尺寸属性",normalizedTitle:"light.shadow.mapsize阴影贴图尺寸属性",charIndex:155},{level:3,title:".shadow.mapSize和.shadow.camera总结",slug:"shadow-mapsize和-shadow-camera总结",normalizedTitle:".shadow.mapsize和.shadow.camera总结",charIndex:782},{level:3,title:"阴影半径.shadow.radius属性",slug:"阴影半径-shadow-radius属性",normalizedTitle:"阴影半径.shadow.radius属性",charIndex:927}],headersStr:"light.shadow.mapSize阴影贴图尺寸属性 .shadow.mapSize和.shadow.camera总结 阴影半径.shadow.radius属性",content:"# 阴影.mapSize和.radius\n\n接着上节课阴影范围讲解，本节课给大家介绍阴影渲染质量的问题\n\n前面给大家介绍过平行光阴影对象DirectionalLightShadow的阴影相机属性.camera，本节课为大家介绍该阴影对象的阴影贴图尺寸.mapSize属性和阴影半径.radius属性。\n\n * light.shadow.mapSize阴影贴图尺寸属性(提升边缘渲染效果)\n * light.shadow.radius弱化模糊阴影边缘\n\n\n# light.shadow.mapSize阴影贴图尺寸属性\n\n你可以把threejs生成的光源阴影类比为前面学习过的颜色贴图.map，阴影投射到其它物体上，可以理解为阴影就像贴图一样映射到Mesh上。\n\n// mapSize属性默认512x512\nconsole.log('阴影默认像素',directionalLight.shadow.mapSize);\n\n\n你可以尝试把.mapSize设置为比较小的值(尺寸一般2的n次方)，查看阴影渲染质量。\n\ndirectionalLight.shadow.mapSize.set(128,128)\n\n\n你可以尝试把阴影相机.shadow.camera的范围扩大多倍，查看阴影渲染质量变化。你可以发现渲染范围越大，阴影渲染效果越差。\n\ndirectionalLight.shadow.mapSize.set(128,128)\n\n\n如果你的阴影边缘不够清晰，有模糊感、锯齿感，可以适当提升.mapSize属性值。\n\n// 如果阴影边缘锯齿感的时候，可以适当提升像素\ndirectionalLight.shadow.mapSize.set(1024,1024);\ndirectionalLight.shadow.mapSize.set(2048,2048);\n\n\n\n# .shadow.mapSize和.shadow.camera总结\n\n * 在能覆盖包含阴影渲染范围的情况下，.shadow.camera的尺寸尽量小。\n\n * 如果你增加.shadow.camera长方体尺寸范围，阴影模糊锯齿感，可以适当提升.shadow.mapSize的大小。\n\n\n# 阴影半径.shadow.radius属性\n\n如果你在项目中，希望阴影的边缘弱化或者说模糊化,可以通过阴影半径.shadow.radius属性设置\n\n// 模糊弱化阴影边缘\nconsole.log('.shadow.radius',directionalLight.shadow.radius);\n\n\n\n适当提升.shadow.radius,你可以感到阴影边缘与非阴影区域是渐变过渡，或者说阴影边缘逐渐弱化或模糊化，没有很明显的边界感。\n\ndirectionalLight.shadow.radius = 3;\n",normalizedContent:"# 阴影.mapsize和.radius\n\n接着上节课阴影范围讲解，本节课给大家介绍阴影渲染质量的问题\n\n前面给大家介绍过平行光阴影对象directionallightshadow的阴影相机属性.camera，本节课为大家介绍该阴影对象的阴影贴图尺寸.mapsize属性和阴影半径.radius属性。\n\n * light.shadow.mapsize阴影贴图尺寸属性(提升边缘渲染效果)\n * light.shadow.radius弱化模糊阴影边缘\n\n\n# light.shadow.mapsize阴影贴图尺寸属性\n\n你可以把threejs生成的光源阴影类比为前面学习过的颜色贴图.map，阴影投射到其它物体上，可以理解为阴影就像贴图一样映射到mesh上。\n\n// mapsize属性默认512x512\nconsole.log('阴影默认像素',directionallight.shadow.mapsize);\n\n\n你可以尝试把.mapsize设置为比较小的值(尺寸一般2的n次方)，查看阴影渲染质量。\n\ndirectionallight.shadow.mapsize.set(128,128)\n\n\n你可以尝试把阴影相机.shadow.camera的范围扩大多倍，查看阴影渲染质量变化。你可以发现渲染范围越大，阴影渲染效果越差。\n\ndirectionallight.shadow.mapsize.set(128,128)\n\n\n如果你的阴影边缘不够清晰，有模糊感、锯齿感，可以适当提升.mapsize属性值。\n\n// 如果阴影边缘锯齿感的时候，可以适当提升像素\ndirectionallight.shadow.mapsize.set(1024,1024);\ndirectionallight.shadow.mapsize.set(2048,2048);\n\n\n\n# .shadow.mapsize和.shadow.camera总结\n\n * 在能覆盖包含阴影渲染范围的情况下，.shadow.camera的尺寸尽量小。\n\n * 如果你增加.shadow.camera长方体尺寸范围，阴影模糊锯齿感，可以适当提升.shadow.mapsize的大小。\n\n\n# 阴影半径.shadow.radius属性\n\n如果你在项目中，希望阴影的边缘弱化或者说模糊化,可以通过阴影半径.shadow.radius属性设置\n\n// 模糊弱化阴影边缘\nconsole.log('.shadow.radius',directionallight.shadow.radius);\n\n\n\n适当提升.shadow.radius,你可以感到阴影边缘与非阴影区域是渐变过渡，或者说阴影边缘逐渐弱化或模糊化，没有很明显的边界感。\n\ndirectionallight.shadow.radius = 3;\n",charsets:{cjk:!0}},{title:"6. 工厂光源(平行光模拟太阳光)",frontmatter:{title:"6. 工厂光源(平行光模拟太阳光)",date:"2023-02-18T20:31:29.000Z",permalink:"/pages/c418f4/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/11.11.%E5%85%89%E6%BA%90%E5%92%8C%E9%98%B4%E5%BD%B1/06.%E5%B7%A5%E5%8E%82%E5%85%89%E6%BA%90(%E5%B9%B3%E8%A1%8C%E5%85%89%E6%A8%A1%E6%8B%9F%E5%A4%AA%E9%98%B3%E5%85%89).html",relativePath:"01.Three.js教程/11.11.光源和阴影/06.工厂光源(平行光模拟太阳光).md",key:"v-2a39b6e4",path:"/pages/c418f4/",headers:[{level:3,title:"平行光模拟太阳光",slug:"平行光模拟太阳光",normalizedTitle:"平行光模拟太阳光",charIndex:7},{level:3,title:"平行光辅助对象DirectionalLightHelper",slug:"平行光辅助对象directionallighthelper",normalizedTitle:"平行光辅助对象directionallighthelper",charIndex:413},{level:3,title:"平行光位置和方向GUI可视化控制",slug:"平行光位置和方向gui可视化控制",normalizedTitle:"平行光位置和方向gui可视化控制",charIndex:627},{level:3,title:"更新平行光辅助对象DirectionalLightHelper",slug:"更新平行光辅助对象directionallighthelper",normalizedTitle:"更新平行光辅助对象directionallighthelper",charIndex:1223}],headersStr:"平行光模拟太阳光 平行光辅助对象DirectionalLightHelper 平行光位置和方向GUI可视化控制 更新平行光辅助对象DirectionalLightHelper",content:"# 工厂光源(平行光模拟太阳光)\n\n继续上节课内容讲解。\n\n * 环境贴图(上节课)\n * 环境光(上节课)\n * 平行光模拟太阳光\n\n\n# 平行光模拟太阳光\n\n比如实际生活中一个三维场景中，可能会有太阳光照射，太阳距离地球足够远，可以近似认为太阳光是平行光。\n\n工厂地面坐标为0的话，光源从斜上方照射到物体上，可以y给予一个大于0的高度值，xz设置不同的值，控制不同的光线照射方向。\n\n在设置光源高度的时候，你可以先大概测量下三场场景的尺寸，布局具体值，知道大概数量级即可，比如几十、几百，工厂长宽方向100量级，高度方向10量级。\n\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 1);\ndirectionalLight.position.set(100, 60, 50);\nscene.add(directionalLight);\n\n\n\n# 平行光辅助对象DirectionalLightHelper\n\n通过平行光DirectionalLightHelper可以可视化平行光.position和照射方向。\n\n// 参数2表示平行光.position附近方框的尺寸\nconst dirHelper = new THREE.DirectionalLightHelper( directionalLight, 5);\nscene.add( dirHelper );\n\n\n\n# 平行光位置和方向GUI可视化控制\n\n平行光y坐标相对工厂地面设置一定高度，比如通过GUI控制在0~300范围。\n\ngui.add(directionalLight.position, 'y', 0, 300);\n\n\n平行光位置在XOZ平面上绕着y轴旋转，可以给一个半径R，一个角度值angle，然后改变平行光在XOZ平面上旋转角度，通过三角函数计算x和z坐标。\n\nconst obj = {\n    R: 100,\n    angle: 0,\n};\ngui.add(obj, 'R', 0, 300).onChange(function(value){\n    directionalLight.position.x = value * Math.cos(obj.angle);\n    directionalLight.position.z = value * Math.sin(obj.angle);\n});\ngui.add(obj, 'angle', 0, Math.PI*2).onChange(function(value){\n    directionalLight.position.x = obj.R * Math.cos(value);\n    directionalLight.position.z = obj.R * Math.sin(value);\n});\n\n\n\n# 更新平行光辅助对象DirectionalLightHelper\n\n当平行光位置变化的时候，可以执行helper.update()更新行光辅助对象DirectionalLightHelper的姿态同步变化。\n\ngui.add(directionalLight.position, 'y', 0, 300).onChange(function(value){\n    dirHelper.update();\n});\n\n\nconst obj = {\n    R: 100,\n    angle: 0,\n};\ngui.add(obj, 'R', 0, 300).onChange(function(value){\n    directionalLight.position.x = value * Math.cos(obj.angle);\n    directionalLight.position.z = value * Math.sin(obj.angle);\n    dirHelper.update();\n});\ngui.add(obj, 'angle', 0, Math.PI*2).onChange(function(value){\n    directionalLight.position.x = obj.R * Math.cos(value);\n    directionalLight.position.z = obj.R * Math.sin(value);\n    dirHelper.update();\n});\n\n",normalizedContent:"# 工厂光源(平行光模拟太阳光)\n\n继续上节课内容讲解。\n\n * 环境贴图(上节课)\n * 环境光(上节课)\n * 平行光模拟太阳光\n\n\n# 平行光模拟太阳光\n\n比如实际生活中一个三维场景中，可能会有太阳光照射，太阳距离地球足够远，可以近似认为太阳光是平行光。\n\n工厂地面坐标为0的话，光源从斜上方照射到物体上，可以y给予一个大于0的高度值，xz设置不同的值，控制不同的光线照射方向。\n\n在设置光源高度的时候，你可以先大概测量下三场场景的尺寸，布局具体值，知道大概数量级即可，比如几十、几百，工厂长宽方向100量级，高度方向10量级。\n\nconst directionallight = new three.directionallight(0xffffff, 1);\ndirectionallight.position.set(100, 60, 50);\nscene.add(directionallight);\n\n\n\n# 平行光辅助对象directionallighthelper\n\n通过平行光directionallighthelper可以可视化平行光.position和照射方向。\n\n// 参数2表示平行光.position附近方框的尺寸\nconst dirhelper = new three.directionallighthelper( directionallight, 5);\nscene.add( dirhelper );\n\n\n\n# 平行光位置和方向gui可视化控制\n\n平行光y坐标相对工厂地面设置一定高度，比如通过gui控制在0~300范围。\n\ngui.add(directionallight.position, 'y', 0, 300);\n\n\n平行光位置在xoz平面上绕着y轴旋转，可以给一个半径r，一个角度值angle，然后改变平行光在xoz平面上旋转角度，通过三角函数计算x和z坐标。\n\nconst obj = {\n    r: 100,\n    angle: 0,\n};\ngui.add(obj, 'r', 0, 300).onchange(function(value){\n    directionallight.position.x = value * math.cos(obj.angle);\n    directionallight.position.z = value * math.sin(obj.angle);\n});\ngui.add(obj, 'angle', 0, math.pi*2).onchange(function(value){\n    directionallight.position.x = obj.r * math.cos(value);\n    directionallight.position.z = obj.r * math.sin(value);\n});\n\n\n\n# 更新平行光辅助对象directionallighthelper\n\n当平行光位置变化的时候，可以执行helper.update()更新行光辅助对象directionallighthelper的姿态同步变化。\n\ngui.add(directionallight.position, 'y', 0, 300).onchange(function(value){\n    dirhelper.update();\n});\n\n\nconst obj = {\n    r: 100,\n    angle: 0,\n};\ngui.add(obj, 'r', 0, 300).onchange(function(value){\n    directionallight.position.x = value * math.cos(obj.angle);\n    directionallight.position.z = value * math.sin(obj.angle);\n    dirhelper.update();\n});\ngui.add(obj, 'angle', 0, math.pi*2).onchange(function(value){\n    directionallight.position.x = obj.r * math.cos(value);\n    directionallight.position.z = obj.r * math.sin(value);\n    dirhelper.update();\n});\n\n",charsets:{cjk:!0}},{title:"5. 工厂光源(环境贴图和环境光)",frontmatter:{title:"5. 工厂光源(环境贴图和环境光)",date:"2023-02-18T20:31:15.000Z",permalink:"/pages/3824bf/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/11.11.%E5%85%89%E6%BA%90%E5%92%8C%E9%98%B4%E5%BD%B1/05.%E5%B7%A5%E5%8E%82%E5%85%89%E6%BA%90(%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE%E5%92%8C%E7%8E%AF%E5%A2%83%E5%85%89).html",relativePath:"01.Three.js教程/11.11.光源和阴影/05.工厂光源(环境贴图和环境光).md",key:"v-36a594f2",path:"/pages/3824bf/",headers:[{level:3,title:"测试工厂模型中光源",slug:"测试工厂模型中光源",normalizedTitle:"测试工厂模型中光源",charIndex:150},{level:3,title:"环境贴图",slug:"环境贴图",normalizedTitle:"环境贴图",charIndex:7},{level:3,title:"环境光",slug:"环境光",normalizedTitle:"环境光",charIndex:12},{level:3,title:"GUI可视化调试",slug:"gui可视化调试",normalizedTitle:"gui可视化调试",charIndex:1122},{level:3,title:"gui控制环境光光照强度.intensity",slug:"gui控制环境光光照强度-intensity",normalizedTitle:"gui控制环境光光照强度.intensity",charIndex:1432},{level:3,title:"GUI控制环境贴图强度.envMapIntensity",slug:"gui控制环境贴图强度-envmapintensity",normalizedTitle:"gui控制环境贴图强度.envmapintensity",charIndex:1520}],headersStr:"测试工厂模型中光源 环境贴图 环境光 GUI可视化调试 gui控制环境光光照强度.intensity GUI控制环境贴图强度.envMapIntensity",content:"# 工厂光源(环境贴图和环境光)\n\n接下来两节课利用前面知识，给大家总结下，如何设置类似工厂、园区等3D场景的光照。\n\n * 环境贴图\n * 环境光\n * 平行光模拟太阳光(下节课内容)\n\n具体threejs知识点前面基本都讲解过，下面把重点放在整体思路讲解上，具体代码你可以参考课件源码。\n\n\n# 测试工厂模型中光源\n\n课件“演示”文件加载了一个工厂模型，你可以把代码中所有光源注释，执行代码，你无法正常看到工厂模型颜色。\n\n\n# 环境贴图\n\n如果你不设置任何光源和环境贴图，gltf模型默认PBR材质不会正常显示，一片漆黑。\n\n不过你不设置任何光源，只设置环境贴图，物体表面也能看到。虽然环境贴图不是光源，但是会模拟物体周围环境的反射光。就好比你站在街上，周围房子、树木、马路也会反射光线到你身上。\n\n通过.envMapIntensity可以调节环境贴图对模型外表面的影响程度,.envMapIntensity的值可以通过gui交互界面调节。\n\nconst textureCube = new THREE.CubeTextureLoader()\n    .setPath('./环境贴图/')\n    .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);\ntextureCube.encoding = THREE.sRGBEncoding;\nloader.load(\"../工厂.glb\", function (gltf) {\n    gltf.scene.traverse(function (obj) {\n        if (obj.isMesh) { //判断是否是网格模型\n            obj.material.envMap = textureCube; //设置环境贴图\n            obj.material.envMapIntensity = 1.0;\n        }\n    });\n})\n\n\n一般实际开发，对于偏向写实的场景，需要设置环境贴图，比如产品展示、物联网或数字孪生的场景。\n\n\n# 环境光\n\n一般三维场景需要添加环境光，来整体调节三维场景的明暗，环境光强度可以通过参数2，或光照强度属性.intensity设置。\n\n实际开发，可以先给一个大概的值，然后通过gui交互界面微调AmbientLight的光照强度属性.intensity。\n\nconst ambient = new THREE.AmbientLight(0xffffff, 0.4);\nscene.add(ambient);\n\n\n\n# GUI可视化调试\n\n关于gui的介绍，参考入门部分18. gui.js库(可视化改变三维场景)\n\n前面入门部分讲解过gui相关知识，对于光源的等参数，人的大脑很难根据代码想象出来具体效果，所以需要通过可视化的方式调参数。\n\n// 从threejs扩展库引入gui.js\nimport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new GUI();//创建GUI对象 \ngui.domElement.style.right = '0px';\ngui.domElement.style.width = '300px';\n\n\n\n# gui控制环境光光照强度.intensity\n\ngui.add(ambient, 'intensity', 0, 2).name('环境光.intensity');\n\n\n\n# GUI控制环境贴图强度.envMapIntensity\n\n通过材质的环境贴图强度属性.envMapIntensity，可以控制环境贴图对物体表面的影响程度，类比环境光的光照强度。\n\nconst obj = {\n    envMapIntensity:1.0,\n}\ngui.add(obj,'envMapIntensity',0,2).onChange(function(value){\n    // 递归遍历，批量设置模型材质的`.envMapIntensity`属性\n    gltf.scene.traverse(function (obj) {\n        if (obj.isMesh) {\n            obj.material.envMapIntensity = value;\n        }\n    });\n})\n",normalizedContent:"# 工厂光源(环境贴图和环境光)\n\n接下来两节课利用前面知识，给大家总结下，如何设置类似工厂、园区等3d场景的光照。\n\n * 环境贴图\n * 环境光\n * 平行光模拟太阳光(下节课内容)\n\n具体threejs知识点前面基本都讲解过，下面把重点放在整体思路讲解上，具体代码你可以参考课件源码。\n\n\n# 测试工厂模型中光源\n\n课件“演示”文件加载了一个工厂模型，你可以把代码中所有光源注释，执行代码，你无法正常看到工厂模型颜色。\n\n\n# 环境贴图\n\n如果你不设置任何光源和环境贴图，gltf模型默认pbr材质不会正常显示，一片漆黑。\n\n不过你不设置任何光源，只设置环境贴图，物体表面也能看到。虽然环境贴图不是光源，但是会模拟物体周围环境的反射光。就好比你站在街上，周围房子、树木、马路也会反射光线到你身上。\n\n通过.envmapintensity可以调节环境贴图对模型外表面的影响程度,.envmapintensity的值可以通过gui交互界面调节。\n\nconst texturecube = new three.cubetextureloader()\n    .setpath('./环境贴图/')\n    .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);\ntexturecube.encoding = three.srgbencoding;\nloader.load(\"../工厂.glb\", function (gltf) {\n    gltf.scene.traverse(function (obj) {\n        if (obj.ismesh) { //判断是否是网格模型\n            obj.material.envmap = texturecube; //设置环境贴图\n            obj.material.envmapintensity = 1.0;\n        }\n    });\n})\n\n\n一般实际开发，对于偏向写实的场景，需要设置环境贴图，比如产品展示、物联网或数字孪生的场景。\n\n\n# 环境光\n\n一般三维场景需要添加环境光，来整体调节三维场景的明暗，环境光强度可以通过参数2，或光照强度属性.intensity设置。\n\n实际开发，可以先给一个大概的值，然后通过gui交互界面微调ambientlight的光照强度属性.intensity。\n\nconst ambient = new three.ambientlight(0xffffff, 0.4);\nscene.add(ambient);\n\n\n\n# gui可视化调试\n\n关于gui的介绍，参考入门部分18. gui.js库(可视化改变三维场景)\n\n前面入门部分讲解过gui相关知识，对于光源的等参数，人的大脑很难根据代码想象出来具体效果，所以需要通过可视化的方式调参数。\n\n// 从threejs扩展库引入gui.js\nimport { gui } from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new gui();//创建gui对象 \ngui.domelement.style.right = '0px';\ngui.domelement.style.width = '300px';\n\n\n\n# gui控制环境光光照强度.intensity\n\ngui.add(ambient, 'intensity', 0, 2).name('环境光.intensity');\n\n\n\n# gui控制环境贴图强度.envmapintensity\n\n通过材质的环境贴图强度属性.envmapintensity，可以控制环境贴图对物体表面的影响程度，类比环境光的光照强度。\n\nconst obj = {\n    envmapintensity:1.0,\n}\ngui.add(obj,'envmapintensity',0,2).onchange(function(value){\n    // 递归遍历，批量设置模型材质的`.envmapintensity`属性\n    gltf.scene.traverse(function (obj) {\n        if (obj.ismesh) {\n            obj.material.envmapintensity = value;\n        }\n    });\n})\n",charsets:{cjk:!0}},{title:"7. 工厂(模拟太阳光阴影)",frontmatter:{title:"7. 工厂(模拟太阳光阴影)",date:"2023-02-18T20:31:46.000Z",permalink:"/pages/96077e/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/11.11.%E5%85%89%E6%BA%90%E5%92%8C%E9%98%B4%E5%BD%B1/07.%E5%B7%A5%E5%8E%82(%E6%A8%A1%E6%8B%9F%E5%A4%AA%E9%98%B3%E5%85%89%E9%98%B4%E5%BD%B1).html",relativePath:"01.Three.js教程/11.11.光源和阴影/07.工厂(模拟太阳光阴影).md",key:"v-5a5e0b82",path:"/pages/96077e/",headers:[{level:3,title:"工厂设置平行光阴影",slug:"工厂设置平行光阴影",normalizedTitle:"工厂设置平行光阴影",charIndex:66},{level:3,title:"设置工厂阴影范围",slug:"设置工厂阴影范围",normalizedTitle:"设置工厂阴影范围",charIndex:575},{level:3,title:"阴影条纹问题解决.shadowMap.type",slug:"阴影条纹问题解决-shadowmap-type",normalizedTitle:"阴影条纹问题解决.shadowmap.type",charIndex:1134},{level:3,title:"阴影像素.shadow.mapSize",slug:"阴影像素-shadow-mapsize",normalizedTitle:"阴影像素.shadow.mapsize",charIndex:1363},{level:3,title:"阴影边缘弱化.shadow.radius",slug:"阴影边缘弱化-shadow-radius",normalizedTitle:"阴影边缘弱化.shadow.radius",charIndex:1462}],headersStr:"工厂设置平行光阴影 设置工厂阴影范围 阴影条纹问题解决.shadowMap.type 阴影像素.shadow.mapSize 阴影边缘弱化.shadow.radius",content:"# 工厂(模拟太阳光阴影)\n\n真实生活中物体在太阳光下往往是有影子的，在threejs你可以通过平行光阴影模拟太阳光阴影。\n\n\n# 工厂设置平行光阴影\n\n首先你可以先回顾一下前面讲解的11.2 平行光阴影计算，设置工厂3D场景的平行光阴影流程是一样的。\n\n和前面设置一样，允许光源和渲染器光源投影计算。\n\ndirectionalLight.castShadow = true;\nrenderer.shadowMap.enabled = true; \n\n\n * .castShadow设置产生阴影的模型对象\n * .receiveShadow设置接收阴影效果的模型\n\n实际生活中所有物体都可以产生阴影，同时所有物体都可以接收其它物体的阴影，所以所有Mesh都批量设置.castShadow和.receiveShadow属性。\n\n//递归遍历场景，允许所有Mesh产生投影、接收投影\ngltf.scene.traverse(function (obj) {\n    if (obj.isMesh) { //判断是否是网格模型\n        // 批量设置所有Mesh都可以产生阴影和接收阴影\n        obj.castShadow = true;\n        obj.receiveShadow = true;\n    }\n});\n\n\n\n# 设置工厂阴影范围\n\n首先要明确工厂需要阴影计算的尺寸范围，课件源码中提供的工厂尺寸量级大概是100左右，然后根据工厂尺寸量级设置光源阴影范围参数.shadow.camera。\n\n可以先根据工厂尺寸，预先设置.shadow.camera，然后再具体调试参数。\n\n// 设置三维场景计算阴影的范围\ndirectionalLight.shadow.camera.left = -100;\ndirectionalLight.shadow.camera.right = 100;\ndirectionalLight.shadow.camera.top = 100;\ndirectionalLight.shadow.camera.bottom = -100;\ndirectionalLight.shadow.camera.near = 0.5;\ndirectionalLight.shadow.camera.far = 100;\n\n\nCameraHelper辅助调试参数\n\n// 可视化平行光阴影对应的正投影相机对象\nconst cameraHelper = new THREE.CameraHelper(directionalLight.shadow.camera);\nscene.add(cameraHelper);\n\n\n\n# 阴影条纹问题解决.shadowMap.type\n\nWebGL的渲染器的阴影贴图属性.shadowMap的属性值是一个对象，.shadowMap具有.enabled、.type等属性。\n\n模型表面产生条纹影响渲染效果，可以改变.shadowMap.type默认值优化\n\n// 模型表面产生条纹影响渲染效果，可以改变.shadowMap.type默认值优化\nrenderer.shadowMap.type = THREE.VSMShadowMap; \n\n\n\n# 阴影像素.shadow.mapSize\n\n// 如果阴影边缘锯齿感的时候，可以适当提升像素\ndirectionalLight.shadow.mapSize.set(1024,1024);\n\n\n\n# 阴影边缘弱化.shadow.radius\n\n// 模糊弱化阴影边缘\ndirectionalLight.shadow.radius = 3;\n",normalizedContent:"# 工厂(模拟太阳光阴影)\n\n真实生活中物体在太阳光下往往是有影子的，在threejs你可以通过平行光阴影模拟太阳光阴影。\n\n\n# 工厂设置平行光阴影\n\n首先你可以先回顾一下前面讲解的11.2 平行光阴影计算，设置工厂3d场景的平行光阴影流程是一样的。\n\n和前面设置一样，允许光源和渲染器光源投影计算。\n\ndirectionallight.castshadow = true;\nrenderer.shadowmap.enabled = true; \n\n\n * .castshadow设置产生阴影的模型对象\n * .receiveshadow设置接收阴影效果的模型\n\n实际生活中所有物体都可以产生阴影，同时所有物体都可以接收其它物体的阴影，所以所有mesh都批量设置.castshadow和.receiveshadow属性。\n\n//递归遍历场景，允许所有mesh产生投影、接收投影\ngltf.scene.traverse(function (obj) {\n    if (obj.ismesh) { //判断是否是网格模型\n        // 批量设置所有mesh都可以产生阴影和接收阴影\n        obj.castshadow = true;\n        obj.receiveshadow = true;\n    }\n});\n\n\n\n# 设置工厂阴影范围\n\n首先要明确工厂需要阴影计算的尺寸范围，课件源码中提供的工厂尺寸量级大概是100左右，然后根据工厂尺寸量级设置光源阴影范围参数.shadow.camera。\n\n可以先根据工厂尺寸，预先设置.shadow.camera，然后再具体调试参数。\n\n// 设置三维场景计算阴影的范围\ndirectionallight.shadow.camera.left = -100;\ndirectionallight.shadow.camera.right = 100;\ndirectionallight.shadow.camera.top = 100;\ndirectionallight.shadow.camera.bottom = -100;\ndirectionallight.shadow.camera.near = 0.5;\ndirectionallight.shadow.camera.far = 100;\n\n\ncamerahelper辅助调试参数\n\n// 可视化平行光阴影对应的正投影相机对象\nconst camerahelper = new three.camerahelper(directionallight.shadow.camera);\nscene.add(camerahelper);\n\n\n\n# 阴影条纹问题解决.shadowmap.type\n\nwebgl的渲染器的阴影贴图属性.shadowmap的属性值是一个对象，.shadowmap具有.enabled、.type等属性。\n\n模型表面产生条纹影响渲染效果，可以改变.shadowmap.type默认值优化\n\n// 模型表面产生条纹影响渲染效果，可以改变.shadowmap.type默认值优化\nrenderer.shadowmap.type = three.vsmshadowmap; \n\n\n\n# 阴影像素.shadow.mapsize\n\n// 如果阴影边缘锯齿感的时候，可以适当提升像素\ndirectionallight.shadow.mapsize.set(1024,1024);\n\n\n\n# 阴影边缘弱化.shadow.radius\n\n// 模糊弱化阴影边缘\ndirectionallight.shadow.radius = 3;\n",charsets:{cjk:!0}},{title:"8. gui辅助调节光源阴影",frontmatter:{title:"8. gui辅助调节光源阴影",date:"2023-02-18T20:31:59.000Z",permalink:"/pages/3f1331/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/11.11.%E5%85%89%E6%BA%90%E5%92%8C%E9%98%B4%E5%BD%B1/08.gui%E8%BE%85%E5%8A%A9%E8%B0%83%E8%8A%82%E5%85%89%E6%BA%90%E9%98%B4%E5%BD%B1.html",relativePath:"01.Three.js教程/11.11.光源和阴影/08.gui辅助调节光源阴影.md",key:"v-4f8bdade",path:"/pages/3f1331/",headers:[{level:3,title:"阴影范围可视化调节",slug:"阴影范围可视化调节",normalizedTitle:"阴影范围可视化调节",charIndex:88}],headersStr:"阴影范围可视化调节",content:"# gui辅助调节阴影范围\n\n光源阴影范围，也可以通过GUI界面可视化调节，这样更形象。\n\n关于gui的介绍，参考入门部分18. gui.js库(可视化改变三维场景)\n\n\n# 阴影范围可视化调节\n\n * 根据工厂尺寸数量级预先设置.shadow.camera，然后通过GUI调试选择一个合适的值\n * .shadow.camera的位置通过光源的位置调试。\n * .shadow.camera参数改变后，注意执行cameraHelper.update();更新\n\n// 阴影子菜单\nconst shadowFolder = gui.addFolder('平行光阴影');\nconst cam = directionalLight.shadow.camera;\n// 相机left、right等属性变化执行.updateProjectionMatrix();\n// 相机变化了，执行CameraHelper的更新方法.update();\nshadowFolder.add(cam,'left',-500,0).onChange(function(v){\n    cam.updateProjectionMatrix();//相机更新投影矩阵\n    cameraHelper.update();//相机范围变化了，相机辅助对象更新\n});\n\n\n其他参数类似设置\n\nshadowFolder.add(cam,'right',0,500).onChange(function(v){\n    cam.updateProjectionMatrix();\n    cameraHelper.update();\n});\nshadowFolder.add(cam,'top',0,500).onChange(function(v){\n    cam.updateProjectionMatrix();\n    cameraHelper.update();\n});\nshadowFolder.add(cam,'bottom',-500,0).onChange(function(v){\n    cam.updateProjectionMatrix();\n    cameraHelper.update();\n});\nshadowFolder.add(cam,'far',0,1000).onChange(function(v){\n    cam.updateProjectionMatrix();\n    cameraHelper.update();\n});\n\n",normalizedContent:"# gui辅助调节阴影范围\n\n光源阴影范围，也可以通过gui界面可视化调节，这样更形象。\n\n关于gui的介绍，参考入门部分18. gui.js库(可视化改变三维场景)\n\n\n# 阴影范围可视化调节\n\n * 根据工厂尺寸数量级预先设置.shadow.camera，然后通过gui调试选择一个合适的值\n * .shadow.camera的位置通过光源的位置调试。\n * .shadow.camera参数改变后，注意执行camerahelper.update();更新\n\n// 阴影子菜单\nconst shadowfolder = gui.addfolder('平行光阴影');\nconst cam = directionallight.shadow.camera;\n// 相机left、right等属性变化执行.updateprojectionmatrix();\n// 相机变化了，执行camerahelper的更新方法.update();\nshadowfolder.add(cam,'left',-500,0).onchange(function(v){\n    cam.updateprojectionmatrix();//相机更新投影矩阵\n    camerahelper.update();//相机范围变化了，相机辅助对象更新\n});\n\n\n其他参数类似设置\n\nshadowfolder.add(cam,'right',0,500).onchange(function(v){\n    cam.updateprojectionmatrix();\n    camerahelper.update();\n});\nshadowfolder.add(cam,'top',0,500).onchange(function(v){\n    cam.updateprojectionmatrix();\n    camerahelper.update();\n});\nshadowfolder.add(cam,'bottom',-500,0).onchange(function(v){\n    cam.updateprojectionmatrix();\n    camerahelper.update();\n});\nshadowfolder.add(cam,'far',0,1000).onchange(function(v){\n    cam.updateprojectionmatrix();\n    camerahelper.update();\n});\n\n",charsets:{cjk:!0}},{title:"2. 精灵模型标注场景(贴图)",frontmatter:{title:"2. 精灵模型标注场景(贴图)",date:"2023-02-25T16:20:31.000Z",permalink:"/pages/bd93e5/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/12.12.%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8BSprite/02.%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8B%E6%A0%87%E6%B3%A8%E5%9C%BA%E6%99%AF(%E8%B4%B4%E5%9B%BE).html",relativePath:"01.Three.js教程/12.12.精灵模型Sprite/02.精灵模型标注场景(贴图).md",key:"v-44f45938",path:"/pages/bd93e5/",headers:[{level:3,title:"精灵模型设置颜色贴图.map",slug:"精灵模型设置颜色贴图-map",normalizedTitle:"精灵模型设置颜色贴图.map",charIndex:221},{level:3,title:".transparent属性",slug:"transparent属性",normalizedTitle:".transparent属性",charIndex:458},{level:3,title:".color与.map混合",slug:"color与-map混合",normalizedTitle:".color与.map混合",charIndex:683},{level:3,title:"Sprite标注三维场景",slug:"sprite标注三维场景",normalizedTitle:"sprite标注三维场景",charIndex:109}],headersStr:"精灵模型设置颜色贴图.map .transparent属性 .color与.map混合 Sprite标注三维场景",content:'# 精灵模型标注场景(贴图)\n\n前面课程5.5小节讲解过一个例子，就是通过矩形平面Mesh + 贴图标注三维场景。\n\n不过有些时候，你也可以通过Sprite+贴图标注三维场景。\n\n你可以对比案例源码中矩形平面Mesh和Sprite标注三维场景差异。\n\n大家根据需要选择Sprite或矩形Mesh标注场景，如果希望矩形始终平行于canvas画布，就选择Sprite，如果希望矩形标注姿态角度能跟着场景旋转，就使用矩形Mesh标注场景。\n\n\n# 精灵模型设置颜色贴图.map\n\n精灵材质对象SpriteMaterial和普通的网格材质一样具有颜色贴图.map、开启透明.transparent、透明度.opacity等属性。\n\nconst texture = new THREE.TextureLoader().load("./光点.png");\nconst spriteMaterial = new THREE.SpriteMaterial({\n  map: texture, //设置精灵纹理贴图\n});\n\n\n\n# .transparent属性\n\n网格材质.transparent属性默认是false，如果贴图是背景透明的png贴图，需要把.transparent设置为true，对于SpriteMaterial而言，.transparent默认是true。\n\nconst spriteMaterial = new THREE.SpriteMaterial({\n  transparent:true,//SpriteMaterial默认是true\n});\n\n\n\n# .color与.map混合\n\n如果.map是纯白色贴图，你可以通过设置.color,把精灵模型设置为其他任意颜色。一般来说美术把颜色贴图设置为合适的颜色，你就不用再设置.color。\n\nconst spriteMaterial = new THREE.SpriteMaterial({\n  color:0x00ffff,//设置颜色\n  map: texture, //设置精灵纹理贴图\n});\n\n\n\n# Sprite标注三维场景\n\n需要在长方体网格模型的顶部中间添加一个Sprite标注。\n\nconst geometry = new THREE.BoxGeometry(25, 100, 50);\ngeometry.translate(0, 50, 0);\n// mesh顶部中心添加标注，顶部中心坐标是(0,100,0)\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n标注大小，根据场景渲染范围尺寸或者说要标注的物体的尺寸数量级，设置sprite的大小。不用具体，先设置一个大概值，只要和要标注的物体尺寸数量级相差不大即可，再根据需要缩放尺寸。\n\nsprite.scale.set(10, 10, 1);\n\n\n根据标注位置，设置精灵模型在三维空间中的位置坐标，注意考虑模型对象的大小\n\nsprite.position.set(0, 100 + 10/2, 0);//设置位置，要考虑sprite尺寸影响\n',normalizedContent:'# 精灵模型标注场景(贴图)\n\n前面课程5.5小节讲解过一个例子，就是通过矩形平面mesh + 贴图标注三维场景。\n\n不过有些时候，你也可以通过sprite+贴图标注三维场景。\n\n你可以对比案例源码中矩形平面mesh和sprite标注三维场景差异。\n\n大家根据需要选择sprite或矩形mesh标注场景，如果希望矩形始终平行于canvas画布，就选择sprite，如果希望矩形标注姿态角度能跟着场景旋转，就使用矩形mesh标注场景。\n\n\n# 精灵模型设置颜色贴图.map\n\n精灵材质对象spritematerial和普通的网格材质一样具有颜色贴图.map、开启透明.transparent、透明度.opacity等属性。\n\nconst texture = new three.textureloader().load("./光点.png");\nconst spritematerial = new three.spritematerial({\n  map: texture, //设置精灵纹理贴图\n});\n\n\n\n# .transparent属性\n\n网格材质.transparent属性默认是false，如果贴图是背景透明的png贴图，需要把.transparent设置为true，对于spritematerial而言，.transparent默认是true。\n\nconst spritematerial = new three.spritematerial({\n  transparent:true,//spritematerial默认是true\n});\n\n\n\n# .color与.map混合\n\n如果.map是纯白色贴图，你可以通过设置.color,把精灵模型设置为其他任意颜色。一般来说美术把颜色贴图设置为合适的颜色，你就不用再设置.color。\n\nconst spritematerial = new three.spritematerial({\n  color:0x00ffff,//设置颜色\n  map: texture, //设置精灵纹理贴图\n});\n\n\n\n# sprite标注三维场景\n\n需要在长方体网格模型的顶部中间添加一个sprite标注。\n\nconst geometry = new three.boxgeometry(25, 100, 50);\ngeometry.translate(0, 50, 0);\n// mesh顶部中心添加标注，顶部中心坐标是(0,100,0)\nconst mesh = new three.mesh(geometry, material);\n\n\n标注大小，根据场景渲染范围尺寸或者说要标注的物体的尺寸数量级，设置sprite的大小。不用具体，先设置一个大概值，只要和要标注的物体尺寸数量级相差不大即可，再根据需要缩放尺寸。\n\nsprite.scale.set(10, 10, 1);\n\n\n根据标注位置，设置精灵模型在三维空间中的位置坐标，注意考虑模型对象的大小\n\nsprite.position.set(0, 100 + 10/2, 0);//设置位置，要考虑sprite尺寸影响\n',charsets:{cjk:!0}},{title:"3. Sprite模拟下雨、下雪",frontmatter:{title:"3. Sprite模拟下雨、下雪",date:"2023-02-25T16:20:46.000Z",permalink:"/pages/477843/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/12.12.%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8BSprite/03.Sprite%E6%A8%A1%E6%8B%9F%E4%B8%8B%E9%9B%A8%E3%80%81%E4%B8%8B%E9%9B%AA.html",relativePath:"01.Three.js教程/12.12.精灵模型Sprite/03.Sprite模拟下雨、下雪.md",key:"v-3a585300",path:"/pages/477843/",headers:[{level:3,title:"Sprite模拟雨滴",slug:"sprite模拟雨滴",normalizedTitle:"sprite模拟雨滴",charIndex:172},{level:3,title:"雨滴在3D空间随机分布",slug:"雨滴在3d空间随机分布",normalizedTitle:"雨滴在3d空间随机分布",charIndex:474},{level:3,title:"周期性改变雨滴Sprite位置",slug:"周期性改变雨滴sprite位置",normalizedTitle:"周期性改变雨滴sprite位置",charIndex:952},{level:3,title:"根据时间计算Sprite位置",slug:"根据时间计算sprite位置",normalizedTitle:"根据时间计算sprite位置",charIndex:1321},{level:3,title:"相机镜头附近的雨滴偏大",slug:"相机镜头附近的雨滴偏大",normalizedTitle:"相机镜头附近的雨滴偏大",charIndex:1681},{level:3,title:"下雪效果模拟",slug:"下雪效果模拟",normalizedTitle:"下雪效果模拟",charIndex:2027}],headersStr:"Sprite模拟雨滴 雨滴在3D空间随机分布 周期性改变雨滴Sprite位置 根据时间计算Sprite位置 相机镜头附近的雨滴偏大 下雪效果模拟",content:'# Sprite模拟下雨、下雪\n\n在实际开发的时候，物联网3D可视化、数字孪生、游戏等项目可能会模拟天气的效果。\n\n如果你想模拟下雨效果，一个雨滴用一个3D水滴形曲面表示，假设一个水滴用40个三角形表示，1万个雨滴，就是40万个三角形，精灵模型Sprite在threejs内部就像相当于两个三角形构成的矩形，1万个精灵模型，相当于2万个三角形，Sprite模拟雨滴相比比3D曲面几何体表示雨滴顶点数量就会少很多，这样threejs渲染性能就更好。\n\n\n# Sprite模拟雨滴\n\n提供一个背景透明的png雨滴贴图，然后作为Sprite的颜色贴图，用来模拟雨滴3D几何体。\n\nconst texture = new THREE.TextureLoader().load("./雨滴.png");\nconst spriteMaterial = new THREE.SpriteMaterial({\n    map: texture, \n});\nconst sprite = new THREE.Sprite(spriteMaterial);\n\n\n\n# 雨滴在3D空间随机分布\n\n批量创建多个精灵模型，在一个长方体空间上随机分布。\n\nSprite分布渲染范围和数量，根据渲染范围来预先给一个大概的值，然后可以根据需要，在调整雨滴分布范围尺寸。\n\nconst group = new THREE.Group();\nfor (let i = 0; i < 16000; i++) {\n    // 精灵模型共享材质\n    const sprite = new THREE.Sprite(spriteMaterial);\n    group.add(sprite);\n    sprite.scale.set(1, 1, 1);\n    // 设置精灵模型位置，在长方体空间上上随机分布\n    const x = 1000 * (Math.random() - 0.5);\n    const y = 600 * Math.random();\n    const z = 1000 * (Math.random() - 0.5);\n    sprite.position.set(x, y, z)\n}\n\n\n\n# 周期性改变雨滴Sprite位置\n\nfunction loop() {\n    // loop()每次执行都会更新雨滴的位置，进而产生动画效果\n    group.children.forEach(sprite => {\n        // 雨滴的y坐标每次减1\n        sprite.position.y -= 1;\n        if (sprite.position.y < 0) {\n            // 如果雨滴落到地面，重置y，从新下落\n            sprite.position.y = 600;\n        }\n    });\n    requestAnimationFrame(loop);\n}\nloop();\n\n\nloop()执行时间间隔和渲染循环render()是一样的。\n\n\n# 根据时间计算Sprite位置\n\nconst clock = new THREE.Clock();\nfunction loop() {\n    // loop()两次执行时间间隔\n    const t = clock.getDelta();\n    group.children.forEach(sprite => {\n        // 雨滴的y坐标每次减t*60\n        sprite.position.y -= t*60;\n        if (sprite.position.y < 0) {\n            sprite.position.y = 600;\n        }\n    });\n    requestAnimationFrame(loop);\n}\nloop();\n\n\n\n# 相机镜头附近的雨滴偏大\n\n相机在下雨的场景中，相机会渲染near~far范围的Sprite，距离相机0~near范围不会渲染，小部分Sprite会在相机镜头前经过，大家都知道透视投影远小近大，这时候相机near附近雨滴Sprite会显示比较大，你可以把near调整大一些，这样距离相机非常近的Sprite不会渲染。\n\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\n\n\nnear调整大一些，避免距离相机非常近的雨滴渲染非常大的现象。\n\nconst camera = new THREE.PerspectiveCamera(30, width / height, 50, 3000);\n\n\n\n# 下雪效果模拟\n\n把雨滴代码中与雨滴贴图更换雪花纹理贴图，雪花下降速度可以适当调整。当然这也只是近似模拟，比如雪花随风飘动、角度旋转等等都没有模拟。\n\nconst texture = new THREE.TextureLoader().load("./雪花.png");\n',normalizedContent:'# sprite模拟下雨、下雪\n\n在实际开发的时候，物联网3d可视化、数字孪生、游戏等项目可能会模拟天气的效果。\n\n如果你想模拟下雨效果，一个雨滴用一个3d水滴形曲面表示，假设一个水滴用40个三角形表示，1万个雨滴，就是40万个三角形，精灵模型sprite在threejs内部就像相当于两个三角形构成的矩形，1万个精灵模型，相当于2万个三角形，sprite模拟雨滴相比比3d曲面几何体表示雨滴顶点数量就会少很多，这样threejs渲染性能就更好。\n\n\n# sprite模拟雨滴\n\n提供一个背景透明的png雨滴贴图，然后作为sprite的颜色贴图，用来模拟雨滴3d几何体。\n\nconst texture = new three.textureloader().load("./雨滴.png");\nconst spritematerial = new three.spritematerial({\n    map: texture, \n});\nconst sprite = new three.sprite(spritematerial);\n\n\n\n# 雨滴在3d空间随机分布\n\n批量创建多个精灵模型，在一个长方体空间上随机分布。\n\nsprite分布渲染范围和数量，根据渲染范围来预先给一个大概的值，然后可以根据需要，在调整雨滴分布范围尺寸。\n\nconst group = new three.group();\nfor (let i = 0; i < 16000; i++) {\n    // 精灵模型共享材质\n    const sprite = new three.sprite(spritematerial);\n    group.add(sprite);\n    sprite.scale.set(1, 1, 1);\n    // 设置精灵模型位置，在长方体空间上上随机分布\n    const x = 1000 * (math.random() - 0.5);\n    const y = 600 * math.random();\n    const z = 1000 * (math.random() - 0.5);\n    sprite.position.set(x, y, z)\n}\n\n\n\n# 周期性改变雨滴sprite位置\n\nfunction loop() {\n    // loop()每次执行都会更新雨滴的位置，进而产生动画效果\n    group.children.foreach(sprite => {\n        // 雨滴的y坐标每次减1\n        sprite.position.y -= 1;\n        if (sprite.position.y < 0) {\n            // 如果雨滴落到地面，重置y，从新下落\n            sprite.position.y = 600;\n        }\n    });\n    requestanimationframe(loop);\n}\nloop();\n\n\nloop()执行时间间隔和渲染循环render()是一样的。\n\n\n# 根据时间计算sprite位置\n\nconst clock = new three.clock();\nfunction loop() {\n    // loop()两次执行时间间隔\n    const t = clock.getdelta();\n    group.children.foreach(sprite => {\n        // 雨滴的y坐标每次减t*60\n        sprite.position.y -= t*60;\n        if (sprite.position.y < 0) {\n            sprite.position.y = 600;\n        }\n    });\n    requestanimationframe(loop);\n}\nloop();\n\n\n\n# 相机镜头附近的雨滴偏大\n\n相机在下雨的场景中，相机会渲染near~far范围的sprite，距离相机0~near范围不会渲染，小部分sprite会在相机镜头前经过，大家都知道透视投影远小近大，这时候相机near附近雨滴sprite会显示比较大，你可以把near调整大一些，这样距离相机非常近的sprite不会渲染。\n\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\n\n\nnear调整大一些，避免距离相机非常近的雨滴渲染非常大的现象。\n\nconst camera = new three.perspectivecamera(30, width / height, 50, 3000);\n\n\n\n# 下雪效果模拟\n\n把雨滴代码中与雨滴贴图更换雪花纹理贴图，雪花下降速度可以适当调整。当然这也只是近似模拟，比如雪花随风飘动、角度旋转等等都没有模拟。\n\nconst texture = new three.textureloader().load("./雪花.png");\n',charsets:{cjk:!0}},{title:"1. 精灵模型Sprite",frontmatter:{title:"1. 精灵模型Sprite",date:"2023-02-25T16:20:12.000Z",permalink:"/pages/75d790/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/12.12.%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8BSprite/01.%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8BSprite.html",relativePath:"01.Three.js教程/12.12.精灵模型Sprite/01.精灵模型Sprite.md",key:"v-41dffdd4",path:"/pages/75d790/",headers:[{level:3,title:"创建精灵模型材质SpriteMaterial",slug:"创建精灵模型材质spritematerial",normalizedTitle:"创建精灵模型材质spritematerial",charIndex:172},{level:3,title:"创建精灵模型Sprite",slug:"创建精灵模型sprite",normalizedTitle:"创建精灵模型sprite",charIndex:428},{level:3,title:"正投影相机验证Sprite尺寸",slug:"正投影相机验证sprite尺寸",normalizedTitle:"正投影相机验证sprite尺寸",charIndex:762},{level:3,title:"对比Sprite和矩形平面Mesh",slug:"对比sprite和矩形平面mesh",normalizedTitle:"对比sprite和矩形平面mesh",charIndex:999},{level:3,title:"Sprite属性.position、.scale",slug:"sprite属性-position、-scale",normalizedTitle:"sprite属性.position、.scale",charIndex:1198},{level:3,title:"对比尺寸相同Spirte和矩形平面Mesh",slug:"对比尺寸相同spirte和矩形平面mesh",normalizedTitle:"对比尺寸相同spirte和矩形平面mesh",charIndex:1476},{level:3,title:"SpriteMaterial旋转属性.rotation",slug:"spritematerial旋转属性-rotation",normalizedTitle:"spritematerial旋转属性.rotation",charIndex:1864}],headersStr:"创建精灵模型材质SpriteMaterial 创建精灵模型Sprite 正投影相机验证Sprite尺寸 对比Sprite和矩形平面Mesh Sprite属性.position、.scale 对比尺寸相同Spirte和矩形平面Mesh SpriteMaterial旋转属性.rotation",content:"# 精灵模型Sprite\n\nThree.js的精灵模型Sprite和Threejs的网格模型Mesh一样都是模型对象，父类都是Object3D,关于精灵模型对象Sprite的方法和属性除了可以查看文档Sprite，也可以查看父类Object3D。\n\n第一次接触精灵模型Sprite的时候，可以类比以前讲解过的网格模型Mesh学习。\n\n\n\n\n# 创建精灵模型材质SpriteMaterial\n\n\n\n精灵材质对象SpriteMaterial和普通的网格材质一样可以设置颜色.color、颜色贴图.map、开启透明.transparent、透明度.opacity等属性，精灵材质对象SpriteMaterial的父类是材质Material。\n\n// 创建精灵材质对象SpriteMaterial\nconst spriteMaterial = new THREE.SpriteMaterial({\n  color:0x00ffff,//设置颜色\n});\n\n\n\n# 创建精灵模型Sprite\n\n创建精灵模型对象Sprite和创建网格模型对象一样需要创建一个材质对象，不同的地方在于创建精灵模型对象不需要创建几何体对象Geometry。\n\n// 创建精灵模型对象，不需要几何体geometry参数\nconst sprite = new THREE.Sprite(spriteMaterial);\n\n\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n精灵模型Sprite默认是一个矩形形状，默认长宽都是1，默认在坐标原点位置。Sprite默认尺寸为1，如果你在画布上看不太清，可以适当调整相机参数。\n\n对于透视投影相机而言，Sprite和Mesh一样遵循远小近大的投影规律。\n\n\n# 正投影相机验证Sprite尺寸\n\nSprite默认尺寸是1，如果正投影相机对象的top, bottom范围分别为0.5，-0.5，上下方向渲染范围是1，精灵模型默认尺寸长宽都是1，这样刚好上下方向100%填充画布。\n\nconst s = 0.5;//控制left, right, top, bottom范围大小\nconst camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 8000);\n\n\n\n# 对比Sprite和矩形平面Mesh\n\nSprite形状是矩形，PlaneGeometry创建的网格模型Mesh的形状也是矩形。\n\nSprite与矩形平面Mesh的区别在于,当你旋转三维场景的时候，如果通过相机控件OrbitControls旋转测试，你可以发现Sprite矩形平面会始终平行于Canvas画布或者说屏幕，而矩形平面Mesh的姿态角度会跟着旋转，不一定平行于canvas画布。\n\n\n# Sprite属性.position、.scale\n\n精灵模型Sprite和Mesh一样具有位置.position和缩放.scale属性。\n\nsprite.scale只需要设置x、y两个分量就可以，z方向默认值就行。\n\n// 控制精灵大小\nconsole.log('sprite.scale',sprite.scale);\nsprite.scale.set(50, 25, 1); //只需要设置x、y两个分量就可以\n\n\nsprite.position设置精灵模型在三维空间中的位置坐标\n\nsprite.position.set(0,50,0);\n\n\n\n# 对比尺寸相同Spirte和矩形平面Mesh\n\n对于网格模型Mesh而言，可以通过几何体geometry和mesh.scale定义尺寸，Spirte没有几何体，需要通过sprite.scale定义矩形精灵的长和宽。\n\n打开案例源码“3.对比相同尺寸Sprite和矩形Mesh”，对比相同尺寸Spirte和矩形平面Mesh渲染效果，进一步掌握Sprite尺寸定义。\n\n// 尺寸相同的Sprite和矩形平面Mesh\nconst sprite = new THREE.Sprite(spriteMaterial);\nsprite.scale.set(50, 25, 1);\nconst geometry = new THREE.PlaneGeometry(50, 25);\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n\n# SpriteMaterial旋转属性.rotation\n\n精灵材质SpriteMaterial的属性除了和网格材质类似的属性和方法外，还有一些自己独特的方法和属性，比如.rotation旋转精灵模型，更多相关属性和方法可以查看threejs文档关于SpriteMaterial的介绍。\n\nconst spriteMaterial = new THREE.SpriteMaterial({\n  rotation:Math.PI/4,//旋转精灵对象45度，弧度值\n});\n",normalizedContent:"# 精灵模型sprite\n\nthree.js的精灵模型sprite和threejs的网格模型mesh一样都是模型对象，父类都是object3d,关于精灵模型对象sprite的方法和属性除了可以查看文档sprite，也可以查看父类object3d。\n\n第一次接触精灵模型sprite的时候，可以类比以前讲解过的网格模型mesh学习。\n\n\n\n\n# 创建精灵模型材质spritematerial\n\n\n\n精灵材质对象spritematerial和普通的网格材质一样可以设置颜色.color、颜色贴图.map、开启透明.transparent、透明度.opacity等属性，精灵材质对象spritematerial的父类是材质material。\n\n// 创建精灵材质对象spritematerial\nconst spritematerial = new three.spritematerial({\n  color:0x00ffff,//设置颜色\n});\n\n\n\n# 创建精灵模型sprite\n\n创建精灵模型对象sprite和创建网格模型对象一样需要创建一个材质对象，不同的地方在于创建精灵模型对象不需要创建几何体对象geometry。\n\n// 创建精灵模型对象，不需要几何体geometry参数\nconst sprite = new three.sprite(spritematerial);\n\n\nconst mesh = new three.mesh(geometry, material);\n\n\n精灵模型sprite默认是一个矩形形状，默认长宽都是1，默认在坐标原点位置。sprite默认尺寸为1，如果你在画布上看不太清，可以适当调整相机参数。\n\n对于透视投影相机而言，sprite和mesh一样遵循远小近大的投影规律。\n\n\n# 正投影相机验证sprite尺寸\n\nsprite默认尺寸是1，如果正投影相机对象的top, bottom范围分别为0.5，-0.5，上下方向渲染范围是1，精灵模型默认尺寸长宽都是1，这样刚好上下方向100%填充画布。\n\nconst s = 0.5;//控制left, right, top, bottom范围大小\nconst camera = new three.orthographiccamera(-s * k, s * k, s, -s, 1, 8000);\n\n\n\n# 对比sprite和矩形平面mesh\n\nsprite形状是矩形，planegeometry创建的网格模型mesh的形状也是矩形。\n\nsprite与矩形平面mesh的区别在于,当你旋转三维场景的时候，如果通过相机控件orbitcontrols旋转测试，你可以发现sprite矩形平面会始终平行于canvas画布或者说屏幕，而矩形平面mesh的姿态角度会跟着旋转，不一定平行于canvas画布。\n\n\n# sprite属性.position、.scale\n\n精灵模型sprite和mesh一样具有位置.position和缩放.scale属性。\n\nsprite.scale只需要设置x、y两个分量就可以，z方向默认值就行。\n\n// 控制精灵大小\nconsole.log('sprite.scale',sprite.scale);\nsprite.scale.set(50, 25, 1); //只需要设置x、y两个分量就可以\n\n\nsprite.position设置精灵模型在三维空间中的位置坐标\n\nsprite.position.set(0,50,0);\n\n\n\n# 对比尺寸相同spirte和矩形平面mesh\n\n对于网格模型mesh而言，可以通过几何体geometry和mesh.scale定义尺寸，spirte没有几何体，需要通过sprite.scale定义矩形精灵的长和宽。\n\n打开案例源码“3.对比相同尺寸sprite和矩形mesh”，对比相同尺寸spirte和矩形平面mesh渲染效果，进一步掌握sprite尺寸定义。\n\n// 尺寸相同的sprite和矩形平面mesh\nconst sprite = new three.sprite(spritematerial);\nsprite.scale.set(50, 25, 1);\nconst geometry = new three.planegeometry(50, 25);\nconst mesh = new three.mesh(geometry, material);\n\n\n\n# spritematerial旋转属性.rotation\n\n精灵材质spritematerial的属性除了和网格材质类似的属性和方法外，还有一些自己独特的方法和属性，比如.rotation旋转精灵模型，更多相关属性和方法可以查看threejs文档关于spritematerial的介绍。\n\nconst spritematerial = new three.spritematerial({\n  rotation:math.pi/4,//旋转精灵对象45度，弧度值\n});\n",charsets:{cjk:!0}},{title:"1. 后处理(发光描边OutlinePass)",frontmatter:{title:"1. 后处理(发光描边OutlinePass)",date:"2023-02-25T16:21:29.000Z",permalink:"/pages/e1e75d/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/13.13.%E5%90%8E%E5%A4%84%E7%90%86EffectComposer/01.%E5%90%8E%E5%A4%84%E7%90%86(%E9%AB%98%E4%BA%AE%E5%8F%91%E5%85%89%E6%8F%8F%E8%BE%B9OutlinePass).html",relativePath:"01.Three.js教程/13.13.后处理EffectComposer/01.后处理(高亮发光描边OutlinePass).md",key:"v-f21ec9e0",path:"/pages/e1e75d/",headers:[{level:3,title:"不同功能后处理通道",slug:"不同功能后处理通道",normalizedTitle:"不同功能后处理通道",charIndex:194},{level:3,title:"引入EffectComposer.js",slug:"引入effectcomposer-js",normalizedTitle:"引入effectcomposer.js",charIndex:464},{level:3,title:"渲染器通道RenderPass",slug:"渲染器通道renderpass",normalizedTitle:"渲染器通道renderpass",charIndex:854},{level:3,title:"OutlinePass通道",slug:"outlinepass通道",normalizedTitle:"outlinepass通道",charIndex:1278},{level:3,title:"OutlinePass属性.selectedObjects",slug:"outlinepass属性-selectedobjects",normalizedTitle:"outlinepass属性.selectedobjects",charIndex:1704},{level:3,title:"设置OutlinePass通道",slug:"设置outlinepass通道",normalizedTitle:"设置outlinepass通道",charIndex:1931},{level:3,title:"渲染循环执行EffectComposer.render()",slug:"渲染循环执行effectcomposer-render",normalizedTitle:"渲染循环执行effectcomposer.render()",charIndex:2041},{level:3,title:"修改OutlinePass默认描边效果",slug:"修改outlinepass默认描边效果",normalizedTitle:"修改outlinepass默认描边效果",charIndex:2313}],headersStr:"不同功能后处理通道 引入EffectComposer.js 渲染器通道RenderPass OutlinePass通道 OutlinePass属性.selectedObjects 设置OutlinePass通道 渲染循环执行EffectComposer.render() 修改OutlinePass默认描边效果",content:"# 后处理(高亮发光描边OutlinePass)\n\n查看threejs文件包目录examples/jsm/postprocessing/，你可以看到Three.js提供了一个扩展库EffectComposer.js,通过EffectComposer可以实现一些后期处理效果。\n\n所谓threejs后期处理，就像ps一样，对threejs的渲染结果进行后期处理，比如添加发光效果。\n\n\n# 不同功能后处理通道\n\n查看threejs文件包目录examples/jsm/postprocessing/，你可以看到threejs提供了很多后处理通道，想实现什么样的后期处理效果，需要调用threejs对应的后处理通道扩展库。\n\n * OutlinePass.js：高亮发光描边\n * UnrealBloomPass.js：Bloom发光\n * GlitchPass.js：画面抖动效果\n\n比如OutlinePass.js扩展库提供的类OutlinePass就可以给一个模型添加一个高亮发光描边，下面就给大家演示下如何实现。\n\n\n\n\n# 引入EffectComposer.js\n\n你可以在threejs文件包目录examples/jsm/postprocessing/找到扩展库EffectComposer.js。\n\n代码中引入后处理扩展库EffectComposer.js\n\nimport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n\n\n大家都知道three.js WebGL渲染器执行渲染方法.render()会得到一张图像，如果你需要对一个webgl渲染器的渲染结果进行后期处理，就把它作为EffectComposer的参数。\n\n// 创建后处理对象EffectComposer，WebGL渲染器作为参数\nconst composer = new EffectComposer(renderer);\n\n\n\n# 渲染器通道RenderPass\n\nRenderPass.js扩展库目录：examples/jsm/postprocessing/\n\n// 引入渲染器通道RenderPass\nimport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n\n\n通过EffectComposer(renderer)指定了需要后处理的渲染器WebGLRenderer，渲染器通道RenderPass的作用是指定后处理对应的相机camera和场景scene。\n\n// 创建一个渲染器通道，场景和相机作为参数\nconst renderPass = new RenderPass(scene, camera);\n\n\n给EffectComposer添加一个渲染器通道RenderPass。\n\n// 设置renderPass通道\ncomposer.addPass(renderPass);\n\n\n\n# OutlinePass通道\n\nOutlinePass可以给指定的某个模型对象添加一个高亮发光描边效果。\n\nOutlinePass.js扩展库目录：examples/jsm/postprocessing/\n\n// 引入OutlinePass通道\nimport { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';\n\n\n创建OutlinePass通道\n\n// OutlinePass第一个参数v2的尺寸和canvas画布保持一致\nconst v2 = new THREE.Vector2(window.innerWidth, window.innerHeight);\n// const v2 = new THREE.Vector2(800, 600);\nconst outlinePass = new OutlinePass(v2, scene, camera);\n\n\n\n# OutlinePass属性.selectedObjects\n\nthree.js场景中有多个模型的话，你希望给哪个模型对象设置发光描边效果，就可以通过OutlinePass的选择对象属性.selectedObjects设置。\n\n// 一个模型对象\noutlinePass.selectedObjects = [mesh];\n// 多个模型对象\noutlinePass.selectedObjects = [mesh1,mesh2,group];\n\n\n\n# 设置OutlinePass通道\n\n最后把创建好的OutlinePass通道添加到后处理composer中。\n\n// 设置OutlinePass通道\ncomposer.addPass(outlinePass);\n\n\n\n# 渲染循环执行EffectComposer.render()\n\n渲染循环中后处理EffectComposer执行.render()，会调用webgl渲染器执行.render()，也就是说renderer.render(scene, camera)不用再执行。\n\n// 渲染循环\nfunction render() {\n    composer.render();\n    // renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 修改OutlinePass默认描边效果\n\n参考下节课具体讲解",normalizedContent:"# 后处理(高亮发光描边outlinepass)\n\n查看threejs文件包目录examples/jsm/postprocessing/，你可以看到three.js提供了一个扩展库effectcomposer.js,通过effectcomposer可以实现一些后期处理效果。\n\n所谓threejs后期处理，就像ps一样，对threejs的渲染结果进行后期处理，比如添加发光效果。\n\n\n# 不同功能后处理通道\n\n查看threejs文件包目录examples/jsm/postprocessing/，你可以看到threejs提供了很多后处理通道，想实现什么样的后期处理效果，需要调用threejs对应的后处理通道扩展库。\n\n * outlinepass.js：高亮发光描边\n * unrealbloompass.js：bloom发光\n * glitchpass.js：画面抖动效果\n\n比如outlinepass.js扩展库提供的类outlinepass就可以给一个模型添加一个高亮发光描边，下面就给大家演示下如何实现。\n\n\n\n\n# 引入effectcomposer.js\n\n你可以在threejs文件包目录examples/jsm/postprocessing/找到扩展库effectcomposer.js。\n\n代码中引入后处理扩展库effectcomposer.js\n\nimport { effectcomposer } from 'three/addons/postprocessing/effectcomposer.js';\n\n\n大家都知道three.js webgl渲染器执行渲染方法.render()会得到一张图像，如果你需要对一个webgl渲染器的渲染结果进行后期处理，就把它作为effectcomposer的参数。\n\n// 创建后处理对象effectcomposer，webgl渲染器作为参数\nconst composer = new effectcomposer(renderer);\n\n\n\n# 渲染器通道renderpass\n\nrenderpass.js扩展库目录：examples/jsm/postprocessing/\n\n// 引入渲染器通道renderpass\nimport { renderpass } from 'three/addons/postprocessing/renderpass.js';\n\n\n通过effectcomposer(renderer)指定了需要后处理的渲染器webglrenderer，渲染器通道renderpass的作用是指定后处理对应的相机camera和场景scene。\n\n// 创建一个渲染器通道，场景和相机作为参数\nconst renderpass = new renderpass(scene, camera);\n\n\n给effectcomposer添加一个渲染器通道renderpass。\n\n// 设置renderpass通道\ncomposer.addpass(renderpass);\n\n\n\n# outlinepass通道\n\noutlinepass可以给指定的某个模型对象添加一个高亮发光描边效果。\n\noutlinepass.js扩展库目录：examples/jsm/postprocessing/\n\n// 引入outlinepass通道\nimport { outlinepass } from 'three/addons/postprocessing/outlinepass.js';\n\n\n创建outlinepass通道\n\n// outlinepass第一个参数v2的尺寸和canvas画布保持一致\nconst v2 = new three.vector2(window.innerwidth, window.innerheight);\n// const v2 = new three.vector2(800, 600);\nconst outlinepass = new outlinepass(v2, scene, camera);\n\n\n\n# outlinepass属性.selectedobjects\n\nthree.js场景中有多个模型的话，你希望给哪个模型对象设置发光描边效果，就可以通过outlinepass的选择对象属性.selectedobjects设置。\n\n// 一个模型对象\noutlinepass.selectedobjects = [mesh];\n// 多个模型对象\noutlinepass.selectedobjects = [mesh1,mesh2,group];\n\n\n\n# 设置outlinepass通道\n\n最后把创建好的outlinepass通道添加到后处理composer中。\n\n// 设置outlinepass通道\ncomposer.addpass(outlinepass);\n\n\n\n# 渲染循环执行effectcomposer.render()\n\n渲染循环中后处理effectcomposer执行.render()，会调用webgl渲染器执行.render()，也就是说renderer.render(scene, camera)不用再执行。\n\n// 渲染循环\nfunction render() {\n    composer.render();\n    // renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 修改outlinepass默认描边效果\n\n参考下节课具体讲解",charsets:{cjk:!0}},{title:"3. Bloom发光通道",frontmatter:{title:"3. Bloom发光通道",date:"2023-03-03T11:12:04.000Z",permalink:"/pages/4583d8/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/13.13.%E5%90%8E%E5%A4%84%E7%90%86EffectComposer/03.Bloom%E5%8F%91%E5%85%89%E9%80%9A%E9%81%93.html",relativePath:"01.Three.js教程/13.13.后处理EffectComposer/03.Bloom发光通道.md",key:"v-7fcce397",path:"/pages/4583d8/",headers:[{level:3,title:"Bloom发光通道UnrealBloomPass",slug:"bloom发光通道unrealbloompass",normalizedTitle:"bloom发光通道unrealbloompass",charIndex:129},{level:3,title:"发光强度.strength",slug:"发光强度-strength",normalizedTitle:"发光强度.strength",charIndex:615},{level:3,title:"全文检索关键词EffectComposer",slug:"全文检索关键词effectcomposer",normalizedTitle:"全文检索关键词effectcomposer",charIndex:751}],headersStr:"Bloom发光通道UnrealBloomPass 发光强度.strength 全文检索关键词EffectComposer",content:"# Bloom发光通道\n\n前面两节课，通过OutlinePass给大家演示过后处理的整个流程，本节课给大演示一个Bloom发光通道案例。\n\n * OutlinePass.js：高亮发光描边\n * UnrealBloomPass.js：Bloom发光\n\n\n# Bloom发光通道UnrealBloomPass\n\nUnrealBloomPass.js扩展库目录：examples/jsm/postprocessing/\n\n// 引入UnrealBloomPass通道\nimport { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';\n\n\nUnrealBloomPass参数1是一个二维向量Vector2，二维向量尺x、y分量要和Canvas画布的宽、高度尺寸保持一致。\n\n// canvas画布宽高度尺寸是800, 600\nconst bloomPass = new UnrealBloomPass(new THREE.Vector2(800, 600));\n\n\n// canvas画布宽高度window.innerWidth, window.innerHeight\nnew UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight));\n\n\n\n# 发光强度.strength\n\nBloom发光强度bloomPass.strength，默认1.0。\n\nconsole.log('发光强度',bloomPass.strength);\n\n\n//bloom发光强度\nbloomPass.strength = 2.0;\n\n\n\n# 全文检索关键词EffectComposer\n\nthreejs文件包examples文件目录，全文检索关键词EffectComposer，可以找到后处理的很多案例。\n\nthreejs后期处理有很多相关的通道，大家学习的时候，也不可能都记住，平时用到那个通道，可以去examples文件搜索对应关键词。\n\n全文检索关键词UnrealBloomPass，可以找到Bloom发光通道的相关3D案例，你可以参考学习。",normalizedContent:"# bloom发光通道\n\n前面两节课，通过outlinepass给大家演示过后处理的整个流程，本节课给大演示一个bloom发光通道案例。\n\n * outlinepass.js：高亮发光描边\n * unrealbloompass.js：bloom发光\n\n\n# bloom发光通道unrealbloompass\n\nunrealbloompass.js扩展库目录：examples/jsm/postprocessing/\n\n// 引入unrealbloompass通道\nimport { unrealbloompass } from 'three/addons/postprocessing/unrealbloompass.js';\n\n\nunrealbloompass参数1是一个二维向量vector2，二维向量尺x、y分量要和canvas画布的宽、高度尺寸保持一致。\n\n// canvas画布宽高度尺寸是800, 600\nconst bloompass = new unrealbloompass(new three.vector2(800, 600));\n\n\n// canvas画布宽高度window.innerwidth, window.innerheight\nnew unrealbloompass(new three.vector2(window.innerwidth, window.innerheight));\n\n\n\n# 发光强度.strength\n\nbloom发光强度bloompass.strength，默认1.0。\n\nconsole.log('发光强度',bloompass.strength);\n\n\n//bloom发光强度\nbloompass.strength = 2.0;\n\n\n\n# 全文检索关键词effectcomposer\n\nthreejs文件包examples文件目录，全文检索关键词effectcomposer，可以找到后处理的很多案例。\n\nthreejs后期处理有很多相关的通道，大家学习的时候，也不可能都记住，平时用到那个通道，可以去examples文件搜索对应关键词。\n\n全文检索关键词unrealbloompass，可以找到bloom发光通道的相关3d案例，你可以参考学习。",charsets:{cjk:!0}},{title:"2. OutlinePass描边样式",frontmatter:{title:"2. OutlinePass描边样式",date:"2023-02-25T16:21:42.000Z",permalink:"/pages/73bfc8/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/13.13.%E5%90%8E%E5%A4%84%E7%90%86EffectComposer/02.OutlinePass%E5%8F%91%E5%85%89%E6%8F%8F%E8%BE%B9%E6%A0%B7%E5%BC%8F.html",relativePath:"01.Three.js教程/13.13.后处理EffectComposer/02.OutlinePass发光描边样式.md",key:"v-0853d625",path:"/pages/73bfc8/",headers:[{level:3,title:"描边颜色.visibleEdgeColor",slug:"描边颜色-visibleedgecolor",normalizedTitle:"描边颜色.visibleedgecolor",charIndex:327},{level:3,title:"修改OutlinePass默认边框效果",slug:"修改outlinepass默认边框效果",normalizedTitle:"修改outlinepass默认边框效果",charIndex:353},{level:3,title:"描边厚度.edgeThickness",slug:"描边厚度-edgethickness",normalizedTitle:"描边厚度.edgethickness",charIndex:476},{level:3,title:"描边亮度.edgeStrength",slug:"描边亮度-edgestrength",normalizedTitle:"描边亮度.edgestrength",charIndex:648},{level:3,title:"描边闪烁.pulsePeriod",slug:"描边闪烁-pulseperiod",normalizedTitle:"描边闪烁.pulseperiod",charIndex:806}],headersStr:"描边颜色.visibleEdgeColor 修改OutlinePass默认边框效果 描边厚度.edgeThickness 描边亮度.edgeStrength 描边闪烁.pulsePeriod",content:"# OutlinePass高亮发光描边样式\n\n继续上节课关于OutlinePass的讲解，给大家演示如何修改OutlinePass默认高亮发光描边样式。\n\nOutlinePass有很多控制高亮外边框样式的属性，下面介绍几个比较常用的属性。\n\n//模型描边颜色，默认白色         \noutlinePass.visibleEdgeColor.set(0xffff00); \n//高亮发光描边厚度\noutlinePass.edgeThickness = 4; \n//高亮描边发光强度\noutlinePass.edgeStrength = 6; \n //模型闪烁频率控制，默认0不闪烁\noutlinePass.pulsePeriod = 2;\n\n\n\n# 描边颜色.visibleEdgeColor\n\n\n# 修改OutlinePass默认边框效果\n\n.visibleEdgeColor可以设置模型边缘高亮描边颜色\n\n//模型边缘高亮边框颜色，默认白色  \noutlinePass.visibleEdgeColor.set(0xffff00);\n\n\n\n# 描边厚度.edgeThickness\n\noutlinePass.edgeThickness表示高亮发光描边的厚度，默认值1\n\nconsole.log('描边厚度',outlinePass.edgeThickness);          \n\n\n轮廓边缘描边厚度设置\n\noutlinePass.edgeThickness = 4.0;\n\n\n\n# 描边亮度.edgeStrength\n\noutlinePass.edgeThickness表示高亮描边的发光强度，默认值3\n\nconsole.log('描边亮度',outlinePass.edgeStrength);\n\n\n高亮描边发光强度设置\n\noutlinePass.edgeStrength = 6; \n\n\n\n# 描边闪烁.pulsePeriod\n\noutlinePass.pulsePeriod的功能是控制描边的闪烁频率，默认0不闪烁。\n\noutlinePass.pulsePeriod = 2;\n",normalizedContent:"# outlinepass高亮发光描边样式\n\n继续上节课关于outlinepass的讲解，给大家演示如何修改outlinepass默认高亮发光描边样式。\n\noutlinepass有很多控制高亮外边框样式的属性，下面介绍几个比较常用的属性。\n\n//模型描边颜色，默认白色         \noutlinepass.visibleedgecolor.set(0xffff00); \n//高亮发光描边厚度\noutlinepass.edgethickness = 4; \n//高亮描边发光强度\noutlinepass.edgestrength = 6; \n //模型闪烁频率控制，默认0不闪烁\noutlinepass.pulseperiod = 2;\n\n\n\n# 描边颜色.visibleedgecolor\n\n\n# 修改outlinepass默认边框效果\n\n.visibleedgecolor可以设置模型边缘高亮描边颜色\n\n//模型边缘高亮边框颜色，默认白色  \noutlinepass.visibleedgecolor.set(0xffff00);\n\n\n\n# 描边厚度.edgethickness\n\noutlinepass.edgethickness表示高亮发光描边的厚度，默认值1\n\nconsole.log('描边厚度',outlinepass.edgethickness);          \n\n\n轮廓边缘描边厚度设置\n\noutlinepass.edgethickness = 4.0;\n\n\n\n# 描边亮度.edgestrength\n\noutlinepass.edgethickness表示高亮描边的发光强度，默认值3\n\nconsole.log('描边亮度',outlinepass.edgestrength);\n\n\n高亮描边发光强度设置\n\noutlinepass.edgestrength = 6; \n\n\n\n# 描边闪烁.pulseperiod\n\noutlinepass.pulseperiod的功能是控制描边的闪烁频率，默认0不闪烁。\n\noutlinepass.pulseperiod = 2;\n",charsets:{cjk:!0}},{title:"4. 多通道组合(GlitchPass和描边)",frontmatter:{title:"4. 多通道组合(GlitchPass和描边)",date:"2023-03-03T11:12:18.000Z",permalink:"/pages/9618d5/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/13.13.%E5%90%8E%E5%A4%84%E7%90%86EffectComposer/04.%E5%A4%9A%E9%80%9A%E9%81%93%E7%BB%84%E5%90%88(GlitchPass%E5%92%8C%E6%8F%8F%E8%BE%B9).html",relativePath:"01.Three.js教程/13.13.后处理EffectComposer/04.多通道组合(GlitchPass和描边).md",key:"v-6e8891b6",path:"/pages/9618d5/",headers:[{level:3,title:"GlitchPass通道",slug:"glitchpass通道",normalizedTitle:"glitchpass通道",charIndex:85},{level:3,title:"多通道组合(OutlinePass+GlitchPass)",slug:"多通道组合-outlinepass-glitchpass",normalizedTitle:"多通道组合(outlinepass+glitchpass)",charIndex:303},{level:3,title:"描边颜色.visibleEdgeColor",slug:"描边颜色-visibleedgecolor",normalizedTitle:"描边颜色.visibleedgecolor",charIndex:1708},{level:3,title:"修改OutlinePass默认边框效果",slug:"修改outlinepass默认边框效果",normalizedTitle:"修改outlinepass默认边框效果",charIndex:1734},{level:3,title:"描边厚度.edgeThickness",slug:"描边厚度-edgethickness",normalizedTitle:"描边厚度.edgethickness",charIndex:1857},{level:3,title:"描边亮度.edgeStrength",slug:"描边亮度-edgestrength",normalizedTitle:"描边亮度.edgestrength",charIndex:2029},{level:3,title:"描边闪烁.pulsePeriod",slug:"描边闪烁-pulseperiod",normalizedTitle:"描边闪烁.pulseperiod",charIndex:2187}],headersStr:"GlitchPass通道 多通道组合(OutlinePass+GlitchPass) 描边颜色.visibleEdgeColor 修改OutlinePass默认边框效果 描边厚度.edgeThickness 描边亮度.edgeStrength 描边闪烁.pulsePeriod",content:"# 多通道组合(GlitchPass和描边)\n\nthreejs可以多个后处理效果组合使用，比如模型先通过OutlinePass设置描边，再设置其它的后处理通道。\n\n\n# GlitchPass通道\n\n// 引入GlitchPass通道\nimport { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';\n\n\nGlitchPass通道会产生闪屏效果。\n\nconst glitchPass = new GlitchPass();\n// 设置glitchPass通道\ncomposer.addPass(glitchPass);\n\n\n\n# 多通道组合(OutlinePass+GlitchPass)\n\nOutlinePass和GlitchPass通道组合使用,一个通道就像流水线上的一个工位一样，负责完成一个后处理功能，然后交给下一个通道，完成新的后处理功能。\n\n// 引入后处理扩展库EffectComposer.js\nimport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n// 引入渲染器通道RenderPass\nimport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n// 引入OutlinePass通道\nimport { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';\n// 引入GlitchPass通道\nimport { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';\n\n\n// 创建后处理对象EffectComposer，WebGL渲染器作为参数\nconst composer = new EffectComposer(renderer);\n// 1. 创建一个渲染器通道，场景和相机作为参数\nconst renderPass = new RenderPass(scene, camera);\n// 设置renderPass通道\ncomposer.addPass(renderPass);\n\n// 2. 创建OutlinePass通道\nconst v2 = new THREE.Vector2(window.innerWidth, window.innerHeight);\nconst outlinePass = new OutlinePass(v2, scene, camera);\noutlinePass.selectedObjects = [mesh];\noutlinePass.edgeThickness = 4;\noutlinePass.edgeStrength = 6;\ncomposer.addPass(outlinePass);\n\n// 3. 设置glitchPass通道\nconst glitchPass = new GlitchPass();\ncomposer.addPass(glitchPass);\n\n\n\n# OutlinePass高亮发光描边样式\n\n继续上节课关于OutlinePass的讲解，给大家演示如何修改OutlinePass默认高亮发光描边样式。\n\nOutlinePass有很多控制高亮外边框样式的属性，下面介绍几个比较常用的属性。\n\n//模型描边颜色，默认白色         \noutlinePass.visibleEdgeColor.set(0xffff00); \n//高亮发光描边厚度\noutlinePass.edgeThickness = 4; \n//高亮描边发光强度\noutlinePass.edgeStrength = 6; \n //模型闪烁频率控制，默认0不闪烁\noutlinePass.pulsePeriod = 2;\n\n\n\n# 描边颜色.visibleEdgeColor\n\n\n# 修改OutlinePass默认边框效果\n\n.visibleEdgeColor可以设置模型边缘高亮描边颜色\n\n//模型边缘高亮边框颜色，默认白色  \noutlinePass.visibleEdgeColor.set(0xffff00);\n\n\n\n# 描边厚度.edgeThickness\n\noutlinePass.edgeThickness表示高亮发光描边的厚度，默认值1\n\nconsole.log('描边厚度',outlinePass.edgeThickness);          \n\n\n轮廓边缘描边厚度设置\n\noutlinePass.edgeThickness = 4.0;\n\n\n\n# 描边亮度.edgeStrength\n\noutlinePass.edgeThickness表示高亮描边的发光强度，默认值3\n\nconsole.log('描边亮度',outlinePass.edgeStrength);\n\n\n高亮描边发光强度设置\n\noutlinePass.edgeStrength = 6; \n\n\n\n# 描边闪烁.pulsePeriod\n\noutlinePass.pulsePeriod的功能是控制描边的闪烁频率，默认0不闪烁。\n\noutlinePass.pulsePeriod = 2;\n",normalizedContent:"# 多通道组合(glitchpass和描边)\n\nthreejs可以多个后处理效果组合使用，比如模型先通过outlinepass设置描边，再设置其它的后处理通道。\n\n\n# glitchpass通道\n\n// 引入glitchpass通道\nimport { glitchpass } from 'three/addons/postprocessing/glitchpass.js';\n\n\nglitchpass通道会产生闪屏效果。\n\nconst glitchpass = new glitchpass();\n// 设置glitchpass通道\ncomposer.addpass(glitchpass);\n\n\n\n# 多通道组合(outlinepass+glitchpass)\n\noutlinepass和glitchpass通道组合使用,一个通道就像流水线上的一个工位一样，负责完成一个后处理功能，然后交给下一个通道，完成新的后处理功能。\n\n// 引入后处理扩展库effectcomposer.js\nimport { effectcomposer } from 'three/addons/postprocessing/effectcomposer.js';\n// 引入渲染器通道renderpass\nimport { renderpass } from 'three/addons/postprocessing/renderpass.js';\n// 引入outlinepass通道\nimport { outlinepass } from 'three/addons/postprocessing/outlinepass.js';\n// 引入glitchpass通道\nimport { glitchpass } from 'three/addons/postprocessing/glitchpass.js';\n\n\n// 创建后处理对象effectcomposer，webgl渲染器作为参数\nconst composer = new effectcomposer(renderer);\n// 1. 创建一个渲染器通道，场景和相机作为参数\nconst renderpass = new renderpass(scene, camera);\n// 设置renderpass通道\ncomposer.addpass(renderpass);\n\n// 2. 创建outlinepass通道\nconst v2 = new three.vector2(window.innerwidth, window.innerheight);\nconst outlinepass = new outlinepass(v2, scene, camera);\noutlinepass.selectedobjects = [mesh];\noutlinepass.edgethickness = 4;\noutlinepass.edgestrength = 6;\ncomposer.addpass(outlinepass);\n\n// 3. 设置glitchpass通道\nconst glitchpass = new glitchpass();\ncomposer.addpass(glitchpass);\n\n\n\n# outlinepass高亮发光描边样式\n\n继续上节课关于outlinepass的讲解，给大家演示如何修改outlinepass默认高亮发光描边样式。\n\noutlinepass有很多控制高亮外边框样式的属性，下面介绍几个比较常用的属性。\n\n//模型描边颜色，默认白色         \noutlinepass.visibleedgecolor.set(0xffff00); \n//高亮发光描边厚度\noutlinepass.edgethickness = 4; \n//高亮描边发光强度\noutlinepass.edgestrength = 6; \n //模型闪烁频率控制，默认0不闪烁\noutlinepass.pulseperiod = 2;\n\n\n\n# 描边颜色.visibleedgecolor\n\n\n# 修改outlinepass默认边框效果\n\n.visibleedgecolor可以设置模型边缘高亮描边颜色\n\n//模型边缘高亮边框颜色，默认白色  \noutlinepass.visibleedgecolor.set(0xffff00);\n\n\n\n# 描边厚度.edgethickness\n\noutlinepass.edgethickness表示高亮发光描边的厚度，默认值1\n\nconsole.log('描边厚度',outlinepass.edgethickness);          \n\n\n轮廓边缘描边厚度设置\n\noutlinepass.edgethickness = 4.0;\n\n\n\n# 描边亮度.edgestrength\n\noutlinepass.edgethickness表示高亮描边的发光强度，默认值3\n\nconsole.log('描边亮度',outlinepass.edgestrength);\n\n\n高亮描边发光强度设置\n\noutlinepass.edgestrength = 6; \n\n\n\n# 描边闪烁.pulseperiod\n\noutlinepass.pulseperiod的功能是控制描边的闪烁频率，默认0不闪烁。\n\noutlinepass.pulseperiod = 2;\n",charsets:{cjk:!0}},{title:"5. gltf工厂模型设置发光描边",frontmatter:{title:"5. gltf工厂模型设置发光描边",date:"2023-03-03T11:12:32.000Z",permalink:"/pages/c9b485/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/13.13.%E5%90%8E%E5%A4%84%E7%90%86EffectComposer/05.gltf%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%9E%8B%E8%AE%BE%E7%BD%AE%E5%8F%91%E5%85%89%E6%8F%8F%E8%BE%B9.html",relativePath:"01.Three.js教程/13.13.后处理EffectComposer/05.gltf工厂模型设置发光描边.md",key:"v-1529c538",path:"/pages/c9b485/",headers:[{level:3,title:"1.引入扩展库",slug:"_1-引入扩展库",normalizedTitle:"1.引入扩展库",charIndex:161},{level:3,title:"2.设置后期处理通道",slug:"_2-设置后期处理通道",normalizedTitle:"2.设置后期处理通道",charIndex:483},{level:3,title:"3.渲染循环执行EffectComposer.render()",slug:"_3-渲染循环执行effectcomposer-render",normalizedTitle:"3.渲染循环执行effectcomposer.render()",charIndex:1063},{level:3,title:"4. UI界面控制outlinePass.selectedObjects",slug:"_4-ui界面控制outlinepass-selectedobjects",normalizedTitle:"4. ui界面控制outlinepass.selectedobjects",charIndex:1238}],headersStr:"1.引入扩展库 2.设置后期处理通道 3.渲染循环执行EffectComposer.render() 4. UI界面控制outlinePass.selectedObjects",content:"# gltf工厂模型设置发光描边\n\n本节课算是一个发光描边OutlinePass后处理的练习题，通过按钮点击选择gltf工厂的某个设备模型，添加发光描边效果。\n\n课件演示文件提供了加载gltf工厂模型的源码，你可以在此基础上，利用13.1和13.2节讲解过的OutlinePass知识给工厂设备添加发光描边效果。\n\n\n# 1.引入扩展库\n\n具体参考13.1节讲解\n\n// 引入后处理扩展库EffectComposer.js\nimport { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n// 引入渲染器通道RenderPass\nimport { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n// 引入OutlinePass通道\nimport { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';\n\n\n\n# 2.设置后期处理通道\n\n具体参考13.1和13.2节讲解\n\n注意outlinePass.selectedObjects先不用设置，后面通过UI按钮鼠标事件触发的的函数设置。\n\n// 创建后处理对象EffectComposer，WebGL渲染器作为参数\nconst composer = new EffectComposer(renderer);\nconst renderPass = new RenderPass(scene, camera);\ncomposer.addPass(renderPass);\n\n// 创建OutlinePass通道\nconst v2 = new THREE.Vector2(window.innerWidth, window.innerHeight);\nconst outlinePass = new OutlinePass(v2, scene, camera);\n// outlinePass.selectedObjects = [mesh];\noutlinePass.visibleEdgeColor.set(0x00ffff);\noutlinePass.edgeThickness = 4;\noutlinePass.edgeStrength = 6;\ncomposer.addPass(outlinePass);\n\n\n\n# 3.渲染循环执行EffectComposer.render()\n\n// 渲染循环\nfunction render() {\n    composer.render();\n    // renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 4. UI界面控制outlinePass.selectedObjects\n\n用于和3D场景交互的UI按钮，具体参考课件中index.html文件中HTML和CSS代码。\n\n<div id=\"A\" class=\"bu\">设备A</div>\n<div id=\"B\" class=\"bu\" style=\"margin-left: 10px;\">设备B</div>\n\n\n通过UI按钮控制，哪个模型添加发光描边效果\n\ndocument.getElementById('A').addEventListener('click',function(){\n    const A = model.getObjectByName ('设备A');\n    outlinePass.selectedObjects = [A];\n})\ndocument.getElementById('B').addEventListener('click',function(){\n    const B = model.getObjectByName ('设备B');\n    outlinePass.selectedObjects = [B];\n})\n",normalizedContent:"# gltf工厂模型设置发光描边\n\n本节课算是一个发光描边outlinepass后处理的练习题，通过按钮点击选择gltf工厂的某个设备模型，添加发光描边效果。\n\n课件演示文件提供了加载gltf工厂模型的源码，你可以在此基础上，利用13.1和13.2节讲解过的outlinepass知识给工厂设备添加发光描边效果。\n\n\n# 1.引入扩展库\n\n具体参考13.1节讲解\n\n// 引入后处理扩展库effectcomposer.js\nimport { effectcomposer } from 'three/addons/postprocessing/effectcomposer.js';\n// 引入渲染器通道renderpass\nimport { renderpass } from 'three/addons/postprocessing/renderpass.js';\n// 引入outlinepass通道\nimport { outlinepass } from 'three/addons/postprocessing/outlinepass.js';\n\n\n\n# 2.设置后期处理通道\n\n具体参考13.1和13.2节讲解\n\n注意outlinepass.selectedobjects先不用设置，后面通过ui按钮鼠标事件触发的的函数设置。\n\n// 创建后处理对象effectcomposer，webgl渲染器作为参数\nconst composer = new effectcomposer(renderer);\nconst renderpass = new renderpass(scene, camera);\ncomposer.addpass(renderpass);\n\n// 创建outlinepass通道\nconst v2 = new three.vector2(window.innerwidth, window.innerheight);\nconst outlinepass = new outlinepass(v2, scene, camera);\n// outlinepass.selectedobjects = [mesh];\noutlinepass.visibleedgecolor.set(0x00ffff);\noutlinepass.edgethickness = 4;\noutlinepass.edgestrength = 6;\ncomposer.addpass(outlinepass);\n\n\n\n# 3.渲染循环执行effectcomposer.render()\n\n// 渲染循环\nfunction render() {\n    composer.render();\n    // renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 4. ui界面控制outlinepass.selectedobjects\n\n用于和3d场景交互的ui按钮，具体参考课件中index.html文件中html和css代码。\n\n<div id=\"a\" class=\"bu\">设备a</div>\n<div id=\"b\" class=\"bu\" style=\"margin-left: 10px;\">设备b</div>\n\n\n通过ui按钮控制，哪个模型添加发光描边效果\n\ndocument.getelementbyid('a').addeventlistener('click',function(){\n    const a = model.getobjectbyname ('设备a');\n    outlinepass.selectedobjects = [a];\n})\ndocument.getelementbyid('b').addeventlistener('click',function(){\n    const b = model.getobjectbyname ('设备b');\n    outlinepass.selectedobjects = [b];\n})\n",charsets:{cjk:!0}},{title:"6. gltf后处理颜色异常(伽马校正)",frontmatter:{title:"6. gltf后处理颜色异常(伽马校正)",date:"2023-03-03T11:12:46.000Z",permalink:"/pages/db8785/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/13.13.%E5%90%8E%E5%A4%84%E7%90%86EffectComposer/06.gltf%E5%90%8E%E5%A4%84%E7%90%86%E9%A2%9C%E8%89%B2%E5%BC%82%E5%B8%B8(%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3).html",relativePath:"01.Three.js教程/13.13.后处理EffectComposer/06.gltf后处理颜色异常(伽马校正).md",key:"v-58d55029",path:"/pages/db8785/",headers:[{level:3,title:"颜色偏差的原因",slug:"颜色偏差的原因",normalizedTitle:"颜色偏差的原因",charIndex:109},{level:3,title:"引入GammaCorrectionShader.js",slug:"引入gammacorrectionshader-js",normalizedTitle:"引入gammacorrectionshader.js",charIndex:307},{level:3,title:"引入ShaderPass.js",slug:"引入shaderpass-js",normalizedTitle:"引入shaderpass.js",charIndex:607},{level:3,title:"创建伽马校正后处理通道",slug:"创建伽马校正后处理通道",normalizedTitle:"创建伽马校正后处理通道",charIndex:783}],headersStr:"颜色偏差的原因 引入GammaCorrectionShader.js 引入ShaderPass.js 创建伽马校正后处理通道",content:"# gltf后处理颜色异常(伽马校正)\n\n你打开上节课代码，可以发现，加载gltf模型，如果使用EffectComposer添加后处理功能，模型颜色可能会出现异常，对于这种情况，首先要先分析产生颜色偏差原因。\n\n\n# 颜色偏差的原因\n\n首先你可以回顾6.3和6.9节内容，加载gltf模型如果出现颜色偏差，需要设置renderer.outputEncoding解决。\n\n如果你使用threejs后处理功能EffectComposer，renderer.outputEncoding会无效，自然会出现颜色偏差。\n\nrenderer.outputEncoding = THREE.sRGBEncoding;\n\n\n\n# 引入GammaCorrectionShader.js\n\nGammaCorrectionShader.js扩展库的目录：examples/jsm/shaders/\n\nexamples/jsm/shaders/目录下有很多不同功能的shader文件,GammaCorrectionShader.js的功能就是进行伽马校正，具体点说就是可以用来解决gltf模型后处理时候，颜色偏差的问题。\n\n// 伽马校正后处理Shader\nimport {GammaCorrectionShader} from 'three/addons/shaders/GammaCorrectionShader.js';\n\n\n\n# 引入ShaderPass.js\n\nShaderPass.js扩展库目录：examples/jsm/postprocessing/\n\n// ShaderPass功能：使用后处理Shader创建后处理通道\nimport {ShaderPass} from 'three/addons/postprocessing/ShaderPass.js';\n\n\n\n# 创建伽马校正后处理通道\n\nthreejs并没有直接提供伽马校正的后处理通道，提供了一个伽马校正的Shader对象GammaCorrectionShader，这时候可以把Shader对象作为ShaderPass的参数创建一个通道。\n\n// 创建伽马校正通道\nconst gammaPass= new ShaderPass(GammaCorrectionShader);\ncomposer.addPass(gammaPass);\n",normalizedContent:"# gltf后处理颜色异常(伽马校正)\n\n你打开上节课代码，可以发现，加载gltf模型，如果使用effectcomposer添加后处理功能，模型颜色可能会出现异常，对于这种情况，首先要先分析产生颜色偏差原因。\n\n\n# 颜色偏差的原因\n\n首先你可以回顾6.3和6.9节内容，加载gltf模型如果出现颜色偏差，需要设置renderer.outputencoding解决。\n\n如果你使用threejs后处理功能effectcomposer，renderer.outputencoding会无效，自然会出现颜色偏差。\n\nrenderer.outputencoding = three.srgbencoding;\n\n\n\n# 引入gammacorrectionshader.js\n\ngammacorrectionshader.js扩展库的目录：examples/jsm/shaders/\n\nexamples/jsm/shaders/目录下有很多不同功能的shader文件,gammacorrectionshader.js的功能就是进行伽马校正，具体点说就是可以用来解决gltf模型后处理时候，颜色偏差的问题。\n\n// 伽马校正后处理shader\nimport {gammacorrectionshader} from 'three/addons/shaders/gammacorrectionshader.js';\n\n\n\n# 引入shaderpass.js\n\nshaderpass.js扩展库目录：examples/jsm/postprocessing/\n\n// shaderpass功能：使用后处理shader创建后处理通道\nimport {shaderpass} from 'three/addons/postprocessing/shaderpass.js';\n\n\n\n# 创建伽马校正后处理通道\n\nthreejs并没有直接提供伽马校正的后处理通道，提供了一个伽马校正的shader对象gammacorrectionshader，这时候可以把shader对象作为shaderpass的参数创建一个通道。\n\n// 创建伽马校正通道\nconst gammapass= new shaderpass(gammacorrectionshader);\ncomposer.addpass(gammapass);\n",charsets:{cjk:!0}},{title:"7. 抗锯齿后处理",frontmatter:{title:"7. 抗锯齿后处理",date:"2023-03-03T11:13:09.000Z",permalink:"/pages/fe22af/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/13.13.%E5%90%8E%E5%A4%84%E7%90%86EffectComposer/07.%E6%8A%97%E9%94%AF%E9%BD%BF%E5%90%8E%E5%A4%84%E7%90%86.html",relativePath:"01.Three.js教程/13.13.后处理EffectComposer/07.抗锯齿后处理.md",key:"v-36e902b0",path:"/pages/fe22af/",headers:[{level:3,title:"gltf模型使用后处理带来的锯齿",slug:"gltf模型使用后处理带来的锯齿",normalizedTitle:"gltf模型使用后处理带来的锯齿",charIndex:73},{level:3,title:"FXAA抗锯齿通道",slug:"fxaa抗锯齿通道",normalizedTitle:"fxaa抗锯齿通道",charIndex:428},{level:3,title:"SMAA抗锯齿通道",slug:"smaa抗锯齿通道",normalizedTitle:"smaa抗锯齿通道",charIndex:1204}],headersStr:"gltf模型使用后处理带来的锯齿 FXAA抗锯齿通道 SMAA抗锯齿通道",content:"# 抗锯齿后处理\n\nthree.js提供了多种抗锯齿的后处理，下面给大家演示下FXAAShader和SMAAPass两种抗锯齿的后处理。\n\n\n# gltf模型使用后处理带来的锯齿\n\n你可以对比下面两种情况的渲染效果。(使用后处理之后带来了锯齿)\n\n * gltf工厂模型，无后处理 ( 课件文件：“无后处理的gltf工厂” )\n * gltf工厂模型，有后处理EffectComposer (课件文件：“演示”)\n\n调整相机参数，方便观察工厂设备B的渲染细节\n\n// camera.position.set(202, 123, 125);\ncamera.position.set(1.1, 11.8, 62.4);\n// 可视化选择相机位置\ncontrols.addEventListener('change',function(){\n    console.log('camera.position',camera.position);\n})\n\n\n\n# FXAA抗锯齿通道\n\nFXAA减弱了锯齿，但是并不完美。\n\n// ShaderPass功能：使用后处理Shader创建后处理通道\nimport {ShaderPass} from 'three/addons/postprocessing/ShaderPass.js';\n// FXAA抗锯齿Shader\nimport { FXAAShader } from 'three/addons/shaders/FXAAShader.js';\n\n\n// 设置设备像素比，避免canvas画布输出模糊\nrenderer.setPixelRatio(window.devicePixelRatio);\n\n\n.getPixelRatio()获取renderer.setPixelRatio()设置的值\n\n// .getPixelRatio()获取设备像素比 \nconst pixelRatio = renderer.getPixelRatio();\n\n\n设置FAXX抗锯齿通道\n\nconst FXAAPass = new ShaderPass( FXAAShader );\n// `.getPixelRatio()`获取`renderer.setPixelRatio()`设置的值\nconst pixelRatio = renderer.getPixelRatio();//获取设备像素比 \n// width、height是canva画布的宽高度\nFXAAPass.uniforms.resolution.value.x = 1 /(width*pixelRatio);\nFXAAPass.uniforms.resolution.value.y = 1 /(height*pixelRatio);\ncomposer.addPass( FXAAPass );\n\n\n\n# SMAA抗锯齿通道\n\nSMAA相比较FXAA抗锯齿效果更好一些。\n\n// SMAA抗锯齿通道\nimport {SMAAPass} from 'three/addons/postprocessing/SMAAPass.js';\n\n\n创建SMAAPass抗锯齿通道\n\n//获取.setPixelRatio()设置的设备像素比\nconst pixelRatio = renderer.getPixelRatio();\n// width、height是canva画布的宽高度\nconst smaaPass = new SMAAPass(width * pixelRatio, height * pixelRatio);\ncomposer.addPass(smaaPass);\n",normalizedContent:"# 抗锯齿后处理\n\nthree.js提供了多种抗锯齿的后处理，下面给大家演示下fxaashader和smaapass两种抗锯齿的后处理。\n\n\n# gltf模型使用后处理带来的锯齿\n\n你可以对比下面两种情况的渲染效果。(使用后处理之后带来了锯齿)\n\n * gltf工厂模型，无后处理 ( 课件文件：“无后处理的gltf工厂” )\n * gltf工厂模型，有后处理effectcomposer (课件文件：“演示”)\n\n调整相机参数，方便观察工厂设备b的渲染细节\n\n// camera.position.set(202, 123, 125);\ncamera.position.set(1.1, 11.8, 62.4);\n// 可视化选择相机位置\ncontrols.addeventlistener('change',function(){\n    console.log('camera.position',camera.position);\n})\n\n\n\n# fxaa抗锯齿通道\n\nfxaa减弱了锯齿，但是并不完美。\n\n// shaderpass功能：使用后处理shader创建后处理通道\nimport {shaderpass} from 'three/addons/postprocessing/shaderpass.js';\n// fxaa抗锯齿shader\nimport { fxaashader } from 'three/addons/shaders/fxaashader.js';\n\n\n// 设置设备像素比，避免canvas画布输出模糊\nrenderer.setpixelratio(window.devicepixelratio);\n\n\n.getpixelratio()获取renderer.setpixelratio()设置的值\n\n// .getpixelratio()获取设备像素比 \nconst pixelratio = renderer.getpixelratio();\n\n\n设置faxx抗锯齿通道\n\nconst fxaapass = new shaderpass( fxaashader );\n// `.getpixelratio()`获取`renderer.setpixelratio()`设置的值\nconst pixelratio = renderer.getpixelratio();//获取设备像素比 \n// width、height是canva画布的宽高度\nfxaapass.uniforms.resolution.value.x = 1 /(width*pixelratio);\nfxaapass.uniforms.resolution.value.y = 1 /(height*pixelratio);\ncomposer.addpass( fxaapass );\n\n\n\n# smaa抗锯齿通道\n\nsmaa相比较fxaa抗锯齿效果更好一些。\n\n// smaa抗锯齿通道\nimport {smaapass} from 'three/addons/postprocessing/smaapass.js';\n\n\n创建smaapass抗锯齿通道\n\n//获取.setpixelratio()设置的设备像素比\nconst pixelratio = renderer.getpixelratio();\n// width、height是canva画布的宽高度\nconst smaapass = new smaapass(width * pixelratio, height * pixelratio);\ncomposer.addpass(smaapass);\n",charsets:{cjk:!0}},{title:"1. 射线Ray",frontmatter:{title:"1. 射线Ray",date:"2023-03-03T11:13:41.000Z",permalink:"/pages/500511/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/14.14.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E6%A8%A1%E5%9E%8B/01.%E5%B0%84%E7%BA%BFRay.html",relativePath:"01.Three.js教程/14.14.射线拾取模型/01.射线Ray.md",key:"v-0b069e57",path:"/pages/500511/",headers:[{level:3,title:"射线Ray",slug:"射线ray-2",normalizedTitle:"射线ray",charIndex:2},{level:3,title:"射线起点.origin",slug:"射线起点-origin",normalizedTitle:"射线起点.origin",charIndex:182},{level:3,title:"射线方向.direction",slug:"射线方向-direction",normalizedTitle:"射线方向.direction",charIndex:382},{level:3,title:".intersectTriangle()方法",slug:"intersecttriangle-方法",normalizedTitle:".intersecttriangle()方法",charIndex:816}],headersStr:"射线Ray 射线起点.origin 射线方向.direction .intersectTriangle()方法",content:"# 射线Ray\n\n射线Ray和三维向量Vector3一样属于数学几何计算相关的API,可以进行射线交叉计算。\n\n\n# 射线Ray\n\n学习Three.js中的射线Ray概念，你可以类比数学几何中提到的射线，在三维空间中，一条线把一个点作为起点，然后沿着某个方向无限延伸。\n\n// 创建射线对象Ray\nconst ray = new THREE.Ray()\n\n\n\n# 射线起点.origin\n\n射线Ray的起点.origin在3D空间中的坐标，可以用一个三维向量Vector3的x、y、z分量表示。\n\n// 设置射线起点\nray.origin = new THREE.Vector3(1,0,3);\n\n\n起点.origin属性值是三维向量Vector3，也可以用.set()方法设置。\n\n// 设置射线起点\nray.origin.set(1, 0, 3);\n\n\n\n# 射线方向.direction\n\n射线Ray的方向.direction通用用一个三维向量Vector3表示,向量长度保证为1，也就是单位向量。\n\n// 表示射线沿着x轴正方向\nray.direction = new THREE.Vector3(1,0,0);\n// 表示射线沿着x轴负方向\nray.direction = new THREE.Vector3(-1,0,0);\n\n\n// 表示射线沿着y方向\nray.direction = new THREE.Vector3(0,1,0);\n\n\n注意.direction的值需要是单位向量，不是的话可以执行.normalize()归一化或者说标准化。\n\nray.direction = new THREE.Vector3(5,0,0).normalize();\n\n\n// 表示射线沿着xy坐标轴的中间线\nray.direction = new THREE.Vector3(1,1,0).normalize();\n\n\n\n# .intersectTriangle()方法\n\n射线Ray有很多关于数学计算的方法，下面就先介绍一个与三角形交叉计算相关的方法.intersectTriangle(),简单说，就是计算一个射线和一个三角形在3D空间中是否交叉。\n\n执行.intersectTriangle()方法，如果相交返回交点坐标，不相交返回空值null。\n\n// 三角形三个点坐标\nconst p1 = new THREE.Vector3(100, 25, 0);\nconst p2 = new THREE.Vector3(100, -25, 25);\nconst p3 = new THREE.Vector3(100, -25, -25);\nconst point = new THREE.Vector3();//用来记录射线和三角形的交叉点\n// `.intersectTriangle()`计算射线和三角形是否相交叉，相交返回交点，不相交返回null\nconst result = ray.intersectTriangle(p1,p2,p3,false,point);\nconsole.log('交叉点坐标', point);\nconsole.log('查看是否相交', result);\n\n\n.intersectTriangle()参数4表示是否进行背面剔除，p1,p2,p3可以理解为一个三角形，有正反两面，一面是正面，一面是反面，关于三角形正反面可以参考2.3节讲解。\n\n在一面观察p1,p2,p3，如果沿着三个点的顺序转圈是逆时针方向，表示正面，另一面观察，p1,p2,p3就是顺时针方向，表示背面。\n\n.intersectTriangle()参数4设为true，表示进行背面剔除，虽然从几何空间上讲，该案例源码射线和三角形虽然交叉，但在threejs中，三角形背面对着射线，视为交叉无效，进行背面剔除，返回值r是null。\n\nconst r = ray.intersectTriangle(p1,p2,p3,true,point);\nconsole.log('查看是否相交', r);\n",normalizedContent:"# 射线ray\n\n射线ray和三维向量vector3一样属于数学几何计算相关的api,可以进行射线交叉计算。\n\n\n# 射线ray\n\n学习three.js中的射线ray概念，你可以类比数学几何中提到的射线，在三维空间中，一条线把一个点作为起点，然后沿着某个方向无限延伸。\n\n// 创建射线对象ray\nconst ray = new three.ray()\n\n\n\n# 射线起点.origin\n\n射线ray的起点.origin在3d空间中的坐标，可以用一个三维向量vector3的x、y、z分量表示。\n\n// 设置射线起点\nray.origin = new three.vector3(1,0,3);\n\n\n起点.origin属性值是三维向量vector3，也可以用.set()方法设置。\n\n// 设置射线起点\nray.origin.set(1, 0, 3);\n\n\n\n# 射线方向.direction\n\n射线ray的方向.direction通用用一个三维向量vector3表示,向量长度保证为1，也就是单位向量。\n\n// 表示射线沿着x轴正方向\nray.direction = new three.vector3(1,0,0);\n// 表示射线沿着x轴负方向\nray.direction = new three.vector3(-1,0,0);\n\n\n// 表示射线沿着y方向\nray.direction = new three.vector3(0,1,0);\n\n\n注意.direction的值需要是单位向量，不是的话可以执行.normalize()归一化或者说标准化。\n\nray.direction = new three.vector3(5,0,0).normalize();\n\n\n// 表示射线沿着xy坐标轴的中间线\nray.direction = new three.vector3(1,1,0).normalize();\n\n\n\n# .intersecttriangle()方法\n\n射线ray有很多关于数学计算的方法，下面就先介绍一个与三角形交叉计算相关的方法.intersecttriangle(),简单说，就是计算一个射线和一个三角形在3d空间中是否交叉。\n\n执行.intersecttriangle()方法，如果相交返回交点坐标，不相交返回空值null。\n\n// 三角形三个点坐标\nconst p1 = new three.vector3(100, 25, 0);\nconst p2 = new three.vector3(100, -25, 25);\nconst p3 = new three.vector3(100, -25, -25);\nconst point = new three.vector3();//用来记录射线和三角形的交叉点\n// `.intersecttriangle()`计算射线和三角形是否相交叉，相交返回交点，不相交返回null\nconst result = ray.intersecttriangle(p1,p2,p3,false,point);\nconsole.log('交叉点坐标', point);\nconsole.log('查看是否相交', result);\n\n\n.intersecttriangle()参数4表示是否进行背面剔除，p1,p2,p3可以理解为一个三角形，有正反两面，一面是正面，一面是反面，关于三角形正反面可以参考2.3节讲解。\n\n在一面观察p1,p2,p3，如果沿着三个点的顺序转圈是逆时针方向，表示正面，另一面观察，p1,p2,p3就是顺时针方向，表示背面。\n\n.intersecttriangle()参数4设为true，表示进行背面剔除，虽然从几何空间上讲，该案例源码射线和三角形虽然交叉，但在threejs中，三角形背面对着射线，视为交叉无效，进行背面剔除，返回值r是null。\n\nconst r = ray.intersecttriangle(p1,p2,p3,true,point);\nconsole.log('查看是否相交', r);\n",charsets:{cjk:!0}},{title:"2. Raycaster(射线拾取模型)",frontmatter:{title:"2. Raycaster(射线拾取模型)",date:"2023-03-03T11:13:50.000Z",permalink:"/pages/a448b6/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/14.14.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E6%A8%A1%E5%9E%8B/02.Raycaster(%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E6%A8%A1%E5%9E%8B).html",relativePath:"01.Three.js教程/14.14.射线拾取模型/02.Raycaster(射线拾取模型).md",key:"v-281b710e",path:"/pages/a448b6/",headers:[{level:3,title:"射线投射器Raycaster",slug:"射线投射器raycaster",normalizedTitle:"射线投射器raycaster",charIndex:55},{level:3,title:"射线交叉计算(.intersectObjects()方法)",slug:"射线交叉计算-intersectobjects-方法",normalizedTitle:"射线交叉计算(.intersectobjects()方法)",charIndex:360},{level:3,title:".intersectObjects()射线拾取返回信息",slug:"intersectobjects-射线拾取返回信息",normalizedTitle:".intersectobjects()射线拾取返回信息",charIndex:853},{level:3,title:"射线选中的模型对象改变材质颜色",slug:"射线选中的模型对象改变材质颜色",normalizedTitle:"射线选中的模型对象改变材质颜色",charIndex:1313}],headersStr:"射线投射器Raycaster 射线交叉计算(.intersectObjects()方法) .intersectObjects()射线拾取返回信息 射线选中的模型对象改变材质颜色",content:'# Raycaster(射线拾取模型)\n\n上节课给大家介绍过射线Ray，下面给大家介绍另一个和射线相关的API射线投射器Raycaster。\n\n\n# 射线投射器Raycaster\n\n射线投射器Raycaster具有一个射线属性.ray，该属性的值就是上节课讲解的射线对象Ray。\n\nconst raycaster = new THREE.Raycaster();\nconsole.log(\'射线属性\',raycaster.ray);\n\n\n// 设置射线起点\nraycaster.ray.origin = new THREE.Vector3(-100, 0, 0);\n// 设置射线方向射线方向沿着x轴\nraycaster.ray.direction = new THREE.Vector3(1, 0, 0);\n\n\n\n# 射线交叉计算(.intersectObjects()方法)\n\n射线投射器Raycaster通过.intersectObjects()方法可以计算出来与自身射线.ray相交的网格模型。\n\n.intersectObjects([mesh1, mesh2, mesh3])对参数中的网格模型对象进行射线交叉计算,未选中对象返回空数组[],选中一个对象，数组1个元素，选中多个对象，数组多个元素，如果选中多个对象，对象在数组中按照先后排序。\n\nconst raycaster = new THREE.Raycaster();\nraycaster.ray.origin = new THREE.Vector3(-100, 0, 0);\nraycaster.ray.direction = new THREE.Vector3(1, 0, 0);\n// 射线发射拾取模型对象\nconst intersects = raycaster.intersectObjects([mesh1, mesh2, mesh3]);\nconsole.log("射线器返回的对象", intersects);\n\n\n\n# .intersectObjects()射线拾取返回信息\n\n射线拾取返回的intersects里面的元素包含多种信息，你可以通过threejs文档查看，或者在浏览器控制台打印查看。\n\n.intersectObjects()和.intersectObject()功能相同，只是具体语法不同，.intersectObjects()返回数组元素包含的信息，可以参考文档关于.intersectObject()的介绍。\n\nconsole.log("射线器返回的对象", intersects);\n// intersects.length大于0说明，说明选中了模型\nif (intersects.length > 0) {\n    console.log("交叉点坐标", intersects[0].point);\n    console.log("交叉对象",intersects[0].object);\n    console.log("射线原点和交叉点距离",intersects[0].distance);\n}\n\n\n\n# 射线选中的模型对象改变材质颜色\n\nconst intersects = raycaster.intersectObjects([mesh1, mesh2, mesh3]);\nif (intersects.length > 0) {\n    // 选中模型的第一个模型，设置为红色\n    intersects[0].object.material.color.set(0xff0000);\n}\n',normalizedContent:'# raycaster(射线拾取模型)\n\n上节课给大家介绍过射线ray，下面给大家介绍另一个和射线相关的api射线投射器raycaster。\n\n\n# 射线投射器raycaster\n\n射线投射器raycaster具有一个射线属性.ray，该属性的值就是上节课讲解的射线对象ray。\n\nconst raycaster = new three.raycaster();\nconsole.log(\'射线属性\',raycaster.ray);\n\n\n// 设置射线起点\nraycaster.ray.origin = new three.vector3(-100, 0, 0);\n// 设置射线方向射线方向沿着x轴\nraycaster.ray.direction = new three.vector3(1, 0, 0);\n\n\n\n# 射线交叉计算(.intersectobjects()方法)\n\n射线投射器raycaster通过.intersectobjects()方法可以计算出来与自身射线.ray相交的网格模型。\n\n.intersectobjects([mesh1, mesh2, mesh3])对参数中的网格模型对象进行射线交叉计算,未选中对象返回空数组[],选中一个对象，数组1个元素，选中多个对象，数组多个元素，如果选中多个对象，对象在数组中按照先后排序。\n\nconst raycaster = new three.raycaster();\nraycaster.ray.origin = new three.vector3(-100, 0, 0);\nraycaster.ray.direction = new three.vector3(1, 0, 0);\n// 射线发射拾取模型对象\nconst intersects = raycaster.intersectobjects([mesh1, mesh2, mesh3]);\nconsole.log("射线器返回的对象", intersects);\n\n\n\n# .intersectobjects()射线拾取返回信息\n\n射线拾取返回的intersects里面的元素包含多种信息，你可以通过threejs文档查看，或者在浏览器控制台打印查看。\n\n.intersectobjects()和.intersectobject()功能相同，只是具体语法不同，.intersectobjects()返回数组元素包含的信息，可以参考文档关于.intersectobject()的介绍。\n\nconsole.log("射线器返回的对象", intersects);\n// intersects.length大于0说明，说明选中了模型\nif (intersects.length > 0) {\n    console.log("交叉点坐标", intersects[0].point);\n    console.log("交叉对象",intersects[0].object);\n    console.log("射线原点和交叉点距离",intersects[0].distance);\n}\n\n\n\n# 射线选中的模型对象改变材质颜色\n\nconst intersects = raycaster.intersectobjects([mesh1, mesh2, mesh3]);\nif (intersects.length > 0) {\n    // 选中模型的第一个模型，设置为红色\n    intersects[0].object.material.color.set(0xff0000);\n}\n',charsets:{cjk:!0}},{title:"4. Raycaster(鼠标点击选中模型)",frontmatter:{title:"4. Raycaster(鼠标点击选中模型)",date:"2023-03-03T11:27:58.000Z",permalink:"/pages/f96af1/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/14.14.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E6%A8%A1%E5%9E%8B/04.Raycaster(%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E9%80%89%E4%B8%AD%E6%A8%A1%E5%9E%8B).html",relativePath:"01.Three.js教程/14.14.射线拾取模型/04.Raycaster(鼠标点击选中模型).md",key:"v-48b62e34",path:"/pages/f96af1/",headers:[{level:3,title:"射线拾取网格模型步骤",slug:"射线拾取网格模型步骤",normalizedTitle:"射线拾取网格模型步骤",charIndex:1117},{level:3,title:"1. 坐标转化(屏幕坐标转标准设备坐标)",slug:"_1-坐标转化-屏幕坐标转标准设备坐标",normalizedTitle:"1. 坐标转化(屏幕坐标转标准设备坐标)",charIndex:1205},{level:3,title:"2. 计算射线(.setFromCamera()方法)",slug:"_2-计算射线-setfromcamera-方法",normalizedTitle:"2. 计算射线(.setfromcamera()方法)",charIndex:1448},{level:3,title:"3. 射线交叉计算(.intersectObjects()方法)",slug:"_3-射线交叉计算-intersectobjects-方法",normalizedTitle:"3. 射线交叉计算(.intersectobjects()方法)",charIndex:1793}],headersStr:"射线拾取网格模型步骤 1. 坐标转化(屏幕坐标转标准设备坐标) 2. 计算射线(.setFromCamera()方法) 3. 射线交叉计算(.intersectObjects()方法)",content:"# Raycaster(鼠标点击选中模型)\n\n在实际开发中，射线投射器Raycaster经常会使用到，本节课先通过一个简单的小案例来给大家展示射线投射器Raycaster的射线拾取功能，简单说就是鼠标点击，选中一个模型对象。\n\n下面代码的功能是鼠标单击threejs的canvas画布，通过射线投射器Raycaster射线拾取网格模型，被选中拾取到的网格模型改变颜色。\n\nrenderer.domElement.addEventListener('click', function (event) {\n    // .offsetY、.offsetX以canvas画布左上角为坐标原点,单位px\n    const px = event.offsetX;\n    const py = event.offsetY;\n    //屏幕坐标px、py转WebGL标准设备坐标x、y\n    //width、height表示canvas画布宽高度\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n    //创建一个射线投射器`Raycaster`\n    const raycaster = new THREE.Raycaster();\n    //.setFromCamera()计算射线投射器`Raycaster`的射线属性.ray\n    // 形象点说就是在点击位置创建一条射线，射线穿过的模型代表选中\n    raycaster.setFromCamera(new THREE.Vector2(x, y), camera);\n    //.intersectObjects([mesh1, mesh2, mesh3])对参数中的网格模型对象进行射线交叉计算\n    // 未选中对象返回空数组[],选中一个对象，数组1个元素，选中两个对象，数组两个元素\n    const intersects = raycaster.intersectObjects([mesh1, mesh2, mesh3]);\n    console.log(\"射线器返回的对象\", intersects);\n    // intersects.length大于0说明，说明选中了模型\n    if (intersects.length > 0) {\n        // 选中模型的第一个模型，设置为红色\n        intersects[0].object.material.color.set(0xff0000);\n    }\n})\n\n\n\n# 射线拾取网格模型步骤\n\n * 1.坐标转化(鼠标单击的屏幕坐标转标准设备坐标)\n\n * 2.射线计算(通过鼠标单击位置+相机参数计算射线值)\n\n * 3.射线交叉计算\n\n\n# 1. 坐标转化(屏幕坐标转标准设备坐标)\n\n// .offsetY、.offsetX以canvas画布左上角为坐标原点,单位px\nconst px = event.offsetX;\nconst py = event.offsetY;\n//屏幕坐标px、py转WebGL标准设备坐标x、y\n//width、height表示canvas画布宽高度\nconst x = (px / width) * 2 - 1;\nconst y = -(py / height) * 2 + 1;\n\n\n\n# 2. 计算射线(.setFromCamera()方法)\n\n把鼠标单击位置坐标和相机作为.setFromCamera()方法的参数，.setFromCamera()就会计算射线投射器Raycaster的射线属性.ray,形象点说就是在点击位置创建一条射线，用来选中拾取模型对象。\n\n//创建一个射线投射器`Raycaster`\nconst raycaster = new THREE.Raycaster();\n//.setFromCamera()计算射线投射器`Raycaster`的射线属性.ray\n// 形象点说就是在点击位置创建一条射线，用来选中拾取模型对象\nraycaster.setFromCamera(new THREE.Vector2(x, y), camera);\n\n\n\n# 3. 射线交叉计算(.intersectObjects()方法)\n\n通过.intersectObjects()方法可以计算出来与射线相交的网格模型(语法参考上节课14.2讲解)。\n\nconst intersects = raycaster.intersectObjects([mesh1, mesh2, mesh3]);\nif (intersects.length > 0) {\n    // 选中模型的第一个模型，设置为红色\n    intersects[0].object.material.color.set(0xff0000);\n}\n",normalizedContent:"# raycaster(鼠标点击选中模型)\n\n在实际开发中，射线投射器raycaster经常会使用到，本节课先通过一个简单的小案例来给大家展示射线投射器raycaster的射线拾取功能，简单说就是鼠标点击，选中一个模型对象。\n\n下面代码的功能是鼠标单击threejs的canvas画布，通过射线投射器raycaster射线拾取网格模型，被选中拾取到的网格模型改变颜色。\n\nrenderer.domelement.addeventlistener('click', function (event) {\n    // .offsety、.offsetx以canvas画布左上角为坐标原点,单位px\n    const px = event.offsetx;\n    const py = event.offsety;\n    //屏幕坐标px、py转webgl标准设备坐标x、y\n    //width、height表示canvas画布宽高度\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n    //创建一个射线投射器`raycaster`\n    const raycaster = new three.raycaster();\n    //.setfromcamera()计算射线投射器`raycaster`的射线属性.ray\n    // 形象点说就是在点击位置创建一条射线，射线穿过的模型代表选中\n    raycaster.setfromcamera(new three.vector2(x, y), camera);\n    //.intersectobjects([mesh1, mesh2, mesh3])对参数中的网格模型对象进行射线交叉计算\n    // 未选中对象返回空数组[],选中一个对象，数组1个元素，选中两个对象，数组两个元素\n    const intersects = raycaster.intersectobjects([mesh1, mesh2, mesh3]);\n    console.log(\"射线器返回的对象\", intersects);\n    // intersects.length大于0说明，说明选中了模型\n    if (intersects.length > 0) {\n        // 选中模型的第一个模型，设置为红色\n        intersects[0].object.material.color.set(0xff0000);\n    }\n})\n\n\n\n# 射线拾取网格模型步骤\n\n * 1.坐标转化(鼠标单击的屏幕坐标转标准设备坐标)\n\n * 2.射线计算(通过鼠标单击位置+相机参数计算射线值)\n\n * 3.射线交叉计算\n\n\n# 1. 坐标转化(屏幕坐标转标准设备坐标)\n\n// .offsety、.offsetx以canvas画布左上角为坐标原点,单位px\nconst px = event.offsetx;\nconst py = event.offsety;\n//屏幕坐标px、py转webgl标准设备坐标x、y\n//width、height表示canvas画布宽高度\nconst x = (px / width) * 2 - 1;\nconst y = -(py / height) * 2 + 1;\n\n\n\n# 2. 计算射线(.setfromcamera()方法)\n\n把鼠标单击位置坐标和相机作为.setfromcamera()方法的参数，.setfromcamera()就会计算射线投射器raycaster的射线属性.ray,形象点说就是在点击位置创建一条射线，用来选中拾取模型对象。\n\n//创建一个射线投射器`raycaster`\nconst raycaster = new three.raycaster();\n//.setfromcamera()计算射线投射器`raycaster`的射线属性.ray\n// 形象点说就是在点击位置创建一条射线，用来选中拾取模型对象\nraycaster.setfromcamera(new three.vector2(x, y), camera);\n\n\n\n# 3. 射线交叉计算(.intersectobjects()方法)\n\n通过.intersectobjects()方法可以计算出来与射线相交的网格模型(语法参考上节课14.2讲解)。\n\nconst intersects = raycaster.intersectobjects([mesh1, mesh2, mesh3]);\nif (intersects.length > 0) {\n    // 选中模型的第一个模型，设置为红色\n    intersects[0].object.material.color.set(0xff0000);\n}\n",charsets:{cjk:!0}},{title:"5. Canvas尺寸变化(射线坐标计算)",frontmatter:{title:"5. Canvas尺寸变化(射线坐标计算)",date:"2023-03-03T17:10:03.000Z",permalink:"/pages/6065de/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/14.14.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E6%A8%A1%E5%9E%8B/05.Canvas%E5%B0%BA%E5%AF%B8%E5%8F%98%E5%8C%96(%E5%B0%84%E7%BA%BF%E5%9D%90%E6%A0%87%E8%AE%A1%E7%AE%97).html",relativePath:"01.Three.js教程/14.14.射线拾取模型/05.Canvas尺寸变化(射线坐标计算).md",key:"v-b8bc7f42",path:"/pages/6065de/",headers:[{level:3,title:"canvas画布全屏-尺寸跟着浏览器窗口变化",slug:"canvas画布全屏-尺寸跟着浏览器窗口变化",normalizedTitle:"canvas画布全屏-尺寸跟着浏览器窗口变化",charIndex:197},{level:3,title:"canvas局部布局-尺寸随窗口变化",slug:"canvas局部布局-尺寸随窗口变化",normalizedTitle:"canvas局部布局-尺寸随窗口变化",charIndex:1382}],headersStr:"canvas画布全屏-尺寸跟着浏览器窗口变化 canvas局部布局-尺寸随窗口变化",content:"# Canvas尺寸变化(射线坐标计算)\n\n本节课内容非常简单，就是你鼠标单击canvas画布，用射线拾取模型的时候，有一点要注意，Canvas画布尺寸如果不是固定的，而是变化的，会对坐标变换有影响。\n\n学习本节课内容之前，可以先回顾下，前面关于threejs Canvas画布布局的讲解。\n\n1.12. Canvas画布布局和全屏\n\n8.1. three.js Canvas画布布局\n\n\n# canvas画布全屏-尺寸跟着浏览器窗口变化\n\nconst width = window.innerWidth;\nconst height = window.innerHeight;\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n};\n\n\n如果canvas画布尺寸变化了，下面代码中的width、height还是原来的值,这时候射线拾取就有可能无法拾取到模型对象。\n\nrenderer.domElement.addEventListener('click', function (event) {\n    const px = event.offsetX;\n    const py = event.offsetY;\n    //屏幕坐标转WebGL标准设备坐标\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n\n\n每次触发click事件，都要重新计算canvas画布。\n\nrenderer.domElement.addEventListener('click', function (event) {\n    const px = event.offsetX;\n    const py = event.offsetY;\n    //屏幕坐标转WebGL标准设备坐标\n    const x = (px / window.innerWidth) * 2 - 1;\n    const y = -(py / window.innerHeight) * 2 + 1;\n})\n\n\n特殊情况，canvas画布和body左上角重合，可以用clientX、clientY替换offsetX、offsetY\n\nrenderer.domElement.addEventListener('click', function (event) {\n    const px = event.clientX;\n    const py = event.clientY;\n    //屏幕坐标转WebGL标准设备坐标\n    const x = (px / window.innerWidth) * 2 - 1;\n    const y = -(py / window.innerHeight) * 2 + 1;\n})\n\n\n\n# canvas局部布局-尺寸随窗口变化\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerWidth - 200; //canvas画布宽度\n    const height = window.innerHeight - 60; //canvas画布高度\n    renderer.setSize(width, height);\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    document.getElementById('left').style.height = height + 'px';\n};\n\n\nrenderer.domElement.addEventListener('click', function (event) {\n    const width = window.innerWidth-200;\n    const height = window.innerHeight-60;\n    //屏幕坐标转WebGL标准设备坐标\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n",normalizedContent:"# canvas尺寸变化(射线坐标计算)\n\n本节课内容非常简单，就是你鼠标单击canvas画布，用射线拾取模型的时候，有一点要注意，canvas画布尺寸如果不是固定的，而是变化的，会对坐标变换有影响。\n\n学习本节课内容之前，可以先回顾下，前面关于threejs canvas画布布局的讲解。\n\n1.12. canvas画布布局和全屏\n\n8.1. three.js canvas画布布局\n\n\n# canvas画布全屏-尺寸跟着浏览器窗口变化\n\nconst width = window.innerwidth;\nconst height = window.innerheight;\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    renderer.setsize(window.innerwidth, window.innerheight);\n    camera.aspect = window.innerwidth / window.innerheight;\n    camera.updateprojectionmatrix();\n};\n\n\n如果canvas画布尺寸变化了，下面代码中的width、height还是原来的值,这时候射线拾取就有可能无法拾取到模型对象。\n\nrenderer.domelement.addeventlistener('click', function (event) {\n    const px = event.offsetx;\n    const py = event.offsety;\n    //屏幕坐标转webgl标准设备坐标\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n\n\n每次触发click事件，都要重新计算canvas画布。\n\nrenderer.domelement.addeventlistener('click', function (event) {\n    const px = event.offsetx;\n    const py = event.offsety;\n    //屏幕坐标转webgl标准设备坐标\n    const x = (px / window.innerwidth) * 2 - 1;\n    const y = -(py / window.innerheight) * 2 + 1;\n})\n\n\n特殊情况，canvas画布和body左上角重合，可以用clientx、clienty替换offsetx、offsety\n\nrenderer.domelement.addeventlistener('click', function (event) {\n    const px = event.clientx;\n    const py = event.clienty;\n    //屏幕坐标转webgl标准设备坐标\n    const x = (px / window.innerwidth) * 2 - 1;\n    const y = -(py / window.innerheight) * 2 + 1;\n})\n\n\n\n# canvas局部布局-尺寸随窗口变化\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerwidth - 200; //canvas画布宽度\n    const height = window.innerheight - 60; //canvas画布高度\n    renderer.setsize(width, height);\n    camera.aspect = width / height;\n    camera.updateprojectionmatrix();\n    document.getelementbyid('left').style.height = height + 'px';\n};\n\n\nrenderer.domelement.addeventlistener('click', function (event) {\n    const width = window.innerwidth-200;\n    const height = window.innerheight-60;\n    //屏幕坐标转webgl标准设备坐标\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n",charsets:{cjk:!0}},{title:"3. 屏幕坐标转标准设备坐标",frontmatter:{title:"3. 屏幕坐标转标准设备坐标",date:"2023-03-03T11:14:13.000Z",permalink:"/pages/41d16d/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/14.14.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E6%A8%A1%E5%9E%8B/03.%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87%E8%BD%AC%E6%A0%87%E5%87%86%E8%AE%BE%E5%A4%87%E5%9D%90%E6%A0%87.html",relativePath:"01.Three.js教程/14.14.射线拾取模型/03.屏幕坐标转标准设备坐标.md",key:"v-7a6b5bc6",path:"/pages/41d16d/",headers:[{level:3,title:"获取鼠标事件坐标",slug:"获取鼠标事件坐标",normalizedTitle:"获取鼠标事件坐标",charIndex:51},{level:3,title:"标准设备坐标系",slug:"标准设备坐标系",normalizedTitle:"标准设备坐标系",charIndex:704},{level:3,title:"屏幕坐标转标准设备坐标",slug:"屏幕坐标转标准设备坐标-2",normalizedTitle:"屏幕坐标转标准设备坐标",charIndex:2},{level:3,title:"使用.clientX、.clientY计算canvas画布屏幕坐标",slug:"使用-clientx、-clienty计算canvas画布屏幕坐标",normalizedTitle:"使用.clientx、.clienty计算canvas画布屏幕坐标",charIndex:1504}],headersStr:"获取鼠标事件坐标 标准设备坐标系 屏幕坐标转标准设备坐标 使用.clientX、.clientY计算canvas画布屏幕坐标",content:"# 屏幕坐标转标准设备坐标\n\n在讲解下节课鼠标点击选中模型之前，先给大家讲解下坐标系的问题。\n\n\n# 获取鼠标事件坐标\n\n先来了解一些，普通的web前端相关知识。\n\n鼠标单击HTML元素，通过函数的参数鼠标事件对象event，可以获取一些坐标信息。课件源码中是以threejs的canvas画布为例给大家演示。\n\naddEventListener('click',function(event){\n    // event对象有很多鼠标事件相关信息\n    console.log('event',event);\n})\n\n\n.offsetX、.offsetY表示鼠标单击位置的坐标，单位是像素px，以点击的HTML元素左上角为坐标原点，水平向右方向为x轴，竖直向下方向为y轴。\n\naddEventListener('click',function(event){\n    const px = event.offsetX;\n    const py = event.offsetY;\n})\n\n\n下图灰色区域是一个HTML元素。\n\n.clientX、.clientY和.offsetX、.offsetY含义区别在于坐标原点不同，其他一样。\n\naddEventListener('click',function(event){\n    const cx = event.clientX;\n    const cy = event.clientY;\n})\n\n\n特殊情况，如果HTML元素CSS布局中，距离顶部、左侧距离为零，.clientX、.clientY和.offsetX、.offsetY是相同的。\n\n\n# 标准设备坐标系\n\nThree.js Canvas画布具有一个标准设备坐标系，该坐标系的坐标原点在canvas画布的中间位置，x轴水平向右，y轴竖直向上。\n\n标准设备坐标系的坐标值不是绝对值，是相对值，范围是[-1,1]区间，也是说canvas画布上任何一个位置的坐标，如果用标准设备坐标系去衡量，那么坐标的所有值都在-1到1之间。\n\n\n\n\n# 屏幕坐标转标准设备坐标\n\n你可以用.offsetX和.offsetY当做canvas画布的屏幕坐标。\n\nthreejs canvas画布上一个点，可以用.offsetX、.offsetY绝对值表示，同样也可以用标准设备坐标系去表达。\n\n\n\n把.offsetX和.offsetY坐标转化为标准设备坐标坐标。\n\n// 坐标转化公式\naddEventListener('click',function(event){\n    const px = event.offsetX;\n    const py = event.offsetY;\n    //屏幕坐标px、py转标准设备坐标x、y\n    //width、height表示canvas画布宽高度\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n\n\ncanvas画布的宽度是width，.offsetX的范围是0~width,.offsetX除以canvas画布宽度width，就可以从绝对值变成相对值，范围是0~1，相对值乘以2，范围0~2，再减去1，范围是-1~1，刚好和canvas画布标准设备坐标的范围-1~1能够对应起来。\n\n对于.offsetY的转标准设备坐标y，和.offsetX转标准设备坐标x相似，唯一要注意地方就是两个坐标系的y坐标相反，同样计算方式，最后取相反数即可。\n\n\n# 使用.clientX、.clientY计算canvas画布屏幕坐标\n\n用.offsetX、.offsetY可以直接表示canvas画布屏幕坐标，如果用.clientX、.clientY表示，这时候要注意，把.clientX、.clientY转化为以canvas画布左上角为原点的坐标。\n\n// 屏幕坐标转标准设备坐标\naddEventListener('click',function(event){\n    // left、top表示canvas画布布局，距离顶部和左侧的距离(px)\n    const px = event.clientX-left;\n    const py = event.clientY-top;\n    //屏幕坐标px、py转标准设备坐标x、y\n    //width、height表示canvas画布宽高度\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n\n\n特殊情况，canvas画布，左上角和网页body右上角重合，比如大部分课程canvas全屏布局的案例。\n\n要注意，把.clientX、.clientY转化为以canvas画布左上角为原点的坐标\n\naddEventListener('click',function(event){\n    const px = event.clientX;\n    const py = event.clientY;\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n\n\n实际开发的时候，你可以用.clientX、.clientY计算标准设备坐标，也可以用.offsetX、.offsetY计算标准设备坐标。",normalizedContent:"# 屏幕坐标转标准设备坐标\n\n在讲解下节课鼠标点击选中模型之前，先给大家讲解下坐标系的问题。\n\n\n# 获取鼠标事件坐标\n\n先来了解一些，普通的web前端相关知识。\n\n鼠标单击html元素，通过函数的参数鼠标事件对象event，可以获取一些坐标信息。课件源码中是以threejs的canvas画布为例给大家演示。\n\naddeventlistener('click',function(event){\n    // event对象有很多鼠标事件相关信息\n    console.log('event',event);\n})\n\n\n.offsetx、.offsety表示鼠标单击位置的坐标，单位是像素px，以点击的html元素左上角为坐标原点，水平向右方向为x轴，竖直向下方向为y轴。\n\naddeventlistener('click',function(event){\n    const px = event.offsetx;\n    const py = event.offsety;\n})\n\n\n下图灰色区域是一个html元素。\n\n.clientx、.clienty和.offsetx、.offsety含义区别在于坐标原点不同，其他一样。\n\naddeventlistener('click',function(event){\n    const cx = event.clientx;\n    const cy = event.clienty;\n})\n\n\n特殊情况，如果html元素css布局中，距离顶部、左侧距离为零，.clientx、.clienty和.offsetx、.offsety是相同的。\n\n\n# 标准设备坐标系\n\nthree.js canvas画布具有一个标准设备坐标系，该坐标系的坐标原点在canvas画布的中间位置，x轴水平向右，y轴竖直向上。\n\n标准设备坐标系的坐标值不是绝对值，是相对值，范围是[-1,1]区间，也是说canvas画布上任何一个位置的坐标，如果用标准设备坐标系去衡量，那么坐标的所有值都在-1到1之间。\n\n\n\n\n# 屏幕坐标转标准设备坐标\n\n你可以用.offsetx和.offsety当做canvas画布的屏幕坐标。\n\nthreejs canvas画布上一个点，可以用.offsetx、.offsety绝对值表示，同样也可以用标准设备坐标系去表达。\n\n\n\n把.offsetx和.offsety坐标转化为标准设备坐标坐标。\n\n// 坐标转化公式\naddeventlistener('click',function(event){\n    const px = event.offsetx;\n    const py = event.offsety;\n    //屏幕坐标px、py转标准设备坐标x、y\n    //width、height表示canvas画布宽高度\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n\n\ncanvas画布的宽度是width，.offsetx的范围是0~width,.offsetx除以canvas画布宽度width，就可以从绝对值变成相对值，范围是0~1，相对值乘以2，范围0~2，再减去1，范围是-1~1，刚好和canvas画布标准设备坐标的范围-1~1能够对应起来。\n\n对于.offsety的转标准设备坐标y，和.offsetx转标准设备坐标x相似，唯一要注意地方就是两个坐标系的y坐标相反，同样计算方式，最后取相反数即可。\n\n\n# 使用.clientx、.clienty计算canvas画布屏幕坐标\n\n用.offsetx、.offsety可以直接表示canvas画布屏幕坐标，如果用.clientx、.clienty表示，这时候要注意，把.clientx、.clienty转化为以canvas画布左上角为原点的坐标。\n\n// 屏幕坐标转标准设备坐标\naddeventlistener('click',function(event){\n    // left、top表示canvas画布布局，距离顶部和左侧的距离(px)\n    const px = event.clientx-left;\n    const py = event.clienty-top;\n    //屏幕坐标px、py转标准设备坐标x、y\n    //width、height表示canvas画布宽高度\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n\n\n特殊情况，canvas画布，左上角和网页body右上角重合，比如大部分课程canvas全屏布局的案例。\n\n要注意，把.clientx、.clienty转化为以canvas画布左上角为原点的坐标\n\naddeventlistener('click',function(event){\n    const px = event.clientx;\n    const py = event.clienty;\n    const x = (px / width) * 2 - 1;\n    const y = -(py / height) * 2 + 1;\n})\n\n\n实际开发的时候，你可以用.clientx、.clienty计算标准设备坐标，也可以用.offsetx、.offsety计算标准设备坐标。",charsets:{cjk:!0}},{title:"6. 射线拾取层级模型(模型描边)",frontmatter:{title:"6. 射线拾取层级模型(模型描边)",date:"2023-03-10T08:44:54.000Z",permalink:"/pages/dd2774/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/14.14.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E6%A8%A1%E5%9E%8B/06.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B(%E9%80%89%E4%B8%AD%E6%A8%A1%E5%9E%8B%E5%8F%91%E5%85%89%E6%8F%8F%E8%BE%B9).html",relativePath:"01.Three.js教程/14.14.射线拾取模型/06.射线拾取层级模型(选中模型发光描边).md",key:"v-5c5e9bdc",path:"/pages/dd2774/",headers:[{level:3,title:".intersectObjects()参数的元素是层级模型",slug:"intersectobjects-参数的元素是层级模型",normalizedTitle:".intersectobjects()参数的元素是层级模型",charIndex:218},{level:3,title:".intersectObjects()拾取层级模型解决方法",slug:"intersectobjects-拾取层级模型解决方法",normalizedTitle:".intersectobjects()拾取层级模型解决方法",charIndex:680},{level:3,title:"完整代码",slug:"完整代码",normalizedTitle:"完整代码",charIndex:1445}],headersStr:".intersectObjects()参数的元素是层级模型 .intersectObjects()拾取层级模型解决方法 完整代码",content:"# 射线拾取层级模型(发光描边)\n\n前面几节课演示过，通过射线投射器Raycaster的.intersectObjects()方法可以拾取Mesh模型对象。\n\n如果一个层级模型包含多个网格网格模型Mesh，使用.intersectObjects()方法拾取的时候，返回的结果默认是层级模型的后代Mesh，没办法整体选中该层级模型。\n\n下面以案例：射线拾取工厂设备添加发光描边，给大家演示如何解决含多Mesh的层级模型如何拾取。\n\n\n# .intersectObjects()参数的元素是层级模型\n\n通过Blender查看工厂模型，你可以发现存储罐cunchu.children里面有两个子对象设备A、设备B，这些子对象本身都是由多个Mesh构成的父对象。\n\n执行.intersectObjects(cunchu.children)进行射线拾取计算，返回结果并不是设备A或设备B父对象，而是他们的某个子对象Mesh。\n\nconst cunchu = model.getObjectByName('存储罐');\n// 射线拾取模型对象(包含多个Mesh)\n// 射线交叉计算拾取模型\nconst intersects = raycaster.intersectObjects(cunchu.children);\n\n\n课件源码已经设置好后处理OutlinePass,为了方便测试查看，那个Mesh被选中了，你直接给射线选中模型添加发光描边即可。\n\noutlinePass.selectedObjects = [intersects[0].object];\n\n\n\n# .intersectObjects()拾取层级模型解决方法\n\n.intersectObjects([父对象A,父对象B...])\n\n给需要射线拾取父对象的所有子对象Mesh自定义一个属性.ancestors，然后让该属性指向需要射线拾取父对象。\n\nconst cunchu = model.getObjectByName('存储罐');\n// 射线拾取模型对象(包含多个Mesh)\n// 可以给待选对象的所有子孙后代Mesh，设置一个祖先属性ancestors,值指向祖先(待选对象)    \nfor (let i = 0; i < cunchu.children.length; i++) {\n    const group = cunchu.children[i];\n    //递归遍历chooseObj，并给chooseObj的所有子孙后代设置一个ancestors属性指向自己\n    group.traverse(function (obj) {\n        if (obj.isMesh) {\n            obj.ancestors = group;\n        }\n    })\n}\n// 射线交叉计算拾取模型\nconst intersects = raycaster.intersectObjects(cunchu.children);\nconsole.log('intersects', intersects);\nif (intersects.length > 0) {\n    // 通过.ancestors属性判断那个模型对象被选中了\n    outlinePass.selectedObjects = [intersects[0].object.ancestors];\n}\n\n\n\n# 完整代码\n\n鼠标单击选中工厂某个设备，并添加高亮发光描边后处理效果。\n\naddEventListener('click', function (event) {\n    const px = event.offsetX;\n    const py = event.offsetY;\n    //屏幕坐标转标准设备坐标\n    const x = (px / window.innerWidth) * 2 - 1;\n    const y = -(py / window.innerHeight) * 2 + 1;\n    const raycaster = new THREE.Raycaster();\n    //.setFromCamera()在点击位置生成raycaster的射线ray\n    raycaster.setFromCamera(new THREE.Vector2(x, y), camera);\n    const cunchu = model.getObjectByName('存储罐');\n    // 射线拾取模型对象(包含多个Mesh)\n    // 可以给待选对象的所有子孙后代Mesh，设置一个祖先属性ancestors,值指向祖先(待选对象)    \n    for (let i = 0; i < cunchu.children.length; i++) {\n        const group = cunchu.children[i];\n        //递归遍历chooseObj，并给chooseObj的所有子孙后代设置一个ancestors属性指向自己\n        group.traverse(function (obj) {\n            if (obj.isMesh) {\n                obj.ancestors = group;\n            }\n        })\n    }\n    // 射线交叉计算拾取模型\n    const intersects = raycaster.intersectObjects(cunchu.children);\n    console.log('intersects', intersects);\n    if (intersects.length > 0) {\n        // 通过.ancestors属性判断那个模型对象被选中了\n        outlinePass.selectedObjects = [intersects[0].object.ancestors];\n    }\n})\n",normalizedContent:"# 射线拾取层级模型(发光描边)\n\n前面几节课演示过，通过射线投射器raycaster的.intersectobjects()方法可以拾取mesh模型对象。\n\n如果一个层级模型包含多个网格网格模型mesh，使用.intersectobjects()方法拾取的时候，返回的结果默认是层级模型的后代mesh，没办法整体选中该层级模型。\n\n下面以案例：射线拾取工厂设备添加发光描边，给大家演示如何解决含多mesh的层级模型如何拾取。\n\n\n# .intersectobjects()参数的元素是层级模型\n\n通过blender查看工厂模型，你可以发现存储罐cunchu.children里面有两个子对象设备a、设备b，这些子对象本身都是由多个mesh构成的父对象。\n\n执行.intersectobjects(cunchu.children)进行射线拾取计算，返回结果并不是设备a或设备b父对象，而是他们的某个子对象mesh。\n\nconst cunchu = model.getobjectbyname('存储罐');\n// 射线拾取模型对象(包含多个mesh)\n// 射线交叉计算拾取模型\nconst intersects = raycaster.intersectobjects(cunchu.children);\n\n\n课件源码已经设置好后处理outlinepass,为了方便测试查看，那个mesh被选中了，你直接给射线选中模型添加发光描边即可。\n\noutlinepass.selectedobjects = [intersects[0].object];\n\n\n\n# .intersectobjects()拾取层级模型解决方法\n\n.intersectobjects([父对象a,父对象b...])\n\n给需要射线拾取父对象的所有子对象mesh自定义一个属性.ancestors，然后让该属性指向需要射线拾取父对象。\n\nconst cunchu = model.getobjectbyname('存储罐');\n// 射线拾取模型对象(包含多个mesh)\n// 可以给待选对象的所有子孙后代mesh，设置一个祖先属性ancestors,值指向祖先(待选对象)    \nfor (let i = 0; i < cunchu.children.length; i++) {\n    const group = cunchu.children[i];\n    //递归遍历chooseobj，并给chooseobj的所有子孙后代设置一个ancestors属性指向自己\n    group.traverse(function (obj) {\n        if (obj.ismesh) {\n            obj.ancestors = group;\n        }\n    })\n}\n// 射线交叉计算拾取模型\nconst intersects = raycaster.intersectobjects(cunchu.children);\nconsole.log('intersects', intersects);\nif (intersects.length > 0) {\n    // 通过.ancestors属性判断那个模型对象被选中了\n    outlinepass.selectedobjects = [intersects[0].object.ancestors];\n}\n\n\n\n# 完整代码\n\n鼠标单击选中工厂某个设备，并添加高亮发光描边后处理效果。\n\naddeventlistener('click', function (event) {\n    const px = event.offsetx;\n    const py = event.offsety;\n    //屏幕坐标转标准设备坐标\n    const x = (px / window.innerwidth) * 2 - 1;\n    const y = -(py / window.innerheight) * 2 + 1;\n    const raycaster = new three.raycaster();\n    //.setfromcamera()在点击位置生成raycaster的射线ray\n    raycaster.setfromcamera(new three.vector2(x, y), camera);\n    const cunchu = model.getobjectbyname('存储罐');\n    // 射线拾取模型对象(包含多个mesh)\n    // 可以给待选对象的所有子孙后代mesh，设置一个祖先属性ancestors,值指向祖先(待选对象)    \n    for (let i = 0; i < cunchu.children.length; i++) {\n        const group = cunchu.children[i];\n        //递归遍历chooseobj，并给chooseobj的所有子孙后代设置一个ancestors属性指向自己\n        group.traverse(function (obj) {\n            if (obj.ismesh) {\n                obj.ancestors = group;\n            }\n        })\n    }\n    // 射线交叉计算拾取模型\n    const intersects = raycaster.intersectobjects(cunchu.children);\n    console.log('intersects', intersects);\n    if (intersects.length > 0) {\n        // 通过.ancestors属性判断那个模型对象被选中了\n        outlinepass.selectedobjects = [intersects[0].object.ancestors];\n    }\n})\n",charsets:{cjk:!0}},{title:"1. CSS2DRenderer(HTML标签)",frontmatter:{title:"1. CSS2DRenderer(HTML标签)",date:"2023-03-10T08:45:55.000Z",permalink:"/pages/428714/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/01.CSS2DRenderer(HTM%E5%85%83%E7%B4%A0%E4%BD%9C%E4%B8%BA%E6%A0%87%E7%AD%BE).html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/01.CSS2DRenderer(HTM元素作为标签).md",key:"v-a691e0fc",path:"/pages/428714/",headers:[{level:3,title:"引入扩展库CSS2DRenderer.js",slug:"引入扩展库css2drenderer-js",normalizedTitle:"引入扩展库css2drenderer.js",charIndex:109},{level:3,title:"总体思路",slug:"总体思路",normalizedTitle:"总体思路",charIndex:604},{level:3,title:"1. HTML元素创建标签",slug:"_1-html元素创建标签",normalizedTitle:"1. html元素创建标签",charIndex:761},{level:3,title:"2. CSS2模型对象CSS2DObject",slug:"_2-css2模型对象css2dobject",normalizedTitle:"2. css2模型对象css2dobject",charIndex:1093},{level:3,title:"3. CSS2渲染器CSS2DRenderer",slug:"_3-css2渲染器css2drenderer",normalizedTitle:"3. css2渲染器css2drenderer",charIndex:1618},{level:3,title:"3.1 CSS2Renderer.render()渲染HTML标签",slug:"_3-1-css2renderer-render-渲染html标签",normalizedTitle:"3.1 css2renderer.render()渲染html标签",charIndex:1957},{level:3,title:"3.2 CSS2Renderer.setSize()",slug:"_3-2-css2renderer-setsize",normalizedTitle:"3.2 css2renderer.setsize()",charIndex:2241},{level:3,title:"3.3 渲染结果CSS2Renderer.domElement",slug:"_3-3-渲染结果css2renderer-domelement",normalizedTitle:"3.3 渲染结果css2renderer.domelement",charIndex:2404},{level:3,title:"查看css2Renderer.render()渲染结果CSS2Renderer.domElement",slug:"查看css2renderer-render-渲染结果css2renderer-domelement",normalizedTitle:"查看css2renderer.render()渲染结果css2renderer.domelement",charIndex:2582},{level:3,title:"4. CSS2Renderer.domElement重新定位",slug:"_4-css2renderer-domelement重新定位",normalizedTitle:"4. css2renderer.domelement重新定位",charIndex:3182},{level:3,title:"css2Renderer.render()渲染本质",slug:"css2renderer-render-渲染本质",normalizedTitle:"css2renderer.render()渲染本质",charIndex:3883},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:3548}],headersStr:"引入扩展库CSS2DRenderer.js 总体思路 1. HTML元素创建标签 2. CSS2模型对象CSS2DObject 3. CSS2渲染器CSS2DRenderer 3.1 CSS2Renderer.render()渲染HTML标签 3.2 CSS2Renderer.setSize() 3.3 渲染结果CSS2Renderer.domElement 查看css2Renderer.render()渲染结果CSS2Renderer.domElement 4. CSS2Renderer.domElement重新定位 css2Renderer.render()渲染本质 测试",content:"# CSS2DRenderer(HTML元素作为标签)\n\n下面给大家介绍一个threejs的扩展库CSS2DRenderer.js，通过CSS2DRenderer.js可以把HTML元素作为标签标注三维场景。\n\n\n# 引入扩展库CSS2DRenderer.js\n\n在threejs文件包目录examples/jsm/renderers/，你可以找到CSS2DRenderer.js扩展库。\n\nthreejs扩展库CSS2DRenderer.js提供了两个类CSS2渲染器CSS2DRenderer、CSS2模型对象CSS2DObject。\n\n// 引入CSS2渲染器CSS2DRenderer和CSS2模型对象CSS2DObject\nimport { CSS2DRenderer,CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';\n\n\n// 引入CSS2渲染器CSS2DRenderer\nimport { CSS2DRenderer } from 'three/addons/renderers/CSS2DRenderer.js';\n// 引入CSS2模型对象CSS2DObject\nimport { CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';\n\n\n\n# 总体思路\n\n本节课先为大家演示标签标注最基本的内容，更多需要完善优化的的细节，可以关注后面几节课讲解。\n\n * 1.HTML元素创建标签\n * 2.CSS2模型对象CSS2DObject\n * 3.CSS2渲染器CSS2DRenderer\n * 4.CSS2Renderer.domElement重新定位\n\n\n# 1. HTML元素创建标签\n\n你可以根据需要，使用HTML、CSS代码创建你想要的标签。如果基于vue或react开发，也可以用vue或react创建的UI组件表示标签。\n\n<div id=\"tag\">标签内容</div>\n\n\n如果你想用HTML元素作为标签标注三维场景中模型信息，就需要考虑定位的问题。比如一个模型，在代码中你可以知道它的局部坐标或世界坐标xyz，但是你并不知道渲染后在canvas画布上位置，距离web页面顶部top和左侧的像素px值。\n\n自己写代码把世界坐标xyz，转化为像素px表示屏幕坐标，比较麻烦，不过threejs扩展库CSS2DRenderer.js可以帮助你实现坐标转化，给HTML元素标签定位，下面给大家演示如何实现。\n\n\n# 2. CSS2模型对象CSS2DObject\n\n// 引入CSS2模型对象CSS2DObject\nimport { CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';\n\n\n通过CSS2DObject类，可以把一个HTML元素转化为一个类似threejs网格模型的对象，换句话说就是你可以把CSS2DObject当成threejs的一个模型一样去设置位置.position或添加到场景中。\n\nconst div = document.getElementById('tag');\n// HTML元素转化为threejs的CSS2模型对象\nconst tag = new CSS2DObject(div);\n\n\n你想把HTML标签标注在那个位置，你通过.position属性设置标签模型对象的xyz坐标。\n\ntag.position.set(50,0,50);\n\n\n把HTML元素对应的CSS2模型对象添加到其它模型对象或三维场景中。\n\nscene.add(tag);\n\n\nconst group = new THREE.Group();\ngroup.add(tag);\n\n\n\n# 3. CSS2渲染器CSS2DRenderer\n\n// 引入CSS2渲染器CSS2DRenderer\nimport { CSS2DRenderer } from 'three/addons/renderers/CSS2DRenderer.js';\n\n\n// 创建一个CSS2渲染器CSS2DRenderer\nconst css2Renderer = new CSS2DRenderer();\n\n\nCSS2渲染器CSS2DRenderer和WebGL渲染器WebGLRenderer虽然不同，但是有些属性和方法是相似的，可以类比记忆学习。比如.domElement、.setSize()、.render()。可以先参考webgl渲染器写代码，然后再给大家解释其中的含义。\n\n\n# 3.1 CSS2Renderer.render()渲染HTML标签\n\nCSS2渲染器CSS2DRenderer和常用的WebGL渲染器WebGLRenderer一样都是渲染器，只是渲染模型对象不同，WebGLRenderer主要是渲染threejs自身的网格、点、线等模型，CSS2DRenderer用来渲染HTML元素标签对应的CSS2模型对象CSS2DObject。\n\n// 用法和webgl渲染器渲染方法类似\ncss2Renderer.render(scene, camera);\n// renderer.render(scene, camera);\n\n\n\n# 3.2 CSS2Renderer.setSize()\n\n设置CSS2Renderer.render()渲染输出标签的尺寸范围，一般和threejs canvas画布宽高度一致即可。\n\n// width, height：canvas画布宽高度\ncss2Renderer.setSize(width, height);\n\n\n\n# 3.3 渲染结果CSS2Renderer.domElement\n\nCSS2Renderer.render()渲染会输出标签对应的HTML元素，也就是css2Renderer.domElement，你可以插入到web网页中任何你想放的位置。\n\ndocument.body.appendChild(css2Renderer.domElement);\n\n\n\n# 查看css2Renderer.render()渲染结果CSS2Renderer.domElement\n\nthreejs执行css2Renderer.render()之后，你打开浏览器控制台元素选项,找到你创建的HTML标签<div id=\"tag\">标签内容</div>，你可以发现<div id=\"tag\"></div>外面多了一层div父元素,CSS2Renderer.domElement对应的就是<div id=\"tag\"></div>外面的父元素。\n\ndocument.body.appendChild(css2Renderer.domElement);\n// 渲染HTML标签对应的CSS2DObject模型对象\ncss2Renderer.render(scene, camera);\n\n\n外面父元素的宽高度也被CSS2Renderer设置为threejs canvas画布的宽高度，就是css2Renderer.setSize(width, height);设置的结果。\n\ncss2Renderer.setSize(width, height);\n\n\n\x3c!-- `<div id=\"tag\"></div>`外面多了一层div父元素 --\x3e\n<div style=\"overflow: hidden; width: 600px; height: 300px;\">\n</div>\n\n\n\n# 4. CSS2Renderer.domElement重新定位\n\n<div id=\"tag\"></div>外面div父元素重新定位，叠加到canvas画布上，与canvas画布重合即可，你可以可以看到HTML标签的标注效果。\n\nCSS2Renderer.domElement定位方法很多，不过这都是普通前端CSS知识，也不一定要与课程相同，你可以根据你自己的前端CSS知识，自由发挥。你只要能让标签父元素叠加到threejs canvas画布上面且重合就行。\n\n下面是本节课案例中布局方式写法，后面也会给大家演示其它的布局写法。\n\ncss2Renderer.domElement.style.position = 'absolute';\ncss2Renderer.domElement.style.top = '0px';\n\n\n你可以测试下面两个div元素的布局规律，会知道为什么设置.style.top = '0px'。\n\n<div style=\"height: 300px;background: #999;\">默认定位元素</div>\n<div style=\"position: absolute;\">绝对定位</div>\n\n\n改变canvas画布在网页的布局位置，标签父元素css2Renderer.domElement也要跟着重新定位\n\n// 改变canvas画布在网页位置，标签父元素也要重新定位\nrenderer.domElement.style.marginTop = '200px';\ncss2Renderer.domElement.style.top = '200px';\n\n\n\n# css2Renderer.render()渲染本质\n\n<div id=\"tag\"></div>本身也多了一些CSS位置相关属性，这些都是css2Renderer.render()渲染的结果。你也可以发现，你创建的HTML标签<div id=\"tag\"></div>不在原来的位置了，其实是被CSS2Renderer改变了位置。\n\ncss2Renderer.render()渲染HTML元素对应的CSS2模型对象，本质上就是根据CSS2模型对象的xyz世界坐标，计算HTML标签元素在canvas画布上的屏幕像素坐标位置。\n\nconst div = document.getElementById('tag');\n// HTML元素转化为threejs的CSS2模型对象\nconst tag = new CSS2DObject(div);\n\n\n// 渲染HTML标签对应的CSS2DObject模型对象\ncss2Renderer.render(scene, camera);\n\n\n\n# 测试\n\n改变模型mesh位置。\n\nmesh.position.set(100,0,0);\n\n\n如果你想用HTML元素标注模型，可以把CSS2模型对象也设置在mesh对应的位置。\n\ntag.position.set(100,0,0);\n",normalizedContent:"# css2drenderer(html元素作为标签)\n\n下面给大家介绍一个threejs的扩展库css2drenderer.js，通过css2drenderer.js可以把html元素作为标签标注三维场景。\n\n\n# 引入扩展库css2drenderer.js\n\n在threejs文件包目录examples/jsm/renderers/，你可以找到css2drenderer.js扩展库。\n\nthreejs扩展库css2drenderer.js提供了两个类css2渲染器css2drenderer、css2模型对象css2dobject。\n\n// 引入css2渲染器css2drenderer和css2模型对象css2dobject\nimport { css2drenderer,css2dobject } from 'three/addons/renderers/css2drenderer.js';\n\n\n// 引入css2渲染器css2drenderer\nimport { css2drenderer } from 'three/addons/renderers/css2drenderer.js';\n// 引入css2模型对象css2dobject\nimport { css2dobject } from 'three/addons/renderers/css2drenderer.js';\n\n\n\n# 总体思路\n\n本节课先为大家演示标签标注最基本的内容，更多需要完善优化的的细节，可以关注后面几节课讲解。\n\n * 1.html元素创建标签\n * 2.css2模型对象css2dobject\n * 3.css2渲染器css2drenderer\n * 4.css2renderer.domelement重新定位\n\n\n# 1. html元素创建标签\n\n你可以根据需要，使用html、css代码创建你想要的标签。如果基于vue或react开发，也可以用vue或react创建的ui组件表示标签。\n\n<div id=\"tag\">标签内容</div>\n\n\n如果你想用html元素作为标签标注三维场景中模型信息，就需要考虑定位的问题。比如一个模型，在代码中你可以知道它的局部坐标或世界坐标xyz，但是你并不知道渲染后在canvas画布上位置，距离web页面顶部top和左侧的像素px值。\n\n自己写代码把世界坐标xyz，转化为像素px表示屏幕坐标，比较麻烦，不过threejs扩展库css2drenderer.js可以帮助你实现坐标转化，给html元素标签定位，下面给大家演示如何实现。\n\n\n# 2. css2模型对象css2dobject\n\n// 引入css2模型对象css2dobject\nimport { css2dobject } from 'three/addons/renderers/css2drenderer.js';\n\n\n通过css2dobject类，可以把一个html元素转化为一个类似threejs网格模型的对象，换句话说就是你可以把css2dobject当成threejs的一个模型一样去设置位置.position或添加到场景中。\n\nconst div = document.getelementbyid('tag');\n// html元素转化为threejs的css2模型对象\nconst tag = new css2dobject(div);\n\n\n你想把html标签标注在那个位置，你通过.position属性设置标签模型对象的xyz坐标。\n\ntag.position.set(50,0,50);\n\n\n把html元素对应的css2模型对象添加到其它模型对象或三维场景中。\n\nscene.add(tag);\n\n\nconst group = new three.group();\ngroup.add(tag);\n\n\n\n# 3. css2渲染器css2drenderer\n\n// 引入css2渲染器css2drenderer\nimport { css2drenderer } from 'three/addons/renderers/css2drenderer.js';\n\n\n// 创建一个css2渲染器css2drenderer\nconst css2renderer = new css2drenderer();\n\n\ncss2渲染器css2drenderer和webgl渲染器webglrenderer虽然不同，但是有些属性和方法是相似的，可以类比记忆学习。比如.domelement、.setsize()、.render()。可以先参考webgl渲染器写代码，然后再给大家解释其中的含义。\n\n\n# 3.1 css2renderer.render()渲染html标签\n\ncss2渲染器css2drenderer和常用的webgl渲染器webglrenderer一样都是渲染器，只是渲染模型对象不同，webglrenderer主要是渲染threejs自身的网格、点、线等模型，css2drenderer用来渲染html元素标签对应的css2模型对象css2dobject。\n\n// 用法和webgl渲染器渲染方法类似\ncss2renderer.render(scene, camera);\n// renderer.render(scene, camera);\n\n\n\n# 3.2 css2renderer.setsize()\n\n设置css2renderer.render()渲染输出标签的尺寸范围，一般和threejs canvas画布宽高度一致即可。\n\n// width, height：canvas画布宽高度\ncss2renderer.setsize(width, height);\n\n\n\n# 3.3 渲染结果css2renderer.domelement\n\ncss2renderer.render()渲染会输出标签对应的html元素，也就是css2renderer.domelement，你可以插入到web网页中任何你想放的位置。\n\ndocument.body.appendchild(css2renderer.domelement);\n\n\n\n# 查看css2renderer.render()渲染结果css2renderer.domelement\n\nthreejs执行css2renderer.render()之后，你打开浏览器控制台元素选项,找到你创建的html标签<div id=\"tag\">标签内容</div>，你可以发现<div id=\"tag\"></div>外面多了一层div父元素,css2renderer.domelement对应的就是<div id=\"tag\"></div>外面的父元素。\n\ndocument.body.appendchild(css2renderer.domelement);\n// 渲染html标签对应的css2dobject模型对象\ncss2renderer.render(scene, camera);\n\n\n外面父元素的宽高度也被css2renderer设置为threejs canvas画布的宽高度，就是css2renderer.setsize(width, height);设置的结果。\n\ncss2renderer.setsize(width, height);\n\n\n\x3c!-- `<div id=\"tag\"></div>`外面多了一层div父元素 --\x3e\n<div style=\"overflow: hidden; width: 600px; height: 300px;\">\n</div>\n\n\n\n# 4. css2renderer.domelement重新定位\n\n<div id=\"tag\"></div>外面div父元素重新定位，叠加到canvas画布上，与canvas画布重合即可，你可以可以看到html标签的标注效果。\n\ncss2renderer.domelement定位方法很多，不过这都是普通前端css知识，也不一定要与课程相同，你可以根据你自己的前端css知识，自由发挥。你只要能让标签父元素叠加到threejs canvas画布上面且重合就行。\n\n下面是本节课案例中布局方式写法，后面也会给大家演示其它的布局写法。\n\ncss2renderer.domelement.style.position = 'absolute';\ncss2renderer.domelement.style.top = '0px';\n\n\n你可以测试下面两个div元素的布局规律，会知道为什么设置.style.top = '0px'。\n\n<div style=\"height: 300px;background: #999;\">默认定位元素</div>\n<div style=\"position: absolute;\">绝对定位</div>\n\n\n改变canvas画布在网页的布局位置，标签父元素css2renderer.domelement也要跟着重新定位\n\n// 改变canvas画布在网页位置，标签父元素也要重新定位\nrenderer.domelement.style.margintop = '200px';\ncss2renderer.domelement.style.top = '200px';\n\n\n\n# css2renderer.render()渲染本质\n\n<div id=\"tag\"></div>本身也多了一些css位置相关属性，这些都是css2renderer.render()渲染的结果。你也可以发现，你创建的html标签<div id=\"tag\"></div>不在原来的位置了，其实是被css2renderer改变了位置。\n\ncss2renderer.render()渲染html元素对应的css2模型对象，本质上就是根据css2模型对象的xyz世界坐标，计算html标签元素在canvas画布上的屏幕像素坐标位置。\n\nconst div = document.getelementbyid('tag');\n// html元素转化为threejs的css2模型对象\nconst tag = new css2dobject(div);\n\n\n// 渲染html标签对应的css2dobject模型对象\ncss2renderer.render(scene, camera);\n\n\n\n# 测试\n\n改变模型mesh位置。\n\nmesh.position.set(100,0,0);\n\n\n如果你想用html元素标注模型，可以把css2模型对象也设置在mesh对应的位置。\n\ntag.position.set(100,0,0);\n",charsets:{cjk:!0}},{title:"2. HTML标签遮挡Canvas画布事件",frontmatter:{title:"2. HTML标签遮挡Canvas画布事件",date:"2023-03-10T08:46:37.000Z",permalink:"/pages/63aef4/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/02.HTML%E6%A0%87%E7%AD%BE%E9%81%AE%E6%8C%A1Canvas%E7%94%BB%E5%B8%83%E4%BA%8B%E4%BB%B6.html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/02.HTML标签遮挡Canvas画布事件.md",key:"v-505a04dd",path:"/pages/63aef4/",headers:[{level:3,title:".style.pointerEvents",slug:"style-pointerevents",normalizedTitle:".style.pointerevents",charIndex:180},{level:3,title:"CSS属性z-index",slug:"css属性z-index",normalizedTitle:"css属性z-index",charIndex:391}],headersStr:".style.pointerEvents CSS属性z-index",content:"# HTML标签遮挡Canvas画布事件\n\nHTML元素标签<div id=\"tag\"></div>外面div父元素遮挡了Canvas画布鼠标事件，会造成相机控件OrbitControls的旋转、缩放等操作无效，也有可能会影响你的射线拾取,等等任何与canvas画布有关的鼠标事件都有可能收到影响，不过这算是普通web前端内容，选择前端方式解决即可。\n\n\n# .style.pointerEvents\n\n设置.style.pointerEvents = none，就可以解决HTML元素标签对threejs canvas画布鼠标事件的遮挡。\n\ncss2Renderer.domElement.style.pointerEvents = 'none';\n\n\n这时候你在测试threejs代码执行效果，你会发现OrbitControls旋转缩放是正常的、射线也能正常拾取模型。\n\n\n# CSS属性z-index\n\n说到模型标签CSS2DRenderer.domElement遮挡canvas画布的问题，有必要给大家提一下CSS属性z-index，简单说就是HTML元素位置重合的时候，谁在上，谁在下的问题。如果你不熟悉CSS属性z-index熟悉，可以百度了解下，下面主要给大家说下该属性对threejs HTML标签的影响。\n\n在实际开发中，有时候可能会出现threejs canvas画布遮挡标签HTML元素的问题，这种现象可能出现，也可能不出现，具体和你的前端代码有关。如果你的代码中HTML元素标签被canvas画布挡住了，这时候你可以调整CSS布局代码，或者直接修改z-index的值。\n\n本节课和上节课案例，threejs标签默认是叠加在canvas画布上，下面就通过强制修改z-index值给大家演示下。\n\ncss2Renderer.domElement在下，threejs canvas画布在上，标签被canvas画布遮挡，看不到标签。\n\nrenderer.domElement.style.zIndex = 1;\ncss2Renderer.domElement.style.zIndex = -1;\n\n\ncss2Renderer.domElement在上，threejs canvas画布在下，可以看到标签\n\nrenderer.domElement.style.zIndex = -1;\ncss2Renderer.domElement.style.zIndex = 1;\n",normalizedContent:"# html标签遮挡canvas画布事件\n\nhtml元素标签<div id=\"tag\"></div>外面div父元素遮挡了canvas画布鼠标事件，会造成相机控件orbitcontrols的旋转、缩放等操作无效，也有可能会影响你的射线拾取,等等任何与canvas画布有关的鼠标事件都有可能收到影响，不过这算是普通web前端内容，选择前端方式解决即可。\n\n\n# .style.pointerevents\n\n设置.style.pointerevents = none，就可以解决html元素标签对threejs canvas画布鼠标事件的遮挡。\n\ncss2renderer.domelement.style.pointerevents = 'none';\n\n\n这时候你在测试threejs代码执行效果，你会发现orbitcontrols旋转缩放是正常的、射线也能正常拾取模型。\n\n\n# css属性z-index\n\n说到模型标签css2drenderer.domelement遮挡canvas画布的问题，有必要给大家提一下css属性z-index，简单说就是html元素位置重合的时候，谁在上，谁在下的问题。如果你不熟悉css属性z-index熟悉，可以百度了解下，下面主要给大家说下该属性对threejs html标签的影响。\n\n在实际开发中，有时候可能会出现threejs canvas画布遮挡标签html元素的问题，这种现象可能出现，也可能不出现，具体和你的前端代码有关。如果你的代码中html元素标签被canvas画布挡住了，这时候你可以调整css布局代码，或者直接修改z-index的值。\n\n本节课和上节课案例，threejs标签默认是叠加在canvas画布上，下面就通过强制修改z-index值给大家演示下。\n\ncss2renderer.domelement在下，threejs canvas画布在上，标签被canvas画布遮挡，看不到标签。\n\nrenderer.domelement.style.zindex = 1;\ncss2renderer.domelement.style.zindex = -1;\n\n\ncss2renderer.domelement在上，threejs canvas画布在下，可以看到标签\n\nrenderer.domelement.style.zindex = -1;\ncss2renderer.domelement.style.zindex = 1;\n",charsets:{cjk:!0}},{title:"4. 标签位置不同设置方式",frontmatter:{title:"4. 标签位置不同设置方式",date:"2023-03-13T10:58:42.000Z",permalink:"/pages/9b6a56/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/04.%E6%A0%87%E7%AD%BE%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%E8%AE%BE%E7%BD%AE%E6%96%B9%E5%BC%8F.html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/04.标签位置不同设置方式.md",key:"v-20360617",path:"/pages/9b6a56/",headers:[{level:3,title:"mesh增加一个父对象,查看标签变化",slug:"mesh增加一个父对象-查看标签变化",normalizedTitle:"mesh增加一个父对象,查看标签变化",charIndex:323},{level:3,title:".getWorldPosition()方法计算世界坐标",slug:"getworldposition-方法计算世界坐标",normalizedTitle:".getworldposition()方法计算世界坐标",charIndex:711},{level:3,title:"CSS2模型对象作为Mesh子对象",slug:"css2模型对象作为mesh子对象",normalizedTitle:"css2模型对象作为mesh子对象",charIndex:1288},{level:3,title:"标注模型几何体的某个顶点",slug:"标注模型几何体的某个顶点",normalizedTitle:"标注模型几何体的某个顶点",charIndex:1534},{level:3,title:"标注圆锥顶部(了解局部坐标系原点)",slug:"标注圆锥顶部-了解局部坐标系原点",normalizedTitle:"标注圆锥顶部(了解局部坐标系原点)",charIndex:1860}],headersStr:"mesh增加一个父对象,查看标签变化 .getWorldPosition()方法计算世界坐标 CSS2模型对象作为Mesh子对象 标注模型几何体的某个顶点 标注圆锥顶部(了解局部坐标系原点)",content:"# 标签位置不同设置方式\n\n前面给大家讲解过，你想把HTML元素标签标注在三维场景中哪个位置，可以设置HTML标签对应的CSS2模型对象CSS2DObject位置属性.position。\n\nCSS2模型标签对象位置和要标注的Mesh放在同一个位置，这样HTML标签就可以标注Mesh。\n\nmesh.position.set(50,0,50);\n\n// HTML元素转化为threejs的CSS2模型对象\nconst tag = new CSS2DObject(div);\ntag.position.set(50,0,50);\n\ngroup.add(mesh,tag);\n\n\n在学习本节课之前，最好把章节4关于层级模型知识的讲解回顾一下。\n\n\n# mesh增加一个父对象,查看标签变化\n\nmesh增加一个父对象,且设置父对象的位置坐标，然后查看标签变化。\n\nmesh.position.set(50,0,50);\n// mesh设置一个父对象meshGroup\nconst meshGroup = new THREE.Group();\nmeshGroup.add(mesh);\n// mesh位置受到父对象局部坐标.positionn影响\nmeshGroup.position.x = -100;\n\n\n如果需要的mesh有多个父对象，且都有自己的位置属性.position，设置mesh标签对象位置CSS2DObject.position的时候，就需要考虑mesh父对象的位置对mesh的影响。\n\n// tag.position.set(50,0,50);\ntag.position.set(-50,0,50);\n\n\n\n# .getWorldPosition()方法计算世界坐标\n\n前面4.3节. 本地坐标和世界坐标内容讲解过，通过.getWorldPosition()方法可以获取一个模型的世界坐标。\n\nmesh.position.set(50,0,50);\n// mesh设置一个父对象meshGroup\nconst meshGroup = new THREE.Group();\nmeshGroup.add(mesh);\n// mesh位置受到父对象局部坐标.positionn影响\nmeshGroup.position.x = -100;\n\nconst tag = new CSS2DObject(div);\nconst worldPosition = new THREE.Vector3();\n// 获取mesh的世界坐标(meshGroup.position和mesh.position累加结果)\nmesh.getWorldPosition(worldPosition);\n// mesh世界坐标复制给tag\ntag.position.copy(worldPosition);\n\nconst group = new THREE.Group();\n// 最后meshGroup和tag放在同一个父对象中即可\ngroup.add(meshGroup,tag);\n\n\n\n# CSS2模型对象作为Mesh子对象\n\n无论mesh有多少个父对象，CSS2模型对象作为Mesh子对象,可以直接继承mesh的世界坐标，相比通过.getWorldPosition()方法获取世界坐标，再设置标签模型位置CSS2DObject.position更方便。\n\n// HTML元素转化为threejs的CSS2模型对象\nconst tag = new CSS2DObject(div);\n//标签tag作为mesh子对象，默认受到父对象位置影响\nmesh.add(tag);\n\n\n\n# 标注模型几何体的某个顶点\n\n标签模型对象作为需要标注mesh的子对象，然后获取mesh几何体某个顶点的坐标，作为标签模型对象局部坐标.position。\n\n// HTML元素转化为threejs的CSS2模型对象\nconst tag = new CSS2DObject(div);\n//标签tag作为mesh子对象，默认受到父对象位置影响\nmesh.add(tag);\n\nconst pos = geometry.attributes.position;\n// 获取几何体顶点1的xyz坐标，设置标签局部坐标.position属性\ntag.position.set(pos.getX(0),pos.getY(0),pos.getZ(0));\n\n\n\n# 标注圆锥顶部(了解局部坐标系原点)\n\n圆锥几何体局部坐标系默认位于自己高度一半位置。\n\nconst geometry = new THREE.ConeGeometry(25, 80);\nconst mesh = new THREE.Mesh(geometry, material);\n// 可视化模型的局部坐标系\nconst axesHelper = new THREE.AxesHelper(100);\nmesh.add(axesHelper);\n\n\n一个模型对象，不管是一个mesh，还是多个mesh组成的模型，本身是有尺寸的，如果你把标签模型对象CSS2DObject作为该模型对象的子元素，标签默认是标注在模型的局部坐标系坐标原点。\n\nconst div = document.getElementById('tag');\n// HTML元素转化为threejs的CSS2模型对象\nconst tag = new CSS2DObject(div);\n//标签tag作为mesh子对象，默认受到父对象位置影响\nmesh.add(tag);\n\n\n平移改变圆锥几何体顶点坐标，圆锥mesh的局部坐标系相对自身发生改变，位于圆锥底部，标签想标注在顶部，除了标签作为圆锥mesh子对象，还需要向上平移圆锥Mesh的高度尺寸。\n\n//y轴正方向，平移高度一半\ngeometry.translate(0, 40, 0); \n//圆锥mesh局部坐标系原点在自己底部时候，标签需要向上偏移圆锥自身高度\ntag.position.y += 80; \n\n\n沿着y方向平移-40，改变圆锥几何体顶点坐标，圆锥mesh的局部坐标系坐标原点此刻位于圆锥顶部，这样标签刚好标注在顶部。\n\n//y轴负方向，平移高度一半，标签刚好标注在顶部\ngeometry.translate(0,-40,0);\n",normalizedContent:"# 标签位置不同设置方式\n\n前面给大家讲解过，你想把html元素标签标注在三维场景中哪个位置，可以设置html标签对应的css2模型对象css2dobject位置属性.position。\n\ncss2模型标签对象位置和要标注的mesh放在同一个位置，这样html标签就可以标注mesh。\n\nmesh.position.set(50,0,50);\n\n// html元素转化为threejs的css2模型对象\nconst tag = new css2dobject(div);\ntag.position.set(50,0,50);\n\ngroup.add(mesh,tag);\n\n\n在学习本节课之前，最好把章节4关于层级模型知识的讲解回顾一下。\n\n\n# mesh增加一个父对象,查看标签变化\n\nmesh增加一个父对象,且设置父对象的位置坐标，然后查看标签变化。\n\nmesh.position.set(50,0,50);\n// mesh设置一个父对象meshgroup\nconst meshgroup = new three.group();\nmeshgroup.add(mesh);\n// mesh位置受到父对象局部坐标.positionn影响\nmeshgroup.position.x = -100;\n\n\n如果需要的mesh有多个父对象，且都有自己的位置属性.position，设置mesh标签对象位置css2dobject.position的时候，就需要考虑mesh父对象的位置对mesh的影响。\n\n// tag.position.set(50,0,50);\ntag.position.set(-50,0,50);\n\n\n\n# .getworldposition()方法计算世界坐标\n\n前面4.3节. 本地坐标和世界坐标内容讲解过，通过.getworldposition()方法可以获取一个模型的世界坐标。\n\nmesh.position.set(50,0,50);\n// mesh设置一个父对象meshgroup\nconst meshgroup = new three.group();\nmeshgroup.add(mesh);\n// mesh位置受到父对象局部坐标.positionn影响\nmeshgroup.position.x = -100;\n\nconst tag = new css2dobject(div);\nconst worldposition = new three.vector3();\n// 获取mesh的世界坐标(meshgroup.position和mesh.position累加结果)\nmesh.getworldposition(worldposition);\n// mesh世界坐标复制给tag\ntag.position.copy(worldposition);\n\nconst group = new three.group();\n// 最后meshgroup和tag放在同一个父对象中即可\ngroup.add(meshgroup,tag);\n\n\n\n# css2模型对象作为mesh子对象\n\n无论mesh有多少个父对象，css2模型对象作为mesh子对象,可以直接继承mesh的世界坐标，相比通过.getworldposition()方法获取世界坐标，再设置标签模型位置css2dobject.position更方便。\n\n// html元素转化为threejs的css2模型对象\nconst tag = new css2dobject(div);\n//标签tag作为mesh子对象，默认受到父对象位置影响\nmesh.add(tag);\n\n\n\n# 标注模型几何体的某个顶点\n\n标签模型对象作为需要标注mesh的子对象，然后获取mesh几何体某个顶点的坐标，作为标签模型对象局部坐标.position。\n\n// html元素转化为threejs的css2模型对象\nconst tag = new css2dobject(div);\n//标签tag作为mesh子对象，默认受到父对象位置影响\nmesh.add(tag);\n\nconst pos = geometry.attributes.position;\n// 获取几何体顶点1的xyz坐标，设置标签局部坐标.position属性\ntag.position.set(pos.getx(0),pos.gety(0),pos.getz(0));\n\n\n\n# 标注圆锥顶部(了解局部坐标系原点)\n\n圆锥几何体局部坐标系默认位于自己高度一半位置。\n\nconst geometry = new three.conegeometry(25, 80);\nconst mesh = new three.mesh(geometry, material);\n// 可视化模型的局部坐标系\nconst axeshelper = new three.axeshelper(100);\nmesh.add(axeshelper);\n\n\n一个模型对象，不管是一个mesh，还是多个mesh组成的模型，本身是有尺寸的，如果你把标签模型对象css2dobject作为该模型对象的子元素，标签默认是标注在模型的局部坐标系坐标原点。\n\nconst div = document.getelementbyid('tag');\n// html元素转化为threejs的css2模型对象\nconst tag = new css2dobject(div);\n//标签tag作为mesh子对象，默认受到父对象位置影响\nmesh.add(tag);\n\n\n平移改变圆锥几何体顶点坐标，圆锥mesh的局部坐标系相对自身发生改变，位于圆锥底部，标签想标注在顶部，除了标签作为圆锥mesh子对象，还需要向上平移圆锥mesh的高度尺寸。\n\n//y轴正方向，平移高度一半\ngeometry.translate(0, 40, 0); \n//圆锥mesh局部坐标系原点在自己底部时候，标签需要向上偏移圆锥自身高度\ntag.position.y += 80; \n\n\n沿着y方向平移-40，改变圆锥几何体顶点坐标，圆锥mesh的局部坐标系坐标原点此刻位于圆锥顶部，这样标签刚好标注在顶部。\n\n//y轴负方向，平移高度一半，标签刚好标注在顶部\ngeometry.translate(0,-40,0);\n",charsets:{cjk:!0}},{title:"7. 射线拾取Sprite控制场景",frontmatter:{title:"7. 射线拾取Sprite控制场景",date:"2023-03-10T08:45:10.000Z",permalink:"/pages/b73a83/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/14.14.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E6%A8%A1%E5%9E%8B/07.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96Sprite%E6%8E%A7%E5%88%B6%E5%9C%BA%E6%99%AF.html",relativePath:"01.Three.js教程/14.14.射线拾取模型/07.射线拾取Sprite控制场景.md",key:"v-a5230b16",path:"/pages/b73a83/",headers:[{level:3,title:"给精灵模型绑定一个函数.change()",slug:"给精灵模型绑定一个函数-change",normalizedTitle:"给精灵模型绑定一个函数.change()",charIndex:143},{level:3,title:"射线选中Sprite,sprite.change()函数执行",slug:"射线选中sprite-sprite-change-函数执行",normalizedTitle:"射线选中sprite,sprite.change()函数执行",charIndex:345}],headersStr:"给精灵模型绑定一个函数.change() 射线选中Sprite,sprite.change()函数执行",content:"# 射线拾取Sprite控制场景\n\n射线投射器Raycaster通过.intersectObjects()方法可以拾取网格模型Mesh，一样也可以拾取精灵模型Sprite。\n\n下面举一个例子，把精灵模型当做一个功能按钮，当鼠标单击选中以后，改变3D场景中参数，比如模型的颜色。\n\n\n# 给精灵模型绑定一个函数.change()\n\n三维场景中提供了两个精灵模型对象，可以分别自定义一个方法.change()。\n\nsprite.change = function(){\n  mesh.material.color.set(0xffffff);\n}\nsprite2.change = function(){\n  mesh.material.color.set(0xffff00);\n}\n\n\n\n# 射线选中Sprite,sprite.change()函数执行\n\n鼠标单击，如果选中某个精灵模型，就调用该精灵模型绑定的函数.change()。\n\naddEventListener('click', function (event) {\n    ...\n    ...\n    // 射线交叉计算拾取精灵模型\n    const intersects = raycaster.intersectObjects([sprite,sprite2]);\n    if (intersects.length > 0) {\n        intersects[0].object.change();//执行选中sprite绑定的change函数\n    }\n})\n",normalizedContent:"# 射线拾取sprite控制场景\n\n射线投射器raycaster通过.intersectobjects()方法可以拾取网格模型mesh，一样也可以拾取精灵模型sprite。\n\n下面举一个例子，把精灵模型当做一个功能按钮，当鼠标单击选中以后，改变3d场景中参数，比如模型的颜色。\n\n\n# 给精灵模型绑定一个函数.change()\n\n三维场景中提供了两个精灵模型对象，可以分别自定义一个方法.change()。\n\nsprite.change = function(){\n  mesh.material.color.set(0xffffff);\n}\nsprite2.change = function(){\n  mesh.material.color.set(0xffff00);\n}\n\n\n\n# 射线选中sprite,sprite.change()函数执行\n\n鼠标单击，如果选中某个精灵模型，就调用该精灵模型绑定的函数.change()。\n\naddeventlistener('click', function (event) {\n    ...\n    ...\n    // 射线交叉计算拾取精灵模型\n    const intersects = raycaster.intersectobjects([sprite,sprite2]);\n    if (intersects.length > 0) {\n        intersects[0].object.change();//执行选中sprite绑定的change函数\n    }\n})\n",charsets:{cjk:!0}},{title:"3. Canvas尺寸变化(HTML标签)",frontmatter:{title:"3. Canvas尺寸变化(HTML标签)",date:"2023-03-10T16:54:59.000Z",permalink:"/pages/0801b3/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/03.Canvas%E7%94%BB%E5%B8%83%E5%B0%BA%E5%AF%B8%E5%8F%98%E5%8C%96(HTML%E6%A0%87%E7%AD%BE).html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/03.Canvas画布尺寸变化(HTML标签).md",key:"v-bb92678c",path:"/pages/0801b3/",headers:[{level:3,title:"Canvas全屏尺寸变化，CSS2渲染器设置",slug:"canvas全屏尺寸变化-css2渲染器设置",normalizedTitle:"canvas全屏尺寸变化，css2渲染器设置",charIndex:421},{level:3,title:"canvas局部布局-，CSS2渲染器设置",slug:"canvas局部布局-css2渲染器设置",normalizedTitle:"canvas局部布局-，css2渲染器设置",charIndex:974},{level:3,title:"局部布局Canvas尺寸变化，CSS2渲染器设置",slug:"局部布局canvas尺寸变化-css2渲染器设置",normalizedTitle:"局部布局canvas尺寸变化，css2渲染器设置",charIndex:1592}],headersStr:"Canvas全屏尺寸变化，CSS2渲染器设置 canvas局部布局-，CSS2渲染器设置 局部布局Canvas尺寸变化，CSS2渲染器设置",content:"# Canvas画布尺寸变化(HTML标签)\n\n前面内容讲解过，如果threejs Canvas画布尺寸变化，需要同步更新相机等受canvas画布尺寸影响的参数，对于HTML标签标注也是如此。\n\n1.12. Canvas画布布局和全屏\n\n8.1. three.js Canvas画布布局\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    // cnavas画布宽高度重新设置\n    renderer.setSize(width,height);\n    // 相机参数重新设置\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n};\n\n\n\n# Canvas全屏尺寸变化，CSS2渲染器设置\n\ncanvas画布完全填充浏览器文档区域，如果窗口尺寸变化了，通过renderer.setSize()设置canvas画布尺寸，HTML标签相关的CSS渲染器代码也要同步设置css2Renderer.setSize()。\n\n执行css2Renderer.setSize()设置CSS2渲染器输出的HTML标签.domElement的尺寸，保持和canvas画布尺寸一样。\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    // cnavas画布宽高度重新设置\n    renderer.setSize(width,height);\n    // HTML标签css2Renderer.domElement尺寸重新设置\n    css2Renderer.setSize(width,height);\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n};\n\n\n\n# canvas局部布局-，CSS2渲染器设置\n\n在8.1. three.js Canvas画布布局的讲解的基础上，给大家设置HTML元素标签。\n\n代码中web页面右下角div元素是用来插入canvas画布的HTML元素。\n\n<div id=\"webgl\" style=\"position: absolute;top: 60px;left: 200px\"></div>\n\n\nCSS2渲染器输出的标签和webgl渲染器输出的canvas画布一样插入id为webgl的元素中\n\ndocument.getElementById('webgl').appendChild(renderer.domElement);\n\n\ndocument.getElementById('webgl').appendChild(css2Renderer.domElement);\n\n\n和原来一样，标签的父元素css2Renderer.domElement叠加到threejs canvas画布上面，并完全重合，具体代码根据你CSS布局代码设置，下面代码是课程案例设置方式，不一定要完全一样。不同CSS布局，有不同的叠加写法，同样的CSS布局，也可能有多种写法。\n\ncss2Renderer.domElement.style.position = 'absolute';\ncss2Renderer.domElement.style.top = '0px';\n\n\n\n# 局部布局Canvas尺寸变化，CSS2渲染器设置\n\n尺寸跟随窗口变化，CSS2渲染器标签的代码同样设置。\n\nwindow.onresize = function () { \n    const width = window.innerWidth - 200; //canvas画布高度\n    const height = window.innerHeight - 60; //canvas画布宽度\n    renderer.setSize(width, height);\n    // HTML标签css2Renderer.domElement尺寸重新设置\n    css2Renderer.setSize(width,height);\n    camera.aspect = width / height;\n    camera.updateProjectionMatrix();\n    document.getElementById('left').style.height = height + 'px';\n};\n",normalizedContent:"# canvas画布尺寸变化(html标签)\n\n前面内容讲解过，如果threejs canvas画布尺寸变化，需要同步更新相机等受canvas画布尺寸影响的参数，对于html标签标注也是如此。\n\n1.12. canvas画布布局和全屏\n\n8.1. three.js canvas画布布局\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerwidth;\n    const height = window.innerheight;\n    // cnavas画布宽高度重新设置\n    renderer.setsize(width,height);\n    // 相机参数重新设置\n    camera.aspect = width / height;\n    camera.updateprojectionmatrix();\n};\n\n\n\n# canvas全屏尺寸变化，css2渲染器设置\n\ncanvas画布完全填充浏览器文档区域，如果窗口尺寸变化了，通过renderer.setsize()设置canvas画布尺寸，html标签相关的css渲染器代码也要同步设置css2renderer.setsize()。\n\n执行css2renderer.setsize()设置css2渲染器输出的html标签.domelement的尺寸，保持和canvas画布尺寸一样。\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    const width = window.innerwidth;\n    const height = window.innerheight;\n    // cnavas画布宽高度重新设置\n    renderer.setsize(width,height);\n    // html标签css2renderer.domelement尺寸重新设置\n    css2renderer.setsize(width,height);\n    camera.aspect = width / height;\n    camera.updateprojectionmatrix();\n};\n\n\n\n# canvas局部布局-，css2渲染器设置\n\n在8.1. three.js canvas画布布局的讲解的基础上，给大家设置html元素标签。\n\n代码中web页面右下角div元素是用来插入canvas画布的html元素。\n\n<div id=\"webgl\" style=\"position: absolute;top: 60px;left: 200px\"></div>\n\n\ncss2渲染器输出的标签和webgl渲染器输出的canvas画布一样插入id为webgl的元素中\n\ndocument.getelementbyid('webgl').appendchild(renderer.domelement);\n\n\ndocument.getelementbyid('webgl').appendchild(css2renderer.domelement);\n\n\n和原来一样，标签的父元素css2renderer.domelement叠加到threejs canvas画布上面，并完全重合，具体代码根据你css布局代码设置，下面代码是课程案例设置方式，不一定要完全一样。不同css布局，有不同的叠加写法，同样的css布局，也可能有多种写法。\n\ncss2renderer.domelement.style.position = 'absolute';\ncss2renderer.domelement.style.top = '0px';\n\n\n\n# 局部布局canvas尺寸变化，css2渲染器设置\n\n尺寸跟随窗口变化，css2渲染器标签的代码同样设置。\n\nwindow.onresize = function () { \n    const width = window.innerwidth - 200; //canvas画布高度\n    const height = window.innerheight - 60; //canvas画布宽度\n    renderer.setsize(width, height);\n    // html标签css2renderer.domelement尺寸重新设置\n    css2renderer.setsize(width,height);\n    camera.aspect = width / height;\n    camera.updateprojectionmatrix();\n    document.getelementbyid('left').style.height = height + 'px';\n};\n",charsets:{cjk:!0}},{title:"6. 标签指示线或箭头指向标注点",frontmatter:{title:"6. 标签指示线或箭头指向标注点",date:"2023-03-13T10:58:57.000Z",permalink:"/pages/fb01c9/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/06.%E6%A0%87%E7%AD%BE%E6%8C%87%E7%A4%BA%E7%BA%BF%E6%88%96%E7%AE%AD%E5%A4%B4%E6%8C%87%E5%90%91%E6%A0%87%E6%B3%A8%E7%82%B9.html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/06.标签指示线或箭头指向标注点.md",key:"v-4b104e94",path:"/pages/fb01c9/",headers:[{level:3,title:"CSS2渲染器渲染HTML标签的位置特征",slug:"css2渲染器渲染html标签的位置特征",normalizedTitle:"css2渲染器渲染html标签的位置特征",charIndex:79},{level:3,title:"工厂设备标签CSS代码",slug:"工厂设备标签css代码",normalizedTitle:"工厂设备标签css代码",charIndex:345},{level:3,title:"工厂标签的HTML元素适当平移",slug:"工厂标签的html元素适当平移",normalizedTitle:"工厂标签的html元素适当平移",charIndex:1778},{level:3,title:"HTML标签渲染前隐藏",slug:"html标签渲染前隐藏",normalizedTitle:"html标签渲染前隐藏",charIndex:2068}],headersStr:"CSS2渲染器渲染HTML标签的位置特征 工厂设备标签CSS代码 工厂标签的HTML元素适当平移 HTML标签渲染前隐藏",content:'# 标签指示线和箭头指向标注点\n\nCSS2渲染器渲染HTML元素作为模型标签的时候，想把标签的箭头或指示线放在标注点上，下面给大家说下如何实现。\n\n\n\n\n# CSS2渲染器渲染HTML标签的位置特征\n\nCSS2渲染器渲染的HTML元素标签，默认情况下，HTML元素标签自身的几何中心与标注点重合。\n\n你可以查看本节课课件“圆锥标注”的案例验证。\n\nconst div = document.getElementById(\'tag\');\n// id="tag"元素高度40px,默认标签中心与圆锥顶部重合\n// CSS2渲染器会把标签HTML默认设置为绝对定位，意味着你可以直接设置top\ndiv.style.top = \'-20px\';//平移20px，使标签底部和圆锥顶部重合\n\n\n\n# 工厂设备标签CSS代码\n\n工厂设备标签的HTML、CSS布局代码，课件中已经提供。当然你可以根据自己前端知识更换其他CSS布局写法，只要视觉效果符合UI设计需求都行。\n\n标签HTML元素布局方式都是前端CSS知识，课程不在演示，下面主要讲解threejs代码。\n\n\x3c!-- CSS布局方式写法很多，不一定和课程一致 --\x3e\n<div id="tag">\n    \x3c!-- position:relative;约束子元素绝对定位参照点 --\x3e\n    <div style="position:relative;width:400px;height:322px;color: #fff;">\n        \x3c!-- 图片绝对定位100%填充父元素，作为标签的背景 --\x3e\n        <img src="./信息背景.png" alt="" style="width:100%;position: absolute;left: 0px;top: 0px;">\n        \x3c!-- 名称、存储量、设备状态、等信息叠加到背景图上即可 --\x3e\n        <div style="position:absolute;left:48px;top:36px;font-size:16px;">\n            <div style="font-size:20px;font-weight: 400;">\n                <span>设备A</span>\n            </div>\n            <div style="margin-top: 30px;">\n                <span style="font-weight: 400;margin-left: 80px;font-size: 40px;color: #00ffff;">276559 L</span>\n            </div>\n            <div style="margin-top: 20px;">\n                <span style="color: #ccc;font-weight: 300;">管理</span><span\n                   style="font-weight: 400;margin-left: 30px;">郭老师</span>\n            </div>\n            <div style="margin-top: 10px;">\n                <span style="color: #ccc;font-weight: 300;">工号</span><span\n                   style="font-weight: 400;margin-left: 30px;">webgl3d.cn</span>\n            </div>\n        </div>\n        <div style="position:absolute;left:285px;top:35px;">\n            <span style="color: #ffff00;">异常</span>\n        </div>\n    </div>\n</div>\n\n\n\n# 工厂标签的HTML元素适当平移\n\n工厂标签对应的HTML元素，你可适当偏移，使直线的起点和标注点位置重合，具体如何偏移，根据UI设计的效果，指示线起点相对标签中心位置来定。\n\nconst div = document.getElementById(\'tag\');\n// id="tag"元素高度322px,默认标签中心与标注点\ndiv.style.top = \'-161px\'; //平移-161px，指示线端点和标注点重合\n// div.style.top = \'-140px\'; //可以在-161px基础上微调\n// div.style.left = \'px\';\n\n\n\n# HTML标签渲染前隐藏\n\n在CSS2渲染器渲染HTML标签，重新定位标签之前，threejs执行代码和加载gltf模型也是需要时间的，这时候标签对应的HTML、CSS代码会显示在web页上面。\n\n可以先把标签隐藏display: none;，等gltf模型加载完成，HTML元素转化CSS2模型对象以后，再取消HTML隐藏状态，CSS2渲染器默认会把标签设置为display: block;，这样就不用自己代码恢复HTML标签元素的隐藏状态了。\n\n\x3c!-- CSS2渲染器渲染器之前，隐藏标签 --\x3e\n<div id="tag" style="display: none;"><>\n',normalizedContent:'# 标签指示线和箭头指向标注点\n\ncss2渲染器渲染html元素作为模型标签的时候，想把标签的箭头或指示线放在标注点上，下面给大家说下如何实现。\n\n\n\n\n# css2渲染器渲染html标签的位置特征\n\ncss2渲染器渲染的html元素标签，默认情况下，html元素标签自身的几何中心与标注点重合。\n\n你可以查看本节课课件“圆锥标注”的案例验证。\n\nconst div = document.getelementbyid(\'tag\');\n// id="tag"元素高度40px,默认标签中心与圆锥顶部重合\n// css2渲染器会把标签html默认设置为绝对定位，意味着你可以直接设置top\ndiv.style.top = \'-20px\';//平移20px，使标签底部和圆锥顶部重合\n\n\n\n# 工厂设备标签css代码\n\n工厂设备标签的html、css布局代码，课件中已经提供。当然你可以根据自己前端知识更换其他css布局写法，只要视觉效果符合ui设计需求都行。\n\n标签html元素布局方式都是前端css知识，课程不在演示，下面主要讲解threejs代码。\n\n\x3c!-- css布局方式写法很多，不一定和课程一致 --\x3e\n<div id="tag">\n    \x3c!-- position:relative;约束子元素绝对定位参照点 --\x3e\n    <div style="position:relative;width:400px;height:322px;color: #fff;">\n        \x3c!-- 图片绝对定位100%填充父元素，作为标签的背景 --\x3e\n        <img src="./信息背景.png" alt="" style="width:100%;position: absolute;left: 0px;top: 0px;">\n        \x3c!-- 名称、存储量、设备状态、等信息叠加到背景图上即可 --\x3e\n        <div style="position:absolute;left:48px;top:36px;font-size:16px;">\n            <div style="font-size:20px;font-weight: 400;">\n                <span>设备a</span>\n            </div>\n            <div style="margin-top: 30px;">\n                <span style="font-weight: 400;margin-left: 80px;font-size: 40px;color: #00ffff;">276559 l</span>\n            </div>\n            <div style="margin-top: 20px;">\n                <span style="color: #ccc;font-weight: 300;">管理</span><span\n                   style="font-weight: 400;margin-left: 30px;">郭老师</span>\n            </div>\n            <div style="margin-top: 10px;">\n                <span style="color: #ccc;font-weight: 300;">工号</span><span\n                   style="font-weight: 400;margin-left: 30px;">webgl3d.cn</span>\n            </div>\n        </div>\n        <div style="position:absolute;left:285px;top:35px;">\n            <span style="color: #ffff00;">异常</span>\n        </div>\n    </div>\n</div>\n\n\n\n# 工厂标签的html元素适当平移\n\n工厂标签对应的html元素，你可适当偏移，使直线的起点和标注点位置重合，具体如何偏移，根据ui设计的效果，指示线起点相对标签中心位置来定。\n\nconst div = document.getelementbyid(\'tag\');\n// id="tag"元素高度322px,默认标签中心与标注点\ndiv.style.top = \'-161px\'; //平移-161px，指示线端点和标注点重合\n// div.style.top = \'-140px\'; //可以在-161px基础上微调\n// div.style.left = \'px\';\n\n\n\n# html标签渲染前隐藏\n\n在css2渲染器渲染html标签，重新定位标签之前，threejs执行代码和加载gltf模型也是需要时间的，这时候标签对应的html、css代码会显示在web页上面。\n\n可以先把标签隐藏display: none;，等gltf模型加载完成，html元素转化css2模型对象以后，再取消html隐藏状态，css2渲染器默认会把标签设置为display: block;，这样就不用自己代码恢复html标签元素的隐藏状态了。\n\n\x3c!-- css2渲染器渲染器之前，隐藏标签 --\x3e\n<div id="tag" style="display: none;"><>\n',charsets:{cjk:!0}},{title:"5. 标签位置(标注工厂设备)",frontmatter:{title:"5. 标签位置(标注工厂设备)",date:"2023-03-13T10:58:49.000Z",permalink:"/pages/6ec16d/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/05.%E6%A0%87%E7%AD%BE%E4%BD%8D%E7%BD%AE(%E6%A0%87%E6%B3%A8%E5%B7%A5%E5%8E%82%E8%AE%BE%E5%A4%87).html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/05.标签位置(标注工厂设备).md",key:"v-596ce778",path:"/pages/6ec16d/",headers:[{level:3,title:"回顾：CSS2模型对象继承父对象位置",slug:"回顾-css2模型对象继承父对象位置",normalizedTitle:"回顾：css2模型对象继承父对象位置",charIndex:57},{level:3,title:"模型软件中工厂设备局部坐标系",slug:"模型软件中工厂设备局部坐标系",normalizedTitle:"模型软件中工厂设备局部坐标系",charIndex:235},{level:3,title:"threejs获取工厂设备，查看局部坐标系",slug:"threejs获取工厂设备-查看局部坐标系",normalizedTitle:"threejs获取工厂设备，查看局部坐标系",charIndex:445},{level:3,title:"CSS2模型对象标注工厂设备",slug:"css2模型对象标注工厂设备",normalizedTitle:"css2模型对象标注工厂设备",charIndex:708},{level:3,title:"建模软件创建空对象(控制标签位置)",slug:"建模软件创建空对象-控制标签位置",normalizedTitle:"建模软件创建空对象(控制标签位置)",charIndex:1017}],headersStr:"回顾：CSS2模型对象继承父对象位置 模型软件中工厂设备局部坐标系 threejs获取工厂设备，查看局部坐标系 CSS2模型对象标注工厂设备 建模软件创建空对象(控制标签位置)",content:"# 标签位置(标注工厂设备)\n\n下面以一个工厂设备模型的标注为例，给大家演示工厂设备标签的位置如何设置。\n\n\n# 回顾：CSS2模型对象继承父对象位置\n\n在上节课“圆锥标注案例中”给大家说过，HTML标签对应的CSS2模型对象，如果作为一个模型的子对象，默认标注在模型的局部坐标系原点位置。\n\nconst tag = new CSS2DObject(div);\n//标签tag作为obj子对象，默认标注在obj的局部坐标系坐标原点\nobj.add(tag);\n\n\n\n# 模型软件中工厂设备局部坐标系\n\n一个模型本身是有尺寸的，你想把模型标签标在模型那个具体位置，可以在三维软件中，把该模型的局部坐标系坐标原点设置在哪里。\n\n本节课课件中提供的gltf工厂模型，有两个相同的形状的设备，名字分别为设备A和设备B，为了给大家演示标签功能，设备A和设备B的局部坐标系相对自身位置不同，下面分别进行标注。\n\n你可以先尝试利用前面学习过的知识，获取某个模型设备进行标注，然后在跟着视频学习。\n\n\n# threejs获取工厂设备，查看局部坐标系\n\nloader.load(\"../工厂.glb\", function (gltf) {\n    const obj = gltf.scene.getObjectByName('设备A');\n})\n\n\n\nconst obj = gltf.scene.getObjectByName('设备B');\n\n\n// 可视化工厂设备obj的局部坐标系\nconst axesHelper = new THREE.AxesHelper(30);\nobj.add(axesHelper);\n\n\n\n# CSS2模型对象标注工厂设备\n\n标签tag作为obj子对象，默认标注在工厂设备obj的局部坐标系坐标原点\n\nloader.load(\"../工厂.glb\", function (gltf) {\n    const tag = new CSS2DObject(div);\n    // const obj = gltf.scene.getObjectByName('设备A');\n    const obj = gltf.scene.getObjectByName('设备B');\n    //标签tag作为obj子对象，默认标注在工厂设备obj的局部坐标系坐标原点\n    obj.add(tag);\n})\n\n\n\n# 建模软件创建空对象(控制标签位置)\n\n除了上面调整局部坐标系方式，还有一种更灵活，更方便的标注方式，就是在你的三维建模软件中，任何你想标注的位置，创建一个空对象(空的模型对象，没有任何模型顶点数据，只是一个空对象)。\n\n不同三维建模软件中，创建空对象方式不同，不过思路是相同。\n\nloader.load(\"../工厂.glb\", function (gltf) {\n    const tag = new CSS2DObject(div);\n    // obj是建模软件中创建的一个空对象\n    const obj = gltf.scene.getObjectByName('设备B标注');\n    // const obj = gltf.scene.getObjectByName('停车场标注');\n    //tag会标注在空对象obj对应的位置\n    obj.add(tag);\n})\n\n",normalizedContent:"# 标签位置(标注工厂设备)\n\n下面以一个工厂设备模型的标注为例，给大家演示工厂设备标签的位置如何设置。\n\n\n# 回顾：css2模型对象继承父对象位置\n\n在上节课“圆锥标注案例中”给大家说过，html标签对应的css2模型对象，如果作为一个模型的子对象，默认标注在模型的局部坐标系原点位置。\n\nconst tag = new css2dobject(div);\n//标签tag作为obj子对象，默认标注在obj的局部坐标系坐标原点\nobj.add(tag);\n\n\n\n# 模型软件中工厂设备局部坐标系\n\n一个模型本身是有尺寸的，你想把模型标签标在模型那个具体位置，可以在三维软件中，把该模型的局部坐标系坐标原点设置在哪里。\n\n本节课课件中提供的gltf工厂模型，有两个相同的形状的设备，名字分别为设备a和设备b，为了给大家演示标签功能，设备a和设备b的局部坐标系相对自身位置不同，下面分别进行标注。\n\n你可以先尝试利用前面学习过的知识，获取某个模型设备进行标注，然后在跟着视频学习。\n\n\n# threejs获取工厂设备，查看局部坐标系\n\nloader.load(\"../工厂.glb\", function (gltf) {\n    const obj = gltf.scene.getobjectbyname('设备a');\n})\n\n\n\nconst obj = gltf.scene.getobjectbyname('设备b');\n\n\n// 可视化工厂设备obj的局部坐标系\nconst axeshelper = new three.axeshelper(30);\nobj.add(axeshelper);\n\n\n\n# css2模型对象标注工厂设备\n\n标签tag作为obj子对象，默认标注在工厂设备obj的局部坐标系坐标原点\n\nloader.load(\"../工厂.glb\", function (gltf) {\n    const tag = new css2dobject(div);\n    // const obj = gltf.scene.getobjectbyname('设备a');\n    const obj = gltf.scene.getobjectbyname('设备b');\n    //标签tag作为obj子对象，默认标注在工厂设备obj的局部坐标系坐标原点\n    obj.add(tag);\n})\n\n\n\n# 建模软件创建空对象(控制标签位置)\n\n除了上面调整局部坐标系方式，还有一种更灵活，更方便的标注方式，就是在你的三维建模软件中，任何你想标注的位置，创建一个空对象(空的模型对象，没有任何模型顶点数据，只是一个空对象)。\n\n不同三维建模软件中，创建空对象方式不同，不过思路是相同。\n\nloader.load(\"../工厂.glb\", function (gltf) {\n    const tag = new css2dobject(div);\n    // obj是建模软件中创建的一个空对象\n    const obj = gltf.scene.getobjectbyname('设备b标注');\n    // const obj = gltf.scene.getobjectbyname('停车场标注');\n    //tag会标注在空对象obj对应的位置\n    obj.add(tag);\n})\n\n",charsets:{cjk:!0}},{title:"7. 鼠标选中模型弹出标签(工厂)",frontmatter:{title:"7. 鼠标选中模型弹出标签(工厂)",date:"2023-03-13T10:59:06.000Z",permalink:"/pages/793f8d/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/07.%E9%BC%A0%E6%A0%87%E9%80%89%E4%B8%AD%E6%A8%A1%E5%9E%8B%E5%BC%B9%E5%87%BA%E6%A0%87%E7%AD%BE(%E5%B7%A5%E5%8E%82%E6%A1%88%E4%BE%8B).html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/07.鼠标选中模型弹出标签(工厂案例).md",key:"v-af3ef6e0",path:"/pages/793f8d/",headers:[{level:3,title:"添加HTML元素标签，并隐藏",slug:"添加html元素标签-并隐藏",normalizedTitle:"添加html元素标签，并隐藏",charIndex:69},{level:3,title:"HTML元素转化为CSS2模型对象",slug:"html元素转化为css2模型对象",normalizedTitle:"html元素转化为css2模型对象",charIndex:177},{level:3,title:"设置CSS2渲染器代码",slug:"设置css2渲染器代码",normalizedTitle:"设置css2渲染器代码",charIndex:468},{level:3,title:"在射线代码基础上，添加标签代码",slug:"在射线代码基础上-添加标签代码",normalizedTitle:"在射线代码基础上，添加标签代码",charIndex:1121},{level:3,title:"没有选中模型，不显示标签和发光描边",slug:"没有选中模型-不显示标签和发光描边",normalizedTitle:"没有选中模型，不显示标签和发光描边",charIndex:1987},{level:3,title:"修改标签内容",slug:"修改标签内容",normalizedTitle:"修改标签内容",charIndex:2718}],headersStr:"添加HTML元素标签，并隐藏 HTML元素转化为CSS2模型对象 设置CSS2渲染器代码 在射线代码基础上，添加标签代码 没有选中模型，不显示标签和发光描边 修改标签内容",content:"# 鼠标选中模型弹出标签(工厂案例)\n\n射线、标签等知识点都学习过，你可以把本节课作为练习题，实现鼠标点击模型，弹出标签的功能。\n\n\n# 添加HTML元素标签，并隐藏\n\n引入标签的HTML、CSS代码，在射线拾取模型对象之前注意先隐藏display: none;。\n\n<div id=\"tag\" style=\"display: none;\">\n\n\n\n# HTML元素转化为CSS2模型对象\n\n// 引入CSS2模型对象CSS2DObject\nimport {\n    CSS2DObject\n} from 'three/addons/renderers/CSS2DRenderer.js';\nconst div = document.getElementById('tag');\ndiv.style.top = '-161px'; //指示线端点和标注点重合\n// HTML元素转化为threejs的CSS2模型对象\nconst tag = new CSS2DObject(div);\nexport default tag;\n\n\n\n# 设置CSS2渲染器代码\n\n// 引入CSS2渲染器CSS2DRenderer\nimport {CSS2DRenderer} from 'three/addons/renderers/CSS2DRenderer.js';\n\n\n// 创建一个CSS2渲染器CSS2DRenderer\nconst css2Renderer = new CSS2DRenderer();\ncss2Renderer.setSize(width, height);\n// HTML标签<div id=\"tag\"></div>外面父元素叠加到canvas画布上且重合\ncss2Renderer.domElement.style.position = 'absolute';\ncss2Renderer.domElement.style.top = '0px';\n//设置.pointerEvents=none，解决HTML元素标签对threejs canvas画布鼠标事件的遮挡\ncss2Renderer.domElement.style.pointerEvents = 'none';\ndocument.body.appendChild(css2Renderer.domElement);\n\n\n// 渲染循环\nfunction render() {\n    css2Renderer.render(scene, camera);\n    // ...\n    requestAnimationFrame(render);\n}\n\n\n\n# 在射线代码基础上，添加标签代码\n\n当发生鼠标事件，如果射线拾取到模型对象，就把标签做为选中模型的子对象，或作为选中模型对应标注点空对象的子对象。\n\n前面说过，如果你想标注工厂中模型，CSS2模型对象有两种定位方式，下面两种定位模型位置方法任选其一即可。\n\n需要标注的模型，把局部坐标系坐标原点设置在需要标注的位置\n\nif (intersects.length > 0) {\n    // 通过.ancestors属性判断那个模型对象被选中了\n    outlinePass.selectedObjects = [intersects[0].object.ancestors];\n    //tag会标注在intersects[0].object.ancestors模型的局部坐标系原点位置\n    intersects[0].object.ancestors.add(tag);\n}\n\n\n工厂模型添加一个空对象，用来标记需要标注的位置。\n\n标注点对应空对象命名规则和代码规则息息相关，模型中两个设备的名字是设备A、设备B，对应的标注点空对象命名分别为设备A标注、设备B标注。\n\nif (intersects.length > 0) {\n    // 通过.ancestors属性判断那个模型对象被选中了\n    outlinePass.selectedObjects = [intersects[0].object.ancestors];\n    // 获取模型对象对应的标注点\n    // console.log('intersects[0].object.ancestors.name',intersects[0].object.ancestors.name);\n    const obj = model.getObjectByName(intersects[0].object.ancestors.name+'标注');\n    //tag会标注在空对象obj对应的位置\n    obj.add(tag);\n}\n\n\n\n# 没有选中模型，不显示标签和发光描边\n\n在射线鼠标事件函数外面声明一个变量chooseObj来表示，此时是否有模型处于选中状态，如果没有，就把标签和发光描边取消。\n\nlet chooseObj = null;\naddEventListener('click', function (event) {\n    // ...射线拾取的代码\n    // 射线交叉计算拾取模型\n    const intersects = raycaster.intersectObjects(cunchu.children);\n    if (intersects.length > 0) {\n        // 通过.ancestors属性判断那个模型对象被选中了\n        outlinePass.selectedObjects = [intersects[0].object.ancestors];\n        //tag会标注在intersects[0].object.ancestors模型的局部坐标系原点位置\n        intersects[0].object.ancestors.add(tag);\n        chooseObj = intersects[0].object.ancestors;\n    }else{\n        if(chooseObj){//把原来选中模型对应的标签和发光描边隐藏\n            outlinePass.selectedObjects = [];//无发光描边\n            chooseObj.remove(tag);//从场景移除\n        }\n    }\n})\n\n\n\n# 修改标签内容\n\n可以根据选中的设备设置对应的标签内容数据，下面只是以设备名称为例进行演示，其它的标签数据，也可以类似修改。\n\n<span id=\"name\">设备A</span>\n\n\n// 获取设备名称标签\nconst span = document.getElementById('name');\naddEventListener('click', function (event) {\n    // ...\n    // ...\n    // 射线交叉计算拾取模型\n    const intersects = raycaster.intersectObjects(cunchu.children);\n    if (intersects.length > 0) {\n        span.innerHTML = intersects[0].object.ancestors.name;//修改标签数据\n    }\n})\n",normalizedContent:"# 鼠标选中模型弹出标签(工厂案例)\n\n射线、标签等知识点都学习过，你可以把本节课作为练习题，实现鼠标点击模型，弹出标签的功能。\n\n\n# 添加html元素标签，并隐藏\n\n引入标签的html、css代码，在射线拾取模型对象之前注意先隐藏display: none;。\n\n<div id=\"tag\" style=\"display: none;\">\n\n\n\n# html元素转化为css2模型对象\n\n// 引入css2模型对象css2dobject\nimport {\n    css2dobject\n} from 'three/addons/renderers/css2drenderer.js';\nconst div = document.getelementbyid('tag');\ndiv.style.top = '-161px'; //指示线端点和标注点重合\n// html元素转化为threejs的css2模型对象\nconst tag = new css2dobject(div);\nexport default tag;\n\n\n\n# 设置css2渲染器代码\n\n// 引入css2渲染器css2drenderer\nimport {css2drenderer} from 'three/addons/renderers/css2drenderer.js';\n\n\n// 创建一个css2渲染器css2drenderer\nconst css2renderer = new css2drenderer();\ncss2renderer.setsize(width, height);\n// html标签<div id=\"tag\"></div>外面父元素叠加到canvas画布上且重合\ncss2renderer.domelement.style.position = 'absolute';\ncss2renderer.domelement.style.top = '0px';\n//设置.pointerevents=none，解决html元素标签对threejs canvas画布鼠标事件的遮挡\ncss2renderer.domelement.style.pointerevents = 'none';\ndocument.body.appendchild(css2renderer.domelement);\n\n\n// 渲染循环\nfunction render() {\n    css2renderer.render(scene, camera);\n    // ...\n    requestanimationframe(render);\n}\n\n\n\n# 在射线代码基础上，添加标签代码\n\n当发生鼠标事件，如果射线拾取到模型对象，就把标签做为选中模型的子对象，或作为选中模型对应标注点空对象的子对象。\n\n前面说过，如果你想标注工厂中模型，css2模型对象有两种定位方式，下面两种定位模型位置方法任选其一即可。\n\n需要标注的模型，把局部坐标系坐标原点设置在需要标注的位置\n\nif (intersects.length > 0) {\n    // 通过.ancestors属性判断那个模型对象被选中了\n    outlinepass.selectedobjects = [intersects[0].object.ancestors];\n    //tag会标注在intersects[0].object.ancestors模型的局部坐标系原点位置\n    intersects[0].object.ancestors.add(tag);\n}\n\n\n工厂模型添加一个空对象，用来标记需要标注的位置。\n\n标注点对应空对象命名规则和代码规则息息相关，模型中两个设备的名字是设备a、设备b，对应的标注点空对象命名分别为设备a标注、设备b标注。\n\nif (intersects.length > 0) {\n    // 通过.ancestors属性判断那个模型对象被选中了\n    outlinepass.selectedobjects = [intersects[0].object.ancestors];\n    // 获取模型对象对应的标注点\n    // console.log('intersects[0].object.ancestors.name',intersects[0].object.ancestors.name);\n    const obj = model.getobjectbyname(intersects[0].object.ancestors.name+'标注');\n    //tag会标注在空对象obj对应的位置\n    obj.add(tag);\n}\n\n\n\n# 没有选中模型，不显示标签和发光描边\n\n在射线鼠标事件函数外面声明一个变量chooseobj来表示，此时是否有模型处于选中状态，如果没有，就把标签和发光描边取消。\n\nlet chooseobj = null;\naddeventlistener('click', function (event) {\n    // ...射线拾取的代码\n    // 射线交叉计算拾取模型\n    const intersects = raycaster.intersectobjects(cunchu.children);\n    if (intersects.length > 0) {\n        // 通过.ancestors属性判断那个模型对象被选中了\n        outlinepass.selectedobjects = [intersects[0].object.ancestors];\n        //tag会标注在intersects[0].object.ancestors模型的局部坐标系原点位置\n        intersects[0].object.ancestors.add(tag);\n        chooseobj = intersects[0].object.ancestors;\n    }else{\n        if(chooseobj){//把原来选中模型对应的标签和发光描边隐藏\n            outlinepass.selectedobjects = [];//无发光描边\n            chooseobj.remove(tag);//从场景移除\n        }\n    }\n})\n\n\n\n# 修改标签内容\n\n可以根据选中的设备设置对应的标签内容数据，下面只是以设备名称为例进行演示，其它的标签数据，也可以类似修改。\n\n<span id=\"name\">设备a</span>\n\n\n// 获取设备名称标签\nconst span = document.getelementbyid('name');\naddeventlistener('click', function (event) {\n    // ...\n    // ...\n    // 射线交叉计算拾取模型\n    const intersects = raycaster.intersectobjects(cunchu.children);\n    if (intersects.length > 0) {\n        span.innerhtml = intersects[0].object.ancestors.name;//修改标签数据\n    }\n})\n",charsets:{cjk:!0}},{title:"8. 单击按钮关闭HTML标签",frontmatter:{title:"8. 单击按钮关闭HTML标签",date:"2023-03-13T10:59:15.000Z",permalink:"/pages/1fa97c/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/08.%E5%8D%95%E6%9C%BA%E6%8C%89%E9%92%AE%E5%85%B3%E9%97%ADHTML%E6%A0%87%E7%AD%BE.html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/08.单机按钮关闭HTML标签.md",key:"v-442556e6",path:"/pages/1fa97c/",headers:[{level:3,title:"HTML标签增加一个关闭按钮",slug:"html标签增加一个关闭按钮",normalizedTitle:"html标签增加一个关闭按钮",charIndex:58},{level:3,title:"单击按钮关闭HTML标签",slug:"单击按钮关闭html标签-2",normalizedTitle:"单击按钮关闭html标签",charIndex:2},{level:3,title:"单击关闭按钮无效情况",slug:"单击关闭按钮无效情况",normalizedTitle:"单击关闭按钮无效情况",charIndex:548}],headersStr:"HTML标签增加一个关闭按钮 单击按钮关闭HTML标签 单击关闭按钮无效情况",content:"# 单击按钮关闭HTML标签\n\n给HTML标签，增加一个关闭按钮，鼠标单击之后，可以把射线弹出的标签关闭。\n\n\n# HTML标签增加一个关闭按钮\n\n<style>\n    #close:hover {\n        cursor: pointer;\n    }\n</style>\n<div style=\"position:absolute;left:350px;top:20px;\">\n    <img id=\"close\" src=\"./关闭.png\"  width=\"32\">\n</div>\n\n\n\n# 单击按钮关闭HTML标签\n\n注意把原来射线拾取里面隐藏发光描边和标签的代码删除，以免影响HTML关闭标签的功能测试。\n\n// 鼠标单击按钮，关闭HTML标签\ndocument.getElementById('close').addEventListener('click',function(){\n    if (chooseObj) {//把原来选中模型对应的标签和发光描边隐藏\n        outlinePass.selectedObjects = []; //无发光描边\n        chooseObj.remove(tag); //从场景移除\n    }\n})\n\n\n\n# 单击关闭按钮无效情况\n\n现在你单击按钮去关闭HTML元素标签，如果发现无效，有可能是HTML标签设置了属性.style.pointerEvents = 'none'\n\n//设置.pointerEvents=none，解决HTML元素标签对threejs canvas画布鼠标事件的遮挡\ncss2Renderer.domElement.style.pointerEvents = 'none';\n\n\n如果你的项目要求三维场景的添加标签时候，不能影响canvas画布的事件，必须设置.style.pointerEvents = 'none'，可以考虑把标签的子元素，关闭按钮，单独设置.style.pointerEvents = 'auto'或者style=\"pointer-events: auto;\"\n\n<img id=\"close\" src=\"./关闭.png\" style=\"pointer-events: auto;\">\n\n\ndocument.getElementById('close').style.pointerEvents = 'auto';\n",normalizedContent:"# 单击按钮关闭html标签\n\n给html标签，增加一个关闭按钮，鼠标单击之后，可以把射线弹出的标签关闭。\n\n\n# html标签增加一个关闭按钮\n\n<style>\n    #close:hover {\n        cursor: pointer;\n    }\n</style>\n<div style=\"position:absolute;left:350px;top:20px;\">\n    <img id=\"close\" src=\"./关闭.png\"  width=\"32\">\n</div>\n\n\n\n# 单击按钮关闭html标签\n\n注意把原来射线拾取里面隐藏发光描边和标签的代码删除，以免影响html关闭标签的功能测试。\n\n// 鼠标单击按钮，关闭html标签\ndocument.getelementbyid('close').addeventlistener('click',function(){\n    if (chooseobj) {//把原来选中模型对应的标签和发光描边隐藏\n        outlinepass.selectedobjects = []; //无发光描边\n        chooseobj.remove(tag); //从场景移除\n    }\n})\n\n\n\n# 单击关闭按钮无效情况\n\n现在你单击按钮去关闭html元素标签，如果发现无效，有可能是html标签设置了属性.style.pointerevents = 'none'\n\n//设置.pointerevents=none，解决html元素标签对threejs canvas画布鼠标事件的遮挡\ncss2renderer.domelement.style.pointerevents = 'none';\n\n\n如果你的项目要求三维场景的添加标签时候，不能影响canvas画布的事件，必须设置.style.pointerevents = 'none'，可以考虑把标签的子元素，关闭按钮，单独设置.style.pointerevents = 'auto'或者style=\"pointer-events: auto;\"\n\n<img id=\"close\" src=\"./关闭.png\" style=\"pointer-events: auto;\">\n\n\ndocument.getelementbyid('close').style.pointerevents = 'auto';\n",charsets:{cjk:!0}},{title:"10. CSS3批量标注多个标签",frontmatter:{title:"10. CSS3批量标注多个标签",date:"2023-03-22T20:47:21.000Z",permalink:"/pages/b5f8e2/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/10.CSS3%E6%89%B9%E9%87%8F%E6%A0%87%E6%B3%A8%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE.html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/10.CSS3批量标注多个标签.md",key:"v-a0685c18",path:"/pages/b5f8e2/",headers:[{level:3,title:"CSS3渲染器基本代码",slug:"css3渲染器基本代码",normalizedTitle:"css3渲染器基本代码",charIndex:61},{level:3,title:"标签HTML、CSS代码",slug:"标签html、css代码",normalizedTitle:"标签html、css代码",charIndex:866},{level:3,title:"HTML标签渲染前隐藏",slug:"html标签渲染前隐藏",normalizedTitle:"html标签渲染前隐藏",charIndex:1227},{level:3,title:"三维软件中设置需要标注的位置",slug:"三维软件中设置需要标注的位置",normalizedTitle:"三维软件中设置需要标注的位置",charIndex:1343},{level:3,title:"创建CSS3模型对象或精灵对象标注场景",slug:"创建css3模型对象或精灵对象标注场景",normalizedTitle:"创建css3模型对象或精灵对象标注场景",charIndex:1432},{level:3,title:"模型缩放",slug:"模型缩放",normalizedTitle:"模型缩放",charIndex:1757},{level:3,title:"模型定位",slug:"模型定位",normalizedTitle:"模型定位",charIndex:1387},{level:3,title:"批量创建标签",slug:"批量创建标签",normalizedTitle:"批量创建标签",charIndex:2261}],headersStr:"CSS3渲染器基本代码 标签HTML、CSS代码 HTML标签渲染前隐藏 三维软件中设置需要标注的位置 创建CSS3模型对象或精灵对象标注场景 模型缩放 模型定位 批量创建标签",content:"# CSS3批量标注多个标签\n\n下面以工厂为例，使用CSS3DRenderer批量渲染多个HTML元素标签。\n\n\n\n\n# CSS3渲染器基本代码\n\nCSS3渲染器代码和上节课内容一样设置即可。\n\n// 引入CSS3渲染器CSS3DRenderer\nimport {CSS3DRenderer} from 'three/addons/renderers/CSS3DRenderer.js';\n\n\n// 创建一个CSS3渲染器CSS3DRenderer\nconst css3Renderer = new CSS3DRenderer();\ncss3Renderer.setSize(width, height);\n// HTML标签<div id=\"tag\"></div>外面父元素叠加到canvas画布上且重合\ncss3Renderer.domElement.style.position = 'absolute';\ncss3Renderer.domElement.style.top = '0px';\n//设置.pointerEvents=none，解决HTML元素标签对threejs canvas画布鼠标事件的遮挡\ncss3Renderer.domElement.style.pointerEvents = 'none';\ndocument.body.appendChild(css3Renderer.domElement);\n\n\n// 渲染循环\nfunction render() {\n    css3Renderer.render(scene, camera);\n    // ...\n    requestAnimationFrame(render);\n}\n\n\nwindow.onresize = function () {\n    ...\n    // HTML标签css3Renderer.domElement尺寸重新设置\n    css3Renderer.setSize(width,height);\n};\n\n\n\n# 标签HTML、CSS代码\n\n使用了一个带有箭头的背景图png图片。\n\n<style>\n    #tag {\n        width: 70px;\n        height: 40px;\n        line-height: 32px;\n        text-align: center;\n        color: #fff;\n        font-size: 16px;\n        background-image: url(./标签箭头背景.png);\n        background-repeat: no-repeat;\n        background-size: 100% 100%;\n    }\n</style>\n<div id=\"tag\">设备A</div>\n\n\n\n# HTML标签渲染前隐藏\n\n在CSS3渲染器渲染HTML标签，重新定位标签之前，可以先把标签隐藏display: none;。\n\n<div id=\"tag\" style=\"display: none;\">设备A</div>\n\n\n\n# 三维软件中设置需要标注的位置\n\n在需要标注的位置，可以创建多个空对象，用来给CSS3标签模型定位。\n\n工厂模型中分别命名了三个空对象设备A标注、设备B标注、停车场标注。\n\n\n# 创建CSS3模型对象或精灵对象标注场景\n\nconst div = document.getElementById('tag');\n// HTML元素转化为threejs的CSS3对象\n// const tag = new CSS3DObject(div);\nconst tag = new CSS3DSprite(div);\ndiv.style.pointerEvents = 'none';//避免标签遮挡canvas鼠标事件\n// obj是建模软件中创建的一个空对象\nconst obj = gltf.scene.getObjectByName('设备A标注');\n//tag会标注在空对象obj对应的位置\nobj.add(tag);\n\n\n\n# 模型缩放\n\n设置CSS3模型或精灵对象尺寸的时候，你就把他想象为一个普通矩形平面网格模型Mesh，CSS3模型或精灵的尺寸来自自身HTML元素的尺寸像素值。\n\nHTML标签元素的高度是几十个像素，工厂尺寸是100多，整体预览工厂模型的时候，如果标签覆盖区域过大，你可以适当缩小。\n\n// const tag = new CSS3DObject(div);\nconst tag = new CSS3DSprite(div);\n//适当缩放模型标签\ntag.scale.set(0.1,0.1,1);\n\n\n\n# 模型定位\n\n把模型标签背景的箭头放在空对象标注点的附近位置，根据HTML标签的几何中心与标签箭头的top、left差值来设置即可，注意如果缩放了标签模型，还要考虑缩放的问题。\n\n注意不同标签top、left差值，可能不同，该案例只有top方向偏差是高度一半(注意height、border、padding的影响)。\n\ntag.scale.set(0.1,0.1,1);\n//标签底部箭头和空对象标注点重合：偏移高度像素值一半*缩放比例\ntag.position.y = 40/2*0.1;\n\n\n\n# 批量创建标签\n\n如果是Vue或React批量创建UI组件还是比较方便的，原生HTML、CSS的话，注意批量创建DOM即可，原理一样。\n\n//需要批量标注的标签数据arr\nconst arr = ['设备A','设备B','停车场'];\nfor (let i = 0; i < arr.length; i++) {\n    // 注意是多个标签，需要克隆复制一份\n    const div = document.getElementById('tag').cloneNode();\n    div.innerHTML = arr[i];//标签数据填写\n    // HTML元素转化为threejs的CSS3对象\n    // const tag = new CSS3DObject(div);\n    const tag = new CSS3DSprite(div);\n    div.style.pointerEvents = 'none'; //避免标签遮挡canvas鼠标事件\n    // obj是建模软件中创建的一个空对象\n    const obj = gltf.scene.getObjectByName(arr[i]+'标注');\n    //tag会标注在空对象obj对应的位置\n    obj.add(tag);\n\n    tag.scale.set(0.1,0.1,1);//适当缩放模型标签\n    tag.position.y = 40/2*0.1;//标签底部箭头和空对象标注点重合：偏移高度像素值一半*缩放比例\n}\n",normalizedContent:"# css3批量标注多个标签\n\n下面以工厂为例，使用css3drenderer批量渲染多个html元素标签。\n\n\n\n\n# css3渲染器基本代码\n\ncss3渲染器代码和上节课内容一样设置即可。\n\n// 引入css3渲染器css3drenderer\nimport {css3drenderer} from 'three/addons/renderers/css3drenderer.js';\n\n\n// 创建一个css3渲染器css3drenderer\nconst css3renderer = new css3drenderer();\ncss3renderer.setsize(width, height);\n// html标签<div id=\"tag\"></div>外面父元素叠加到canvas画布上且重合\ncss3renderer.domelement.style.position = 'absolute';\ncss3renderer.domelement.style.top = '0px';\n//设置.pointerevents=none，解决html元素标签对threejs canvas画布鼠标事件的遮挡\ncss3renderer.domelement.style.pointerevents = 'none';\ndocument.body.appendchild(css3renderer.domelement);\n\n\n// 渲染循环\nfunction render() {\n    css3renderer.render(scene, camera);\n    // ...\n    requestanimationframe(render);\n}\n\n\nwindow.onresize = function () {\n    ...\n    // html标签css3renderer.domelement尺寸重新设置\n    css3renderer.setsize(width,height);\n};\n\n\n\n# 标签html、css代码\n\n使用了一个带有箭头的背景图png图片。\n\n<style>\n    #tag {\n        width: 70px;\n        height: 40px;\n        line-height: 32px;\n        text-align: center;\n        color: #fff;\n        font-size: 16px;\n        background-image: url(./标签箭头背景.png);\n        background-repeat: no-repeat;\n        background-size: 100% 100%;\n    }\n</style>\n<div id=\"tag\">设备a</div>\n\n\n\n# html标签渲染前隐藏\n\n在css3渲染器渲染html标签，重新定位标签之前，可以先把标签隐藏display: none;。\n\n<div id=\"tag\" style=\"display: none;\">设备a</div>\n\n\n\n# 三维软件中设置需要标注的位置\n\n在需要标注的位置，可以创建多个空对象，用来给css3标签模型定位。\n\n工厂模型中分别命名了三个空对象设备a标注、设备b标注、停车场标注。\n\n\n# 创建css3模型对象或精灵对象标注场景\n\nconst div = document.getelementbyid('tag');\n// html元素转化为threejs的css3对象\n// const tag = new css3dobject(div);\nconst tag = new css3dsprite(div);\ndiv.style.pointerevents = 'none';//避免标签遮挡canvas鼠标事件\n// obj是建模软件中创建的一个空对象\nconst obj = gltf.scene.getobjectbyname('设备a标注');\n//tag会标注在空对象obj对应的位置\nobj.add(tag);\n\n\n\n# 模型缩放\n\n设置css3模型或精灵对象尺寸的时候，你就把他想象为一个普通矩形平面网格模型mesh，css3模型或精灵的尺寸来自自身html元素的尺寸像素值。\n\nhtml标签元素的高度是几十个像素，工厂尺寸是100多，整体预览工厂模型的时候，如果标签覆盖区域过大，你可以适当缩小。\n\n// const tag = new css3dobject(div);\nconst tag = new css3dsprite(div);\n//适当缩放模型标签\ntag.scale.set(0.1,0.1,1);\n\n\n\n# 模型定位\n\n把模型标签背景的箭头放在空对象标注点的附近位置，根据html标签的几何中心与标签箭头的top、left差值来设置即可，注意如果缩放了标签模型，还要考虑缩放的问题。\n\n注意不同标签top、left差值，可能不同，该案例只有top方向偏差是高度一半(注意height、border、padding的影响)。\n\ntag.scale.set(0.1,0.1,1);\n//标签底部箭头和空对象标注点重合：偏移高度像素值一半*缩放比例\ntag.position.y = 40/2*0.1;\n\n\n\n# 批量创建标签\n\n如果是vue或react批量创建ui组件还是比较方便的，原生html、css的话，注意批量创建dom即可，原理一样。\n\n//需要批量标注的标签数据arr\nconst arr = ['设备a','设备b','停车场'];\nfor (let i = 0; i < arr.length; i++) {\n    // 注意是多个标签，需要克隆复制一份\n    const div = document.getelementbyid('tag').clonenode();\n    div.innerhtml = arr[i];//标签数据填写\n    // html元素转化为threejs的css3对象\n    // const tag = new css3dobject(div);\n    const tag = new css3dsprite(div);\n    div.style.pointerevents = 'none'; //避免标签遮挡canvas鼠标事件\n    // obj是建模软件中创建的一个空对象\n    const obj = gltf.scene.getobjectbyname(arr[i]+'标注');\n    //tag会标注在空对象obj对应的位置\n    obj.add(tag);\n\n    tag.scale.set(0.1,0.1,1);//适当缩放模型标签\n    tag.position.y = 40/2*0.1;//标签底部箭头和空对象标注点重合：偏移高度像素值一半*缩放比例\n}\n",charsets:{cjk:!0}},{title:"11. 精灵模型Sprite作为标签",frontmatter:{title:"11. 精灵模型Sprite作为标签",date:"2023-03-22T20:47:46.000Z",permalink:"/pages/76a18d/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/11.%E7%B2%BE%E7%81%B5%E6%A8%A1%E5%9E%8BSprite%E4%BD%9C%E4%B8%BA%E6%A0%87%E7%AD%BE.html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/11.精灵模型Sprite作为标签.md",key:"v-23d9bdae",path:"/pages/76a18d/",headers:[{level:3,title:"精灵模型标签",slug:"精灵模型标签",normalizedTitle:"精灵模型标签",charIndex:117},{level:3,title:"标注工厂设备",slug:"标注工厂设备",normalizedTitle:"标注工厂设备",charIndex:103},{level:3,title:"精灵模型底部和标注位置重合",slug:"精灵模型底部和标注位置重合",normalizedTitle:"精灵模型底部和标注位置重合",charIndex:671},{level:3,title:"精灵模型Sprite和CSS3精灵模型CSS3DSprite标签差异",slug:"精灵模型sprite和css3精灵模型css3dsprite标签差异",normalizedTitle:"精灵模型sprite和css3精灵模型css3dsprite标签差异",charIndex:794},{level:3,title:"标注多个设备状态",slug:"标注多个设备状态",normalizedTitle:"标注多个设备状态",charIndex:911}],headersStr:"精灵模型标签 标注工厂设备 精灵模型底部和标注位置重合 精灵模型Sprite和CSS3精灵模型CSS3DSprite标签差异 标注多个设备状态",content:"# Sprite作为标签标注设备\n\n实际开发的时候，可以使用精灵模型Sprite + 颜色贴图作为标签，标注三维场景。\n\n下面具体知识点，在精灵模型章节基本都讲解过，学习下面内容之前，你可以尝试用精灵模型去标注工厂设备。\n\n\n\n\n# 精灵模型标签\n\n如果你想想用精灵模型表达什么含义，可以美术提供一个对应的贴图。\n\nconst texLoader= new THREE.TextureLoader();\nconst texture = texLoader.load(\"./警告.png\");\nconst spriteMaterial = new THREE.SpriteMaterial({\n  map: texture,\n});\nconst sprite = new THREE.Sprite(spriteMaterial);\n\n\n可以根据标注的场景尺寸量级，设置精灵模型大小，不要过大或过小，先大概标注，比如精灵标签比设备尺寸小一个数量级，然后再精确调整。\n\nsprite.scale.set(5, 5, 1);\nsprite.position.y = 5 / 2; //标签底部箭头和空对象标注点重合  \n\n\n\n# 标注工厂设备\n\n在工厂三维模型需要标注的位置，设置一个空对象，用来控制精灵模型标签的位置。\n\n// obj是建模软件中创建的一个空对象\nconst obj = gltf.scene.getObjectByName('设备A标注');\n//tag会标注在空对象obj对应的位置\nobj.add(sprite);\n\n\n\n# 精灵模型底部和标注位置重合\n\n设置精灵模型位置属性，使精灵标签底部和空对象标注位置重合。\n\nsprite.scale.set(4, 4, 1);\n//标签底部箭头和空对象标注点重合  \nsprite.position.y = 4/2;\n\n\n\n# 精灵模型Sprite和CSS3精灵模型CSS3DSprite标签差异\n\n精灵模型渲染Sprite的标签，默认可以被其他网格模型遮挡，但是CSS3渲染器渲染的HTML元素标签是叠加在canvas画布上，不会被其它网格模型遮挡。\n\n\n# 标注多个设备状态\n\n封装一个创建精灵标签的函数，可以根据需要调用，标注任何设备。\n\nimport * as THREE from 'three';\n// 标注位置对应的模型对象obj\nfunction createSprite(obj,state) {\n    const texLoader= new THREE.TextureLoader();\n    let texture = null;\n    if(state == '警告'){\n        texture= texLoader.load(\"./警告.png\");\n    }else{\n        texture = texLoader.load(\"./故障.png\");\n    }\n    const spriteMaterial = new THREE.SpriteMaterial({\n        map: texture,\n    });\n    const sprite = new THREE.Sprite(spriteMaterial);\n    // 控制精灵大小\n    sprite.scale.set(5, 5, 1);\n    sprite.position.y = 5 / 2; //标签底部箭头和空对象标注点重合  \n    obj.add(sprite); //tag会标注在空对象obj对应的位置\n}\n\nexport default createSprite;\n",normalizedContent:"# sprite作为标签标注设备\n\n实际开发的时候，可以使用精灵模型sprite + 颜色贴图作为标签，标注三维场景。\n\n下面具体知识点，在精灵模型章节基本都讲解过，学习下面内容之前，你可以尝试用精灵模型去标注工厂设备。\n\n\n\n\n# 精灵模型标签\n\n如果你想想用精灵模型表达什么含义，可以美术提供一个对应的贴图。\n\nconst texloader= new three.textureloader();\nconst texture = texloader.load(\"./警告.png\");\nconst spritematerial = new three.spritematerial({\n  map: texture,\n});\nconst sprite = new three.sprite(spritematerial);\n\n\n可以根据标注的场景尺寸量级，设置精灵模型大小，不要过大或过小，先大概标注，比如精灵标签比设备尺寸小一个数量级，然后再精确调整。\n\nsprite.scale.set(5, 5, 1);\nsprite.position.y = 5 / 2; //标签底部箭头和空对象标注点重合  \n\n\n\n# 标注工厂设备\n\n在工厂三维模型需要标注的位置，设置一个空对象，用来控制精灵模型标签的位置。\n\n// obj是建模软件中创建的一个空对象\nconst obj = gltf.scene.getobjectbyname('设备a标注');\n//tag会标注在空对象obj对应的位置\nobj.add(sprite);\n\n\n\n# 精灵模型底部和标注位置重合\n\n设置精灵模型位置属性，使精灵标签底部和空对象标注位置重合。\n\nsprite.scale.set(4, 4, 1);\n//标签底部箭头和空对象标注点重合  \nsprite.position.y = 4/2;\n\n\n\n# 精灵模型sprite和css3精灵模型css3dsprite标签差异\n\n精灵模型渲染sprite的标签，默认可以被其他网格模型遮挡，但是css3渲染器渲染的html元素标签是叠加在canvas画布上，不会被其它网格模型遮挡。\n\n\n# 标注多个设备状态\n\n封装一个创建精灵标签的函数，可以根据需要调用，标注任何设备。\n\nimport * as three from 'three';\n// 标注位置对应的模型对象obj\nfunction createsprite(obj,state) {\n    const texloader= new three.textureloader();\n    let texture = null;\n    if(state == '警告'){\n        texture= texloader.load(\"./警告.png\");\n    }else{\n        texture = texloader.load(\"./故障.png\");\n    }\n    const spritematerial = new three.spritematerial({\n        map: texture,\n    });\n    const sprite = new three.sprite(spritematerial);\n    // 控制精灵大小\n    sprite.scale.set(5, 5, 1);\n    sprite.position.y = 5 / 2; //标签底部箭头和空对象标注点重合  \n    obj.add(sprite); //tag会标注在空对象obj对应的位置\n}\n\nexport default createsprite;\n",charsets:{cjk:!0}},{title:"9. CSS3DRenderer渲染HTML标签",frontmatter:{title:"9. CSS3DRenderer渲染HTML标签",date:"2023-03-22T20:47:09.000Z",permalink:"/pages/b23f11/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/09.CSS3DRenderer%E6%B8%B2%E6%9F%93HTML%E6%A0%87%E7%AD%BE.html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/09.CSS3DRenderer渲染HTML标签.md",key:"v-444b2197",path:"/pages/b23f11/",headers:[{level:3,title:"设置CSS3渲染器代码",slug:"设置css3渲染器代码",normalizedTitle:"设置css3渲染器代码",charIndex:167},{level:3,title:"CSS3对象模型CSS3DObject",slug:"css3对象模型css3dobject",normalizedTitle:"css3对象模型css3dobject",charIndex:982},{level:3,title:"CSS3DObject渲染效果测试",slug:"css3dobject渲染效果测试",normalizedTitle:"css3dobject渲染效果测试",charIndex:1681},{level:3,title:"禁止CSS3DObject标签对应HTMl元素背面显示",slug:"禁止css3dobject标签对应html元素背面显示",normalizedTitle:"禁止css3dobject标签对应html元素背面显示",charIndex:1976},{level:3,title:"标签相对标注点的位置",slug:"标签相对标注点的位置",normalizedTitle:"标签相对标注点的位置",charIndex:2072},{level:3,title:"CSS3DRenderer渲染的HTML标签尺寸",slug:"css3drenderer渲染的html标签尺寸",normalizedTitle:"css3drenderer渲染的html标签尺寸",charIndex:2125},{level:3,title:"缩放标签",slug:"缩放标签",normalizedTitle:"缩放标签",charIndex:2696},{level:3,title:"标签偏移",slug:"标签偏移",normalizedTitle:"标签偏移",charIndex:2819},{level:3,title:"CSS3精灵模型CSS3DSprite",slug:"css3精灵模型css3dsprite",normalizedTitle:"css3精灵模型css3dsprite",charIndex:3130},{level:3,title:"CSS3精灵模型CSS3DSprite渲染特点",slug:"css3精灵模型css3dsprite渲染特点",normalizedTitle:"css3精灵模型css3dsprite渲染特点",charIndex:3559},{level:3,title:"标签局部遮挡鼠标事件",slug:"标签局部遮挡鼠标事件",normalizedTitle:"标签局部遮挡鼠标事件",charIndex:3741}],headersStr:"设置CSS3渲染器代码 CSS3对象模型CSS3DObject CSS3DObject渲染效果测试 禁止CSS3DObject标签对应HTMl元素背面显示 标签相对标注点的位置 CSS3DRenderer渲染的HTML标签尺寸 缩放标签 标签偏移 CSS3精灵模型CSS3DSprite CSS3精灵模型CSS3DSprite渲染特点 标签局部遮挡鼠标事件",content:"# CSS3DRenderer渲染HTML标签\n\nCSS3渲染器CSS3DRenderer和CSS2渲染器CSS2DRenderer整体使用流程基本相同，只是在HTML标签渲染效果方面不同，比如CSS3渲染的标签会跟着场景相机同步缩放，而CSS2渲染的标签默认保持自身像素值。\n\n下面就在CSS2渲染器代码基础上给大家讲解。\n\n\n# 设置CSS3渲染器代码\n\n和CSS2渲染器代码一样设置，只需要把CSS2换成CSS3即可。\n\n// 引入CSS3渲染器CSS3DRenderer\nimport {CSS3DRenderer} from 'three/addons/renderers/CSS3DRenderer.js';\n\n\n// 创建一个CSS3渲染器CSS3DRenderer\nconst css3Renderer = new CSS3DRenderer();\ncss3Renderer.setSize(width, height);\n// HTML标签<div id=\"tag\"></div>外面父元素叠加到canvas画布上且重合\ncss3Renderer.domElement.style.position = 'absolute';\ncss3Renderer.domElement.style.top = '0px';\n//设置.pointerEvents=none，解决HTML元素标签对threejs canvas画布鼠标事件的遮挡\ncss3Renderer.domElement.style.pointerEvents = 'none';\ndocument.body.appendChild(css3Renderer.domElement);\n\n\n// 渲染循环\nfunction render() {\n    css3Renderer.render(scene, camera);\n    // ...\n    requestAnimationFrame(render);\n}\n\n\nwindow.onresize = function () {\n    ...\n    // HTML标签css3Renderer.domElement尺寸重新设置\n    css3Renderer.setSize(width,height);\n};\n\n\n\n# CSS3对象模型CSS3DObject\n\nCSS3对象模型CSS3DObject可以类比前面介绍的CSS2模型对象CSS2DObject学习。\n\n// 引入CSS3模型对象CSS3DObject\nimport { CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';\n\n\n通过CSS3DObject类，可以把一个HTML元素转化为一个CSS3模型对象，就像threejs的网格模型一样，可以添加到场景中，可以设置位置，可以作为其它模型对象的子对象。\n\nconst div = document.getElementById('tag');\n// HTML元素转化为threejs的CSS3模型对象\nconst tag = new CSS3DObject(div);\n//标签tag作为mesh子对象，默认标注在模型局部坐标系坐标原点\nmesh.add(tag);\n// 相对父对象局部坐标原点偏移80,刚好标注在圆锥\ntag.position.y += 80;\n\n\ntag.position.y += 80;标注圆锥模型的顶部\n\nconst geometry = new THREE.ConeGeometry(25, 80);\ngeometry.translate(0, 40, 0);\nconst mesh = new THREE.Mesh(geometry, material);\nmesh.add(tag);\n// 相对父对象局部坐标原点偏移80,刚好标注在圆锥顶部\ntag.position.y += 80;\n\n\n\n# CSS3DObject渲染效果测试\n\nCSS3模型对象CSS3DObject渲染结果，就像一个矩形平面网格模型一样。你通过相机控件OrbitControls旋转、缩放三维场景，CSS3模型对象CSS3DObject跟着旋转、缩放。\n\n旋转过程中HTML元素标签的正反面都可以看到。\n\n一个网格模型被另一个不透明网格模型遮挡，canvas画布上不会显示，不过注意一点CSS3DObject模型本质上渲染到网页上还是HTML元素，这就是说模型背面的HTML标签并不会被遮挡，CSS3DObject标签是以HTMl元素形式叠加在canvas画布上的，不受threejs内部模型对象影响。\n\n\n# 禁止CSS3DObject标签对应HTMl元素背面显示\n\n<div id=\"tag\" style=\"backface-visibility: hidden;\">标签内容</div>\n\n\n\n# 标签相对标注点的位置\n\n默认情况下CSS3模型对象渲染的标签的几何中心默认和标注位置的坐标重合。\n\n\n# CSS3DRenderer渲染的HTML标签尺寸\n\nCSS2DRenderer渲染HTML元素标签，默认情况下，HTML元素会保持本身尺寸的像素值，除非你通过代码缩放。\n\nCSS3DRenderer渲染的HTML元素，你可以把HTML标签对象想象为一个矩形平面网格模型Mesh，HTML标签对象在threejs中的尺寸来源是HTML元素的像素尺寸值，比如HTML像素高度40px，那么HTML标签对象在threejs中的数字相当于高度为40的矩形平面网格模型。\n\n测试验证上面规律总结：把标签的高度设置为160px，160的一半是80，也就是圆锥的高度，这样HTML标签下半部分和圆锥底部重合。\n\n<div id=\"tag\" style=\"height: 160px;\">标签内容</div>\n\n\nborder、padding、height、width都会影响标签渲染大小，你可以分别测试体验。\n\n<style>\n    #tag {\n        padding: 0px 10px;\n        border: #00ffff solid 1px;\n        height: 40px;\n        border-radius: 5px;\n        width: 65px;\n    }\n</style>\n\n\n\n# 缩放标签\n\nconst div = document.getElementById('tag');\nconst tag = new CSS3DObject(div);\ntag.scale.set(0.5,0.5,1);//缩放标签尺寸\n\n\n\n# 标签偏移\n\nCSS2渲染HTML标签偏移方式\n\nconst div = document.getElementById('tag');\n// id=\"tag\"元素高度322px,默认标签中心与标注点\ndiv.style.top = '-161px'; //平移-161px，指示线端点和标注点重合\n\n\nCSS2渲染的标签和CSS3渲染的标签偏移方式不同，CSS3标签，直接按照threejs模型尺寸修改方式改变，比用HTML像素方式更方便准确。\n\ntag.scale.set(0.5,0.5,1);//缩放标签尺寸\ntag.position.y += 10;//累加标签高度一半，标签底部和圆锥顶部标注位置重合\n\n\n\n# CSS3精灵模型CSS3DSprite\n\n// 引入CSS3精灵模型对象CSS3DSprite\nimport { CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';\n\n\nCSS3对象模型CSS3DObject渲染效果类似矩形平面网格模型Mesh。\n\nCSS3精灵模型CSS3DSprite渲染效果类似以前学习的精灵模型对象Sprite。\n\nconst div = document.getElementById('tag');\n// HTML元素转化为threejs的CSS3精灵模型`CSS3DSprite`\nconst tag = new CSS3DSprite(div);\n//标签tag作为mesh子对象，默认标注在模型局部坐标系坐标原点\nmesh.add(tag);\n// 相对父对象局部坐标原点偏移80,刚好标注在圆锥\ntag.position.y += 80;\n\n\n\n# CSS3精灵模型CSS3DSprite渲染特点\n\nCSS3精灵模型CSS3DSprite对应的HTML标签，可以跟着场景缩放，位置可以跟着场景旋转，但是自身的姿态角度始终平行于canvas画布，不受旋转影响，就像精灵模型一样Sprite\n\nCSS3精灵模型CSS3DSprite尺寸、位置、缩放等渲染规律和CSS3对象模型CSS3DObject基本一致。\n\n\n# 标签局部遮挡鼠标事件\n\nHTML标签<div id=\"tag\"></div>外面的父元素css3Renderer.domElement防止鼠标遮挡canvas事件方式，和CSS2渲染器一样。\n\n//设置.pointerEvents=none，解决HTML元素标签对threejs canvas画布鼠标事件的遮挡\ncss3Renderer.domElement.style.pointerEvents = 'none';\n\n\n标签<div id=\"tag\"></div>在CSS3渲染器渲染的时候，默认会被设置为pointer-events: auto;，这时候虽然css3Renderer.domElement不遮挡canvas画布的鼠标事件，但是<div id=\"tag\"></div>遮挡canvas画布的鼠标事件。\n\n这时候你可以通过代码强制改变CSS3渲染器给标签设置的.style.pointerEvents = 'auto',设置为.style.pointerEvents = 'none',这时候注意一点，修改.style.pointerEvents，要在实例化new CSS3DObject(div)之后，因为执行new CSS3DObject(div)的时候，会把HTML标签设置为.style.pointerEvents = 'auto'。\n\nconst div = document.getElementById('tag');\n// HTML元素转化为threejs的CSS3模型对象\nconst tag = new CSS3DObject(div);\n// new CSS3DObject(div);之后设置style.pointerEvents \ndiv.style.pointerEvents = 'none';\n",normalizedContent:"# css3drenderer渲染html标签\n\ncss3渲染器css3drenderer和css2渲染器css2drenderer整体使用流程基本相同，只是在html标签渲染效果方面不同，比如css3渲染的标签会跟着场景相机同步缩放，而css2渲染的标签默认保持自身像素值。\n\n下面就在css2渲染器代码基础上给大家讲解。\n\n\n# 设置css3渲染器代码\n\n和css2渲染器代码一样设置，只需要把css2换成css3即可。\n\n// 引入css3渲染器css3drenderer\nimport {css3drenderer} from 'three/addons/renderers/css3drenderer.js';\n\n\n// 创建一个css3渲染器css3drenderer\nconst css3renderer = new css3drenderer();\ncss3renderer.setsize(width, height);\n// html标签<div id=\"tag\"></div>外面父元素叠加到canvas画布上且重合\ncss3renderer.domelement.style.position = 'absolute';\ncss3renderer.domelement.style.top = '0px';\n//设置.pointerevents=none，解决html元素标签对threejs canvas画布鼠标事件的遮挡\ncss3renderer.domelement.style.pointerevents = 'none';\ndocument.body.appendchild(css3renderer.domelement);\n\n\n// 渲染循环\nfunction render() {\n    css3renderer.render(scene, camera);\n    // ...\n    requestanimationframe(render);\n}\n\n\nwindow.onresize = function () {\n    ...\n    // html标签css3renderer.domelement尺寸重新设置\n    css3renderer.setsize(width,height);\n};\n\n\n\n# css3对象模型css3dobject\n\ncss3对象模型css3dobject可以类比前面介绍的css2模型对象css2dobject学习。\n\n// 引入css3模型对象css3dobject\nimport { css3dobject } from 'three/addons/renderers/css3drenderer.js';\n\n\n通过css3dobject类，可以把一个html元素转化为一个css3模型对象，就像threejs的网格模型一样，可以添加到场景中，可以设置位置，可以作为其它模型对象的子对象。\n\nconst div = document.getelementbyid('tag');\n// html元素转化为threejs的css3模型对象\nconst tag = new css3dobject(div);\n//标签tag作为mesh子对象，默认标注在模型局部坐标系坐标原点\nmesh.add(tag);\n// 相对父对象局部坐标原点偏移80,刚好标注在圆锥\ntag.position.y += 80;\n\n\ntag.position.y += 80;标注圆锥模型的顶部\n\nconst geometry = new three.conegeometry(25, 80);\ngeometry.translate(0, 40, 0);\nconst mesh = new three.mesh(geometry, material);\nmesh.add(tag);\n// 相对父对象局部坐标原点偏移80,刚好标注在圆锥顶部\ntag.position.y += 80;\n\n\n\n# css3dobject渲染效果测试\n\ncss3模型对象css3dobject渲染结果，就像一个矩形平面网格模型一样。你通过相机控件orbitcontrols旋转、缩放三维场景，css3模型对象css3dobject跟着旋转、缩放。\n\n旋转过程中html元素标签的正反面都可以看到。\n\n一个网格模型被另一个不透明网格模型遮挡，canvas画布上不会显示，不过注意一点css3dobject模型本质上渲染到网页上还是html元素，这就是说模型背面的html标签并不会被遮挡，css3dobject标签是以html元素形式叠加在canvas画布上的，不受threejs内部模型对象影响。\n\n\n# 禁止css3dobject标签对应html元素背面显示\n\n<div id=\"tag\" style=\"backface-visibility: hidden;\">标签内容</div>\n\n\n\n# 标签相对标注点的位置\n\n默认情况下css3模型对象渲染的标签的几何中心默认和标注位置的坐标重合。\n\n\n# css3drenderer渲染的html标签尺寸\n\ncss2drenderer渲染html元素标签，默认情况下，html元素会保持本身尺寸的像素值，除非你通过代码缩放。\n\ncss3drenderer渲染的html元素，你可以把html标签对象想象为一个矩形平面网格模型mesh，html标签对象在threejs中的尺寸来源是html元素的像素尺寸值，比如html像素高度40px，那么html标签对象在threejs中的数字相当于高度为40的矩形平面网格模型。\n\n测试验证上面规律总结：把标签的高度设置为160px，160的一半是80，也就是圆锥的高度，这样html标签下半部分和圆锥底部重合。\n\n<div id=\"tag\" style=\"height: 160px;\">标签内容</div>\n\n\nborder、padding、height、width都会影响标签渲染大小，你可以分别测试体验。\n\n<style>\n    #tag {\n        padding: 0px 10px;\n        border: #00ffff solid 1px;\n        height: 40px;\n        border-radius: 5px;\n        width: 65px;\n    }\n</style>\n\n\n\n# 缩放标签\n\nconst div = document.getelementbyid('tag');\nconst tag = new css3dobject(div);\ntag.scale.set(0.5,0.5,1);//缩放标签尺寸\n\n\n\n# 标签偏移\n\ncss2渲染html标签偏移方式\n\nconst div = document.getelementbyid('tag');\n// id=\"tag\"元素高度322px,默认标签中心与标注点\ndiv.style.top = '-161px'; //平移-161px，指示线端点和标注点重合\n\n\ncss2渲染的标签和css3渲染的标签偏移方式不同，css3标签，直接按照threejs模型尺寸修改方式改变，比用html像素方式更方便准确。\n\ntag.scale.set(0.5,0.5,1);//缩放标签尺寸\ntag.position.y += 10;//累加标签高度一半，标签底部和圆锥顶部标注位置重合\n\n\n\n# css3精灵模型css3dsprite\n\n// 引入css3精灵模型对象css3dsprite\nimport { css3dsprite } from 'three/addons/renderers/css3drenderer.js';\n\n\ncss3对象模型css3dobject渲染效果类似矩形平面网格模型mesh。\n\ncss3精灵模型css3dsprite渲染效果类似以前学习的精灵模型对象sprite。\n\nconst div = document.getelementbyid('tag');\n// html元素转化为threejs的css3精灵模型`css3dsprite`\nconst tag = new css3dsprite(div);\n//标签tag作为mesh子对象，默认标注在模型局部坐标系坐标原点\nmesh.add(tag);\n// 相对父对象局部坐标原点偏移80,刚好标注在圆锥\ntag.position.y += 80;\n\n\n\n# css3精灵模型css3dsprite渲染特点\n\ncss3精灵模型css3dsprite对应的html标签，可以跟着场景缩放，位置可以跟着场景旋转，但是自身的姿态角度始终平行于canvas画布，不受旋转影响，就像精灵模型一样sprite\n\ncss3精灵模型css3dsprite尺寸、位置、缩放等渲染规律和css3对象模型css3dobject基本一致。\n\n\n# 标签局部遮挡鼠标事件\n\nhtml标签<div id=\"tag\"></div>外面的父元素css3renderer.domelement防止鼠标遮挡canvas事件方式，和css2渲染器一样。\n\n//设置.pointerevents=none，解决html元素标签对threejs canvas画布鼠标事件的遮挡\ncss3renderer.domelement.style.pointerevents = 'none';\n\n\n标签<div id=\"tag\"></div>在css3渲染器渲染的时候，默认会被设置为pointer-events: auto;，这时候虽然css3renderer.domelement不遮挡canvas画布的鼠标事件，但是<div id=\"tag\"></div>遮挡canvas画布的鼠标事件。\n\n这时候你可以通过代码强制改变css3渲染器给标签设置的.style.pointerevents = 'auto',设置为.style.pointerevents = 'none',这时候注意一点，修改.style.pointerevents，要在实例化new css3dobject(div)之后，因为执行new css3dobject(div)的时候，会把html标签设置为.style.pointerevents = 'auto'。\n\nconst div = document.getelementbyid('tag');\n// html元素转化为threejs的css3模型对象\nconst tag = new css3dobject(div);\n// new css3dobject(div);之后设置style.pointerevents \ndiv.style.pointerevents = 'none';\n",charsets:{cjk:!0}},{title:"12. Sprite标签(Canvas作为贴图)",frontmatter:{title:"12. Sprite标签(Canvas作为贴图)",date:"2023-03-22T20:47:55.000Z",permalink:"/pages/c15dd2/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/15.15.%E5%9C%BA%E6%99%AF%E6%A0%87%E6%B3%A8%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF/12.Sprite%E6%A0%87%E7%AD%BE(Canvas%E4%BD%9C%E4%B8%BA%E8%B4%B4%E5%9B%BE).html",relativePath:"01.Three.js教程/15.15.场景标注标签信息/12.Sprite标签(Canvas作为贴图).md",key:"v-04884aa9",path:"/pages/c15dd2/",headers:[{level:3,title:"Canvas画布绘制一个标签",slug:"canvas画布绘制一个标签",normalizedTitle:"canvas画布绘制一个标签",charIndex:167},{level:3,title:"CanvasTexture把canvas转化为纹理对象",slug:"canvastexture把canvas转化为纹理对象",normalizedTitle:"canvastexture把canvas转化为纹理对象",charIndex:1658},{level:3,title:"精灵模型尺寸和位置设置",slug:"精灵模型尺寸和位置设置",normalizedTitle:"精灵模型尺寸和位置设置",charIndex:2183},{level:3,title:"cavnas精灵标签封装(标注多个)",slug:"cavnas精灵标签封装-标注多个",normalizedTitle:"cavnas精灵标签封装(标注多个)",charIndex:2546},{level:3,title:"Canvas包含外部图片",slug:"canvas包含外部图片",normalizedTitle:"canvas包含外部图片",charIndex:3347}],headersStr:"Canvas画布绘制一个标签 CanvasTexture把canvas转化为纹理对象 精灵模型尺寸和位置设置 cavnas精灵标签封装(标注多个) Canvas包含外部图片",content:'# Sprite标签(Canvas作为贴图)\n\n上节课案例创建标签的方式，是把一张图片作为Sprite精灵模型的颜色贴图,本节给大家演示把Canvas画布作为Sprite精灵模型的颜色贴图，实现一个标签。\n\n注意：本节课主要是技术方案讲解，默认你有Canvas基础，如果没有Canvas基础，可以学习之后再来学习本节课内容。\n\n\n# Canvas画布绘制一个标签\n\n\n\n你可以使用Canvas绘制特定轮廓的标签，比如加上指引线或箭头，可以输入特定文字。\n\n下面代码自动适配了不同长度的文字标注，文字符号越多，canvas画布越长。\n\n// 生成一个canvas对象，标注文字为参数name\nfunction createCanvas(name) {\n    /**\n     * 创建一个canvas对象，绘制几何图案或添加文字\n     */\n    const canvas = document.createElement("canvas");\n    const arr = name.split(""); //分割为单独字符串\n    let num = 0;\n    const reg = /[\\u4e00-\\u9fa5]/;\n    for (let i = 0; i < arr.length; i++) {\n        if (reg.test(arr[i])) { //判断是不是汉字\n            num += 1;\n        } else {\n            num += 0.5; //英文字母或数字累加0.5\n        }\n    }\n    // 根据字符串符号类型和数量、文字font-size大小来设置canvas画布宽高度\n    const h = 80; //根据渲染像素大小设置，过大性能差，过小不清晰\n    const w = h + num * 32;\n    canvas.width = w;\n    canvas.height = h;\n    const h1 = h * 0.8;\n    const c = canvas.getContext(\'2d\');\n    // 定义轮廓颜色，黑色半透明\n    c.fillStyle = "rgba(0,0,0,0.5)";\n    // 绘制半圆+矩形轮廓\n    const R = h1 / 2;\n    c.arc(R, R, R, -Math.PI / 2, Math.PI / 2, true); //顺时针半圆\n    c.arc(w - R, R, R, Math.PI / 2, -Math.PI / 2, true); //顺时针半圆\n    c.fill();\n    // 绘制箭头\n    c.beginPath();\n    const h2 = h - h1;\n    c.moveTo(w / 2 - h2 * 0.6, h1);\n    c.lineTo(w / 2 + h2 * 0.6, h1);\n    c.lineTo(w / 2, h);\n    c.fill();\n    // 文字\n    c.beginPath();\n    c.translate(w / 2, h1 / 2);\n    c.fillStyle = "#ffffff"; //文本填充颜色\n    c.font = "normal 32px 宋体"; //字体样式设置\n    c.textBaseline = "middle"; //文本与fillText定义的纵坐标\n    c.textAlign = "center"; //文本居中(以fillText定义的横坐标)\n    c.fillText(name, 0, 0);\n    return canvas;\n}\nconst canvas = createCanvas(\'设备A\')\n\n\n\n# CanvasTexture把canvas转化为纹理对象\n\ncanvas画布作为CanvasTexture的参数创建一个纹理对象，本质上你可以理解为CanvasTexture把canvas画布当做图片，读取参数canvas画布上的像素值，创建纹理贴图Texture。\n\nloader.load("../工厂.glb", function (gltf) {\n  model.add(gltf.scene);\n  const canvas = createCanvas(\'设备A\');//创建一个canvas画布\n  // canvas画布作为CanvasTexture的参数创建一个纹理对象\n  // 本质上你可以理解为CanvasTexture读取参数canvas画布上的像素值\n  const texture = new THREE.CanvasTexture(canvas);\n  const spriteMaterial = new THREE.SpriteMaterial({\n    map: texture,\n  });\n  const sprite = new THREE.Sprite(spriteMaterial);\n})\n\n\n\n# 精灵模型尺寸和位置设置\n\n精灵模型尺寸和位置设置具体思路可以参考上节课讲解。\n\n注意精灵模型宽高比和canvas画布宽高比保持一致即可。\n\nconst y = 4;//精灵y方向尺寸\n// sprite宽高比和canvas画布保持一致\nconst x = canvas.width/canvas.height*y;//精灵x方向尺寸\nsprite.scale.set(x, y, 1);// 控制精灵大小\nsprite.position.y = y / 2; //标签底部箭头和空对象标注点重合  \nconst obj = gltf.scene.getObjectByName(\'设备A标注\'); // obj是建模软件中创建的一个空对象\nobj.add(sprite); //tag会标注在空对象obj对应的位置\n\n\n\n# cavnas精灵标签封装(标注多个)\n\n封装一个创建cavnas精灵标签的函数，可以根据需要调用，标注任何需要标注的地方。\n\nimport * as THREE from \'three\';\nimport createCanvas from \'./canvas\';\n// 标注位置对应的模型对象obj\n// name：标注文字\nfunction createSprite(obj,name) {\n    const canvas = createCanvas(name);//创建一个canvas画布\n    // canvas画布作为CanvasTexture的参数创建一个纹理对象\n    const texture = new THREE.CanvasTexture(canvas);\n    const spriteMaterial = new THREE.SpriteMaterial({\n      map: texture,\n    });\n    const sprite = new THREE.Sprite(spriteMaterial);\n    // 控制精灵大小(sprite宽高比和canvas画布保持一致)\n    const s = 0.05;//通过canvas宽高度缩放后，设置sprite.scale，避免图文宽高比变形\n    const x = canvas.width*s;\n    const y = canvas.height*s;\n    sprite.scale.set(x, y, 1);\n    sprite.position.y = y / 2; //标签底部箭头和空对象标注点重合  \n    obj.add(sprite); //tag会标注在空对象obj对应的位置\n}\n\nexport default createSprite;\n\n\n\n# Canvas包含外部图片\n\n如果Canvas包含外部图片作为背景，注意创建CanvasTexture的时候，不管你的代码结构怎么组织，主要要等图像加载完成再执行THREE.CanvasTexture(canvas)，如果还未加载完成，创建纹理时候，读取画布像素时候，会不包含图片。\n\n// 生成一个canvas对象，标注文字为参数name\nfunction createCanvas(img,name) {\n    /**\n     * 创建一个canvas对象，绘制几何图案或添加文字\n     */\n    const canvas = document.createElement("canvas");\n    const w = 140; //根据渲染像素大小设置，过大性能差，过小不清晰\n    const h = 80;\n    canvas.width = w;\n    canvas.height = h;\n    const h1 = h * 0.8;\n    const c = canvas.getContext(\'2d\');\n    c.fillStyle = "rgba(0,0,0,0.0)"; //背景透明\n    c.fillRect(0, 0, w, h);\n    c.drawImage(img, 0, 0, w, h);//图片绘制到canvas画布上\n    // 文字\n    c.beginPath();\n    c.translate(w / 2, h1 / 2);\n    c.fillStyle = "#ffffff"; //文本填充颜色\n    c.font = "normal 32px 宋体"; //字体样式设置\n    c.textBaseline = "middle"; //文本与fillText定义的纵坐标\n    c.textAlign = "center"; //文本居中(以fillText定义的横坐标)\n    c.fillText(name, 0, 0);\n    return canvas;\n}\n\n\n  const img = new Image();\n  img.src = "./标签箭头背景.png";\n  img.onload = function () {\n    const canvas = createCanvas(img,\'设备A\');//创建一个canvas画布\n    // 图片加载完成后，读取canvas像素数据创建CanvasTexture\n    const texture = new THREE.CanvasTexture(canvas);\n    ...\n    const sprite = new THREE.Sprite(spriteMaterial);\n    ...\n  }\n',normalizedContent:'# sprite标签(canvas作为贴图)\n\n上节课案例创建标签的方式，是把一张图片作为sprite精灵模型的颜色贴图,本节给大家演示把canvas画布作为sprite精灵模型的颜色贴图，实现一个标签。\n\n注意：本节课主要是技术方案讲解，默认你有canvas基础，如果没有canvas基础，可以学习之后再来学习本节课内容。\n\n\n# canvas画布绘制一个标签\n\n\n\n你可以使用canvas绘制特定轮廓的标签，比如加上指引线或箭头，可以输入特定文字。\n\n下面代码自动适配了不同长度的文字标注，文字符号越多，canvas画布越长。\n\n// 生成一个canvas对象，标注文字为参数name\nfunction createcanvas(name) {\n    /**\n     * 创建一个canvas对象，绘制几何图案或添加文字\n     */\n    const canvas = document.createelement("canvas");\n    const arr = name.split(""); //分割为单独字符串\n    let num = 0;\n    const reg = /[\\u4e00-\\u9fa5]/;\n    for (let i = 0; i < arr.length; i++) {\n        if (reg.test(arr[i])) { //判断是不是汉字\n            num += 1;\n        } else {\n            num += 0.5; //英文字母或数字累加0.5\n        }\n    }\n    // 根据字符串符号类型和数量、文字font-size大小来设置canvas画布宽高度\n    const h = 80; //根据渲染像素大小设置，过大性能差，过小不清晰\n    const w = h + num * 32;\n    canvas.width = w;\n    canvas.height = h;\n    const h1 = h * 0.8;\n    const c = canvas.getcontext(\'2d\');\n    // 定义轮廓颜色，黑色半透明\n    c.fillstyle = "rgba(0,0,0,0.5)";\n    // 绘制半圆+矩形轮廓\n    const r = h1 / 2;\n    c.arc(r, r, r, -math.pi / 2, math.pi / 2, true); //顺时针半圆\n    c.arc(w - r, r, r, math.pi / 2, -math.pi / 2, true); //顺时针半圆\n    c.fill();\n    // 绘制箭头\n    c.beginpath();\n    const h2 = h - h1;\n    c.moveto(w / 2 - h2 * 0.6, h1);\n    c.lineto(w / 2 + h2 * 0.6, h1);\n    c.lineto(w / 2, h);\n    c.fill();\n    // 文字\n    c.beginpath();\n    c.translate(w / 2, h1 / 2);\n    c.fillstyle = "#ffffff"; //文本填充颜色\n    c.font = "normal 32px 宋体"; //字体样式设置\n    c.textbaseline = "middle"; //文本与filltext定义的纵坐标\n    c.textalign = "center"; //文本居中(以filltext定义的横坐标)\n    c.filltext(name, 0, 0);\n    return canvas;\n}\nconst canvas = createcanvas(\'设备a\')\n\n\n\n# canvastexture把canvas转化为纹理对象\n\ncanvas画布作为canvastexture的参数创建一个纹理对象，本质上你可以理解为canvastexture把canvas画布当做图片，读取参数canvas画布上的像素值，创建纹理贴图texture。\n\nloader.load("../工厂.glb", function (gltf) {\n  model.add(gltf.scene);\n  const canvas = createcanvas(\'设备a\');//创建一个canvas画布\n  // canvas画布作为canvastexture的参数创建一个纹理对象\n  // 本质上你可以理解为canvastexture读取参数canvas画布上的像素值\n  const texture = new three.canvastexture(canvas);\n  const spritematerial = new three.spritematerial({\n    map: texture,\n  });\n  const sprite = new three.sprite(spritematerial);\n})\n\n\n\n# 精灵模型尺寸和位置设置\n\n精灵模型尺寸和位置设置具体思路可以参考上节课讲解。\n\n注意精灵模型宽高比和canvas画布宽高比保持一致即可。\n\nconst y = 4;//精灵y方向尺寸\n// sprite宽高比和canvas画布保持一致\nconst x = canvas.width/canvas.height*y;//精灵x方向尺寸\nsprite.scale.set(x, y, 1);// 控制精灵大小\nsprite.position.y = y / 2; //标签底部箭头和空对象标注点重合  \nconst obj = gltf.scene.getobjectbyname(\'设备a标注\'); // obj是建模软件中创建的一个空对象\nobj.add(sprite); //tag会标注在空对象obj对应的位置\n\n\n\n# cavnas精灵标签封装(标注多个)\n\n封装一个创建cavnas精灵标签的函数，可以根据需要调用，标注任何需要标注的地方。\n\nimport * as three from \'three\';\nimport createcanvas from \'./canvas\';\n// 标注位置对应的模型对象obj\n// name：标注文字\nfunction createsprite(obj,name) {\n    const canvas = createcanvas(name);//创建一个canvas画布\n    // canvas画布作为canvastexture的参数创建一个纹理对象\n    const texture = new three.canvastexture(canvas);\n    const spritematerial = new three.spritematerial({\n      map: texture,\n    });\n    const sprite = new three.sprite(spritematerial);\n    // 控制精灵大小(sprite宽高比和canvas画布保持一致)\n    const s = 0.05;//通过canvas宽高度缩放后，设置sprite.scale，避免图文宽高比变形\n    const x = canvas.width*s;\n    const y = canvas.height*s;\n    sprite.scale.set(x, y, 1);\n    sprite.position.y = y / 2; //标签底部箭头和空对象标注点重合  \n    obj.add(sprite); //tag会标注在空对象obj对应的位置\n}\n\nexport default createsprite;\n\n\n\n# canvas包含外部图片\n\n如果canvas包含外部图片作为背景，注意创建canvastexture的时候，不管你的代码结构怎么组织，主要要等图像加载完成再执行three.canvastexture(canvas)，如果还未加载完成，创建纹理时候，读取画布像素时候，会不包含图片。\n\n// 生成一个canvas对象，标注文字为参数name\nfunction createcanvas(img,name) {\n    /**\n     * 创建一个canvas对象，绘制几何图案或添加文字\n     */\n    const canvas = document.createelement("canvas");\n    const w = 140; //根据渲染像素大小设置，过大性能差，过小不清晰\n    const h = 80;\n    canvas.width = w;\n    canvas.height = h;\n    const h1 = h * 0.8;\n    const c = canvas.getcontext(\'2d\');\n    c.fillstyle = "rgba(0,0,0,0.0)"; //背景透明\n    c.fillrect(0, 0, w, h);\n    c.drawimage(img, 0, 0, w, h);//图片绘制到canvas画布上\n    // 文字\n    c.beginpath();\n    c.translate(w / 2, h1 / 2);\n    c.fillstyle = "#ffffff"; //文本填充颜色\n    c.font = "normal 32px 宋体"; //字体样式设置\n    c.textbaseline = "middle"; //文本与filltext定义的纵坐标\n    c.textalign = "center"; //文本居中(以filltext定义的横坐标)\n    c.filltext(name, 0, 0);\n    return canvas;\n}\n\n\n  const img = new image();\n  img.src = "./标签箭头背景.png";\n  img.onload = function () {\n    const canvas = createcanvas(img,\'设备a\');//创建一个canvas画布\n    // 图片加载完成后，读取canvas像素数据创建canvastexture\n    const texture = new three.canvastexture(canvas);\n    ...\n    const sprite = new three.sprite(spritematerial);\n    ...\n  }\n',charsets:{cjk:!0}},{title:"2. 动画播放(暂停、倍速、循环)",frontmatter:{title:"2. 动画播放(暂停、倍速、循环)",date:"2023-03-22T20:48:23.000Z",permalink:"/pages/c8f25d/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/02.%E5%8A%A8%E7%94%BB%E6%92%AD%E6%94%BE(%E6%9A%82%E5%81%9C%E3%80%81%E5%80%8D%E9%80%9F%E3%80%81%E5%BE%AA%E7%8E%AF).html",relativePath:"01.Three.js教程/16.16.关键帧动画/02.动画播放(暂停、倍速、循环).md",key:"v-4a7931ea",path:"/pages/c8f25d/",headers:[{level:3,title:"动画动作对象AnimationAction",slug:"动画动作对象animationaction",normalizedTitle:"动画动作对象animationaction",charIndex:91},{level:3,title:"AnimationAction的循环属性.loop",slug:"animationaction的循环属性-loop",normalizedTitle:"animationaction的循环属性.loop",charIndex:432},{level:3,title:"AnimationAction的.clampWhenFinished属性",slug:"animationaction的-clampwhenfinished属性",normalizedTitle:"animationaction的.clampwhenfinished属性",charIndex:634},{level:3,title:"停止结束动画.stop()",slug:"停止结束动画-stop",normalizedTitle:"停止结束动画.stop()",charIndex:963},{level:3,title:"是否暂停播放.paused",slug:"是否暂停播放-paused",normalizedTitle:"是否暂停播放.paused",charIndex:1432},{level:3,title:"倍速播放.timeScale",slug:"倍速播放-timescale",normalizedTitle:"倍速播放.timescale",charIndex:1979},{level:3,title:"拖动条调整播放速度",slug:"拖动条调整播放速度",normalizedTitle:"拖动条调整播放速度",charIndex:2061}],headersStr:"动画动作对象AnimationAction AnimationAction的循环属性.loop AnimationAction的.clampWhenFinished属性 停止结束动画.stop() 是否暂停播放.paused 倍速播放.timeScale 拖动条调整播放速度",content:"# 动画播放(暂停、倍速、循环)\n\n上节课对关键帧动画如何创建，如何播放，做了整体介绍，下面进一步介绍关键帧动画播放的知识，比如关键帧动画停止播放、暂停播放、倍速播放...\n\n\n# 动画动作对象AnimationAction\n\n查看文档你可以知道，执行播放器AnimationMixer的.clipAction()方法会返回一个AnimationAction对象。\n\n//AnimationMixer的`.clipAction()`返回一个AnimationAction对象\nconst clipAction = mixer.clipAction(clip);\n\n\nAnimationAction对象的功能就是用来控制如何播放关键帧动画，比如是否播放、几倍速播放、是否循环播放、是否暂停播放...\n\n你可以测试注释代码clipAction.play();，看看关键帧动画是否变化。\n\n//.play()控制动画播放\nclipAction.play();\n\n\n\n# AnimationAction的循环属性.loop\n\n通过AnimationAction的循环属性.loop可以控制动画是否循环播放。\n\nconst clipAction = mixer.clipAction(clip);\n//.play()控制动画播放，默认循环播放\nclipAction.play();\n//不循环播放\nclipAction.loop = THREE.LoopOnce; \n\n\n\n# AnimationAction的.clampWhenFinished属性\n\n当你通过clipAction.loop = THREE.LoopOnce设置播放模式为非循环模式的时候，你会发现关键帧动画执行完成一个后，模型回到了关键帧动画开头状态，如果你希望模型停留在关键帧动画结束的状态，可以设置.clampWhenFinished属性实现，.clampWhenFinished属性默认是false，设置为true即可\n\n//不循环播放，执行一次后默认回到动画开头\nclipAction.loop = THREE.LoopOnce; \n\n\n// 物体状态停留在动画结束的时候\nclipAction.clampWhenFinished = true;\n\n\n\n# 停止结束动画.stop()\n\n执行AnimationAction的.stop()方法，动画会停止，并结束，模型回到动画开始状态,注意不是暂停，是动画彻底终止，回到初始状态。\n\n//动画停止结束，回到开始状态\nclipAction.stop();\n\n\n<div class=\"pos\">\n    <div id=\"stop\" class=\"bu\">停止</div>\n    <div id=\"play\" class=\"bu\" style=\"margin-left: 10px;\">播放</div>\n</div>\n\n\ndocument.getElementById('stop').addEventListener('click',function(){\n  clipAction.stop();//动画停止结束，回到开始状态\n})\ndocument.getElementById('play').addEventListener('click',function(){\n  clipAction.play();//播放动画\n})\n\n\n\n# 是否暂停播放.paused\n\n.paused默认值false，动画正常执行，如果你想暂停正在执行的动画可以把.paused设置为true，对于暂停执行的动画，你把.paused设置为false，动画会接着暂停的位置继续执行。\n\n<div id=\"bu\" class=\"bu\">暂停</div>\n\n\nconst bu = document.getElementById('bu');\nbu.addEventListener('click',function(){\n    // AnimationAction.paused默认值false，设置为true，可以临时暂停动画\n    if (clipAction.paused) {//暂停状态\n        clipAction.paused = false;//切换为播放状态\n        bu.innerHTML='暂停';// 如果改变为播放状态，按钮文字设置为“暂停”\n      } else {//播放状态\n        clipAction.paused = true;//切换为暂停状态\n        bu.innerHTML='继续';// 如果改变为暂停状态，按钮文字设置为“继续”\n      }\n})\n\n\n\n# 倍速播放.timeScale\n\nclipAction.timeScale = 1;//默认\nclipAction.timeScale = 2;//2倍速\n\n\n\n# 拖动条调整播放速度\n\ngui辅助快速创建一个可交互拖动条，实际开发，可以用vue或react创建的拖动条。\n\nconst gui = new GUI(); //创建GUI对象\n// 0~6倍速之间调节\ngui.add(clipAction, 'timeScale', 0, 6);\n",normalizedContent:"# 动画播放(暂停、倍速、循环)\n\n上节课对关键帧动画如何创建，如何播放，做了整体介绍，下面进一步介绍关键帧动画播放的知识，比如关键帧动画停止播放、暂停播放、倍速播放...\n\n\n# 动画动作对象animationaction\n\n查看文档你可以知道，执行播放器animationmixer的.clipaction()方法会返回一个animationaction对象。\n\n//animationmixer的`.clipaction()`返回一个animationaction对象\nconst clipaction = mixer.clipaction(clip);\n\n\nanimationaction对象的功能就是用来控制如何播放关键帧动画，比如是否播放、几倍速播放、是否循环播放、是否暂停播放...\n\n你可以测试注释代码clipaction.play();，看看关键帧动画是否变化。\n\n//.play()控制动画播放\nclipaction.play();\n\n\n\n# animationaction的循环属性.loop\n\n通过animationaction的循环属性.loop可以控制动画是否循环播放。\n\nconst clipaction = mixer.clipaction(clip);\n//.play()控制动画播放，默认循环播放\nclipaction.play();\n//不循环播放\nclipaction.loop = three.looponce; \n\n\n\n# animationaction的.clampwhenfinished属性\n\n当你通过clipaction.loop = three.looponce设置播放模式为非循环模式的时候，你会发现关键帧动画执行完成一个后，模型回到了关键帧动画开头状态，如果你希望模型停留在关键帧动画结束的状态，可以设置.clampwhenfinished属性实现，.clampwhenfinished属性默认是false，设置为true即可\n\n//不循环播放，执行一次后默认回到动画开头\nclipaction.loop = three.looponce; \n\n\n// 物体状态停留在动画结束的时候\nclipaction.clampwhenfinished = true;\n\n\n\n# 停止结束动画.stop()\n\n执行animationaction的.stop()方法，动画会停止，并结束，模型回到动画开始状态,注意不是暂停，是动画彻底终止，回到初始状态。\n\n//动画停止结束，回到开始状态\nclipaction.stop();\n\n\n<div class=\"pos\">\n    <div id=\"stop\" class=\"bu\">停止</div>\n    <div id=\"play\" class=\"bu\" style=\"margin-left: 10px;\">播放</div>\n</div>\n\n\ndocument.getelementbyid('stop').addeventlistener('click',function(){\n  clipaction.stop();//动画停止结束，回到开始状态\n})\ndocument.getelementbyid('play').addeventlistener('click',function(){\n  clipaction.play();//播放动画\n})\n\n\n\n# 是否暂停播放.paused\n\n.paused默认值false，动画正常执行，如果你想暂停正在执行的动画可以把.paused设置为true，对于暂停执行的动画，你把.paused设置为false，动画会接着暂停的位置继续执行。\n\n<div id=\"bu\" class=\"bu\">暂停</div>\n\n\nconst bu = document.getelementbyid('bu');\nbu.addeventlistener('click',function(){\n    // animationaction.paused默认值false，设置为true，可以临时暂停动画\n    if (clipaction.paused) {//暂停状态\n        clipaction.paused = false;//切换为播放状态\n        bu.innerhtml='暂停';// 如果改变为播放状态，按钮文字设置为“暂停”\n      } else {//播放状态\n        clipaction.paused = true;//切换为暂停状态\n        bu.innerhtml='继续';// 如果改变为暂停状态，按钮文字设置为“继续”\n      }\n})\n\n\n\n# 倍速播放.timescale\n\nclipaction.timescale = 1;//默认\nclipaction.timescale = 2;//2倍速\n\n\n\n# 拖动条调整播放速度\n\ngui辅助快速创建一个可交互拖动条，实际开发，可以用vue或react创建的拖动条。\n\nconst gui = new gui(); //创建gui对象\n// 0~6倍速之间调节\ngui.add(clipaction, 'timescale', 0, 6);\n",charsets:{cjk:!0}},{title:"1. 关键帧动画",frontmatter:{title:"1. 关键帧动画",date:"2023-03-22T20:48:15.000Z",permalink:"/pages/3aff37/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/01.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB.html",relativePath:"01.Three.js教程/16.16.关键帧动画/01.关键帧动画.md",key:"v-30f87000",path:"/pages/3aff37/",headers:[{level:3,title:"关键帧动画解释",slug:"关键帧动画解释",normalizedTitle:"关键帧动画解释",charIndex:153},{level:3,title:"1. 创建关键帧动画AnimationClip",slug:"_1-创建关键帧动画animationclip",normalizedTitle:"1. 创建关键帧动画animationclip",charIndex:359},{level:3,title:"1.1 模型命名",slug:"_1-1-模型命名",normalizedTitle:"1.1 模型命名",charIndex:1021},{level:3,title:"1.2 KeyframeTrack设置关键帧数据",slug:"_1-2-keyframetrack设置关键帧数据",normalizedTitle:"1.2 keyframetrack设置关键帧数据",charIndex:1131},{level:3,title:"1.3 创建关键帧动画AnimationClip",slug:"_1-3-创建关键帧动画animationclip",normalizedTitle:"1.3 创建关键帧动画animationclip",charIndex:1821},{level:3,title:"2.1 AnimationMixer播放关键帧动画AnimationClip",slug:"_2-1-animationmixer播放关键帧动画animationclip",normalizedTitle:"2.1 animationmixer播放关键帧动画animationclip",charIndex:2191},{level:3,title:"2.2 mixer.update()更新播放器AnimationMixer时间",slug:"_2-2-mixer-update-更新播放器animationmixer时间",normalizedTitle:"2.2 mixer.update()更新播放器animationmixer时间",charIndex:2639}],headersStr:"关键帧动画解释 1. 创建关键帧动画AnimationClip 1.1 模型命名 1.2 KeyframeTrack设置关键帧数据 1.3 创建关键帧动画AnimationClip 2.1 AnimationMixer播放关键帧动画AnimationClip 2.2 mixer.update()更新播放器AnimationMixer时间",content:'# 关键帧动画\n\n打开课件案例源码，你可以看到物体从一个位置移动到另一个位置的动画效果，移动过程中也出现过颜色变化。\n\n课件源码效果具体描述，就是0~3秒物体逐渐从坐标原点移动端x轴100位置，然后3~6秒物体逐渐从x轴100移动到z轴100位置，同时2~5秒时间内，把物体从红色逐渐改变为蓝色。\n\n\n# 关键帧动画解释\n\n所谓关键帧动画，你可以理解为在时间轴上，选择几个关键的时间点，然后分别定义这几个时间点对应物体状态(比如位置、姿态、颜色等)，然后基于几个关键的时间——状态数据，生成连续的动画。\n\n课件源码位置关键帧数据(时间——状态)\n\n * 0秒：坐标原点\n * 3秒：x轴上100坐标\n * 6秒：z轴上100坐标\n\n课件源码颜色关键帧数据(时间——状态)\n\n * 2秒：红色\n * 5秒：蓝色\n\n\n# 1. 创建关键帧动画AnimationClip\n\n * 1.1 给需要设置关键帧动画的模型命名\n * 1.2 设置关键帧数据KeyframeTrack\n * 1.3 基于关键帧数据KeyframeTrack，创建关键帧动画AnimationClip\n\n// 给需要设置关键帧动画的模型命名\nmesh.name = "Box";\nconst times = [0, 3, 6]; //时间轴上，设置三个时刻0、3、6秒\n// times中三个不同时间点，物体分别对应values中的三个xyz坐标\nconst values = [0, 0, 0, 100, 0, 0, 0, 0, 100];\n// 0~3秒，物体从(0,0,0)逐渐移动到(100,0,0),3~6秒逐渐从(100,0,0)移动到(0,0,100)\nconst posKF = new THREE.KeyframeTrack(\'Box.position\', times, values);\n// 从2秒到5秒，物体从红色逐渐变化为蓝色\nconst colorKF = new THREE.KeyframeTrack(\'Box.material.color\', [2, 5], [1, 0, 0, 0, 0, 1]);\n// 1.3 基于关键帧数据，创建一个clip关键帧动画对象，命名"test"，持续时间6秒。\nconst clip = new THREE.AnimationClip("test", 6, [posKF, colorKF]);\n\n\n\n# 1.1 模型命名\n\n你如果你想给一个模型对象设置关键帧动画，比如一个网格模型mesh、一个层级模型group，模型需要有一个名字，没有的话，可以通过.name属性命名。\n\nmesh.name = "Box";\n\n\n\n# 1.2 KeyframeTrack设置关键帧数据\n\nKeyframeTrack参数1是一个字符串，字符串内容是模型对象的名字.属性构成，比如Box.position表示模型位置，比如Box.material.color表示模型颜色，参数2是时间轴上取的几个关键帧时间点，参数3是时间点对应的物体状态。\n\n位置关键帧数据(时间——状态)\n\n * 0秒：坐标原点\n * 3秒：x轴上100坐标\n * 6秒：z轴上100坐标\n\n// 给名为Box的模型对象的设置关键帧数据KeyframeTrack\nconst times = [0, 3, 6]; //时间轴上，设置三个时刻0、3、6秒\n// times中三个不同时间点，物体分别对应values中的三个xyz坐标\nconst values = [0, 0, 0, 100, 0, 0, 0, 0, 100];\n// 创建关键帧，把模型位置和时间对应起来\n// 0~3秒，物体从(0,0,0)逐渐移动到(100,0,0),3~6秒逐渐从(100,0,0)移动到(0,0,100)\nconst posKF = new THREE.KeyframeTrack(\'Box.position\', times, values);\n\n\n颜色关键帧数据(时间——状态)\n\n * 2秒：红色\n * 5秒：蓝色\n\n// 从2秒到5秒，物体从红色逐渐变化为蓝色\nconst colorKF = new THREE.KeyframeTrack(\'Box.material.color\', [2, 5], [1, 0, 0, 0, 0, 1]);\n\n\n\n# 1.3 创建关键帧动画AnimationClip\n\n基于关键帧数据KeyframeTrack，创建关键帧动画AnimationClip，这样就可以利用关键帧里面的数据生成一个关键帧动画，用于接下来的动画播放。\n\n下面代码基于关键帧数据posKF、colorKF，创建一个clip关键帧动画对象AnimationClip，命名为test，动画持续时间6秒。\n\n// 1.3 AnimationClip表示一个关键帧动画，可以基于关键帧数据产生动画效果\n// 创建一个clip关键帧动画对象，命名"test"，动画持续时间6s\n// AnimationClip包含的所有关键帧数据都放到参数3数组中即可\nconst clip = new THREE.AnimationClip("test",6,[posKF, colorKF]);\n\n\n\n# 2.1 AnimationMixer播放关键帧动画AnimationClip\n\n前面代码,已经编辑好一个模型mesh的关键帧动画AnimationClip,如果你想播放动画，就要借助播放器AnimationMixer。\n\n//包含关键帧动画的模型对象作为AnimationMixer的参数创建一个播放器mixer\nconst mixer = new THREE.AnimationMixer(mesh);\n\n\n执行播放器AnimationMixer的.clipAction()方法返回一个AnimationAction对象,AnimationAction对象用来控制如何播放，比如.play()方法。\n\n//AnimationMixer的`.clipAction()`返回一个AnimationAction对象\nconst clipAction = mixer.clipAction(clip); \n//.play()控制动画播放，默认循环播放\nclipAction.play(); \n\n\n\n# 2.2 mixer.update()更新播放器AnimationMixer时间\n\n如果想播放动画开始变化,需要周期性执行mixer.update()更新播放器AnimationMixer时间数据，比如你可以在requestAnimationFrame创建的可以周期性执行的函数中，更新播放器时间数据。\n\nfunction loop() {\n    requestAnimationFrame(loop);\n}\nloop();\n\n\n通过Clock对象辅助获取每次loop()执行的时间间隔。\n\nconst clock = new THREE.Clock();\nfunction loop() {\n    requestAnimationFrame(loop);\n    //clock.getDelta()方法获得loop()两次执行时间间隔\n    const frameT = clock.getDelta();\n}\nloop();\n\n\n执行mixer.update()更新播放器AnimationMixer时间数据\n\nfunction loop() {\n    requestAnimationFrame(loop);\n    const frameT = clock.getDelta();\n    // 更新播放器相关的时间\n    mixer.update(frameT);\n}\nloop();\n\n\n如果你不想用requestAnimationFrame重新创建一个循环执行函数，也可以在index.js文件渲染循环中引入mixer.update()的代码',normalizedContent:'# 关键帧动画\n\n打开课件案例源码，你可以看到物体从一个位置移动到另一个位置的动画效果，移动过程中也出现过颜色变化。\n\n课件源码效果具体描述，就是0~3秒物体逐渐从坐标原点移动端x轴100位置，然后3~6秒物体逐渐从x轴100移动到z轴100位置，同时2~5秒时间内，把物体从红色逐渐改变为蓝色。\n\n\n# 关键帧动画解释\n\n所谓关键帧动画，你可以理解为在时间轴上，选择几个关键的时间点，然后分别定义这几个时间点对应物体状态(比如位置、姿态、颜色等)，然后基于几个关键的时间——状态数据，生成连续的动画。\n\n课件源码位置关键帧数据(时间——状态)\n\n * 0秒：坐标原点\n * 3秒：x轴上100坐标\n * 6秒：z轴上100坐标\n\n课件源码颜色关键帧数据(时间——状态)\n\n * 2秒：红色\n * 5秒：蓝色\n\n\n# 1. 创建关键帧动画animationclip\n\n * 1.1 给需要设置关键帧动画的模型命名\n * 1.2 设置关键帧数据keyframetrack\n * 1.3 基于关键帧数据keyframetrack，创建关键帧动画animationclip\n\n// 给需要设置关键帧动画的模型命名\nmesh.name = "box";\nconst times = [0, 3, 6]; //时间轴上，设置三个时刻0、3、6秒\n// times中三个不同时间点，物体分别对应values中的三个xyz坐标\nconst values = [0, 0, 0, 100, 0, 0, 0, 0, 100];\n// 0~3秒，物体从(0,0,0)逐渐移动到(100,0,0),3~6秒逐渐从(100,0,0)移动到(0,0,100)\nconst poskf = new three.keyframetrack(\'box.position\', times, values);\n// 从2秒到5秒，物体从红色逐渐变化为蓝色\nconst colorkf = new three.keyframetrack(\'box.material.color\', [2, 5], [1, 0, 0, 0, 0, 1]);\n// 1.3 基于关键帧数据，创建一个clip关键帧动画对象，命名"test"，持续时间6秒。\nconst clip = new three.animationclip("test", 6, [poskf, colorkf]);\n\n\n\n# 1.1 模型命名\n\n你如果你想给一个模型对象设置关键帧动画，比如一个网格模型mesh、一个层级模型group，模型需要有一个名字，没有的话，可以通过.name属性命名。\n\nmesh.name = "box";\n\n\n\n# 1.2 keyframetrack设置关键帧数据\n\nkeyframetrack参数1是一个字符串，字符串内容是模型对象的名字.属性构成，比如box.position表示模型位置，比如box.material.color表示模型颜色，参数2是时间轴上取的几个关键帧时间点，参数3是时间点对应的物体状态。\n\n位置关键帧数据(时间——状态)\n\n * 0秒：坐标原点\n * 3秒：x轴上100坐标\n * 6秒：z轴上100坐标\n\n// 给名为box的模型对象的设置关键帧数据keyframetrack\nconst times = [0, 3, 6]; //时间轴上，设置三个时刻0、3、6秒\n// times中三个不同时间点，物体分别对应values中的三个xyz坐标\nconst values = [0, 0, 0, 100, 0, 0, 0, 0, 100];\n// 创建关键帧，把模型位置和时间对应起来\n// 0~3秒，物体从(0,0,0)逐渐移动到(100,0,0),3~6秒逐渐从(100,0,0)移动到(0,0,100)\nconst poskf = new three.keyframetrack(\'box.position\', times, values);\n\n\n颜色关键帧数据(时间——状态)\n\n * 2秒：红色\n * 5秒：蓝色\n\n// 从2秒到5秒，物体从红色逐渐变化为蓝色\nconst colorkf = new three.keyframetrack(\'box.material.color\', [2, 5], [1, 0, 0, 0, 0, 1]);\n\n\n\n# 1.3 创建关键帧动画animationclip\n\n基于关键帧数据keyframetrack，创建关键帧动画animationclip，这样就可以利用关键帧里面的数据生成一个关键帧动画，用于接下来的动画播放。\n\n下面代码基于关键帧数据poskf、colorkf，创建一个clip关键帧动画对象animationclip，命名为test，动画持续时间6秒。\n\n// 1.3 animationclip表示一个关键帧动画，可以基于关键帧数据产生动画效果\n// 创建一个clip关键帧动画对象，命名"test"，动画持续时间6s\n// animationclip包含的所有关键帧数据都放到参数3数组中即可\nconst clip = new three.animationclip("test",6,[poskf, colorkf]);\n\n\n\n# 2.1 animationmixer播放关键帧动画animationclip\n\n前面代码,已经编辑好一个模型mesh的关键帧动画animationclip,如果你想播放动画，就要借助播放器animationmixer。\n\n//包含关键帧动画的模型对象作为animationmixer的参数创建一个播放器mixer\nconst mixer = new three.animationmixer(mesh);\n\n\n执行播放器animationmixer的.clipaction()方法返回一个animationaction对象,animationaction对象用来控制如何播放，比如.play()方法。\n\n//animationmixer的`.clipaction()`返回一个animationaction对象\nconst clipaction = mixer.clipaction(clip); \n//.play()控制动画播放，默认循环播放\nclipaction.play(); \n\n\n\n# 2.2 mixer.update()更新播放器animationmixer时间\n\n如果想播放动画开始变化,需要周期性执行mixer.update()更新播放器animationmixer时间数据，比如你可以在requestanimationframe创建的可以周期性执行的函数中，更新播放器时间数据。\n\nfunction loop() {\n    requestanimationframe(loop);\n}\nloop();\n\n\n通过clock对象辅助获取每次loop()执行的时间间隔。\n\nconst clock = new three.clock();\nfunction loop() {\n    requestanimationframe(loop);\n    //clock.getdelta()方法获得loop()两次执行时间间隔\n    const framet = clock.getdelta();\n}\nloop();\n\n\n执行mixer.update()更新播放器animationmixer时间数据\n\nfunction loop() {\n    requestanimationframe(loop);\n    const framet = clock.getdelta();\n    // 更新播放器相关的时间\n    mixer.update(framet);\n}\nloop();\n\n\n如果你不想用requestanimationframe重新创建一个循环执行函数，也可以在index.js文件渲染循环中引入mixer.update()的代码',charsets:{cjk:!0}},{title:"3. 动画播放(拖动任意时间状态)",frontmatter:{title:"3. 动画播放(拖动任意时间状态)",date:"2023-03-22T20:48:34.000Z",permalink:"/pages/c98f2f/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/03.%E5%8A%A8%E7%94%BB%E6%92%AD%E6%94%BE(%E6%8B%96%E5%8A%A8%E4%BB%BB%E6%84%8F%E6%97%B6%E9%97%B4%E7%8A%B6%E6%80%81).html",relativePath:"01.Three.js教程/16.16.关键帧动画/03.动画播放(拖动任意时间状态).md",key:"v-a449bf94",path:"/pages/c98f2f/",headers:[{level:3,title:"控制动画播放特定时间段",slug:"控制动画播放特定时间段",normalizedTitle:"控制动画播放特定时间段",charIndex:96},{level:3,title:"查看时间轴上任意时间动画状态",slug:"查看时间轴上任意时间动画状态",normalizedTitle:"查看时间轴上任意时间动画状态",charIndex:704},{level:3,title:"拖动条拖动显示动画任意时刻模型状态",slug:"拖动条拖动显示动画任意时刻模型状态",normalizedTitle:"拖动条拖动显示动画任意时刻模型状态",charIndex:908},{level:3,title:"动画下一步状态",slug:"动画下一步状态",normalizedTitle:"动画下一步状态",charIndex:1267}],headersStr:"控制动画播放特定时间段 查看时间轴上任意时间动画状态 拖动条拖动显示动画任意时刻模型状态 动画下一步状态",content:"# 动画播放(拖动任意时间状态)\n\n如果你想了解,关键帧动画在特定时间段播放，或者把动画定位在时间轴上任何一个时刻，或者借助UI拖动条，拖动查看关键帧任何时刻的状态，可以学习本节课。\n\n\n# 控制动画播放特定时间段\n\nAnimationClip参数2设置为6，执行AnimationAction.play()，默认播放0~6秒之间的关键帧动画。AnimationClip参数2的值会作为自身.duration属性的值。\n\nconst clip = new THREE.AnimationClip(\"test\", 6, [posKF, colorKF]);\nconsole.log('clip.duration',clip.duration);\n\n\n从时间轴上选择时间段播放动画，开始时刻AnimationAction.time，结束时刻AnimationClip.duration。\n\n//AnimationAction设置开始播放时间：从1秒时刻对应动画开始播放\nclipAction.time = 1; \n//AnimationClip设置播放结束时间：到5秒时刻对应的动画状态停止\nclip.duration = 5;\n\n\n注意.loop和.clampWhenFinished对播放效果的影响,如果需要上面代码完全起作用，要设置非循环模式，同时动画播放完，物体停留在结束状态，而不是回到开始状态。\n\n//不循环播放\nclipAction.loop = THREE.LoopOnce; \n// 物体状态停留在动画结束的时候\nclipAction.clampWhenFinished=true;\n\n\n\n# 查看时间轴上任意时间动画状态\n\n把动画设置为暂停状态，然后你可以通过AnimationAction.time把动画定格在时间轴上任何位置。\n\n//在暂停情况下，设置.time属性,把动画定位在任意时刻\nclipAction.paused = true;\nclipAction.time = 1;//物体状态为动画1秒对应状态\nclipAction.time = 3;//物体状态为动画3秒对应状态\n\n\n\n# 拖动条拖动显示动画任意时刻模型状态\n\n默认是播放的，可以预先暂停，再通过拖动条控制。\n\n//在暂停情况下，设置.time属性,把动画定位在任意时刻\nclipAction.paused = true;\n\n\ngui辅助快速创建一个可交互拖动条，调整模型停留在任何选定时间点状态。实际开发时候，你可以通过vue或react的UI组件库实现拖动条。\n\nimport {GUI} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new GUI(); //创建GUI对象\ngui.add(clipAction, 'time', 0, 6);\n\n\n设置步长\n\ngui.add(clipAction, 'time', 0, 6).step(0.1);\n\n\n\n# 动画下一步状态\n\n//在暂停情况下，设置.time属性,把动画定位在任意时刻\nclipAction.paused = true;\n\n\n下一步按钮\n\n<div id=\"bu\" class=\"bu\">下一步</div>\n\n\n点击按钮，模型调整到time累加0.1秒对应的动画状态。\n\nconst bu = document.getElementById('bu');\nbu.addEventListener('click', function () {\n  clipAction.time += 0.1; \n})\n",normalizedContent:"# 动画播放(拖动任意时间状态)\n\n如果你想了解,关键帧动画在特定时间段播放，或者把动画定位在时间轴上任何一个时刻，或者借助ui拖动条，拖动查看关键帧任何时刻的状态，可以学习本节课。\n\n\n# 控制动画播放特定时间段\n\nanimationclip参数2设置为6，执行animationaction.play()，默认播放0~6秒之间的关键帧动画。animationclip参数2的值会作为自身.duration属性的值。\n\nconst clip = new three.animationclip(\"test\", 6, [poskf, colorkf]);\nconsole.log('clip.duration',clip.duration);\n\n\n从时间轴上选择时间段播放动画，开始时刻animationaction.time，结束时刻animationclip.duration。\n\n//animationaction设置开始播放时间：从1秒时刻对应动画开始播放\nclipaction.time = 1; \n//animationclip设置播放结束时间：到5秒时刻对应的动画状态停止\nclip.duration = 5;\n\n\n注意.loop和.clampwhenfinished对播放效果的影响,如果需要上面代码完全起作用，要设置非循环模式，同时动画播放完，物体停留在结束状态，而不是回到开始状态。\n\n//不循环播放\nclipaction.loop = three.looponce; \n// 物体状态停留在动画结束的时候\nclipaction.clampwhenfinished=true;\n\n\n\n# 查看时间轴上任意时间动画状态\n\n把动画设置为暂停状态，然后你可以通过animationaction.time把动画定格在时间轴上任何位置。\n\n//在暂停情况下，设置.time属性,把动画定位在任意时刻\nclipaction.paused = true;\nclipaction.time = 1;//物体状态为动画1秒对应状态\nclipaction.time = 3;//物体状态为动画3秒对应状态\n\n\n\n# 拖动条拖动显示动画任意时刻模型状态\n\n默认是播放的，可以预先暂停，再通过拖动条控制。\n\n//在暂停情况下，设置.time属性,把动画定位在任意时刻\nclipaction.paused = true;\n\n\ngui辅助快速创建一个可交互拖动条，调整模型停留在任何选定时间点状态。实际开发时候，你可以通过vue或react的ui组件库实现拖动条。\n\nimport {gui} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new gui(); //创建gui对象\ngui.add(clipaction, 'time', 0, 6);\n\n\n设置步长\n\ngui.add(clipaction, 'time', 0, 6).step(0.1);\n\n\n\n# 动画下一步状态\n\n//在暂停情况下，设置.time属性,把动画定位在任意时刻\nclipaction.paused = true;\n\n\n下一步按钮\n\n<div id=\"bu\" class=\"bu\">下一步</div>\n\n\n点击按钮，模型调整到time累加0.1秒对应的动画状态。\n\nconst bu = document.getelementbyid('bu');\nbu.addeventlistener('click', function () {\n  clipaction.time += 0.1; \n})\n",charsets:{cjk:!0}},{title:"4. 解析外部模型关键帧动画",frontmatter:{title:"4. 解析外部模型关键帧动画",date:"2023-03-24T15:55:24.000Z",permalink:"/pages/e5737c/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/04.%E8%A7%A3%E6%9E%90%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9E%8B%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB.html",relativePath:"01.Three.js教程/16.16.关键帧动画/04.解析外部模型关键帧动画.md",key:"v-2bbec22a",path:"/pages/e5737c/",headers:[{level:3,title:"关键帧动画模型的父对象作为播放器AnimationMixer参数",slug:"关键帧动画模型的父对象作为播放器animationmixer参数",normalizedTitle:"关键帧动画模型的父对象作为播放器animationmixer参数",charIndex:249},{level:3,title:"查看gltf模型动画数据",slug:"查看gltf模型动画数据",normalizedTitle:"查看gltf模型动画数据",charIndex:815},{level:3,title:"播放AnimationClip动画",slug:"播放animationclip动画",normalizedTitle:"播放animationclip动画",charIndex:1245},{level:3,title:"动画是否循环播放",slug:"动画是否循环播放",normalizedTitle:"动画是否循环播放",charIndex:2592}],headersStr:"关键帧动画模型的父对象作为播放器AnimationMixer参数 查看gltf模型动画数据 播放AnimationClip动画 动画是否循环播放",content:"# 解析外部模型关键帧动画\n\n前面几节课，用到的关键帧动画，是借助threejs提供的两个类KeyframeTrack、AnimationClip自己写代码实现。不过实际开发的时候，很多时候会用三维建模软件，比如Blender，生成关键帧动画，导出包含动画的模型文件，加载模型后,你只需要播放关键帧动画，而不用手写代码创建关键帧动画。\n\n下面就给大家讲解，如果加载解析外部模型文件中的关键帧动画数据。\n\n课件源码中提供了一个美术用Blender编辑好的关键帧动画模型文件，你可以查看预览。\n\n\n# 关键帧动画模型的父对象作为播放器AnimationMixer参数\n\n前面讲解过，如果你想播放一个模型的关键帧动画，需要把模型作为播放器AnimationMixer的参数。\n\n//包含关键帧动画的模型对象作为AnimationMixer的参数创建一个播放器mixer\nconst mixer = new THREE.AnimationMixer(mesh);\n\n\n即便你把mesh的父对象group作为播放器AnimationMixer的参数，播放器也能根据KeyframeTrack参数1包含的模型名字.name确定关键帧动画对应的模型对象。\n\nmesh.name = \"Box\";\nconst group = new THREE.Group();\ngroup.add(mesh);\nconst posKF = new THREE.KeyframeTrack('Box.position', times, values);\nconst clip = new THREE.AnimationClip(\"test\",6,[posKF]);\n//包含关键帧动画的模型对象作为AnimationMixer的参数创建一个播放器mixer\nconst mixer = new THREE.AnimationMixer(group);\n\n\n\n# 查看gltf模型动画数据\n\n一般实际开发的时候，在三维建模软件中，创建生成动画相关数据，然后可以导出gltf、fbx等可以包含动画的文件，最后程序员通过threejs代码加载模型、解析模型包含的动画数据，下面就以gltf模型文件为例给大家演示。\n\n加载gltf模型，如果存在帧动画数据的话，可以通过加载返回gltf对象的动画属性.animations获取。\n\nconst loader = new GLTFLoader(); \nloader.load(\"../工厂.glb\", function (gltf) {\n    console.log('控制台查看gltf对象结构', gltf);\n    console.log('动画数据', gltf.animations);\n})\n\n\ngltf.animations是一个数组，如果没有帧动画数据，就是一个空数组，有帧动画数据的情况下，里面可能1个或多个Clip动画对象AnimationClip。\n\n\n# 播放AnimationClip动画\n\nloader.load(\"../工厂.glb\", function (gltf) { \n    console.log('控制台查看gltf对象结构', gltf);\n    // console.log('动画数据', gltf.animations);\n    model.add(gltf.scene); \n\n    //包含关键帧动画的模型作为参数创建一个播放器\n    const mixer = new THREE.AnimationMixer(gltf.scene);\n    //  获取gltf.animations[0]的第一个clip动画对象\n    const clipAction = mixer.clipAction(gltf.animations[0]); //创建动画clipAction对象\n    clipAction.play(); //播放动画\n\n    // 如果想播放动画,需要周期性执行`mixer.update()`更新AnimationMixer时间数据\n    const clock = new THREE.Clock();\n    function loop() {\n        requestAnimationFrame(loop);\n        //clock.getDelta()方法获得loop()两次执行时间间隔\n        const frameT = clock.getDelta();\n        // 更新播放器相关的时间\n        mixer.update(frameT);\n    }\n    loop();\n})\n\n\n下面是在渲染循环中更新播放器时间。\n\nlet mixer = null; //声明一个播放器变量\nloader.load(\"../工厂.glb\", function (gltf) { \n    model.add(gltf.scene);\n     //包含帧动画的模型作为参数创建一个播放器\n     mixer = new THREE.AnimationMixer(gltf.scene);\n    //  获取gltf.animations[0]的第一个clip动画对象\n     const clipAction = mixer.clipAction(gltf.animations[0]);//创建动画clipAction对象\n     clipAction.play();//播放动画\n})\n\n // 创建一个时钟对象Clock\n const clock = new THREE.Clock();\n function render() {\n     requestAnimationFrame(render);\n     if (mixer !== null) {\n         //clock.getDelta()方法获得两帧的时间间隔\n         // 更新播放器相关的时间\n         mixer.update(clock.getDelta());\n     }\n }\n render();\n\n\n\n# 动画是否循环播放\n\n人走路、跑步美术美术一般设置很短时间运动，如果你想一直看到运动动作，不用设置非循环。\n\n//不循环播放\nclipAction.loop = THREE.LoopOnce; \n// 物体状态停留在动画结束的时候\nclipAction.clampWhenFinished = true\n",normalizedContent:"# 解析外部模型关键帧动画\n\n前面几节课，用到的关键帧动画，是借助threejs提供的两个类keyframetrack、animationclip自己写代码实现。不过实际开发的时候，很多时候会用三维建模软件，比如blender，生成关键帧动画，导出包含动画的模型文件，加载模型后,你只需要播放关键帧动画，而不用手写代码创建关键帧动画。\n\n下面就给大家讲解，如果加载解析外部模型文件中的关键帧动画数据。\n\n课件源码中提供了一个美术用blender编辑好的关键帧动画模型文件，你可以查看预览。\n\n\n# 关键帧动画模型的父对象作为播放器animationmixer参数\n\n前面讲解过，如果你想播放一个模型的关键帧动画，需要把模型作为播放器animationmixer的参数。\n\n//包含关键帧动画的模型对象作为animationmixer的参数创建一个播放器mixer\nconst mixer = new three.animationmixer(mesh);\n\n\n即便你把mesh的父对象group作为播放器animationmixer的参数，播放器也能根据keyframetrack参数1包含的模型名字.name确定关键帧动画对应的模型对象。\n\nmesh.name = \"box\";\nconst group = new three.group();\ngroup.add(mesh);\nconst poskf = new three.keyframetrack('box.position', times, values);\nconst clip = new three.animationclip(\"test\",6,[poskf]);\n//包含关键帧动画的模型对象作为animationmixer的参数创建一个播放器mixer\nconst mixer = new three.animationmixer(group);\n\n\n\n# 查看gltf模型动画数据\n\n一般实际开发的时候，在三维建模软件中，创建生成动画相关数据，然后可以导出gltf、fbx等可以包含动画的文件，最后程序员通过threejs代码加载模型、解析模型包含的动画数据，下面就以gltf模型文件为例给大家演示。\n\n加载gltf模型，如果存在帧动画数据的话，可以通过加载返回gltf对象的动画属性.animations获取。\n\nconst loader = new gltfloader(); \nloader.load(\"../工厂.glb\", function (gltf) {\n    console.log('控制台查看gltf对象结构', gltf);\n    console.log('动画数据', gltf.animations);\n})\n\n\ngltf.animations是一个数组，如果没有帧动画数据，就是一个空数组，有帧动画数据的情况下，里面可能1个或多个clip动画对象animationclip。\n\n\n# 播放animationclip动画\n\nloader.load(\"../工厂.glb\", function (gltf) { \n    console.log('控制台查看gltf对象结构', gltf);\n    // console.log('动画数据', gltf.animations);\n    model.add(gltf.scene); \n\n    //包含关键帧动画的模型作为参数创建一个播放器\n    const mixer = new three.animationmixer(gltf.scene);\n    //  获取gltf.animations[0]的第一个clip动画对象\n    const clipaction = mixer.clipaction(gltf.animations[0]); //创建动画clipaction对象\n    clipaction.play(); //播放动画\n\n    // 如果想播放动画,需要周期性执行`mixer.update()`更新animationmixer时间数据\n    const clock = new three.clock();\n    function loop() {\n        requestanimationframe(loop);\n        //clock.getdelta()方法获得loop()两次执行时间间隔\n        const framet = clock.getdelta();\n        // 更新播放器相关的时间\n        mixer.update(framet);\n    }\n    loop();\n})\n\n\n下面是在渲染循环中更新播放器时间。\n\nlet mixer = null; //声明一个播放器变量\nloader.load(\"../工厂.glb\", function (gltf) { \n    model.add(gltf.scene);\n     //包含帧动画的模型作为参数创建一个播放器\n     mixer = new three.animationmixer(gltf.scene);\n    //  获取gltf.animations[0]的第一个clip动画对象\n     const clipaction = mixer.clipaction(gltf.animations[0]);//创建动画clipaction对象\n     clipaction.play();//播放动画\n})\n\n // 创建一个时钟对象clock\n const clock = new three.clock();\n function render() {\n     requestanimationframe(render);\n     if (mixer !== null) {\n         //clock.getdelta()方法获得两帧的时间间隔\n         // 更新播放器相关的时间\n         mixer.update(clock.getdelta());\n     }\n }\n render();\n\n\n\n# 动画是否循环播放\n\n人走路、跑步美术美术一般设置很短时间运动，如果你想一直看到运动动作，不用设置非循环。\n\n//不循环播放\nclipaction.loop = three.looponce; \n// 物体状态停留在动画结束的时候\nclipaction.clampwhenfinished = true\n",charsets:{cjk:!0}},{title:"5. 机械虚拟装配案例(播放)",frontmatter:{title:"5. 机械虚拟装配案例(播放)",date:"2023-03-24T15:55:41.000Z",permalink:"/pages/478039/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/05.%E6%9C%BA%E6%A2%B0%E8%99%9A%E6%8B%9F%E8%A3%85%E9%85%8D%E6%A1%88%E4%BE%8B(%E6%92%AD%E6%94%BE).html",relativePath:"01.Three.js教程/16.16.关键帧动画/05.机械虚拟装配案例(播放).md",key:"v-64040a28",path:"/pages/478039/",headers:[{level:3,title:"动画不循环播放",slug:"动画不循环播放",normalizedTitle:"动画不循环播放",charIndex:141},{level:3,title:"动画开始设置暂停",slug:"动画开始设置暂停",normalizedTitle:"动画开始设置暂停",charIndex:276},{level:3,title:"按钮控制虚拟装配播放、暂停",slug:"按钮控制虚拟装配播放、暂停",normalizedTitle:"按钮控制虚拟装配播放、暂停",charIndex:468},{level:3,title:"动画播放结束，按钮样式恢复到播放",slug:"动画播放结束-按钮样式恢复到播放",normalizedTitle:"动画播放结束，按钮样式恢复到播放",charIndex:1015},{level:3,title:"拖动条控制播放倍速",slug:"拖动条控制播放倍速",normalizedTitle:"拖动条控制播放倍速",charIndex:1461}],headersStr:"动画不循环播放 动画开始设置暂停 按钮控制虚拟装配播放、暂停 动画播放结束，按钮样式恢复到播放 拖动条控制播放倍速",content:"# 机械虚拟装配案例(播放)\n\n如果你想做一个产品、机械、建筑的虚拟装配动画，可以美术先在建模软件中生成关键帧动画的数据，然后通过threejs加载模型，播放动画数据即可。\n\n本节课用到的threejs知识点在前面几小节基本都详细说明过，你可以先尝试自己能否实现，再听课。\n\n\n# 动画不循环播放\n\n该案例动画是一个虚拟装配的动画，如果你不需要循环播放，可以关闭掉。\n\nconst clipAction = mixer.clipAction(clip);\n//不循环播放\nclipAction.loop = THREE.LoopOnce; \n\n\n\n# 动画开始设置暂停\n\n执行.play()动画默认播放，在按钮控制播放暂停之前，可以先设置.paused = true动画预先暂停。\n\nconst clipAction = mixer.clipAction(clip); //创建动画clipAction对象\nclipAction.play(); //播放动画\nclipAction.paused = true; //暂停状态\n\n\n\n# 按钮控制虚拟装配播放、暂停\n\n<div id=\"bu\" class=\"bu\">播放</div>\n\n\n.paused默认值false，动画正常执行，如果你想暂停正在执行的动画可以把.paused设置为true，对于暂停执行的动画，你把.paused设置为false，动画会接着暂停的位置继续执行。\n\nconst bu = document.getElementById('bu');\nbu.addEventListener('click',function(){\n    // AnimationAction.paused默认值false，设置为true，可以临时暂停动画\n    if (clipAction.paused) {//暂停状态\n        clipAction.paused = false;//切换为播放状态\n        bu.innerHTML='暂停';// 如果改变为播放状态，按钮文字设置为“暂停”\n      } else {//播放状态\n        clipAction.paused = true;//切换为暂停状态\n        bu.innerHTML='播放';// 如果改变为暂停状态，按钮文字设置为“播放”\n      }\n})\n\n\n\n# 动画播放结束，按钮样式恢复到播放\n\n动画播放完成以后，UI按钮的样式还是停留在“暂停”的状态，需要恢复到“播放”样式，提示用户，可以再次点击播放。\n\nclipAction.loop = THREE.LoopOnce; \n// 动画播放完成事件\nmixer.addEventListener('finished', function () {\n    bu.innerHTML = '播放';//播放完成，按钮显示为“播放”\n});\n\n\n执行.reset();动画重新进入新一次执行状态，这样播放按钮可以再次使用。\n\n// 动画播放完成事件\nmixer.addEventListener('finished', function () {\n    bu.innerHTML = '播放';//播放完成，按钮显示为“播放”\n    clipAction.reset(); //重新开始新的动画播放\n    clipAction.paused = true; //切换为暂停状态\n});\n\n\n\n# 拖动条控制播放倍速\n\nimport {GUI} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new GUI(); //创建GUI对象\n// 0~2倍速之间调节\ngui.add(clipAction, 'timeScale', 0, 2).step(0.1).name('倍速');\n",normalizedContent:"# 机械虚拟装配案例(播放)\n\n如果你想做一个产品、机械、建筑的虚拟装配动画，可以美术先在建模软件中生成关键帧动画的数据，然后通过threejs加载模型，播放动画数据即可。\n\n本节课用到的threejs知识点在前面几小节基本都详细说明过，你可以先尝试自己能否实现，再听课。\n\n\n# 动画不循环播放\n\n该案例动画是一个虚拟装配的动画，如果你不需要循环播放，可以关闭掉。\n\nconst clipaction = mixer.clipaction(clip);\n//不循环播放\nclipaction.loop = three.looponce; \n\n\n\n# 动画开始设置暂停\n\n执行.play()动画默认播放，在按钮控制播放暂停之前，可以先设置.paused = true动画预先暂停。\n\nconst clipaction = mixer.clipaction(clip); //创建动画clipaction对象\nclipaction.play(); //播放动画\nclipaction.paused = true; //暂停状态\n\n\n\n# 按钮控制虚拟装配播放、暂停\n\n<div id=\"bu\" class=\"bu\">播放</div>\n\n\n.paused默认值false，动画正常执行，如果你想暂停正在执行的动画可以把.paused设置为true，对于暂停执行的动画，你把.paused设置为false，动画会接着暂停的位置继续执行。\n\nconst bu = document.getelementbyid('bu');\nbu.addeventlistener('click',function(){\n    // animationaction.paused默认值false，设置为true，可以临时暂停动画\n    if (clipaction.paused) {//暂停状态\n        clipaction.paused = false;//切换为播放状态\n        bu.innerhtml='暂停';// 如果改变为播放状态，按钮文字设置为“暂停”\n      } else {//播放状态\n        clipaction.paused = true;//切换为暂停状态\n        bu.innerhtml='播放';// 如果改变为暂停状态，按钮文字设置为“播放”\n      }\n})\n\n\n\n# 动画播放结束，按钮样式恢复到播放\n\n动画播放完成以后，ui按钮的样式还是停留在“暂停”的状态，需要恢复到“播放”样式，提示用户，可以再次点击播放。\n\nclipaction.loop = three.looponce; \n// 动画播放完成事件\nmixer.addeventlistener('finished', function () {\n    bu.innerhtml = '播放';//播放完成，按钮显示为“播放”\n});\n\n\n执行.reset();动画重新进入新一次执行状态，这样播放按钮可以再次使用。\n\n// 动画播放完成事件\nmixer.addeventlistener('finished', function () {\n    bu.innerhtml = '播放';//播放完成，按钮显示为“播放”\n    clipaction.reset(); //重新开始新的动画播放\n    clipaction.paused = true; //切换为暂停状态\n});\n\n\n\n# 拖动条控制播放倍速\n\nimport {gui} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new gui(); //创建gui对象\n// 0~2倍速之间调节\ngui.add(clipaction, 'timescale', 0, 2).step(0.1).name('倍速');\n",charsets:{cjk:!0}},{title:"6. 虚拟装配(任意时间定位)",frontmatter:{title:"6. 虚拟装配(任意时间定位)",date:"2023-03-24T17:20:15.000Z",permalink:"/pages/c9c18c/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/06.%E8%99%9A%E6%8B%9F%E8%A3%85%E9%85%8D(%E4%BB%BB%E6%84%8F%E6%97%B6%E9%97%B4%E5%AE%9A%E4%BD%8D).html",relativePath:"01.Three.js教程/16.16.关键帧动画/06.虚拟装配(任意时间定位).md",key:"v-04470b50",path:"/pages/c9c18c/",headers:[{level:3,title:"属性.duration获取动画默认的执行时间",slug:"属性-duration获取动画默认的执行时间",normalizedTitle:"属性.duration获取动画默认的执行时间",charIndex:109},{level:3,title:"拖动条查看任意时间动画状态",slug:"拖动条查看任意时间动画状态",normalizedTitle:"拖动条查看任意时间动画状态",charIndex:270},{level:3,title:"拖动条与播放按钮功能组合",slug:"拖动条与播放按钮功能组合",normalizedTitle:"拖动条与播放按钮功能组合",charIndex:502}],headersStr:"属性.duration获取动画默认的执行时间 拖动条查看任意时间动画状态 拖动条与播放按钮功能组合",content:"# 虚拟装配(任意时间定位)\n\n继续上节课关于虚拟装配动画的讲解，增加一个拖动条，用来查看任意时间模型动画状态。\n\n关于关键帧动画，通过拖动条查看动画任意时间状态的方法，前面16.3小节讲解过，可以直接参考。\n\n\n# 属性.duration获取动画默认的执行时间\n\n如果你不知道关键帧动画的执行时间，可以通过加载模型返回对象AnimationClip的.duration属性获得。\n\nconst clip = gltf.animations[0];\nconst duration = clip.duration;//默认持续时间\n\n\n\n# 拖动条查看任意时间动画状态\n\nimport {GUI} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new GUI(); //创建GUI对象\n\nclipAction.paused = true;//暂停状态拖动拖动条\n\n// 拖动条查看动画任何时刻模型状态\ngui.add(clipAction,'time',0,duration).step(0.1).name('拖动');\n\n\n\n# 拖动条与播放按钮功能组合\n\n如果动画刚好处于播放状态，你拖动拖动条，会受到动画播放的影响，可以通过代码暂停动画。\n\n播放状态，按钮显示文字是“暂停”，把按钮样式也更改下。\n\n// 拖动条查看动画任何时刻模型状态\ngui.add(clipAction, 'time', 0, duration).step(0.1).name('拖动').onChange(function () {\n    //如果动画处于播放状态会影响拖动条时间定位\n    if (!clipAction.paused){\n        clipAction.paused = true; //切换为暂停状态\n        bu.innerHTML = '播放'; //修改按钮样式\n    }\n});\n",normalizedContent:"# 虚拟装配(任意时间定位)\n\n继续上节课关于虚拟装配动画的讲解，增加一个拖动条，用来查看任意时间模型动画状态。\n\n关于关键帧动画，通过拖动条查看动画任意时间状态的方法，前面16.3小节讲解过，可以直接参考。\n\n\n# 属性.duration获取动画默认的执行时间\n\n如果你不知道关键帧动画的执行时间，可以通过加载模型返回对象animationclip的.duration属性获得。\n\nconst clip = gltf.animations[0];\nconst duration = clip.duration;//默认持续时间\n\n\n\n# 拖动条查看任意时间动画状态\n\nimport {gui} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new gui(); //创建gui对象\n\nclipaction.paused = true;//暂停状态拖动拖动条\n\n// 拖动条查看动画任何时刻模型状态\ngui.add(clipaction,'time',0,duration).step(0.1).name('拖动');\n\n\n\n# 拖动条与播放按钮功能组合\n\n如果动画刚好处于播放状态，你拖动拖动条，会受到动画播放的影响，可以通过代码暂停动画。\n\n播放状态，按钮显示文字是“暂停”，把按钮样式也更改下。\n\n// 拖动条查看动画任何时刻模型状态\ngui.add(clipaction, 'time', 0, duration).step(0.1).name('拖动').onchange(function () {\n    //如果动画处于播放状态会影响拖动条时间定位\n    if (!clipaction.paused){\n        clipaction.paused = true; //切换为暂停状态\n        bu.innerhtml = '播放'; //修改按钮样式\n    }\n});\n",charsets:{cjk:!0}},{title:"8. 变形动画(定制人物胖瘦)",frontmatter:{title:"8. 变形动画(定制人物胖瘦)",date:"2023-03-24T23:58:12.000Z",permalink:"/pages/43c650/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/08.%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB(%E5%AE%9A%E5%88%B6%E4%BA%BA%E7%89%A9%E8%83%96%E7%98%A6).html",relativePath:"01.Three.js教程/16.16.关键帧动画/08.变形动画(定制人物胖瘦).md",key:"v-26245688",path:"/pages/43c650/",headers:[{level:3,title:"查看模型几何体变形相关信息",slug:"查看模型几何体变形相关信息",normalizedTitle:"查看模型几何体变形相关信息",charIndex:101},{level:3,title:"UI界面定制人胖瘦体型",slug:"ui界面定制人胖瘦体型",normalizedTitle:"ui界面定制人胖瘦体型",charIndex:639},{level:3,title:"批量设置所有变形目标的拖动条",slug:"批量设置所有变形目标的拖动条",normalizedTitle:"批量设置所有变形目标的拖动条",charIndex:1029},{level:3,title:"外部模型变形数据生成动画",slug:"外部模型变形数据生成动画",normalizedTitle:"外部模型变形数据生成动画",charIndex:1617}],headersStr:"查看模型几何体变形相关信息 UI界面定制人胖瘦体型 批量设置所有变形目标的拖动条 外部模型变形数据生成动画",content:"# 变形动画(定制人物胖瘦)\n\n下面给大家演示一个变形动画的应用例子，先通过三维建模生成几何体的变形目标顶点数据，不用创建关键帧动画，然后通过拖动条，控制变形目标权重系数，控制人物形象的胖瘦。\n\n\n# 查看模型几何体变形相关信息\n\n查看Blender软件中几何体变形信息，可以通过形态键调节查看测试效果。\n\n\n\n课件代码浏览器控制打印人物模型，可以看到，有几何体的变形目标顶点数据，但是没有通过关键帧动画设置模型的变形动画效果。\n\nloader.load(\"../人.glb\", function (gltf) {\n    console.log('控制台查看gltf对象结构', gltf);\n    model.add(gltf.scene);\n    // 访问人体网格模型\n    const mesh = gltf.scene.children[0]; \n    // 获取所有变形目标的顶点数据\n    const tArr = mesh.geometry.morphAttributes.position\n    console.log('所有变形目标', tArr);\n    console.log('所有权重', mesh.morphTargetInfluences);\n    //每个变形目标对应的含义(注意和变形目标对应起来)\n    const nameArr = ['变胖', '丰乳肥臀', '增肌', '年龄', '变瘦'];\n})\n\n\n\n# UI界面定制人胖瘦体型\n\n人物模型有多个变形目标，下面随机选择了两个设置拖动条控制变形目标对应的权重系数。\n\nimport {GUI} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new GUI();\nconst obj = {\n    t0: 0,\n    t1: 0,\n}\ngui.add(obj, 't0', 0, 1).name('变胖').onChange(function (v) {\n    mesh.morphTargetInfluences[0] = v;\n});\ngui.add(obj, 't1', 0, 1).name('丰乳肥臀').onChange(function (v) {\n    mesh.morphTargetInfluences[1] = v;\n});\n\n\n\n# 批量设置所有变形目标的拖动条\n\nimport {GUI} from 'three/addons/libs/lil-gui.module.min.js';\nconst mesh = gltf.scene.children[0]; // 访问人体网格模型\n// 获取所有变形目标的顶点数据\nconst tArr = mesh.geometry.morphAttributes.position\n// 每个变形目标对应的含义(注意和变形目标对应起来)\nconst nameArr = ['变胖', '丰乳肥臀', '增肌', '年龄', '变瘦'];\n// GUI拖动条可视化改变变形目标权重系数\nconst obj = {};\nconst gui = new GUI();\nfor (let i = 0; i < tArr.length; i++) {\n    obj['t' + i] = 0;//obj批量定义一个属性表示变性目标的权重系数\n    // 批量设置要改变的obj属性，对应name名字，和对应权重\n    gui.add(obj, 't' + i, 0, 1).name(nameArr[i]).onChange(function (v) {\n        mesh.morphTargetInfluences[i] = v;\n    });\n}\n\n\n\n# 外部模型变形数据生成动画\n\nloader.load(\"../人.glb\", function (gltf) {\n    const mesh = gltf.scene.children[0];\n    // 创建变形动画权重系数的关键帧数据\n    mesh.name = \"per\"; //关键帧动画控制的模型对象命名\n    // 设置变形目标1对应权重随着时间的变化\n    const KF1 = new THREE.KeyframeTrack('per.morphTargetInfluences[0]', [0, 5], [0, 1]);\n    // 生成关键帧动画\n    const clip = new THREE.AnimationClip(\"t\", 5, [KF1]);\n\n\n    //包含关键帧动画的模型作为参数创建一个播放器\n    const mixer = new THREE.AnimationMixer(gltf.scene);\n    const clipAction = mixer.clipAction(clip);\n    clipAction.play();\n\n    const clock = new THREE.Clock();\n    function loop() {\n        requestAnimationFrame(loop);\n        const frameT = clock.getDelta();\n        // 更新播放器相关的时间\n        mixer.update(frameT);\n    }\n    loop();\n})\n",normalizedContent:"# 变形动画(定制人物胖瘦)\n\n下面给大家演示一个变形动画的应用例子，先通过三维建模生成几何体的变形目标顶点数据，不用创建关键帧动画，然后通过拖动条，控制变形目标权重系数，控制人物形象的胖瘦。\n\n\n# 查看模型几何体变形相关信息\n\n查看blender软件中几何体变形信息，可以通过形态键调节查看测试效果。\n\n\n\n课件代码浏览器控制打印人物模型，可以看到，有几何体的变形目标顶点数据，但是没有通过关键帧动画设置模型的变形动画效果。\n\nloader.load(\"../人.glb\", function (gltf) {\n    console.log('控制台查看gltf对象结构', gltf);\n    model.add(gltf.scene);\n    // 访问人体网格模型\n    const mesh = gltf.scene.children[0]; \n    // 获取所有变形目标的顶点数据\n    const tarr = mesh.geometry.morphattributes.position\n    console.log('所有变形目标', tarr);\n    console.log('所有权重', mesh.morphtargetinfluences);\n    //每个变形目标对应的含义(注意和变形目标对应起来)\n    const namearr = ['变胖', '丰乳肥臀', '增肌', '年龄', '变瘦'];\n})\n\n\n\n# ui界面定制人胖瘦体型\n\n人物模型有多个变形目标，下面随机选择了两个设置拖动条控制变形目标对应的权重系数。\n\nimport {gui} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new gui();\nconst obj = {\n    t0: 0,\n    t1: 0,\n}\ngui.add(obj, 't0', 0, 1).name('变胖').onchange(function (v) {\n    mesh.morphtargetinfluences[0] = v;\n});\ngui.add(obj, 't1', 0, 1).name('丰乳肥臀').onchange(function (v) {\n    mesh.morphtargetinfluences[1] = v;\n});\n\n\n\n# 批量设置所有变形目标的拖动条\n\nimport {gui} from 'three/addons/libs/lil-gui.module.min.js';\nconst mesh = gltf.scene.children[0]; // 访问人体网格模型\n// 获取所有变形目标的顶点数据\nconst tarr = mesh.geometry.morphattributes.position\n// 每个变形目标对应的含义(注意和变形目标对应起来)\nconst namearr = ['变胖', '丰乳肥臀', '增肌', '年龄', '变瘦'];\n// gui拖动条可视化改变变形目标权重系数\nconst obj = {};\nconst gui = new gui();\nfor (let i = 0; i < tarr.length; i++) {\n    obj['t' + i] = 0;//obj批量定义一个属性表示变性目标的权重系数\n    // 批量设置要改变的obj属性，对应name名字，和对应权重\n    gui.add(obj, 't' + i, 0, 1).name(namearr[i]).onchange(function (v) {\n        mesh.morphtargetinfluences[i] = v;\n    });\n}\n\n\n\n# 外部模型变形数据生成动画\n\nloader.load(\"../人.glb\", function (gltf) {\n    const mesh = gltf.scene.children[0];\n    // 创建变形动画权重系数的关键帧数据\n    mesh.name = \"per\"; //关键帧动画控制的模型对象命名\n    // 设置变形目标1对应权重随着时间的变化\n    const kf1 = new three.keyframetrack('per.morphtargetinfluences[0]', [0, 5], [0, 1]);\n    // 生成关键帧动画\n    const clip = new three.animationclip(\"t\", 5, [kf1]);\n\n\n    //包含关键帧动画的模型作为参数创建一个播放器\n    const mixer = new three.animationmixer(gltf.scene);\n    const clipaction = mixer.clipaction(clip);\n    clipaction.play();\n\n    const clock = new three.clock();\n    function loop() {\n        requestanimationframe(loop);\n        const framet = clock.getdelta();\n        // 更新播放器相关的时间\n        mixer.update(framet);\n    }\n    loop();\n})\n",charsets:{cjk:!0}},{title:"7. 变形动画原理",frontmatter:{title:"7. 变形动画原理",date:"2023-03-24T23:58:23.000Z",permalink:"/pages/d8c0b0/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/07.%E5%8F%98%E5%BD%A2%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86.html",relativePath:"01.Three.js教程/16.16.关键帧动画/07.变形动画原理.md",key:"v-37c2a0b8",path:"/pages/d8c0b0/",headers:[{level:3,title:".morphAttributes设置几何体变形目标顶点数据",slug:"morphattributes设置几何体变形目标顶点数据",normalizedTitle:".morphattributes设置几何体变形目标顶点数据",charIndex:33},{level:3,title:".morphTargetInfluences权重系数控制变形程度",slug:"morphtargetinfluences权重系数控制变形程度",normalizedTitle:".morphtargetinfluences权重系数控制变形程度",charIndex:629},{level:3,title:"多个变形目标综合影响模型形状",slug:"多个变形目标综合影响模型形状",normalizedTitle:"多个变形目标综合影响模型形状",charIndex:1331},{level:3,title:"GUI控制变形权重系数.morphTargetInfluences",slug:"gui控制变形权重系数-morphtargetinfluences",normalizedTitle:"gui控制变形权重系数.morphtargetinfluences",charIndex:1503},{level:3,title:"生成变形动画",slug:"生成变形动画",normalizedTitle:"生成变形动画",charIndex:1945},{level:3,title:"解析外部变形动画模型",slug:"解析外部变形动画模型",normalizedTitle:"解析外部变形动画模型",charIndex:2817}],headersStr:".morphAttributes设置几何体变形目标顶点数据 .morphTargetInfluences权重系数控制变形程度 多个变形目标综合影响模型形状 GUI控制变形权重系数.morphTargetInfluences 生成变形动画 解析外部变形动画模型",content:"# 变形动画原理\n\n下面给大家介绍下变形动画的基本原理。\n\n\n# .morphAttributes设置几何体变形目标顶点数据\n\nBufferGeometry属性.morphAttributes的功能就是用来设置几何体变形目标顶点数据。\n\n//几何体两组顶点一一对应，位置不同，然后通过权重系数，可以控制模型形状在两组顶点之间变化\nconst geometry = new THREE.BoxGeometry(50, 50, 50);\n// 为geometry提供变形目标的顶点数据(注意和原始geometry顶点数量一致)\nconst target1 = new THREE.BoxGeometry(50, 200, 50).attributes.position;//变高\nconst target2 = new THREE.BoxGeometry(10, 50, 10).attributes.position;//变细\n// 几何体顶点变形目标数据，可以设置1组或多组\ngeometry.morphAttributes.position = [target1, target2];\n\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n注意：给一个几何体geometry设置顶点变形数据.morphAttributes时候要注意，在执行代码new THREE.Mesh()之前设置，否则报错。\n\n\n# .morphTargetInfluences权重系数控制变形程度\n\n查看文档，你可以看到网格模型Mesh、点模型、线模型都有一个权重属性.morphTargetInfluences，该权重的作用是，控制geometry自身顶点和变形目标顶点分别对模型形状形象程度。\n\n设置变形目标影响权重，范围一般0~1。\n\nmesh在geometry原始形状和变形目标1顶点对应形状之间变化。\n\nmesh的几何体变形目标是放在一个数组.morphAttributes.position中的，设置权重系数morphTargetInfluences的时候，需要设置索引值， 比如.morphTargetInfluences[0]影响的变形目标是.morphAttributes.position[0]，.morphTargetInfluences[1]影响的变形目标是.morphAttributes.position[1]。\n\n//权重0：物体形状对应geometry.attributes.position表示形状\nmesh.morphTargetInfluences[0] = 0.0;\n//权重1：物体形状对应target1表示形状\nmesh.morphTargetInfluences[0] = 1.0;\n//权重0.5：物体形状对应geometry和target1变形中间状态\nmesh.morphTargetInfluences[0] = 0.5;\n\n\nmesh在geometry原始形状和变形目标2顶点对应形状之间变化\n\nmesh.morphTargetInfluences[1] = 0.5;\n\n\n\n# 多个变形目标综合影响模型形状\n\n一个网格模型的几何体geometry可以有多个变形目标，只要对应权重不为0，每个变形目标的形状都会影响模型的形状。\n\n// 两个变形目标同时影响模型形状\nmesh.morphTargetInfluences[1] = 0.5;\nmesh.morphTargetInfluences[0] = 0.5;\n\n\n\n# GUI控制变形权重系数.morphTargetInfluences\n\nimport {GUI} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new GUI(); \n// GUI拖动条可视化改变变形目标权重系数\nconst obj = {\n    t1: 0,\n    t2: 0,\n}\ngui.add(obj, 't1', 0, 1).name('变形目标1').onChange(function (v) {\n    // 变形目标1对物体形状影响权重\n    mesh.morphTargetInfluences[0] = v;\n});\ngui.add(obj, 't2', 0, 1).name('变形目标2').onChange(function (v) {\n    // 变形目标2对物体形状影响权重\n    mesh.morphTargetInfluences[1] = v;\n});\n\n\n\n# 生成变形动画\n\n生成变形动画的方法非常简单，你只是需要通过关键帧动画，改变模型的变形权重系数即可。\n\n变形动画目标：0~5秒，物体变高，5~10秒，物体变细。\n\n// 创建变形动画权重系数的关键帧数据\nmesh.name = \"Box\";//关键帧动画控制的模型对象命名\n// 设置变形目标1对应权重随着时间的变化\nconst KF1 = new THREE.KeyframeTrack('Box.morphTargetInfluences[0]', [0, 5], [0, 1]);\n// 设置变形目标2对应权重随着时间的变化\nconst KF2 = new THREE.KeyframeTrack('Box.morphTargetInfluences[1]', [5, 10], [0, 1]);\n// 创建一个剪辑clip对象\nconst clip = new THREE.AnimationClip(\"t\", 10, [KF1, KF2]);\n\n\n播放变形模型对应的关键帧动画，你可以看到一个变形动画效果，下面代码和前面播放关键帧动画的代码一样。\n\n// 播放变形动画\nconst mixer = new THREE.AnimationMixer(mesh);\nconst clipAction = mixer.clipAction(clip);\nclipAction.play();\nclipAction.loop = THREE.LoopOnce; //不循环播放\nclipAction.clampWhenFinished = true // 物体状态停留在动画结束的时候\n\nconst clock = new THREE.Clock();\n\nfunction loop() {\n    requestAnimationFrame(loop);\n    const frameT = clock.getDelta();\n    // 更新播放器时间\n    mixer.update(frameT);\n}\nloop();\n\n\n\n# 解析外部变形动画模型\n\n项目开发，大部分情况下，不需要你代码编辑变形动画的几何体变形数据，通常是在三维建模软件中，比如Blender，编辑好变形数据，你只需要在代码中播放变形动画即可。\n\n播放外部变形动画模型，和你播放其它外部模型的关键帧动画一样，只要美术在三维软件中设置好变形的关键帧动画，你只需要播放关键帧动画即可，不同管内部的变形过程。\n\nloader.load(\"./鸟.glb\", function (gltf) { \n    model.add(gltf.scene); \n\n    //包含关键帧动画的模型作为参数创建一个播放器\n    const mixer = new THREE.AnimationMixer(gltf.scene);\n    //  获取gltf.animations[0]的第一个clip动画对象\n    const clipAction = mixer.clipAction(gltf.animations[0]);\n    clipAction.play();\n\n    const clock = new THREE.Clock();\n    function loop() {\n        requestAnimationFrame(loop);\n        const frameT = clock.getDelta();\n        // 更新播放器相关的时间\n        mixer.update(frameT);\n    }\n    loop();\n})\n\n",normalizedContent:"# 变形动画原理\n\n下面给大家介绍下变形动画的基本原理。\n\n\n# .morphattributes设置几何体变形目标顶点数据\n\nbuffergeometry属性.morphattributes的功能就是用来设置几何体变形目标顶点数据。\n\n//几何体两组顶点一一对应，位置不同，然后通过权重系数，可以控制模型形状在两组顶点之间变化\nconst geometry = new three.boxgeometry(50, 50, 50);\n// 为geometry提供变形目标的顶点数据(注意和原始geometry顶点数量一致)\nconst target1 = new three.boxgeometry(50, 200, 50).attributes.position;//变高\nconst target2 = new three.boxgeometry(10, 50, 10).attributes.position;//变细\n// 几何体顶点变形目标数据，可以设置1组或多组\ngeometry.morphattributes.position = [target1, target2];\n\nconst mesh = new three.mesh(geometry, material);\n\n\n注意：给一个几何体geometry设置顶点变形数据.morphattributes时候要注意，在执行代码new three.mesh()之前设置，否则报错。\n\n\n# .morphtargetinfluences权重系数控制变形程度\n\n查看文档，你可以看到网格模型mesh、点模型、线模型都有一个权重属性.morphtargetinfluences，该权重的作用是，控制geometry自身顶点和变形目标顶点分别对模型形状形象程度。\n\n设置变形目标影响权重，范围一般0~1。\n\nmesh在geometry原始形状和变形目标1顶点对应形状之间变化。\n\nmesh的几何体变形目标是放在一个数组.morphattributes.position中的，设置权重系数morphtargetinfluences的时候，需要设置索引值， 比如.morphtargetinfluences[0]影响的变形目标是.morphattributes.position[0]，.morphtargetinfluences[1]影响的变形目标是.morphattributes.position[1]。\n\n//权重0：物体形状对应geometry.attributes.position表示形状\nmesh.morphtargetinfluences[0] = 0.0;\n//权重1：物体形状对应target1表示形状\nmesh.morphtargetinfluences[0] = 1.0;\n//权重0.5：物体形状对应geometry和target1变形中间状态\nmesh.morphtargetinfluences[0] = 0.5;\n\n\nmesh在geometry原始形状和变形目标2顶点对应形状之间变化\n\nmesh.morphtargetinfluences[1] = 0.5;\n\n\n\n# 多个变形目标综合影响模型形状\n\n一个网格模型的几何体geometry可以有多个变形目标，只要对应权重不为0，每个变形目标的形状都会影响模型的形状。\n\n// 两个变形目标同时影响模型形状\nmesh.morphtargetinfluences[1] = 0.5;\nmesh.morphtargetinfluences[0] = 0.5;\n\n\n\n# gui控制变形权重系数.morphtargetinfluences\n\nimport {gui} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new gui(); \n// gui拖动条可视化改变变形目标权重系数\nconst obj = {\n    t1: 0,\n    t2: 0,\n}\ngui.add(obj, 't1', 0, 1).name('变形目标1').onchange(function (v) {\n    // 变形目标1对物体形状影响权重\n    mesh.morphtargetinfluences[0] = v;\n});\ngui.add(obj, 't2', 0, 1).name('变形目标2').onchange(function (v) {\n    // 变形目标2对物体形状影响权重\n    mesh.morphtargetinfluences[1] = v;\n});\n\n\n\n# 生成变形动画\n\n生成变形动画的方法非常简单，你只是需要通过关键帧动画，改变模型的变形权重系数即可。\n\n变形动画目标：0~5秒，物体变高，5~10秒，物体变细。\n\n// 创建变形动画权重系数的关键帧数据\nmesh.name = \"box\";//关键帧动画控制的模型对象命名\n// 设置变形目标1对应权重随着时间的变化\nconst kf1 = new three.keyframetrack('box.morphtargetinfluences[0]', [0, 5], [0, 1]);\n// 设置变形目标2对应权重随着时间的变化\nconst kf2 = new three.keyframetrack('box.morphtargetinfluences[1]', [5, 10], [0, 1]);\n// 创建一个剪辑clip对象\nconst clip = new three.animationclip(\"t\", 10, [kf1, kf2]);\n\n\n播放变形模型对应的关键帧动画，你可以看到一个变形动画效果，下面代码和前面播放关键帧动画的代码一样。\n\n// 播放变形动画\nconst mixer = new three.animationmixer(mesh);\nconst clipaction = mixer.clipaction(clip);\nclipaction.play();\nclipaction.loop = three.looponce; //不循环播放\nclipaction.clampwhenfinished = true // 物体状态停留在动画结束的时候\n\nconst clock = new three.clock();\n\nfunction loop() {\n    requestanimationframe(loop);\n    const framet = clock.getdelta();\n    // 更新播放器时间\n    mixer.update(framet);\n}\nloop();\n\n\n\n# 解析外部变形动画模型\n\n项目开发，大部分情况下，不需要你代码编辑变形动画的几何体变形数据，通常是在三维建模软件中，比如blender，编辑好变形数据，你只需要在代码中播放变形动画即可。\n\n播放外部变形动画模型，和你播放其它外部模型的关键帧动画一样，只要美术在三维软件中设置好变形的关键帧动画，你只需要播放关键帧动画即可，不同管内部的变形过程。\n\nloader.load(\"./鸟.glb\", function (gltf) { \n    model.add(gltf.scene); \n\n    //包含关键帧动画的模型作为参数创建一个播放器\n    const mixer = new three.animationmixer(gltf.scene);\n    //  获取gltf.animations[0]的第一个clip动画对象\n    const clipaction = mixer.clipaction(gltf.animations[0]);\n    clipaction.play();\n\n    const clock = new three.clock();\n    function loop() {\n        requestanimationframe(loop);\n        const framet = clock.getdelta();\n        // 更新播放器相关的时间\n        mixer.update(framet);\n    }\n    loop();\n})\n\n",charsets:{cjk:!0}},{title:"10. 查看外部模型骨骼动画",frontmatter:{title:"10. 查看外部模型骨骼动画",date:"2023-03-25T15:33:51.000Z",permalink:"/pages/56644a/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/10.%E6%9F%A5%E7%9C%8B%E5%A4%96%E9%83%A8%E6%A8%A1%E5%9E%8B%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB.html",relativePath:"01.Three.js教程/16.16.关键帧动画/10.查看外部模型骨骼动画.md",key:"v-4bf5cab4",path:"/pages/56644a/",headers:[{level:3,title:"骨骼动画创建",slug:"骨骼动画创建",normalizedTitle:"骨骼动画创建",charIndex:113},{level:3,title:"可视化外部模型骨骼关节",slug:"可视化外部模型骨骼关节",normalizedTitle:"可视化外部模型骨骼关节",charIndex:281},{level:3,title:"根据骨骼名称读取骨骼关节",slug:"根据骨骼名称读取骨骼关节",normalizedTitle:"根据骨骼名称读取骨骼关节",charIndex:643},{level:3,title:"代码测试骨骼关节Bone带动模型表面变化",slug:"代码测试骨骼关节bone带动模型表面变化",normalizedTitle:"代码测试骨骼关节bone带动模型表面变化",charIndex:974},{level:3,title:"GUI拖动条控制骨骼关节Bone参数变化",slug:"gui拖动条控制骨骼关节bone参数变化",normalizedTitle:"gui拖动条控制骨骼关节bone参数变化",charIndex:1119},{level:3,title:"查看骨骼网格模型SkinnedMesh",slug:"查看骨骼网格模型skinnedmesh",normalizedTitle:"查看骨骼网格模型skinnedmesh",charIndex:1404},{level:3,title:"访问骨骼网格模型的骨架SkinnedMesh.skeleton",slug:"访问骨骼网格模型的骨架skinnedmesh-skeleton",normalizedTitle:"访问骨骼网格模型的骨架skinnedmesh.skeleton",charIndex:1908},{level:3,title:"骨架的骨骼关节属性.skeleton.bones",slug:"骨架的骨骼关节属性-skeleton-bones",normalizedTitle:"骨架的骨骼关节属性.skeleton.bones",charIndex:2152},{level:3,title:"士兵练习案例(拖动条控制骨骼变化)",slug:"士兵练习案例-拖动条控制骨骼变化",normalizedTitle:"士兵练习案例(拖动条控制骨骼变化)",charIndex:2465},{level:3,title:"播放骨骼网格模型的关键帧动画",slug:"播放骨骼网格模型的关键帧动画",normalizedTitle:"播放骨骼网格模型的关键帧动画",charIndex:2522}],headersStr:"骨骼动画创建 可视化外部模型骨骼关节 根据骨骼名称读取骨骼关节 代码测试骨骼关节Bone带动模型表面变化 GUI拖动条控制骨骼关节Bone参数变化 查看骨骼网格模型SkinnedMesh 访问骨骼网格模型的骨架SkinnedMesh.skeleton 骨架的骨骼关节属性.skeleton.bones 士兵练习案例(拖动条控制骨骼变化) 播放骨骼网格模型的关键帧动画",content:"# 查看外部模型骨骼动画\n\n实际开发一般在三维建模软件中编辑骨骼动画，对于threejs而言，你只需要掌握如何通过代码获取你想要的骨骼信息即可。\n\n下面给大家演示，加载一个外部骨骼动画模型，查看骨骼结构，并播放动画。\n\n\n# 骨骼动画创建\n\n实际开发时候，比如一个人物角色模型你想实现走路、奔跑等动作，一般需要美术通过三维建模软件骨骼动画功能实现。简单说就是模型表面顶点数据跟着虚拟的骨骼关节Bone发生变化，比如一个骨骼关节Bone转动，附近的皮肤(模型顶点)跟着旋转变形。\n\n最后用关键帧动画控制骨骼关节运动，带动身体皮肤变形，就可以生成骨骼动画。\n\n\n# 可视化外部模型骨骼关节\n\n把加载的模型gltf.scene作为THREE.SkeletonHelper()参数，添加到场景中,就可以可视化gltf.scene里面骨骼网格模型包含的骨骼关节。\n\nconst loader = new GLTFLoader(); \nloader.load(\"../骨骼动画.glb\", function (gltf) {\n    console.log('控制台查看gltf对象结构', gltf);\n    model.add(gltf.scene);\n    // 骨骼辅助显示\n    const skeletonHelper = new THREE.SkeletonHelper(gltf.scene);\n    model.add(skeletonHelper); \n})\n\n\n\n# 根据骨骼名称读取骨骼关节\n\n骨骼关节Bone的父类Object3D，自然会继承父类Object3D的方法.getObjectByName()，就像普通网格模型一样可以通过节点名称获取骨骼关节对象。\n\n// 根据骨骼关节名字获取骨关节Bone  \n// 在三维软件中，骨骼关节层层展开，可以看到下面三个骨骼关节\nconst bone1 = gltf.scene.getObjectByName('Bone1'); //关节1\nconst bone2 = gltf.scene.getObjectByName('Bone2'); //关节2\nconst bone3 = gltf.scene.getObjectByName('Bone3'); //关节3\n\n\n\n# 代码测试骨骼关节Bone带动模型表面变化\n\n几个骨骼关节旋转了一定角度，你可以打开代码，观察骨骼网格模型的外形变化。\n\nbone2.rotation.x = Math.PI / 6; //关节2旋转\nbone3.rotation.x = Math.PI / 6; //关节3旋转\n\n\n\n# GUI拖动条控制骨骼关节Bone参数变化\n\nimport {GUI} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new GUI();\ngui.add(bone1.rotation, 'x', 0, Math.PI / 3).name('关节1');\ngui.add(bone2.rotation, 'x', 0, Math.PI / 3).name('关节2');\ngui.add(bone3.rotation, 'x', 0, Math.PI / 3).name('关节3');\n\n\n\n# 查看骨骼网格模型SkinnedMesh\n\n在threejs中，骨骼动画模型的外表面是用骨骼网格模型SkinnedMesh表示，SkinnedMesh表示的父类就是网格模型Mesh,SkinnedMesh和网格模型Mesh一样都是网格模型，用来表达一个物体的外表面。\n\n加载gltf模型，如果存在骨骼网格模型的话，可以通过加载返回gltf对象的场景属性.scene查看。浏览器控制层层展开gltf.scene，就可以找到SkinnedMesh的模型对象。\n\nconst loader = new GLTFLoader(); \nloader.load(\"../骨骼动画.glb\", function (gltf) {\n    console.log('控制台查看gltf对象结构', gltf);\n    model.add(gltf.scene);\n    // 根据节点名字获取某个骨骼网格模型\n    const SkinnedMesh = gltf.scene.getObjectByName('身体');\n    console.log('骨骼网格模型', SkinnedMesh);\n})\n\n\n\n# 访问骨骼网格模型的骨架SkinnedMesh.skeleton\n\nSkinnedMesh相比较Mesh区别就是，可以跟着自己的骨架.skeleton变化，比如骨架里面的骨骼关节Bone旋转,会带动附近骨骼网格模型SkinnedMesh跟着旋转。\n\n// 根据节点名字获取某个骨骼网格模型\nconst SkinnedMesh = gltf.scene.getObjectByName('身体');\nconsole.log('骨架', SkinnedMesh.skeleton);\n\n\n\n# 骨架的骨骼关节属性.skeleton.bones\n\n骨架SkinnedMesh.skeleton的关节属性.bones是一个数组包含了所有骨骼关节，你可以和三维软件中骨骼模型骨骼节点目录对照，观察关节属性.bones里面骨骼关节构成规律。\n\n在浏览器控制台，你可以看到.bones数组里面第一个关节对应了Blender中根关节，你点开该关节Bone，可以层层展开下去，查看它的子关节，查看子关节的子关节...\n\nconsole.log('骨架所有关节', SkinnedMesh.skeleton.bones);\nconsole.log('根关节', SkinnedMesh.skeleton.bones[0]);\n\n\n\n# 士兵练习案例(拖动条控制骨骼变化)\n\n你可以参考上面测试，把课件士兵骨骼动画文件，作为练习题，测试一遍。\n\n\n# 播放骨骼网格模型的关键帧动画\n\n骨骼网格模型的关键帧动画，一般都是美术在三维软件中，通过关键帧动画控制骨骼关节变化实现。换句话说，播放骨骼动画，就是前面给大家讲解过的播放关键帧动画。\n\n//包含关键帧动画的模型作为参数创建一个播放器\nconst mixer = new THREE.AnimationMixer(gltf.scene);\n// gltf.animations[0]休息\n// gltf.animations[1]跑步\n// gltf.animations[2]静止展开\n// gltf.animations[3]走路\nconst clipAction = mixer.clipAction(gltf.animations[1]);\nclipAction.play(); //播放动画\n// 如果想播放动画,需要周期性执行`mixer.update()`更新AnimationMixer时间数据\nconst clock = new THREE.Clock();\nfunction loop() {\n    requestAnimationFrame(loop);\n    //clock.getDelta()方法获得loop()两次执行时间间隔\n    const frameT = clock.getDelta();\n    // 更新播放器相关的时间\n    mixer.update(frameT);\n}\nloop();\n",normalizedContent:"# 查看外部模型骨骼动画\n\n实际开发一般在三维建模软件中编辑骨骼动画，对于threejs而言，你只需要掌握如何通过代码获取你想要的骨骼信息即可。\n\n下面给大家演示，加载一个外部骨骼动画模型，查看骨骼结构，并播放动画。\n\n\n# 骨骼动画创建\n\n实际开发时候，比如一个人物角色模型你想实现走路、奔跑等动作，一般需要美术通过三维建模软件骨骼动画功能实现。简单说就是模型表面顶点数据跟着虚拟的骨骼关节bone发生变化，比如一个骨骼关节bone转动，附近的皮肤(模型顶点)跟着旋转变形。\n\n最后用关键帧动画控制骨骼关节运动，带动身体皮肤变形，就可以生成骨骼动画。\n\n\n# 可视化外部模型骨骼关节\n\n把加载的模型gltf.scene作为three.skeletonhelper()参数，添加到场景中,就可以可视化gltf.scene里面骨骼网格模型包含的骨骼关节。\n\nconst loader = new gltfloader(); \nloader.load(\"../骨骼动画.glb\", function (gltf) {\n    console.log('控制台查看gltf对象结构', gltf);\n    model.add(gltf.scene);\n    // 骨骼辅助显示\n    const skeletonhelper = new three.skeletonhelper(gltf.scene);\n    model.add(skeletonhelper); \n})\n\n\n\n# 根据骨骼名称读取骨骼关节\n\n骨骼关节bone的父类object3d，自然会继承父类object3d的方法.getobjectbyname()，就像普通网格模型一样可以通过节点名称获取骨骼关节对象。\n\n// 根据骨骼关节名字获取骨关节bone  \n// 在三维软件中，骨骼关节层层展开，可以看到下面三个骨骼关节\nconst bone1 = gltf.scene.getobjectbyname('bone1'); //关节1\nconst bone2 = gltf.scene.getobjectbyname('bone2'); //关节2\nconst bone3 = gltf.scene.getobjectbyname('bone3'); //关节3\n\n\n\n# 代码测试骨骼关节bone带动模型表面变化\n\n几个骨骼关节旋转了一定角度，你可以打开代码，观察骨骼网格模型的外形变化。\n\nbone2.rotation.x = math.pi / 6; //关节2旋转\nbone3.rotation.x = math.pi / 6; //关节3旋转\n\n\n\n# gui拖动条控制骨骼关节bone参数变化\n\nimport {gui} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new gui();\ngui.add(bone1.rotation, 'x', 0, math.pi / 3).name('关节1');\ngui.add(bone2.rotation, 'x', 0, math.pi / 3).name('关节2');\ngui.add(bone3.rotation, 'x', 0, math.pi / 3).name('关节3');\n\n\n\n# 查看骨骼网格模型skinnedmesh\n\n在threejs中，骨骼动画模型的外表面是用骨骼网格模型skinnedmesh表示，skinnedmesh表示的父类就是网格模型mesh,skinnedmesh和网格模型mesh一样都是网格模型，用来表达一个物体的外表面。\n\n加载gltf模型，如果存在骨骼网格模型的话，可以通过加载返回gltf对象的场景属性.scene查看。浏览器控制层层展开gltf.scene，就可以找到skinnedmesh的模型对象。\n\nconst loader = new gltfloader(); \nloader.load(\"../骨骼动画.glb\", function (gltf) {\n    console.log('控制台查看gltf对象结构', gltf);\n    model.add(gltf.scene);\n    // 根据节点名字获取某个骨骼网格模型\n    const skinnedmesh = gltf.scene.getobjectbyname('身体');\n    console.log('骨骼网格模型', skinnedmesh);\n})\n\n\n\n# 访问骨骼网格模型的骨架skinnedmesh.skeleton\n\nskinnedmesh相比较mesh区别就是，可以跟着自己的骨架.skeleton变化，比如骨架里面的骨骼关节bone旋转,会带动附近骨骼网格模型skinnedmesh跟着旋转。\n\n// 根据节点名字获取某个骨骼网格模型\nconst skinnedmesh = gltf.scene.getobjectbyname('身体');\nconsole.log('骨架', skinnedmesh.skeleton);\n\n\n\n# 骨架的骨骼关节属性.skeleton.bones\n\n骨架skinnedmesh.skeleton的关节属性.bones是一个数组包含了所有骨骼关节，你可以和三维软件中骨骼模型骨骼节点目录对照，观察关节属性.bones里面骨骼关节构成规律。\n\n在浏览器控制台，你可以看到.bones数组里面第一个关节对应了blender中根关节，你点开该关节bone，可以层层展开下去，查看它的子关节，查看子关节的子关节...\n\nconsole.log('骨架所有关节', skinnedmesh.skeleton.bones);\nconsole.log('根关节', skinnedmesh.skeleton.bones[0]);\n\n\n\n# 士兵练习案例(拖动条控制骨骼变化)\n\n你可以参考上面测试，把课件士兵骨骼动画文件，作为练习题，测试一遍。\n\n\n# 播放骨骼网格模型的关键帧动画\n\n骨骼网格模型的关键帧动画，一般都是美术在三维软件中，通过关键帧动画控制骨骼关节变化实现。换句话说，播放骨骼动画，就是前面给大家讲解过的播放关键帧动画。\n\n//包含关键帧动画的模型作为参数创建一个播放器\nconst mixer = new three.animationmixer(gltf.scene);\n// gltf.animations[0]休息\n// gltf.animations[1]跑步\n// gltf.animations[2]静止展开\n// gltf.animations[3]走路\nconst clipaction = mixer.clipaction(gltf.animations[1]);\nclipaction.play(); //播放动画\n// 如果想播放动画,需要周期性执行`mixer.update()`更新animationmixer时间数据\nconst clock = new three.clock();\nfunction loop() {\n    requestanimationframe(loop);\n    //clock.getdelta()方法获得loop()两次执行时间间隔\n    const framet = clock.getdelta();\n    // 更新播放器相关的时间\n    mixer.update(framet);\n}\nloop();\n",charsets:{cjk:!0}},{title:"9. 骨骼关节Bone",frontmatter:{title:"9. 骨骼关节Bone",date:"2023-03-25T15:33:27.000Z",permalink:"/pages/870a19/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/09.%E9%AA%A8%E9%AA%BC%E5%85%B3%E8%8A%82Bone.html",relativePath:"01.Three.js教程/16.16.关键帧动画/09.骨骼关节Bone.md",key:"v-3eb105a6",path:"/pages/870a19/",headers:[{level:3,title:"骨骼关节Bone树结构",slug:"骨骼关节bone树结构",normalizedTitle:"骨骼关节bone树结构",charIndex:209},{level:3,title:"设置关节模型的位置和姿态角度",slug:"设置关节模型的位置和姿态角度",normalizedTitle:"设置关节模型的位置和姿态角度",charIndex:492},{level:3,title:"SkeletonHelper可视化骨骼关节",slug:"skeletonhelper可视化骨骼关节",normalizedTitle:"skeletonhelper可视化骨骼关节",charIndex:745},{level:3,title:"拖动条控制骨骼关节旋转",slug:"拖动条控制骨骼关节旋转",normalizedTitle:"拖动条控制骨骼关节旋转",charIndex:1174}],headersStr:"骨骼关节Bone树结构 设置关节模型的位置和姿态角度 SkeletonHelper可视化骨骼关节 拖动条控制骨骼关节旋转",content:"# 骨骼关节Bone\n\n骨骼关节Bone是threejs的一个类，你可以类似人或动物的骨骼关节，来理解骨骼关节Bone对象。\n\n骨骼关节Bone的作用就是模拟人或动物的关节运动，控制身体表面变形，来生成骨骼动画(可以查看下节课的案例)。\n\n骨骼关节Bone的父类是Object3D,自然会继承Object3D相关的属性或方法，比如位置属性position、旋转方法rotateX()、添加方法add()...\n\n\n# 骨骼关节Bone树结构\n\n人或动物实际的骨骼关节结构往往是比较复杂的，一般可以用一个层级树结构表达。\n\n你可以把骨骼关节当做一个模型对象Object3D，构建一个简单的层级模型。\n\nconst Bone1 = new THREE.Bone(); //关节1，用来作为根关节\nconst Bone2 = new THREE.Bone(); //关节2\nconst Bone3 = new THREE.Bone(); //关节3\n\n// 设置关节父子关系   多个骨头关节构成一个树结构\nBone1.add(Bone2);\nBone2.add(Bone3);\n\n\n\n# 设置关节模型的位置和姿态角度\n\n//根关节Bone1默认位置是(0,0,0)\nBone2.position.y = 60; //Bone2相对父对象Bone1位置\nBone3.position.y = 30; //Bone3相对父对象Bone2位置\n//平移Bone1，Bone2、Bone3跟着平移\nBone1.position.set(50,0,50);\n\n\n// 骨骼关节旋转\nBone1.rotateX(Math.PI / 6);\nBone2.rotateX(Math.PI / 6);\n\n\n\n# SkeletonHelper可视化骨骼关节\n\n把所有骨骼关节对象的父对象，也就是根节点骨骼Bone1，添加一个模型对象中作为子对象，然后把模型对象作为SkeletonHelper的参数，就可以看到骨骼关节的可视化效果。\n\n// 骨骼关节可以和普通网格模型一样作为其他模型子对象，添加到场景中\nconst group = new THREE.Group();\ngroup.add(Bone1);\n\n// SkeletonHelper会可视化参数模型对象所包含的所有骨骼关节\nconst skeletonHelper = new THREE.SkeletonHelper(group);\ngroup.add(skeletonHelper);\n\n\n注意SkeletonHelper的可视化效果，SkeletonHelper几个线段并不表示Bone，每个Bone你可以理解为一个虚拟关节点，SkeletonHelper几个线段是每个虚拟Bone关节点连线。\n\n\n# 拖动条控制骨骼关节旋转\n\nimport {GUI} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new GUI();\ngui.add(Bone1.rotation, 'x', 0, Math.PI / 3).name('关节1');\ngui.add(Bone2.rotation, 'x', 0, Math.PI / 3).name('关节2');\n",normalizedContent:"# 骨骼关节bone\n\n骨骼关节bone是threejs的一个类，你可以类似人或动物的骨骼关节，来理解骨骼关节bone对象。\n\n骨骼关节bone的作用就是模拟人或动物的关节运动，控制身体表面变形，来生成骨骼动画(可以查看下节课的案例)。\n\n骨骼关节bone的父类是object3d,自然会继承object3d相关的属性或方法，比如位置属性position、旋转方法rotatex()、添加方法add()...\n\n\n# 骨骼关节bone树结构\n\n人或动物实际的骨骼关节结构往往是比较复杂的，一般可以用一个层级树结构表达。\n\n你可以把骨骼关节当做一个模型对象object3d，构建一个简单的层级模型。\n\nconst bone1 = new three.bone(); //关节1，用来作为根关节\nconst bone2 = new three.bone(); //关节2\nconst bone3 = new three.bone(); //关节3\n\n// 设置关节父子关系   多个骨头关节构成一个树结构\nbone1.add(bone2);\nbone2.add(bone3);\n\n\n\n# 设置关节模型的位置和姿态角度\n\n//根关节bone1默认位置是(0,0,0)\nbone2.position.y = 60; //bone2相对父对象bone1位置\nbone3.position.y = 30; //bone3相对父对象bone2位置\n//平移bone1，bone2、bone3跟着平移\nbone1.position.set(50,0,50);\n\n\n// 骨骼关节旋转\nbone1.rotatex(math.pi / 6);\nbone2.rotatex(math.pi / 6);\n\n\n\n# skeletonhelper可视化骨骼关节\n\n把所有骨骼关节对象的父对象，也就是根节点骨骼bone1，添加一个模型对象中作为子对象，然后把模型对象作为skeletonhelper的参数，就可以看到骨骼关节的可视化效果。\n\n// 骨骼关节可以和普通网格模型一样作为其他模型子对象，添加到场景中\nconst group = new three.group();\ngroup.add(bone1);\n\n// skeletonhelper会可视化参数模型对象所包含的所有骨骼关节\nconst skeletonhelper = new three.skeletonhelper(group);\ngroup.add(skeletonhelper);\n\n\n注意skeletonhelper的可视化效果，skeletonhelper几个线段并不表示bone，每个bone你可以理解为一个虚拟关节点，skeletonhelper几个线段是每个虚拟bone关节点连线。\n\n\n# 拖动条控制骨骼关节旋转\n\nimport {gui} from 'three/addons/libs/lil-gui.module.min.js';\nconst gui = new gui();\ngui.add(bone1.rotation, 'x', 0, math.pi / 3).name('关节1');\ngui.add(bone2.rotation, 'x', 0, math.pi / 3).name('关节2');\n",charsets:{cjk:!0}},{title:"11. 骨骼动画不同动作切换",frontmatter:{title:"11. 骨骼动画不同动作切换",date:"2023-03-25T15:38:44.000Z",permalink:"/pages/f5175e/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/16.16.%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB/11.%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E4%B8%8D%E5%90%8C%E5%8A%A8%E4%BD%9C%E5%88%87%E6%8D%A2.html",relativePath:"01.Three.js教程/16.16.关键帧动画/11.骨骼动画不同动作切换.md",key:"v-6028f147",path:"/pages/f5175e/",headers:[{level:3,title:"查看人骨骼动画几组动画数据",slug:"查看人骨骼动画几组动画数据",normalizedTitle:"查看人骨骼动画几组动画数据",charIndex:82},{level:3,title:"切换动画不同动作(.play()和.stop())",slug:"切换动画不同动作-play-和-stop",normalizedTitle:"切换动画不同动作(.play()和.stop())",charIndex:443},{level:3,title:"AnimationAction的权重属性.weight",slug:"animationaction的权重属性-weight",normalizedTitle:"animationaction的权重属性.weight",charIndex:1474},{level:3,title:"切换动画不同动作(.weight )",slug:"切换动画不同动作-weight",normalizedTitle:"切换动画不同动作(.weight )",charIndex:null}],headersStr:"查看人骨骼动画几组动画数据 切换动画不同动作(.play()和.stop()) AnimationAction的权重属性.weight 切换动画不同动作(.weight )",content:"# 骨骼动画不同动作切换\n\nThree.js实际开发时候，有时候需要需要切换不同动作的动画。比如一个人从休息状态切换为跑步状态，从走路状态切换为休息状态。\n\n\n# 查看人骨骼动画几组动画数据\n\n课件中gltf模型gltf.animations包含四个关键帧动画对象AnimationClip，分别对应休息、跑步等动作。\n\nconsole.log('控制台查看gltf对象结构', gltf);\n// gltf.animations[0] Idle  休息\n// gltf.animations[1] Run   跑步\n// gltf.animations[2] TPose T形静止展开\n// gltf.animations[3] Walk  走路\nconst mixer = new THREE.AnimationMixer(gltf.scene);\nconst clipAction = mixer.clipAction(gltf.animations[3]);//走路\n\n\n\n# 切换动画不同动作(.play()和.stop())\n\n点击下面按钮切换骨骼动画的不同动作。\n\n<div id=\"Idle\" class=\"bu\">休息</div>\n<div id=\"Run\" class=\"bu\" style=\"margin-left: 10px;\">跑步</div>\n<div id=\"Walk\" class=\"bu\" style=\"margin-left: 10px;\">走路</div>\n\n\n点击按钮，按钮对应的动作对象AnimationAction，执行.play()方法开始动画执行，原来执行中的动画动作对象，执行.stop()方法终止执行。\n\nconst IdleAction = mixer.clipAction(gltf.animations[0]);\nconst RunAction = mixer.clipAction(gltf.animations[1]);\nconst WalkAction = mixer.clipAction(gltf.animations[3]);\nIdleAction.play();\nlet ActionState = IdleAction;//当前处于播放状态的动画动作对象\n// 通过UI按钮控制，切换动画运动状态\ndocument.getElementById('Idle').addEventListener('click', function () {\n    ActionState.stop();//播放状态动画终止\n    IdleAction.play();\n    ActionState = IdleAction;\n})\ndocument.getElementById('Run').addEventListener('click', function () {\n    ActionState.stop();//播放状态动画终止\n    RunAction.play();\n    ActionState = RunAction;\n})\ndocument.getElementById('Walk').addEventListener('click', function () {\n    ActionState.stop();//播放状态动画终止\n    WalkAction.play();\n    ActionState = WalkAction;\n})\n\n\n\n# AnimationAction的权重属性.weight\n\n骨骼动画的多个动画动作对象同时播放，会共同作用于人的骨骼动画。\n\nconst IdleAction = mixer.clipAction(gltf.animations[0]);\nconst RunAction = mixer.clipAction(gltf.animations[1]);\nconst WalkAction = mixer.clipAction(gltf.animations[3]);\nIdleAction.play();\nRunAction.play();\nWalkAction.play();\n\n\n动画动作对象AnimationAction的权重属性.weight可以控制动画的执行，权重为0，对应动画不影响人的动作，权重为1影响程度最大。\n\n// 跑步和走路动画对人影响程度为0，人处于休闲状态\nIdleAction.weight = 1.0;\nRunAction.weight = 0.0;\nWalkAction.weight = 0.0;\n\n\n\n# 切换动画不同动作(.weight)\n\n点击按钮切换骨骼动画的不同动作。\n\nconst mixer = new THREE.AnimationMixer(gltf.scene);\nconst IdleAction = mixer.clipAction(gltf.animations[0]);\nconst RunAction = mixer.clipAction(gltf.animations[1]);\nconst WalkAction = mixer.clipAction(gltf.animations[3]);\nIdleAction.play();\nRunAction.play();\nWalkAction.play();\n// 跑步和走路动画对人影响程度为0，人处于休闲状态\nIdleAction.weight = 1.0;\nRunAction.weight = 0.0;\nWalkAction.weight = 0.0;\nlet ActionState = IdleAction;//标记当前处于播放状态的动画动作对象\n// 通过UI按钮控制，切换动画运动状态\ndocument.getElementById('Idle').addEventListener('click', function () {\n    ActionState.weight = 0.0;//播放状态动画权重设置为0\n    IdleAction.weight = 1.0;\n    ActionState = IdleAction;\n})\ndocument.getElementById('Run').addEventListener('click', function () {\n    ActionState.weight = 0.0;//播放状态动画权重设置为0\n    RunAction.weight = 1.0;\n    ActionState = RunAction;\n})\ndocument.getElementById('Walk').addEventListener('click', function () {\n    ActionState.weight = 0.0;//播放状态动画权重设置为0\n    WalkAction.weight = 1.0;\n    ActionState = WalkAction;\n})\n",normalizedContent:"# 骨骼动画不同动作切换\n\nthree.js实际开发时候，有时候需要需要切换不同动作的动画。比如一个人从休息状态切换为跑步状态，从走路状态切换为休息状态。\n\n\n# 查看人骨骼动画几组动画数据\n\n课件中gltf模型gltf.animations包含四个关键帧动画对象animationclip，分别对应休息、跑步等动作。\n\nconsole.log('控制台查看gltf对象结构', gltf);\n// gltf.animations[0] idle  休息\n// gltf.animations[1] run   跑步\n// gltf.animations[2] tpose t形静止展开\n// gltf.animations[3] walk  走路\nconst mixer = new three.animationmixer(gltf.scene);\nconst clipaction = mixer.clipaction(gltf.animations[3]);//走路\n\n\n\n# 切换动画不同动作(.play()和.stop())\n\n点击下面按钮切换骨骼动画的不同动作。\n\n<div id=\"idle\" class=\"bu\">休息</div>\n<div id=\"run\" class=\"bu\" style=\"margin-left: 10px;\">跑步</div>\n<div id=\"walk\" class=\"bu\" style=\"margin-left: 10px;\">走路</div>\n\n\n点击按钮，按钮对应的动作对象animationaction，执行.play()方法开始动画执行，原来执行中的动画动作对象，执行.stop()方法终止执行。\n\nconst idleaction = mixer.clipaction(gltf.animations[0]);\nconst runaction = mixer.clipaction(gltf.animations[1]);\nconst walkaction = mixer.clipaction(gltf.animations[3]);\nidleaction.play();\nlet actionstate = idleaction;//当前处于播放状态的动画动作对象\n// 通过ui按钮控制，切换动画运动状态\ndocument.getelementbyid('idle').addeventlistener('click', function () {\n    actionstate.stop();//播放状态动画终止\n    idleaction.play();\n    actionstate = idleaction;\n})\ndocument.getelementbyid('run').addeventlistener('click', function () {\n    actionstate.stop();//播放状态动画终止\n    runaction.play();\n    actionstate = runaction;\n})\ndocument.getelementbyid('walk').addeventlistener('click', function () {\n    actionstate.stop();//播放状态动画终止\n    walkaction.play();\n    actionstate = walkaction;\n})\n\n\n\n# animationaction的权重属性.weight\n\n骨骼动画的多个动画动作对象同时播放，会共同作用于人的骨骼动画。\n\nconst idleaction = mixer.clipaction(gltf.animations[0]);\nconst runaction = mixer.clipaction(gltf.animations[1]);\nconst walkaction = mixer.clipaction(gltf.animations[3]);\nidleaction.play();\nrunaction.play();\nwalkaction.play();\n\n\n动画动作对象animationaction的权重属性.weight可以控制动画的执行，权重为0，对应动画不影响人的动作，权重为1影响程度最大。\n\n// 跑步和走路动画对人影响程度为0，人处于休闲状态\nidleaction.weight = 1.0;\nrunaction.weight = 0.0;\nwalkaction.weight = 0.0;\n\n\n\n# 切换动画不同动作(.weight)\n\n点击按钮切换骨骼动画的不同动作。\n\nconst mixer = new three.animationmixer(gltf.scene);\nconst idleaction = mixer.clipaction(gltf.animations[0]);\nconst runaction = mixer.clipaction(gltf.animations[1]);\nconst walkaction = mixer.clipaction(gltf.animations[3]);\nidleaction.play();\nrunaction.play();\nwalkaction.play();\n// 跑步和走路动画对人影响程度为0，人处于休闲状态\nidleaction.weight = 1.0;\nrunaction.weight = 0.0;\nwalkaction.weight = 0.0;\nlet actionstate = idleaction;//标记当前处于播放状态的动画动作对象\n// 通过ui按钮控制，切换动画运动状态\ndocument.getelementbyid('idle').addeventlistener('click', function () {\n    actionstate.weight = 0.0;//播放状态动画权重设置为0\n    idleaction.weight = 1.0;\n    actionstate = idleaction;\n})\ndocument.getelementbyid('run').addeventlistener('click', function () {\n    actionstate.weight = 0.0;//播放状态动画权重设置为0\n    runaction.weight = 1.0;\n    actionstate = runaction;\n})\ndocument.getelementbyid('walk').addeventlistener('click', function () {\n    actionstate.weight = 0.0;//播放状态动画权重设置为0\n    walkaction.weight = 1.0;\n    actionstate = walkaction;\n})\n",charsets:{cjk:!0}},{title:"1. tweenjs创建threejs动画",frontmatter:{title:"1. tweenjs创建threejs动画",date:"2023-04-04T14:49:48.000Z",permalink:"/pages/69bd16/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/17.17.%E5%8A%A8%E7%94%BB%E5%BA%93tween.js/01.tweenjs%E5%88%9B%E5%BB%BAthreejs%E5%8A%A8%E7%94%BB.html",relativePath:"01.Three.js教程/17.17.动画库tween.js/01.tweenjs创建threejs动画.md",key:"v-1d2a71f8",path:"/pages/69bd16/",headers:[{level:3,title:"npm安装",slug:"npm安装",normalizedTitle:"npm安装",charIndex:307},{level:3,title:".html引入tween.js",slug:"html引入tween-js",normalizedTitle:".html引入tween.js",charIndex:422},{level:3,title:"tweenjs基本语法",slug:"tweenjs基本语法",normalizedTitle:"tweenjs基本语法",charIndex:879},{level:3,title:"tweenjs改变threejs模型对象位置",slug:"tweenjs改变threejs模型对象位置",normalizedTitle:"tweenjs改变threejs模型对象位置",charIndex:1477},{level:3,title:"测试模型缩放动画",slug:"测试模型缩放动画",normalizedTitle:"测试模型缩放动画",charIndex:2081}],headersStr:"npm安装 .html引入tween.js tweenjs基本语法 tweenjs改变threejs模型对象位置 测试模型缩放动画",content:'# tweenjs创建threejs动画\n\nTweenJS是一个由JavaScript语言编写的补间动画库，如果需要tweenjs辅助你生成动画，对于任何前端web项目，你都可以选择tweenjs库。\n\n如果你使用three.js开发web3d项目，使用tween.js辅助three.js生成动画效果也是比较好的选择。\n\n * github地址：https://github.com/tweenjs/tween.js/\n * npm地址：https://www.npmjs.com/package/@tweenjs/tween.js\n * 官网：https://createjs.com/tweenjs\n\n\n# npm安装\n\n在工程化开发的时候可以通过npm命令行安装tween.js模块。\n\nnpm i @tweenjs/tween.js@^18\n\n\nimport TWEEN from \'@tweenjs/tween.js\';\n\n\n\n# .html引入tween.js\n\ntween.js-master文件包/dist目录下有多个js文件，如果你想script标签直接引入tween.umd.js即可。\n\n<script src="./tween.js-master/dist/tween.umd.js"><\/script>\n\n\n.html学习环境模拟开发环境中引入方式,就可以和开发环境一样书写import TWEEN from \'@tweenjs/tween.js\'。\n\n\x3c!-- type="importmap"功能：tween在html学习环境和开发环境一样写法 --\x3e\n<script type="importmap">\n    {\n\t\t"imports": {\n\t\t\t"@tweenjs/tween.js": "./tween.esm.js"\n\t\t}\n\t}\n<\/script>\n<script type="module">\n    import TWEEN from \'@tweenjs/tween.js\';\n<\/script>\n\n\n\n# tweenjs基本语法\n\ntweenjs功能从语法的角度讲，就是改变自己的参数对象。\n\nconst pos = {x: 0,y: 0};\nconst tween = new TWEEN.Tween(pos);//创建一段tween动画\n//经过2000毫秒，pos对象的x和y属性分别从零变化为100、50\ntween.to({x: 100,y: 50}, 2000);\n//tween动画开始执行\ntween.start();\n\n\n在requestAnimationFrame动画中，tween更新.update()，tween才能正常执行\n\nfunction loop() {\n    requestAnimationFrame(loop);\n}\nloop();\n\n\nfunction loop() {\n    TWEEN.update();//tween更新\n    requestAnimationFrame(loop);\n}\n\n\n浏览器控制台测试查看tweenjs是否逐渐改变pos对象的x和y属性\n\nfunction loop() {\n    TWEEN.update();\n    // 测试tweenjs是否逐渐改变pos对象的x和y属性\n    console.log(pos.x,pos.y);\n    requestAnimationFrame(loop);\n}\n\n\n\n# tweenjs改变threejs模型对象位置\n\nthree.js模型的位置mesh.position属性是一个具有.x、.y、.z属性的对象，可以直接使用tweenjs直接改变。\n\n//创建一段mesh平移的动画\nconst tween = new TWEEN.Tween(mesh.position);\n//经过2000毫秒，pos对象的x和y属性分别从零变化为100、50\ntween.to({x: 100,y: 50}, 2000);\n//tween动画开始执行\ntween.start(); \n\n\n最后不要忘记在渲染循环中更新TWEEN.update();即可。\n\n// 渲染循环\nfunction render() {\n    TWEEN.update();\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n换个语法形式书写也可以，更简洁\n\nconst tween = new TWEEN.Tween(mesh.position).to({x: 100,y: 50}, 2000).start();\n\n\nconst tween = new TWEEN.Tween(mesh.position)\n.to({x: 100,y: 50}, 2000)\n.start();\n\n\n\n# 测试模型缩放动画\n\n模型的缩放属性mesh.scale和.position属性一样是一个具有.x、.y、.z属性的对象,你也可以直接用tweenjs动画控制。\n\nnew TWEEN.Tween(mesh.scale).to({\n    x: 100,\n    y: 50\n}, 2000).start();\n',normalizedContent:'# tweenjs创建threejs动画\n\ntweenjs是一个由javascript语言编写的补间动画库，如果需要tweenjs辅助你生成动画，对于任何前端web项目，你都可以选择tweenjs库。\n\n如果你使用three.js开发web3d项目，使用tween.js辅助three.js生成动画效果也是比较好的选择。\n\n * github地址：https://github.com/tweenjs/tween.js/\n * npm地址：https://www.npmjs.com/package/@tweenjs/tween.js\n * 官网：https://createjs.com/tweenjs\n\n\n# npm安装\n\n在工程化开发的时候可以通过npm命令行安装tween.js模块。\n\nnpm i @tweenjs/tween.js@^18\n\n\nimport tween from \'@tweenjs/tween.js\';\n\n\n\n# .html引入tween.js\n\ntween.js-master文件包/dist目录下有多个js文件，如果你想script标签直接引入tween.umd.js即可。\n\n<script src="./tween.js-master/dist/tween.umd.js"><\/script>\n\n\n.html学习环境模拟开发环境中引入方式,就可以和开发环境一样书写import tween from \'@tweenjs/tween.js\'。\n\n\x3c!-- type="importmap"功能：tween在html学习环境和开发环境一样写法 --\x3e\n<script type="importmap">\n    {\n\t\t"imports": {\n\t\t\t"@tweenjs/tween.js": "./tween.esm.js"\n\t\t}\n\t}\n<\/script>\n<script type="module">\n    import tween from \'@tweenjs/tween.js\';\n<\/script>\n\n\n\n# tweenjs基本语法\n\ntweenjs功能从语法的角度讲，就是改变自己的参数对象。\n\nconst pos = {x: 0,y: 0};\nconst tween = new tween.tween(pos);//创建一段tween动画\n//经过2000毫秒，pos对象的x和y属性分别从零变化为100、50\ntween.to({x: 100,y: 50}, 2000);\n//tween动画开始执行\ntween.start();\n\n\n在requestanimationframe动画中，tween更新.update()，tween才能正常执行\n\nfunction loop() {\n    requestanimationframe(loop);\n}\nloop();\n\n\nfunction loop() {\n    tween.update();//tween更新\n    requestanimationframe(loop);\n}\n\n\n浏览器控制台测试查看tweenjs是否逐渐改变pos对象的x和y属性\n\nfunction loop() {\n    tween.update();\n    // 测试tweenjs是否逐渐改变pos对象的x和y属性\n    console.log(pos.x,pos.y);\n    requestanimationframe(loop);\n}\n\n\n\n# tweenjs改变threejs模型对象位置\n\nthree.js模型的位置mesh.position属性是一个具有.x、.y、.z属性的对象，可以直接使用tweenjs直接改变。\n\n//创建一段mesh平移的动画\nconst tween = new tween.tween(mesh.position);\n//经过2000毫秒，pos对象的x和y属性分别从零变化为100、50\ntween.to({x: 100,y: 50}, 2000);\n//tween动画开始执行\ntween.start(); \n\n\n最后不要忘记在渲染循环中更新tween.update();即可。\n\n// 渲染循环\nfunction render() {\n    tween.update();\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n换个语法形式书写也可以，更简洁\n\nconst tween = new tween.tween(mesh.position).to({x: 100,y: 50}, 2000).start();\n\n\nconst tween = new tween.tween(mesh.position)\n.to({x: 100,y: 50}, 2000)\n.start();\n\n\n\n# 测试模型缩放动画\n\n模型的缩放属性mesh.scale和.position属性一样是一个具有.x、.y、.z属性的对象,你也可以直接用tweenjs动画控制。\n\nnew tween.tween(mesh.scale).to({\n    x: 100,\n    y: 50\n}, 2000).start();\n',charsets:{cjk:!0}},{title:"2. tweenjs相机运动动画",frontmatter:{title:"2. tweenjs相机运动动画",date:"2023-04-25T11:58:50.000Z",permalink:"/pages/406def/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/17.17.%E5%8A%A8%E7%94%BB%E5%BA%93tween.js/02.tweenjs%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8%E5%8A%A8%E7%94%BB.html",relativePath:"01.Three.js教程/17.17.动画库tween.js/02.tweenjs相机运动动画.md",key:"v-b55eba40",path:"/pages/406def/",headers:[{level:3,title:"相机飞行动画(从一个点飞到另一个点)",slug:"相机飞行动画-从一个点飞到另一个点",normalizedTitle:"相机飞行动画(从一个点飞到另一个点)",charIndex:96},{level:3,title:"相机飞行过程中重新计算相机视线",slug:"相机飞行过程中重新计算相机视线",normalizedTitle:"相机飞行过程中重新计算相机视线",charIndex:480},{level:3,title:"Tweenjs回调函数",slug:"tweenjs回调函数",normalizedTitle:"tweenjs回调函数",charIndex:800},{level:3,title:"相机圆周运动，且保持相机镜头对准坐标原点",slug:"相机圆周运动-且保持相机镜头对准坐标原点",normalizedTitle:"相机圆周运动，且保持相机镜头对准坐标原点",charIndex:1132}],headersStr:"相机飞行动画(从一个点飞到另一个点) 相机飞行过程中重新计算相机视线 Tweenjs回调函数 相机圆周运动，且保持相机镜头对准坐标原点",content:"# tweenjs相机运动动画\n\n下面给大家讲解如何通过tweenjs实现threejs相机动画，具体说就是使用tweenjs改变相机的位置camera.position和视线方向。\n\n\n# 相机飞行动画(从一个点飞到另一个点)\n\n引入tweenjs，并在requestAnimationFrame动画中执行TWEEN.update();更新。\n\nimport TWEEN from '@tweenjs/tween.js';\n// 渲染循环\nfunction render() {\n    TWEEN.update();\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n相机动画:从一个点移动到另一个点\n\ncamera.position.set(202, 123, 125);\nnew TWEEN.Tween(camera.position)\n.to({x: 202,y: 123,z: 50}, 3000)\n.start()\n\n\n\n# 相机飞行过程中重新计算相机视线\n\n只改变相机位置，相机默认视线方向保持不变，如果你想重新计算相机视线方向，可以在相机位置改变的过程中不停地执行lookAt()即可。\n\ncamera.position.set(202, 123, 125);\ncamera.lookAt(0, 0, 0);\nnew TWEEN.Tween(camera.position)\n.to({x: 202,y: 123,z: -350}, 3000)\n// tweenjs改变参数对象的过程中，.onUpdate方法会被重复调用执行\n.onUpdate(function(){\n    camera.lookAt(0, 0, 0);\n})\n.start()\n\n\n\n# Tweenjs回调函数\n\ntwwenjs库提供了onStart、onUpdate、onComplete等用于控制动画执行的回调函数。\n\n * onStart：动画开始执行触发\n * onUpdate：动画执行过程中，一直被调用执行\n * onComplete：动画正常执行完触发\n\n.onUpdate(function(obj){})结构中，obj对应的是new TWEEN.Tween(pos)的参数对象pos。\n\nconst tween = new TWEEN.Tween(pos).to({x: 0}, 4000)\n// 开始执行：动画片段tween开始执行的时候触发onStart\n.onStart(function(obj){\n\t...\n})\n\n\n\n# 相机圆周运动，且保持相机镜头对准坐标原点\n\nconst R = 100; //相机圆周运动的半径\nnew TWEEN.Tween({angle:0})\n.to({angle: Math.PI*2}, 16000)\n.onUpdate(function(obj){\n    camera.position.x = R * Math.cos(obj.angle);\n    camera.position.z = R * Math.sin(obj.angle);\n    camera.lookAt(0, 0, 0);\n})\n.start()\n",normalizedContent:"# tweenjs相机运动动画\n\n下面给大家讲解如何通过tweenjs实现threejs相机动画，具体说就是使用tweenjs改变相机的位置camera.position和视线方向。\n\n\n# 相机飞行动画(从一个点飞到另一个点)\n\n引入tweenjs，并在requestanimationframe动画中执行tween.update();更新。\n\nimport tween from '@tweenjs/tween.js';\n// 渲染循环\nfunction render() {\n    tween.update();\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n相机动画:从一个点移动到另一个点\n\ncamera.position.set(202, 123, 125);\nnew tween.tween(camera.position)\n.to({x: 202,y: 123,z: 50}, 3000)\n.start()\n\n\n\n# 相机飞行过程中重新计算相机视线\n\n只改变相机位置，相机默认视线方向保持不变，如果你想重新计算相机视线方向，可以在相机位置改变的过程中不停地执行lookat()即可。\n\ncamera.position.set(202, 123, 125);\ncamera.lookat(0, 0, 0);\nnew tween.tween(camera.position)\n.to({x: 202,y: 123,z: -350}, 3000)\n// tweenjs改变参数对象的过程中，.onupdate方法会被重复调用执行\n.onupdate(function(){\n    camera.lookat(0, 0, 0);\n})\n.start()\n\n\n\n# tweenjs回调函数\n\ntwwenjs库提供了onstart、onupdate、oncomplete等用于控制动画执行的回调函数。\n\n * onstart：动画开始执行触发\n * onupdate：动画执行过程中，一直被调用执行\n * oncomplete：动画正常执行完触发\n\n.onupdate(function(obj){})结构中，obj对应的是new tween.tween(pos)的参数对象pos。\n\nconst tween = new tween.tween(pos).to({x: 0}, 4000)\n// 开始执行：动画片段tween开始执行的时候触发onstart\n.onstart(function(obj){\n\t...\n})\n\n\n\n# 相机圆周运动，且保持相机镜头对准坐标原点\n\nconst r = 100; //相机圆周运动的半径\nnew tween.tween({angle:0})\n.to({angle: math.pi*2}, 16000)\n.onupdate(function(obj){\n    camera.position.x = r * math.cos(obj.angle);\n    camera.position.z = r * math.sin(obj.angle);\n    camera.lookat(0, 0, 0);\n})\n.start()\n",charsets:{cjk:!0}},{title:"3. 点按钮,相机飞行靠近观察设备",frontmatter:{title:"3. 点按钮,相机飞行靠近观察设备",date:"2023-04-25T11:58:58.000Z",permalink:"/pages/c0b87e/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/17.17.%E5%8A%A8%E7%94%BB%E5%BA%93tween.js/03.%E7%82%B9%E6%8C%89%E9%92%AE,%E7%9B%B8%E6%9C%BA%E9%A3%9E%E8%A1%8C%E9%9D%A0%E8%BF%91%E8%A7%82%E5%AF%9F%E8%AE%BE%E5%A4%87.html",relativePath:"01.Three.js教程/17.17.动画库tween.js/03.点按钮,相机飞行靠近观察设备.md",key:"v-4e113527",path:"/pages/c0b87e/",headers:[{level:3,title:"按钮",slug:"按钮",normalizedTitle:"按钮",charIndex:3},{level:3,title:"点击按钮A，相机运动到设备A附近",slug:"点击按钮a-相机运动到设备a附近",normalizedTitle:"点击按钮a，相机运动到设备a附近",charIndex:395},{level:3,title:"考虑OrbitControls的影响",slug:"考虑orbitcontrols的影响",normalizedTitle:"考虑orbitcontrols的影响",charIndex:2015},{level:3,title:"封装一个相机动画函数",slug:"封装一个相机动画函数",normalizedTitle:"封装一个相机动画函数",charIndex:2857}],headersStr:"按钮 点击按钮A，相机运动到设备A附近 考虑OrbitControls的影响 封装一个相机动画函数",content:"# 点按钮,相机飞行靠近观察设备\n\n继续上节课相机动画的讲解。\n\n实际开发的的时候，一个较大的三维场景，有很多不同的设备或物品，你可能希望通过UI按钮点击切换到不同视角，观察某个区域，或者说放大观察某个特定的物品或设备。\n\n\n# 按钮\n\n切换相机位置和视角的按钮\n\n<div class=\"pos\">\n    <div id=\"A\" class=\"bu\">设备A</div>\n    <div id=\"B\" class=\"bu\" style=\"margin-left: 10px;\">设备B</div>\n    <div id=\"car\" class=\"bu\" style=\"margin-left: 10px;\">停车场</div>\n    <div id=\"all\" class=\"bu\" style=\"margin-left: 10px;\">整体</div>\n</div>\n\n\n\n# 点击按钮A，相机运动到设备A附近\n\n点击按钮A，相机运动到工厂中设备A附近，同时把相机观察目标，逐渐切换到设备A\n\nimport TWEEN from '@tweenjs/tween.js';\nfunction render() {\n    TWEEN.update();\n    requestAnimationFrame(render);\n}\nrender();\n\n\n如果你希望相机移动到场景中某个位置附近，可以在Blender三维建模中，创建一个空对象进行标注，本节课模型用的是原来标注标签的空对象。当然你也可以直接读取某个模型的世界坐标。\n\n获取某个对象世界坐标，作为相机lookAt指向的新目标观察点。\n\nconst A = model.getObjectByName('设备A标注');\nconst pos = new THREE.Vector3();\n//获取三维场景中某个对象世界坐标\nA.getWorldPosition(pos);\n\n\n相机位置相对目标观察点，适当偏移，希望观察的范围大，就距离远一点，希望观察的设备显示效果大，就距离设备近一点。\n\n// 向量的x、y、z坐标分别在pos基础上增加30\nconst pos2 = pos.clone().addScalar(30);\n\n\n相机的位置逐渐改变，相机的观察目标也逐渐改变。\n\n// 切换到设备A预览状态\ndocument.getElementById('A').addEventListener('click', function () {\n    const A = model.getObjectByName('设备A标注');\n    const pos = new THREE.Vector3();\n    A.getWorldPosition(pos); //获取三维场景中某个对象世界坐标\n    // 相机飞行到的位置和观察目标拉开一定的距离\n    const pos2 = pos.clone().addScalar(30);//向量的x、y、z坐标分别在pos基础上增加30\n    // 相机从当前位置camera.position飞行三维场景中某个世界坐标附近\n    new TWEEN.Tween({\n            // 相机开始坐标\n            x: camera.position.x,\n            y: camera.position.y,\n            z: camera.position.z,\n            // 相机开始指向的目标观察点\n            tx: 0,\n            ty: 0,\n            tz: 0,\n        })\n        .to({\n            // 相机结束坐标\n            x: pos2.x,\n            y: pos2.y,\n            z: pos2.z,\n            // 相机结束指向的目标观察点\n            tx: pos.x,\n            ty: pos.y,\n            tz: pos.z,\n        }, 2000)\n        .onUpdate(function (obj) {\n            // 动态改变相机位置\n            camera.position.set(obj.x, obj.y, obj.z);\n            // 动态计算相机视线\n            camera.lookAt(obj.tx, obj.ty, obj.tz);\n        })\n        .start();\n})\n\n\n\n# 考虑OrbitControls的影响\n\n学下下面内容可以参考前面：6.4. OrbitControls辅助设置相机参数\n\n如果你在项目中使用了相机控件OrbitControls，希望相机looAt()指向的目标改变以后，该相机控件让然可以正常使用。需要在动画结束.onComplete()的时候重新设置controls.target，或者.onUpdate()更新controls.target。\n\n.onUpdate(function (obj) {\n    ...\n    camera.lookAt(obj.tx, obj.ty, obj.tz);\n})\n.onComplete(function(obj){\n    controls.target.set(obj.tx, obj.ty, obj.tz);\n    controls.update();\n})\n\n\n或者.onUpdate()中，设置controls.target，并执行controls.update()，OrbitControls相机控件内部也会执行相机的.looAt()方法，完整相机视线重新计算，这样就不用执行camera.lookAt(obj.tx, obj.ty, obj.tz)。\n\n实际开发，相机目标观察点初始状态，不一定就是坐标原点，再设置动画初始目标观察点的时候，可以直接访问controls.target的x、y、z属性获取。\n\n.onUpdate(function (obj) {\n    // 动态改变相机位置\n    camera.position.set(obj.x, obj.y, obj.z);\n    // 动态计算相机视线\n    // camera.lookAt(obj.tx, obj.ty, obj.tz);\n    controls.target.set(obj.tx, obj.ty, obj.tz);\n    controls.update();\n})\n\n\n\n# 封装一个相机动画函数\n\n这样所有的按钮点击后，都可以调用该函数。\n\n动画开始的相机位置和目标观察点，不要手写具体数字，通过相机对象camera.position和相机控件对象读取controls.target，这样不管你点击那个按钮，动画开始状态都是上次相机动画结束的状态。\n\n// 相机动画函数，从A点飞行到B点，A点表示相机当前所处状态\n// pos: 三维向量Vector3，表示动画结束相机位置\n// target: 三维向量Vector3，表示相机动画结束lookAt指向的目标观察点\nfunction createCameraTween(endPos,endTarget){\n    new TWEEN.Tween({\n        // 不管相机此刻处于什么状态，直接读取当前的位置和目标观察点\n        x: camera.position.x,\n        y: camera.position.y,\n        z: camera.position.z,\n        tx: controls.target.x,\n        ty: controls.target.y,\n        tz: controls.target.z,\n    })\n    .to({\n        // 动画结束相机位置坐标\n        x: endPos.x,\n        y: endPos.y,\n        z: endPos.z,\n        // 动画结束相机指向的目标观察点\n        tx: endTarget.x,\n        ty: endTarget.y,\n        tz: endTarget.z,\n    }, 2000)\n    .onUpdate(function (obj) {\n        // 动态改变相机位置\n        camera.position.set(obj.x, obj.y, obj.z);\n        // 动态计算相机视线\n        // camera.lookAt(obj.tx, obj.ty, obj.tz);\n        controls.target.set(obj.tx, obj.ty, obj.tz);\n        controls.update();//内部会执行.lookAt()\n    })\n    .start();\n}\n\n\n设置设备A、设备B、停车场、整体预览四个按钮对应的相机动画，这样你可以在4个按钮之间，随意切换相机的观察状态。\n\n// 切换到设备A预览状态\ndocument.getElementById('A').addEventListener('click', function () {\n    const A = model.getObjectByName('设备A标注');\n    const pos = new THREE.Vector3();\n    A.getWorldPosition(pos); //获取三维场景中某个对象世界坐标\n    // 相机飞行到的位置和观察目标拉开一定的距离\n    const pos2 = pos.clone().addScalar(30);\n    createCameraTween(pos2, controls.target)\n})\n// 切换到设备B的预览状态\ndocument.getElementById('B').addEventListener('click', function () {\n    const B = model.getObjectByName('设备B标注');\n    const pos = new THREE.Vector3();\n    B.getWorldPosition(pos); //获取三维场景中某个对象世界坐标\n    // 相机飞行到的位置和观察目标拉开一定的距离\n    const pos2 = pos.clone().addScalar(30);\n    // 相机从当前位置camera.position飞行三维场景中某个世界坐标附近\n    createCameraTween(pos2, controls.target)\n})\n\n// 切换到设备停车场的预览状态\ndocument.getElementById('car').addEventListener('click', function () {\n    const car = model.getObjectByName('停车场标注');\n    const pos = new THREE.Vector3();\n    car.getWorldPosition(pos); //获取三维场景中某个对象世界坐标\n    // 相机飞行到的位置和观察目标拉开一定的距离\n    const pos2 = pos.clone().addScalar(30);\n    // 相机从当前位置camera.position飞行三维场景中某个世界坐标附近\n    createCameraTween(pos2, pos)\n})\n\n// 相机整体预览对应的位置和观察目标\nconst cameraPos0 = new THREE.Vector3(202, 123, 125) \nconst target0 = new THREE.Vector3(0, 0, 0);\n// 切换整体预览状态\ndocument.getElementById('all').addEventListener('click', function () {\n    // 相机从当前位置camera.position回到整体预览状态\n    createCameraTween(cameraPos0, target0)\n})\n",normalizedContent:"# 点按钮,相机飞行靠近观察设备\n\n继续上节课相机动画的讲解。\n\n实际开发的的时候，一个较大的三维场景，有很多不同的设备或物品，你可能希望通过ui按钮点击切换到不同视角，观察某个区域，或者说放大观察某个特定的物品或设备。\n\n\n# 按钮\n\n切换相机位置和视角的按钮\n\n<div class=\"pos\">\n    <div id=\"a\" class=\"bu\">设备a</div>\n    <div id=\"b\" class=\"bu\" style=\"margin-left: 10px;\">设备b</div>\n    <div id=\"car\" class=\"bu\" style=\"margin-left: 10px;\">停车场</div>\n    <div id=\"all\" class=\"bu\" style=\"margin-left: 10px;\">整体</div>\n</div>\n\n\n\n# 点击按钮a，相机运动到设备a附近\n\n点击按钮a，相机运动到工厂中设备a附近，同时把相机观察目标，逐渐切换到设备a\n\nimport tween from '@tweenjs/tween.js';\nfunction render() {\n    tween.update();\n    requestanimationframe(render);\n}\nrender();\n\n\n如果你希望相机移动到场景中某个位置附近，可以在blender三维建模中，创建一个空对象进行标注，本节课模型用的是原来标注标签的空对象。当然你也可以直接读取某个模型的世界坐标。\n\n获取某个对象世界坐标，作为相机lookat指向的新目标观察点。\n\nconst a = model.getobjectbyname('设备a标注');\nconst pos = new three.vector3();\n//获取三维场景中某个对象世界坐标\na.getworldposition(pos);\n\n\n相机位置相对目标观察点，适当偏移，希望观察的范围大，就距离远一点，希望观察的设备显示效果大，就距离设备近一点。\n\n// 向量的x、y、z坐标分别在pos基础上增加30\nconst pos2 = pos.clone().addscalar(30);\n\n\n相机的位置逐渐改变，相机的观察目标也逐渐改变。\n\n// 切换到设备a预览状态\ndocument.getelementbyid('a').addeventlistener('click', function () {\n    const a = model.getobjectbyname('设备a标注');\n    const pos = new three.vector3();\n    a.getworldposition(pos); //获取三维场景中某个对象世界坐标\n    // 相机飞行到的位置和观察目标拉开一定的距离\n    const pos2 = pos.clone().addscalar(30);//向量的x、y、z坐标分别在pos基础上增加30\n    // 相机从当前位置camera.position飞行三维场景中某个世界坐标附近\n    new tween.tween({\n            // 相机开始坐标\n            x: camera.position.x,\n            y: camera.position.y,\n            z: camera.position.z,\n            // 相机开始指向的目标观察点\n            tx: 0,\n            ty: 0,\n            tz: 0,\n        })\n        .to({\n            // 相机结束坐标\n            x: pos2.x,\n            y: pos2.y,\n            z: pos2.z,\n            // 相机结束指向的目标观察点\n            tx: pos.x,\n            ty: pos.y,\n            tz: pos.z,\n        }, 2000)\n        .onupdate(function (obj) {\n            // 动态改变相机位置\n            camera.position.set(obj.x, obj.y, obj.z);\n            // 动态计算相机视线\n            camera.lookat(obj.tx, obj.ty, obj.tz);\n        })\n        .start();\n})\n\n\n\n# 考虑orbitcontrols的影响\n\n学下下面内容可以参考前面：6.4. orbitcontrols辅助设置相机参数\n\n如果你在项目中使用了相机控件orbitcontrols，希望相机looat()指向的目标改变以后，该相机控件让然可以正常使用。需要在动画结束.oncomplete()的时候重新设置controls.target，或者.onupdate()更新controls.target。\n\n.onupdate(function (obj) {\n    ...\n    camera.lookat(obj.tx, obj.ty, obj.tz);\n})\n.oncomplete(function(obj){\n    controls.target.set(obj.tx, obj.ty, obj.tz);\n    controls.update();\n})\n\n\n或者.onupdate()中，设置controls.target，并执行controls.update()，orbitcontrols相机控件内部也会执行相机的.looat()方法，完整相机视线重新计算，这样就不用执行camera.lookat(obj.tx, obj.ty, obj.tz)。\n\n实际开发，相机目标观察点初始状态，不一定就是坐标原点，再设置动画初始目标观察点的时候，可以直接访问controls.target的x、y、z属性获取。\n\n.onupdate(function (obj) {\n    // 动态改变相机位置\n    camera.position.set(obj.x, obj.y, obj.z);\n    // 动态计算相机视线\n    // camera.lookat(obj.tx, obj.ty, obj.tz);\n    controls.target.set(obj.tx, obj.ty, obj.tz);\n    controls.update();\n})\n\n\n\n# 封装一个相机动画函数\n\n这样所有的按钮点击后，都可以调用该函数。\n\n动画开始的相机位置和目标观察点，不要手写具体数字，通过相机对象camera.position和相机控件对象读取controls.target，这样不管你点击那个按钮，动画开始状态都是上次相机动画结束的状态。\n\n// 相机动画函数，从a点飞行到b点，a点表示相机当前所处状态\n// pos: 三维向量vector3，表示动画结束相机位置\n// target: 三维向量vector3，表示相机动画结束lookat指向的目标观察点\nfunction createcameratween(endpos,endtarget){\n    new tween.tween({\n        // 不管相机此刻处于什么状态，直接读取当前的位置和目标观察点\n        x: camera.position.x,\n        y: camera.position.y,\n        z: camera.position.z,\n        tx: controls.target.x,\n        ty: controls.target.y,\n        tz: controls.target.z,\n    })\n    .to({\n        // 动画结束相机位置坐标\n        x: endpos.x,\n        y: endpos.y,\n        z: endpos.z,\n        // 动画结束相机指向的目标观察点\n        tx: endtarget.x,\n        ty: endtarget.y,\n        tz: endtarget.z,\n    }, 2000)\n    .onupdate(function (obj) {\n        // 动态改变相机位置\n        camera.position.set(obj.x, obj.y, obj.z);\n        // 动态计算相机视线\n        // camera.lookat(obj.tx, obj.ty, obj.tz);\n        controls.target.set(obj.tx, obj.ty, obj.tz);\n        controls.update();//内部会执行.lookat()\n    })\n    .start();\n}\n\n\n设置设备a、设备b、停车场、整体预览四个按钮对应的相机动画，这样你可以在4个按钮之间，随意切换相机的观察状态。\n\n// 切换到设备a预览状态\ndocument.getelementbyid('a').addeventlistener('click', function () {\n    const a = model.getobjectbyname('设备a标注');\n    const pos = new three.vector3();\n    a.getworldposition(pos); //获取三维场景中某个对象世界坐标\n    // 相机飞行到的位置和观察目标拉开一定的距离\n    const pos2 = pos.clone().addscalar(30);\n    createcameratween(pos2, controls.target)\n})\n// 切换到设备b的预览状态\ndocument.getelementbyid('b').addeventlistener('click', function () {\n    const b = model.getobjectbyname('设备b标注');\n    const pos = new three.vector3();\n    b.getworldposition(pos); //获取三维场景中某个对象世界坐标\n    // 相机飞行到的位置和观察目标拉开一定的距离\n    const pos2 = pos.clone().addscalar(30);\n    // 相机从当前位置camera.position飞行三维场景中某个世界坐标附近\n    createcameratween(pos2, controls.target)\n})\n\n// 切换到设备停车场的预览状态\ndocument.getelementbyid('car').addeventlistener('click', function () {\n    const car = model.getobjectbyname('停车场标注');\n    const pos = new three.vector3();\n    car.getworldposition(pos); //获取三维场景中某个对象世界坐标\n    // 相机飞行到的位置和观察目标拉开一定的距离\n    const pos2 = pos.clone().addscalar(30);\n    // 相机从当前位置camera.position飞行三维场景中某个世界坐标附近\n    createcameratween(pos2, pos)\n})\n\n// 相机整体预览对应的位置和观察目标\nconst camerapos0 = new three.vector3(202, 123, 125) \nconst target0 = new three.vector3(0, 0, 0);\n// 切换整体预览状态\ndocument.getelementbyid('all').addeventlistener('click', function () {\n    // 相机从当前位置camera.position回到整体预览状态\n    createcameratween(camerapos0, target0)\n})\n",charsets:{cjk:!0}},{title:"4. 点击设备,相机靠近放大预览",frontmatter:{title:"4. 点击设备,相机靠近放大预览",date:"2023-04-25T11:59:13.000Z",permalink:"/pages/f2273c/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/17.17.%E5%8A%A8%E7%94%BB%E5%BA%93tween.js/04.%E7%82%B9%E5%87%BB%E8%AE%BE%E5%A4%87,%E7%9B%B8%E6%9C%BA%E9%9D%A0%E8%BF%91%E6%94%BE%E5%A4%A7%E9%A2%84%E8%A7%88.html",relativePath:"01.Three.js教程/17.17.动画库tween.js/04.点击设备,相机靠近放大预览.md",key:"v-0ab7f00c",path:"/pages/f2273c/",headers:[{level:3,title:"点击选中设备，相机飞行靠近",slug:"点击选中设备-相机飞行靠近",normalizedTitle:"点击选中设备，相机飞行靠近",charIndex:182},{level:3,title:"关闭设备标签，相机回到整体预览状态",slug:"关闭设备标签-相机回到整体预览状态",normalizedTitle:"关闭设备标签，相机回到整体预览状态",charIndex:778}],headersStr:"点击选中设备，相机飞行靠近 关闭设备标签，相机回到整体预览状态",content:"# 点击设备,相机靠近放大预览\n\n本节课内容，其实和上节课的“3.点按钮,相机飞行靠近观察设备”基本相似，你可以当做练习题。\n\n具体交互效果就是鼠标点击选中某个设备，相机靠近该设备，特别关注，设备在屏幕上呈现放大显示的效果。\n\n下面在前面课程射线拾取模型弹出标签的代码基础上给大家讲解。演示文件已经提前引入tweenjs动画库和上节课封装的相机动画代码。\n\n\n# 点击选中设备，相机飞行靠近\n\nchooseObj是鼠标单击射线拾取的模型对象,你可以获取该模型对象世界坐标对应的某个空对象位置，生成相机动画。\n\nchooseObj是鼠标单击射线拾取的模型对象,你可以获取该模型对象世界坐标，生成相机动画。不过有一点要注意在Blender中，你要设置好选中设备的局部坐标系，确保局部坐标系，在设备上某个位置，比如居中，比如顶部，根据需要自定义设置，不过不要偏差太大，比如设备的局部坐标系与设备本身距离很远。\n\nconst pos = new THREE.Vector3();\nchooseObj.getWorldPosition(pos); //获取三维场景中某个对象世界坐标\n\n\n通过一个空对象来掌控相机动画的观察目标。\n\nconst pos = new THREE.Vector3();\n//获取三维场景中某个对象世界坐标\nmodel.getObjectByName(chooseObj.name+'标注').getWorldPosition(pos); \n\n\n生成相机动画\n\n// 相机飞行到的位置和观察目标拉开一定的距离\nconst pos2 = pos.clone().addScalar(30);\n// 相机从当前位置camera.position飞行三维场景中某个世界坐标附近\ncreateCameraTween(pos2, pos)\n\n\n\n# 关闭设备标签，相机回到整体预览状态\n\n原来标签关闭按钮代码\n\n// 鼠标单击按钮，关闭HTML标签\ndocument.getElementById('close').addEventListener('click', function () {\n    if (chooseObj) { //把原来选中模型对应的标签和发光描边隐藏\n        outlinePass.selectedObjects = []; //无发光描边\n        chooseObj.remove(tag); //从场景移除\n    }\n})\n\n\n关闭设备标签，相机回到整体预览状态\n\n// 相机整体预览对应的位置和观察目标\nconst cameraPos0 = new THREE.Vector3(202, 123, 125)\nconst target0 = new THREE.Vector3(0, 0, 0);\n// 鼠标单击按钮，关闭HTML标签\ndocument.getElementById('close').addEventListener('click', function () {\n    if (chooseObj) { //把原来选中模型对应的标签和发光描边隐藏\n        outlinePass.selectedObjects = []; //无发光描边\n        chooseObj.remove(tag); //从场景移除\n        // 相机从当前位置camera.position回到整体预览状态\n        createCameraTween(cameraPos0, target0)\n    }\n})\n",normalizedContent:"# 点击设备,相机靠近放大预览\n\n本节课内容，其实和上节课的“3.点按钮,相机飞行靠近观察设备”基本相似，你可以当做练习题。\n\n具体交互效果就是鼠标点击选中某个设备，相机靠近该设备，特别关注，设备在屏幕上呈现放大显示的效果。\n\n下面在前面课程射线拾取模型弹出标签的代码基础上给大家讲解。演示文件已经提前引入tweenjs动画库和上节课封装的相机动画代码。\n\n\n# 点击选中设备，相机飞行靠近\n\nchooseobj是鼠标单击射线拾取的模型对象,你可以获取该模型对象世界坐标对应的某个空对象位置，生成相机动画。\n\nchooseobj是鼠标单击射线拾取的模型对象,你可以获取该模型对象世界坐标，生成相机动画。不过有一点要注意在blender中，你要设置好选中设备的局部坐标系，确保局部坐标系，在设备上某个位置，比如居中，比如顶部，根据需要自定义设置，不过不要偏差太大，比如设备的局部坐标系与设备本身距离很远。\n\nconst pos = new three.vector3();\nchooseobj.getworldposition(pos); //获取三维场景中某个对象世界坐标\n\n\n通过一个空对象来掌控相机动画的观察目标。\n\nconst pos = new three.vector3();\n//获取三维场景中某个对象世界坐标\nmodel.getobjectbyname(chooseobj.name+'标注').getworldposition(pos); \n\n\n生成相机动画\n\n// 相机飞行到的位置和观察目标拉开一定的距离\nconst pos2 = pos.clone().addscalar(30);\n// 相机从当前位置camera.position飞行三维场景中某个世界坐标附近\ncreatecameratween(pos2, pos)\n\n\n\n# 关闭设备标签，相机回到整体预览状态\n\n原来标签关闭按钮代码\n\n// 鼠标单击按钮，关闭html标签\ndocument.getelementbyid('close').addeventlistener('click', function () {\n    if (chooseobj) { //把原来选中模型对应的标签和发光描边隐藏\n        outlinepass.selectedobjects = []; //无发光描边\n        chooseobj.remove(tag); //从场景移除\n    }\n})\n\n\n关闭设备标签，相机回到整体预览状态\n\n// 相机整体预览对应的位置和观察目标\nconst camerapos0 = new three.vector3(202, 123, 125)\nconst target0 = new three.vector3(0, 0, 0);\n// 鼠标单击按钮，关闭html标签\ndocument.getelementbyid('close').addeventlistener('click', function () {\n    if (chooseobj) { //把原来选中模型对应的标签和发光描边隐藏\n        outlinepass.selectedobjects = []; //无发光描边\n        chooseobj.remove(tag); //从场景移除\n        // 相机从当前位置camera.position回到整体预览状态\n        createcameratween(camerapos0, target0)\n    }\n})\n",charsets:{cjk:!0}},{title:"6. 模型或标签淡入淡出",frontmatter:{title:"6. 模型或标签淡入淡出",date:"2023-04-25T11:59:45.000Z",permalink:"/pages/5227e0/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/17.17.%E5%8A%A8%E7%94%BB%E5%BA%93tween.js/06.%E6%A8%A1%E5%9E%8B%E6%88%96%E6%A0%87%E7%AD%BE%E6%B7%A1%E5%85%A5%E6%B7%A1%E5%87%BA.html",relativePath:"01.Three.js教程/17.17.动画库tween.js/06.模型或标签淡入淡出.md",key:"v-384d9b66",path:"/pages/5227e0/",headers:[{level:3,title:"Tweenjs回调函数",slug:"tweenjs回调函数",normalizedTitle:"tweenjs回调函数",charIndex:66},{level:3,title:"模型淡入",slug:"模型淡入",normalizedTitle:"模型淡入",charIndex:398},{level:3,title:"模型淡出",slug:"模型淡出",normalizedTitle:"模型淡出",charIndex:745},{level:3,title:"模型HTML标签淡入淡出",slug:"模型html标签淡入淡出",normalizedTitle:"模型html标签淡入淡出",charIndex:1021}],headersStr:"Tweenjs回调函数 模型淡入 模型淡出 模型HTML标签淡入淡出",content:"# 模型或标签淡入淡出\n\n如果你想实现一个模型或标签的淡入淡出效果，可以同过tweenjs控制模型或标签的透明度轻松实现。\n\n\n# Tweenjs回调函数\n\ntwwenjs库提供了onStart、onUpdate、onComplete等用于控制动画执行的回调函数。\n\n * onStart：动画开始执行触发\n * onUpdate：动画执行过程中，一直被调用执行\n * onComplete：动画正常执行完触发\n\n.onUpdate(function(obj){})结构中，obj对应的是new TWEEN.Tween(pos)的参数对象pos。\n\nconst tween = new TWEEN.Tween(pos).to({x: 0}, 4000)\n// 开始执行：动画片段tween开始执行的时候触发onStart\n.onStart(function(obj){\n\t...\n})\n\n\n\n# 模型淡入\n\n// 模型淡入\nmaterial.transparent = true;//开启透明计算\nmaterial.opacity = 0.0;//完全透明\n\n// new TWEEN.Tween(material)\nnew TWEEN.Tween({opacity:material.opacity})\n.to({opacity:1.0}, 3000)\n.onUpdate(function(obj){\n    material.opacity = obj.opacity\n})\n.onComplete(function(){\n    //动画结束：关闭允许透明，恢复到模型原来状态\n    material.transparent = false;\n})\n.start();\n\n\n\n# 模型淡出\n\n// 模型淡出\n// new TWEEN.Tween(material)\nnew TWEEN.Tween({opacity:material.opacity})\n.to({opacity:0.0}, 3000)\n.onStart(function(){\n    //动画开始：允许透明opacity属性才能生效\n    material.transparent = true;\n})\n.onUpdate(function(obj){\n    material.opacity = obj.opacity\n})\n.start();\n\n\n\n# 模型HTML标签淡入淡出\n\nthree.js三维场景中的HTML元素标签淡入淡出和mesh对象淡入淡出类似操作。\n\n单击模型弹出的标签淡入，而不是突然出现。\n\n// HTML元素标签\nconst divTag = document.getElementById('tag');\n\n\nconst intersects = raycaster.intersectObjects(cunchu.children);\nconsole.log('intersects', intersects);\nif (intersects.length > 0) {\n    // 通过.ancestors属性判断那个模型对象被选中了\n    outlinePass.selectedObjects = [intersects[0].object.ancestors];\n    //tag会标注在intersects[0].object.ancestors模型的局部坐标系原点位置\n    intersects[0].object.ancestors.add(tag);\n    span.innerHTML = intersects[0].object.ancestors.name; //修改标签数据\n\n   // 标签淡出\n    new TWEEN.Tween({opacity:0})\n    .to({opacity:1.0}, 1000)\n    .onUpdate(function(obj){\n        //动态更新div元素透明度\n        divTag.style.opacity = obj.opacity;\n    })\n    .start();\n}\n\n\n原来代码，单击按钮，直接关闭标签。\n\n// 鼠标单击按钮，关闭HTML标签\ndocument.getElementById('close').addEventListener('click', function () {\n    if (chooseObj) { //把原来选中模型对应的标签和发光描边隐藏\n        outlinePass.selectedObjects = []; //无发光描边\n        chooseObj.remove(tag); //从场景移除\n    }\n})\n\n\n关闭模型标签淡出，逐渐消失。\n\n// 鼠标单击按钮，关闭HTML标签\ndocument.getElementById('close').addEventListener('click', function () {\n    if (chooseObj) { //把原来选中模型对应的标签和发光描边隐藏\n        outlinePass.selectedObjects = []; //无发光描边\n        // chooseObj.remove(tag); //从场景移除\n        new TWEEN.Tween({opacity: 1})\n            .to({opacity: 0}, 400)\n            .onUpdate(function (obj) {\n                //动态更新div元素透明度\n                divTag.style.opacity = obj.opacity;\n            })\n            .onComplete(function(){\n                // 动画结束再从场景中移除标签\n                chooseObj.remove(tag); //从场景移除\n            })\n            .start();   \n    }\n})\n",normalizedContent:"# 模型或标签淡入淡出\n\n如果你想实现一个模型或标签的淡入淡出效果，可以同过tweenjs控制模型或标签的透明度轻松实现。\n\n\n# tweenjs回调函数\n\ntwwenjs库提供了onstart、onupdate、oncomplete等用于控制动画执行的回调函数。\n\n * onstart：动画开始执行触发\n * onupdate：动画执行过程中，一直被调用执行\n * oncomplete：动画正常执行完触发\n\n.onupdate(function(obj){})结构中，obj对应的是new tween.tween(pos)的参数对象pos。\n\nconst tween = new tween.tween(pos).to({x: 0}, 4000)\n// 开始执行：动画片段tween开始执行的时候触发onstart\n.onstart(function(obj){\n\t...\n})\n\n\n\n# 模型淡入\n\n// 模型淡入\nmaterial.transparent = true;//开启透明计算\nmaterial.opacity = 0.0;//完全透明\n\n// new tween.tween(material)\nnew tween.tween({opacity:material.opacity})\n.to({opacity:1.0}, 3000)\n.onupdate(function(obj){\n    material.opacity = obj.opacity\n})\n.oncomplete(function(){\n    //动画结束：关闭允许透明，恢复到模型原来状态\n    material.transparent = false;\n})\n.start();\n\n\n\n# 模型淡出\n\n// 模型淡出\n// new tween.tween(material)\nnew tween.tween({opacity:material.opacity})\n.to({opacity:0.0}, 3000)\n.onstart(function(){\n    //动画开始：允许透明opacity属性才能生效\n    material.transparent = true;\n})\n.onupdate(function(obj){\n    material.opacity = obj.opacity\n})\n.start();\n\n\n\n# 模型html标签淡入淡出\n\nthree.js三维场景中的html元素标签淡入淡出和mesh对象淡入淡出类似操作。\n\n单击模型弹出的标签淡入，而不是突然出现。\n\n// html元素标签\nconst divtag = document.getelementbyid('tag');\n\n\nconst intersects = raycaster.intersectobjects(cunchu.children);\nconsole.log('intersects', intersects);\nif (intersects.length > 0) {\n    // 通过.ancestors属性判断那个模型对象被选中了\n    outlinepass.selectedobjects = [intersects[0].object.ancestors];\n    //tag会标注在intersects[0].object.ancestors模型的局部坐标系原点位置\n    intersects[0].object.ancestors.add(tag);\n    span.innerhtml = intersects[0].object.ancestors.name; //修改标签数据\n\n   // 标签淡出\n    new tween.tween({opacity:0})\n    .to({opacity:1.0}, 1000)\n    .onupdate(function(obj){\n        //动态更新div元素透明度\n        divtag.style.opacity = obj.opacity;\n    })\n    .start();\n}\n\n\n原来代码，单击按钮，直接关闭标签。\n\n// 鼠标单击按钮，关闭html标签\ndocument.getelementbyid('close').addeventlistener('click', function () {\n    if (chooseobj) { //把原来选中模型对应的标签和发光描边隐藏\n        outlinepass.selectedobjects = []; //无发光描边\n        chooseobj.remove(tag); //从场景移除\n    }\n})\n\n\n关闭模型标签淡出，逐渐消失。\n\n// 鼠标单击按钮，关闭html标签\ndocument.getelementbyid('close').addeventlistener('click', function () {\n    if (chooseobj) { //把原来选中模型对应的标签和发光描边隐藏\n        outlinepass.selectedobjects = []; //无发光描边\n        // chooseobj.remove(tag); //从场景移除\n        new tween.tween({opacity: 1})\n            .to({opacity: 0}, 400)\n            .onupdate(function (obj) {\n                //动态更新div元素透明度\n                divtag.style.opacity = obj.opacity;\n            })\n            .oncomplete(function(){\n                // 动画结束再从场景中移除标签\n                chooseobj.remove(tag); //从场景移除\n            })\n            .start();   \n    }\n})\n",charsets:{cjk:!0}},{title:"1. threejs坐标系与三角函数",frontmatter:{title:"1. threejs坐标系与三角函数",date:"2023-04-22T12:02:59.000Z",permalink:"/pages/001888/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/01.1.%20%E6%95%B0%E5%AD%A6%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/01.threejs%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8E%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0.html",relativePath:"02.Three.js进阶教程/01.1. 数学几何计算基础/01.threejs坐标系与三角函数.md",key:"v-773576a7",path:"/pages/001888/",headers:[{level:3,title:"3D坐标系",slug:"_3d坐标系",normalizedTitle:"3d坐标系",charIndex:116},{level:3,title:"创建辅助坐标轴THREE.AxesHelper",slug:"创建辅助坐标轴three-axeshelper",normalizedTitle:"创建辅助坐标轴three.axeshelper",charIndex:245},{level:3,title:"调整相机视线，观察坐标轴AxesHelper渲染效果",slug:"调整相机视线-观察坐标轴axeshelper渲染效果",normalizedTitle:"调整相机视线，观察坐标轴axeshelper渲染效果",charIndex:453},{level:3,title:"坐标系角度值",slug:"坐标系角度值",normalizedTitle:"坐标系角度值",charIndex:786},{level:3,title:"弧度",slug:"弧度",normalizedTitle:"弧度",charIndex:869},{level:3,title:"MathUtils类度和弧度转换方法",slug:"mathutils类度和弧度转换方法",normalizedTitle:"mathutils类度和弧度转换方法",charIndex:1040},{level:3,title:"JavaScript三角函数",slug:"javascript三角函数",normalizedTitle:"javascript三角函数",charIndex:1244},{level:3,title:"三角函数计算点位置",slug:"三角函数计算点位置",normalizedTitle:"三角函数计算点位置",charIndex:1428},{level:3,title:"学习方法总结",slug:"学习方法总结",normalizedTitle:"学习方法总结",charIndex:1897},{level:3,title:"练习题：沿着圆弧批量创建多个小球",slug:"练习题-沿着圆弧批量创建多个小球",normalizedTitle:"练习题：沿着圆弧批量创建多个小球",charIndex:2176}],headersStr:"3D坐标系 创建辅助坐标轴THREE.AxesHelper 调整相机视线，观察坐标轴AxesHelper渲染效果 坐标系角度值 弧度 MathUtils类度和弧度转换方法 JavaScript三角函数 三角函数计算点位置 学习方法总结 练习题：沿着圆弧批量创建多个小球",content:"# threejs坐标系与三角函数\n\n虽然大部分同学对three.js的坐标系和三角函数已经很熟悉了，但是这是threejs空间几何计算比较重要的内容，有必要在讲解一遍。\n\n如果你特别熟悉了，可以跳过视频，只看电子书文档。\n\n\n# 3D坐标系\n\n在Three.js中进行数学几何空间计算，有必要熟悉和掌握threejs的坐标系特征，下面先复习下基础课程中关于坐标系的介绍。\n\nThree.js默认坐标系一个默认y轴向上的右手坐标系，x轴水平向右，z轴垂直Canvas画布向外。\n\n\n\n\n# 创建辅助坐标轴THREE.AxesHelper\n\n你可以在threejs代码中创建一个三维辅助坐标系THREE.AxesHelper，用于辅助观察三维场景。\n\n//辅助观察的坐标系\nconst axesHelper = new THREE.AxesHelper(100);\nscene.add(axesHelper);\n\n\nThreejs坐标系X、Y、Z轴分别对应的颜色是R、G、B，也就是红、绿、蓝。\n\n\n\n\n# 调整相机视线，观察坐标轴AxesHelper渲染效果\n\n// 位置x、y、z都大于0，视线指向坐标原点\ncamera.position.set(292, 223, 185);\ncamera.lookAt(0, 0, 0);\n\n\n//视线沿着z轴负方向\ncamera.position.set(x, y, z+400);\ncamera.lookAt(x, y, z);\n\n\n//视线沿着z轴正方向\ncamera.position.set(x, y, z-400);\ncamera.lookAt(x, y, z);\n\n\n//视线沿着y轴负方向\ncamera.position.set(x, y+400, z);\ncamera.lookAt(x, y, z);\n\n\n\n# 坐标系角度值\n\n以XOY平面的xoy坐标坐标系为例说明。\n\n以x轴正半轴为起点，作为角度的0度，逆时针旋转一圈是360度，转两圈就是720度，以此类推。\n\n\n\n\n# 弧度\n\nJavaScript语言里面用Math.PI表示180度对应的弧度值。\n\nconsole.log('Math.PI',Math.PI);\n\n\nconst angle = Math.PI/6;//30度\nconst angle = Math.PI/2;//90度\nconst angle = Math.PI;//180度\n\n\n\n\n\n# MathUtils类度和弧度转换方法\n\nthree.js的数学工具类MathUtils也提供度和弧度转化的公式。\n\n// 弧度转度\nconst angle = THREE.MathUtils.radToDeg(Math.PI);\nconsole.log('Math.PI',angle);\n\n\n// 度转弧度\nconst angle = THREE.MathUtils.degToRad(30);\n\n\n\n# JavaScript三角函数\n\nJavaScript语言Math对象提供了多个用于三角函数计算的方法。\n\n方法               含义\nMath.sin(弧度)     正弦值\nMath.cos(弧度)     余弦值\nMath.tan(弧度)     正切值\nMath.asin(正弦值)   反正弦值\nMath.acos(余弦值)   反余弦值\n\n\n# 三角函数计算点位置\n\n直角坐标中，已知一个点距离坐标原点的长度，和与v轴正半轴夹角，计算改点的x和y坐标。\n\n\n\n在threejs代码中创建一个球体网格模型可视化表示该点的坐标(x,y)\n\nconst R = 100;//半径长度\nconst angle = Math.PI/6;//30度\n// const angle = Math.PI/2;//90度\n// const angle = Math.PI;//180度\nconst x = R * Math.cos(angle);\nconst y = R * Math.sin(angle);\nconst geometry = new THREE.SphereGeometry(3); \nconst material = new THREE.MeshLambertMaterial({color: 0x00ffff}); \nconst mesh = new THREE.Mesh(geometry, material); \nmesh.position.set(x,y,0);\n\n\n\n# 学习方法总结\n\n以后自己学习或探索threejs几何空间计算规律的时候，可以用threejs可视化方式表示出来你的计算结果，这样方便验证自己想法是否正确。比如正弦和余弦值区别，你记不清了，你可以代码测试下。\n\n你可以对比threejs代码中下面两种写法，小球的位置差异，就能判断那个是错误的。\n\nconst x = R * Math.cos(angle);\nconst y = R * Math.sin(angle);\n\n\nconst x = R * Math.sin(angle);\nconst y = R * Math.cos(angle);\n\n\n\n# 练习题：沿着圆弧批量创建多个小球\n\n你可以尝试利用刚刚介绍的三角函数的知识，在XOY平面上，沿着0~180度半个圆弧等间距创建11个小球。\n\nconst R = 100; //圆弧半径\nconst N = 10; //分段数量\nconst sp = Math.PI / N; //两个相邻点间隔弧度\nconst group = new THREE.Group();\nfor (let i = 0; i < N + 1; i++) {\n    const angle = sp * i;\n    // 以坐标原点为中心，在XOY平面上生成圆弧上的顶点数据\n    const x = R * Math.cos(angle);\n    const y = R * Math.sin(angle);\n    const mesh = new THREE.Mesh(geometry, material); \n    mesh.position.set(x,y,0);\n    group.add(mesh);\n}\n",normalizedContent:"# threejs坐标系与三角函数\n\n虽然大部分同学对three.js的坐标系和三角函数已经很熟悉了，但是这是threejs空间几何计算比较重要的内容，有必要在讲解一遍。\n\n如果你特别熟悉了，可以跳过视频，只看电子书文档。\n\n\n# 3d坐标系\n\n在three.js中进行数学几何空间计算，有必要熟悉和掌握threejs的坐标系特征，下面先复习下基础课程中关于坐标系的介绍。\n\nthree.js默认坐标系一个默认y轴向上的右手坐标系，x轴水平向右，z轴垂直canvas画布向外。\n\n\n\n\n# 创建辅助坐标轴three.axeshelper\n\n你可以在threejs代码中创建一个三维辅助坐标系three.axeshelper，用于辅助观察三维场景。\n\n//辅助观察的坐标系\nconst axeshelper = new three.axeshelper(100);\nscene.add(axeshelper);\n\n\nthreejs坐标系x、y、z轴分别对应的颜色是r、g、b，也就是红、绿、蓝。\n\n\n\n\n# 调整相机视线，观察坐标轴axeshelper渲染效果\n\n// 位置x、y、z都大于0，视线指向坐标原点\ncamera.position.set(292, 223, 185);\ncamera.lookat(0, 0, 0);\n\n\n//视线沿着z轴负方向\ncamera.position.set(x, y, z+400);\ncamera.lookat(x, y, z);\n\n\n//视线沿着z轴正方向\ncamera.position.set(x, y, z-400);\ncamera.lookat(x, y, z);\n\n\n//视线沿着y轴负方向\ncamera.position.set(x, y+400, z);\ncamera.lookat(x, y, z);\n\n\n\n# 坐标系角度值\n\n以xoy平面的xoy坐标坐标系为例说明。\n\n以x轴正半轴为起点，作为角度的0度，逆时针旋转一圈是360度，转两圈就是720度，以此类推。\n\n\n\n\n# 弧度\n\njavascript语言里面用math.pi表示180度对应的弧度值。\n\nconsole.log('math.pi',math.pi);\n\n\nconst angle = math.pi/6;//30度\nconst angle = math.pi/2;//90度\nconst angle = math.pi;//180度\n\n\n\n\n\n# mathutils类度和弧度转换方法\n\nthree.js的数学工具类mathutils也提供度和弧度转化的公式。\n\n// 弧度转度\nconst angle = three.mathutils.radtodeg(math.pi);\nconsole.log('math.pi',angle);\n\n\n// 度转弧度\nconst angle = three.mathutils.degtorad(30);\n\n\n\n# javascript三角函数\n\njavascript语言math对象提供了多个用于三角函数计算的方法。\n\n方法               含义\nmath.sin(弧度)     正弦值\nmath.cos(弧度)     余弦值\nmath.tan(弧度)     正切值\nmath.asin(正弦值)   反正弦值\nmath.acos(余弦值)   反余弦值\n\n\n# 三角函数计算点位置\n\n直角坐标中，已知一个点距离坐标原点的长度，和与v轴正半轴夹角，计算改点的x和y坐标。\n\n\n\n在threejs代码中创建一个球体网格模型可视化表示该点的坐标(x,y)\n\nconst r = 100;//半径长度\nconst angle = math.pi/6;//30度\n// const angle = math.pi/2;//90度\n// const angle = math.pi;//180度\nconst x = r * math.cos(angle);\nconst y = r * math.sin(angle);\nconst geometry = new three.spheregeometry(3); \nconst material = new three.meshlambertmaterial({color: 0x00ffff}); \nconst mesh = new three.mesh(geometry, material); \nmesh.position.set(x,y,0);\n\n\n\n# 学习方法总结\n\n以后自己学习或探索threejs几何空间计算规律的时候，可以用threejs可视化方式表示出来你的计算结果，这样方便验证自己想法是否正确。比如正弦和余弦值区别，你记不清了，你可以代码测试下。\n\n你可以对比threejs代码中下面两种写法，小球的位置差异，就能判断那个是错误的。\n\nconst x = r * math.cos(angle);\nconst y = r * math.sin(angle);\n\n\nconst x = r * math.sin(angle);\nconst y = r * math.cos(angle);\n\n\n\n# 练习题：沿着圆弧批量创建多个小球\n\n你可以尝试利用刚刚介绍的三角函数的知识，在xoy平面上，沿着0~180度半个圆弧等间距创建11个小球。\n\nconst r = 100; //圆弧半径\nconst n = 10; //分段数量\nconst sp = math.pi / n; //两个相邻点间隔弧度\nconst group = new three.group();\nfor (let i = 0; i < n + 1; i++) {\n    const angle = sp * i;\n    // 以坐标原点为中心，在xoy平面上生成圆弧上的顶点数据\n    const x = r * math.cos(angle);\n    const y = r * math.sin(angle);\n    const mesh = new three.mesh(geometry, material); \n    mesh.position.set(x,y,0);\n    group.add(mesh);\n}\n",charsets:{cjk:!0}},{title:"5. 缓动算法.easing(地球渐入相机动画)",frontmatter:{title:"5. 缓动算法.easing(地球渐入相机动画)",date:"2023-04-25T11:59:28.000Z",permalink:"/pages/51d9ae/"},regularPath:"/01.Three.js%E6%95%99%E7%A8%8B/17.17.%E5%8A%A8%E7%94%BB%E5%BA%93tween.js/05.%E7%BC%93%E5%8A%A8%E7%AE%97%E6%B3%95.easing(%E5%9C%B0%E7%90%83%E6%B8%90%E5%85%A5%E7%9B%B8%E6%9C%BA%E5%8A%A8%E7%94%BB).html",relativePath:"01.Three.js教程/17.17.动画库tween.js/05.缓动算法.easing(地球渐入相机动画).md",key:"v-3996c29d",path:"/pages/51d9ae/",headers:[{level:3,title:"缓动算法.easing案例体验",slug:"缓动算法-easing案例体验",normalizedTitle:"缓动算法.easing案例体验",charIndex:223},{level:3,title:".easing()语法格式",slug:"easing-语法格式",normalizedTitle:".easing()语法格式",charIndex:779},{level:3,title:"easing类型(定义缓动算法起作用地方)",slug:"easing类型-定义缓动算法起作用地方",normalizedTitle:"easing类型(定义缓动算法起作用地方)",charIndex:892},{level:3,title:"官方案例03_graphs.html",slug:"官方案例03-graphs-html",normalizedTitle:"官方案例03_graphs.html",charIndex:1149},{level:3,title:"匀速运动(特殊情况说明)",slug:"匀速运动-特殊情况说明",normalizedTitle:"匀速运动(特殊情况说明)",charIndex:1620}],headersStr:"缓动算法.easing案例体验 .easing()语法格式 easing类型(定义缓动算法起作用地方) 官方案例03_graphs.html 匀速运动(特殊情况说明)",content:"# 缓动算法.easing(地球渐入相机动画)\n\n动画片段tween通过.easing()方法可以设置缓动算法，在一些动画场景中你设置合理的缓动算法，可以让动画看起来非常自然，比如一辆车从静止进入匀速状态，动画最好有一个加速过程的过渡，对于这个加速的方式就可以通过缓动算法实现。\n\n形象理解：所谓缓动，你可以理解为运动缓缓加速的过程，缓动算法就是运动加速的算法，推广一下，不一定针对运动，比如颜色渐变、相机动画也可以类比车辆运动加减速。\n\n\n# 缓动算法.easing案例体验\n\n你可以对比课件案例源码地球相机动画设置和不设置缓动的视觉差异，你会发现设置缓动函数后，视觉效果更加舒适和自然。\n\ncamera.position.set(3000, 3000, 3000);\ncamera.lookAt(0, 0, 0);\n\n// 视觉效果：地球从小到大出现(透视投影相机远小近大投影规律)\nnew TWEEN.Tween(camera.position)\n.to({x: 300,y: 300,z: 300}, 3000)\n.start()\n.easing(TWEEN.Easing.Quadratic.Out);//使用二次缓动函数\n\n\n你可以把上上节课，相机镜头切换动画加上缓动动画，进行测试。\n\ncamera.position.set(3000, 3000, 3000);\ncamera.lookAt(0, 0, 0);\n\n// 视觉效果：地球从小到大出现(透视投影相机远小近大投影规律)\nnew TWEEN.Tween(camera.position)\n.to({x: 300,y: 300,z: 300}, 3000)\n.start()\n.easing(TWEEN.Easing.Sinusoidal.InOut)//进入和结束都设置缓动\n\n\n\n# .easing()语法格式\n\n// easing函数：缓动算法(运动效果)\n// easing类型：定义缓动算法起作用地方\ntween.easing(TWEEN.Easing.easing函数.easing类型);\n\n\n\n# easing类型(定义缓动算法起作用地方)\n\neasing函数和easing类型都有多种方式，可以自由组合使用(Linear除外)。\n\n// 动画开始缓动方式(类比加速启动)\ntween.easing(TWEEN.Easing.Sinusoidal.In);\n// 动画结束缓动方式(类比减速刹车)\ntween.easing(TWEEN.Easing.Sinusoidal.Out);\n// 同时设置In和Out\ntween.easing(TWEEN.Easing.Sinusoidal.InOut);\n\n\n\n# 官方案例03_graphs.html\n\n官方案例tween.js-master\\examples目录里面案例03_graphs.html可以查看各种缓动算法的曲线效果图。\n\nLinear:默认效果可以不设置，可以理解为没有加速过程直接进入匀速状态，或者说没有减速过程，直接刹车\n\nQuadratic：二次方的缓动(t^2)\n\nCubic：三次方的缓动(t^3)\n\nQuartic：四次方的缓动(t^4)\n\nQuintic：五次方的缓动(t^5)\n\nSinusoidal：正弦曲线的缓动(sin(t))\n\nExponential：指数曲线的缓动(2^t)启动非常慢，后面快\n\nCircular：圆形曲线的缓动(sqrt(1-t^2))会有弹性衰减往复运动感\n\nElastic：指数衰减的正弦曲线缓动；TWEEN.Easing.Elastic.inout 会有弹性衰减往复运动感\n\nBack：超过范围的三次方缓动((s+1)*t^3 – s*t^2)会有弹性衰减往复运动感\n\nBounce：指数衰减的反弹缓动。会有弹性衰减往复运动感\n\n\n\n\n# 匀速运动(特殊情况说明)\n\nLinear:默认效果可以不设置，可以理解为没有加速过程直接进入匀速状态，或者说没有减速过程，直接刹车\n\n注意：匀速设置 TWEEN.Easing.Linear.None(默认效果可以不设置)。\n\n对于Linear不要设置TWEEN.Easing.Linear.In、TWEEN.Easing.Linear.Out或TWEEN.Easing.Linear.InOut，会报错",normalizedContent:"# 缓动算法.easing(地球渐入相机动画)\n\n动画片段tween通过.easing()方法可以设置缓动算法，在一些动画场景中你设置合理的缓动算法，可以让动画看起来非常自然，比如一辆车从静止进入匀速状态，动画最好有一个加速过程的过渡，对于这个加速的方式就可以通过缓动算法实现。\n\n形象理解：所谓缓动，你可以理解为运动缓缓加速的过程，缓动算法就是运动加速的算法，推广一下，不一定针对运动，比如颜色渐变、相机动画也可以类比车辆运动加减速。\n\n\n# 缓动算法.easing案例体验\n\n你可以对比课件案例源码地球相机动画设置和不设置缓动的视觉差异，你会发现设置缓动函数后，视觉效果更加舒适和自然。\n\ncamera.position.set(3000, 3000, 3000);\ncamera.lookat(0, 0, 0);\n\n// 视觉效果：地球从小到大出现(透视投影相机远小近大投影规律)\nnew tween.tween(camera.position)\n.to({x: 300,y: 300,z: 300}, 3000)\n.start()\n.easing(tween.easing.quadratic.out);//使用二次缓动函数\n\n\n你可以把上上节课，相机镜头切换动画加上缓动动画，进行测试。\n\ncamera.position.set(3000, 3000, 3000);\ncamera.lookat(0, 0, 0);\n\n// 视觉效果：地球从小到大出现(透视投影相机远小近大投影规律)\nnew tween.tween(camera.position)\n.to({x: 300,y: 300,z: 300}, 3000)\n.start()\n.easing(tween.easing.sinusoidal.inout)//进入和结束都设置缓动\n\n\n\n# .easing()语法格式\n\n// easing函数：缓动算法(运动效果)\n// easing类型：定义缓动算法起作用地方\ntween.easing(tween.easing.easing函数.easing类型);\n\n\n\n# easing类型(定义缓动算法起作用地方)\n\neasing函数和easing类型都有多种方式，可以自由组合使用(linear除外)。\n\n// 动画开始缓动方式(类比加速启动)\ntween.easing(tween.easing.sinusoidal.in);\n// 动画结束缓动方式(类比减速刹车)\ntween.easing(tween.easing.sinusoidal.out);\n// 同时设置in和out\ntween.easing(tween.easing.sinusoidal.inout);\n\n\n\n# 官方案例03_graphs.html\n\n官方案例tween.js-master\\examples目录里面案例03_graphs.html可以查看各种缓动算法的曲线效果图。\n\nlinear:默认效果可以不设置，可以理解为没有加速过程直接进入匀速状态，或者说没有减速过程，直接刹车\n\nquadratic：二次方的缓动(t^2)\n\ncubic：三次方的缓动(t^3)\n\nquartic：四次方的缓动(t^4)\n\nquintic：五次方的缓动(t^5)\n\nsinusoidal：正弦曲线的缓动(sin(t))\n\nexponential：指数曲线的缓动(2^t)启动非常慢，后面快\n\ncircular：圆形曲线的缓动(sqrt(1-t^2))会有弹性衰减往复运动感\n\nelastic：指数衰减的正弦曲线缓动；tween.easing.elastic.inout 会有弹性衰减往复运动感\n\nback：超过范围的三次方缓动((s+1)*t^3 – s*t^2)会有弹性衰减往复运动感\n\nbounce：指数衰减的反弹缓动。会有弹性衰减往复运动感\n\n\n\n\n# 匀速运动(特殊情况说明)\n\nlinear:默认效果可以不设置，可以理解为没有加速过程直接进入匀速状态，或者说没有减速过程，直接刹车\n\n注意：匀速设置 tween.easing.linear.none(默认效果可以不设置)。\n\n对于linear不要设置tween.easing.linear.in、tween.easing.linear.out或tween.easing.linear.inout，会报错",charsets:{cjk:!0}},{title:"2. 三维向量Vector3简介",frontmatter:{title:"2. 三维向量Vector3简介",date:"2023-04-22T12:03:06.000Z",permalink:"/pages/b4b9bb/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/01.1.%20%E6%95%B0%E5%AD%A6%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/02.%E4%B8%89%E7%BB%B4%E5%90%91%E9%87%8FVector3%E7%AE%80%E4%BB%8B.html",relativePath:"02.Three.js进阶教程/01.1. 数学几何计算基础/02.三维向量Vector3简介.md",key:"v-551bde42",path:"/pages/b4b9bb/",headers:[{level:3,title:"向量和标量",slug:"向量和标量",normalizedTitle:"向量和标量",charIndex:269},{level:3,title:"Vector3表示3D空间中位置坐标(非向量)",slug:"vector3表示3d空间中位置坐标-非向量",normalizedTitle:"vector3表示3d空间中位置坐标(非向量)",charIndex:622},{level:3,title:"Vector3表示位移量(向量)",slug:"vector3表示位移量-向量",normalizedTitle:"vector3表示位移量(向量)",charIndex:1081},{level:3,title:"向量加法运算.addVectors()",slug:"向量加法运算-addvectors",normalizedTitle:"向量加法运算.addvectors()",charIndex:1519},{level:3,title:"向量复制方法.copy()",slug:"向量复制方法-copy",normalizedTitle:"向量复制方法.copy()",charIndex:1888},{level:3,title:"向量加法运算.add()",slug:"向量加法运算-add",normalizedTitle:"向量加法运算.add()",charIndex:2025},{level:3,title:"Vector3表示速度(向量)",slug:"vector3表示速度-向量",normalizedTitle:"vector3表示速度(向量)",charIndex:2389},{level:3,title:"向量方法.multiplyScalar()",slug:"向量方法-multiplyscalar",normalizedTitle:"向量方法.multiplyscalar()",charIndex:2860}],headersStr:"向量和标量 Vector3表示3D空间中位置坐标(非向量) Vector3表示位移量(向量) 向量加法运算.addVectors() 向量复制方法.copy() 向量加法运算.add() Vector3表示速度(向量) 向量方法.multiplyScalar()",content:"# 三维向量Vector3简介\n\n如果你已经掌握了数学中关于向量的运算规则，直接去看看threejs Vector3的文档，很多方法和属性都可以快速理解，比如点乘.dot()、叉乘.cross()，这时候你可以回忆你学过的数学知识来理解theejs的APIVector3中的部分方法和属性。\n\n不过有很多同学可能学过，但是都还给老师了，还有些同学干脆是没有向量的概念，这时候直接看threejs文档会不太理解，不过这没关系，下面几节课会通过threejs具体的代码案例讲解，你也不用刻意记忆这些数学概念，只要跟着课程写代码就行。\n\n\n# 向量和标量\n\n数学中有两个概念向量和标量，简单地说向量就是一个有方向的量，比如在3D空间中描述一个人的速度，你需要表达速度的大小，同时也需要表达速度运动的方向，这样才能计算出3D空间中人经过一段时间，在x、y、z三个方向分别走了多长距离。至于标量，就是一个没有方向的量，比如模型的位置具体坐标mesh.position。\n\nthreejs的类Vector3，虽然英文字面意思是向量，除了向量，Vector3也可以用来表示标量，具体看你代码赋予Vector3什么样的含义。比如Vector3作为一个标量，表示网格模型的Mesh的位置mesh.position，Vector3也可以用来表示一个向量，比如一个模型沿着x轴平移，那么平移的方向可以用new THREE.Vector3(1,0,0)表示。\n\n\n# Vector3表示3D空间中位置坐标(非向量)\n\n在基础课程中3.1三维向量Vector3与模型位置就给大家介绍过向量相关知识点，下面简单回顾下。\n\nVector3对象具有属性.x、.y、.z三个属性，这意味着你可以用Vector3对象表示3D空间中的位置坐标x、y、z。\n\nconst v3 = new THREE.Vector3(30,30,0);\nconsole.log('v3',v3);\n\n\nthreejs本身就会给mesh.position一个默认值THREE.Vector3(0,0,0)，这就是说你可以不用给mesh.position赋值Vector3对象，你可以直接访问mesh.position，获取或设置Vector3的.x、.y、.z属性。\n\nconsole.log('mesh.position',mesh.position);\n\n\nmesh.position.y = 80;// 设置网格模型y坐标\nmesh.position.set(80,2,10);// 设置模型xyz坐标\n\n\n\n# Vector3表示位移量(向量)\n\n\n\n比如已知人在3D空间中的坐标A点是(30,30,0),此人运动到B点，从A到B的位移变化量可以用一个向量Vector3表示，已知AB在x轴上投影长度是100，y方向投影长度是50，这个变化可以用三维向量THREE.Vector3(100,50,0)表示,换句话u说，你也可以理解为人沿着x轴走了100，沿着y方向走了50，到达B点。\n\nconst A = new THREE.Vector3(30, 30, 0);// 人起点A\n// walk表示运动的位移量用向量\nconst walk = new THREE.Vector3(100, 50, 0);\nconst B = new THREE.Vector3();// 人运动结束点B\n// 计算结束点xyz坐标\nB.x = A.x + walk.x;\nB.y = A.y + walk.y;\nB.z = A.z + walk.z;\nconsole.log('B',B);\n\n\n\n# 向量加法运算.addVectors()\n\nB.addVectors(A,walk)的含义就是向量A和向量walk的x、y、z三个分量分别相加(B.x = A.x + walk.x;、B.y = A.y + walk.y;、B.z = A.z + walk.z;)。\n\nconst A = new THREE.Vector3(30, 30, 0);// 人起点A\n// walk表示运动的位移量用向量\nconst walk = new THREE.Vector3(100, 50, 0);\nconst B = new THREE.Vector3();// 人运动结束点B\n// addVectors的含义就是参数中两个向量xyz三个分量分别相加\nB.addVectors(A,walk);\nconsole.log('B',B);\n\n\n\n# 向量复制方法.copy()\n\n通过向量复制方法.copy()，把A和B点的坐标赋值给两个表示网格模型对象,可视化A点和B点。\n\n// 两个小球网格模型可视化A点和B点\nmesh1.position.copy(A);\nmesh2.position.copy(B);\n\n\n\n# 向量加法运算.add()\n\n.add()和.addVectors()功能一样，只是语法细节不同。\n\nA和walk的x、y、z属性分别相加，相加的结果替换A原来的x、y、z。\n\nA.add(walk);\n\n\nconst B = A.add(walk);这种写法，B本质上就是A，两个变量指向同一个对象。\n\nconst B = A.add(walk);\nconsole.log('A',A);\nconsole.log('B',B);\n\n\n如果不希望A被改变，且创建一个新的对象表示B点坐标，通过克隆方法.clone()。\n\n// A.clone()克隆一个和A一样对象，然后再加上walk，作为B\n// A不执行.clone()，A和B本质上都指向同一个对象\nconst B = A.clone().add(walk);\n\n\n\n# Vector3表示速度(向量)\n\n\n\n假设一个人的运动速度大小是√2,方向是x和y正半轴的角平分线，那么人的速度可以用向量THREE.Vector3(1, 1, 0)表示。\n\n// 向量v表示人速度，大小√2米每秒，方向是x、y正半轴的角平分线\nconst v = new THREE.Vector3(1, 1, 0);\n\n\n以速度v运动50秒，计算运动位移变化量。\n\n// xyz三个方向上速度分别和时间相乘，得到三个方向上位移\nconst walk = new THREE.Vector3(v.x * 50, v.y * 50, v.z * 50);\n\n\n假设人起点坐标A(30, 30, 0)，以速度v运动50秒，计算运动结束位置。\n\nconst v = new THREE.Vector3(1, 1, 0);\nconst walk = new THREE.Vector3(v.x * 50, v.y * 50, v.z * 50);\n// 运动50秒结束位置B\nconst B = A.clone().add(walk);\n\n\n\n# 向量方法.multiplyScalar()\n\n向量方法.multiplyScalar(50)表示向量x、y、z三个分量和参数分别相乘。\n\nv.clone().multiplyScalar(50)的含义和Vector3(v.x * 50, v.y * 50, v.z * 50)是一样的。\n\n// `.multiplyScalar(50)`表示向量x、y、z三个分量和参数分别相乘\nconst walk = v.clone().multiplyScalar(50);\n// 运动50秒结束位置B\nconst B = A.clone().add(walk);\n",normalizedContent:"# 三维向量vector3简介\n\n如果你已经掌握了数学中关于向量的运算规则，直接去看看threejs vector3的文档，很多方法和属性都可以快速理解，比如点乘.dot()、叉乘.cross()，这时候你可以回忆你学过的数学知识来理解theejs的apivector3中的部分方法和属性。\n\n不过有很多同学可能学过，但是都还给老师了，还有些同学干脆是没有向量的概念，这时候直接看threejs文档会不太理解，不过这没关系，下面几节课会通过threejs具体的代码案例讲解，你也不用刻意记忆这些数学概念，只要跟着课程写代码就行。\n\n\n# 向量和标量\n\n数学中有两个概念向量和标量，简单地说向量就是一个有方向的量，比如在3d空间中描述一个人的速度，你需要表达速度的大小，同时也需要表达速度运动的方向，这样才能计算出3d空间中人经过一段时间，在x、y、z三个方向分别走了多长距离。至于标量，就是一个没有方向的量，比如模型的位置具体坐标mesh.position。\n\nthreejs的类vector3，虽然英文字面意思是向量，除了向量，vector3也可以用来表示标量，具体看你代码赋予vector3什么样的含义。比如vector3作为一个标量，表示网格模型的mesh的位置mesh.position，vector3也可以用来表示一个向量，比如一个模型沿着x轴平移，那么平移的方向可以用new three.vector3(1,0,0)表示。\n\n\n# vector3表示3d空间中位置坐标(非向量)\n\n在基础课程中3.1三维向量vector3与模型位置就给大家介绍过向量相关知识点，下面简单回顾下。\n\nvector3对象具有属性.x、.y、.z三个属性，这意味着你可以用vector3对象表示3d空间中的位置坐标x、y、z。\n\nconst v3 = new three.vector3(30,30,0);\nconsole.log('v3',v3);\n\n\nthreejs本身就会给mesh.position一个默认值three.vector3(0,0,0)，这就是说你可以不用给mesh.position赋值vector3对象，你可以直接访问mesh.position，获取或设置vector3的.x、.y、.z属性。\n\nconsole.log('mesh.position',mesh.position);\n\n\nmesh.position.y = 80;// 设置网格模型y坐标\nmesh.position.set(80,2,10);// 设置模型xyz坐标\n\n\n\n# vector3表示位移量(向量)\n\n\n\n比如已知人在3d空间中的坐标a点是(30,30,0),此人运动到b点，从a到b的位移变化量可以用一个向量vector3表示，已知ab在x轴上投影长度是100，y方向投影长度是50，这个变化可以用三维向量three.vector3(100,50,0)表示,换句话u说，你也可以理解为人沿着x轴走了100，沿着y方向走了50，到达b点。\n\nconst a = new three.vector3(30, 30, 0);// 人起点a\n// walk表示运动的位移量用向量\nconst walk = new three.vector3(100, 50, 0);\nconst b = new three.vector3();// 人运动结束点b\n// 计算结束点xyz坐标\nb.x = a.x + walk.x;\nb.y = a.y + walk.y;\nb.z = a.z + walk.z;\nconsole.log('b',b);\n\n\n\n# 向量加法运算.addvectors()\n\nb.addvectors(a,walk)的含义就是向量a和向量walk的x、y、z三个分量分别相加(b.x = a.x + walk.x;、b.y = a.y + walk.y;、b.z = a.z + walk.z;)。\n\nconst a = new three.vector3(30, 30, 0);// 人起点a\n// walk表示运动的位移量用向量\nconst walk = new three.vector3(100, 50, 0);\nconst b = new three.vector3();// 人运动结束点b\n// addvectors的含义就是参数中两个向量xyz三个分量分别相加\nb.addvectors(a,walk);\nconsole.log('b',b);\n\n\n\n# 向量复制方法.copy()\n\n通过向量复制方法.copy()，把a和b点的坐标赋值给两个表示网格模型对象,可视化a点和b点。\n\n// 两个小球网格模型可视化a点和b点\nmesh1.position.copy(a);\nmesh2.position.copy(b);\n\n\n\n# 向量加法运算.add()\n\n.add()和.addvectors()功能一样，只是语法细节不同。\n\na和walk的x、y、z属性分别相加，相加的结果替换a原来的x、y、z。\n\na.add(walk);\n\n\nconst b = a.add(walk);这种写法，b本质上就是a，两个变量指向同一个对象。\n\nconst b = a.add(walk);\nconsole.log('a',a);\nconsole.log('b',b);\n\n\n如果不希望a被改变，且创建一个新的对象表示b点坐标，通过克隆方法.clone()。\n\n// a.clone()克隆一个和a一样对象，然后再加上walk，作为b\n// a不执行.clone()，a和b本质上都指向同一个对象\nconst b = a.clone().add(walk);\n\n\n\n# vector3表示速度(向量)\n\n\n\n假设一个人的运动速度大小是√2,方向是x和y正半轴的角平分线，那么人的速度可以用向量three.vector3(1, 1, 0)表示。\n\n// 向量v表示人速度，大小√2米每秒，方向是x、y正半轴的角平分线\nconst v = new three.vector3(1, 1, 0);\n\n\n以速度v运动50秒，计算运动位移变化量。\n\n// xyz三个方向上速度分别和时间相乘，得到三个方向上位移\nconst walk = new three.vector3(v.x * 50, v.y * 50, v.z * 50);\n\n\n假设人起点坐标a(30, 30, 0)，以速度v运动50秒，计算运动结束位置。\n\nconst v = new three.vector3(1, 1, 0);\nconst walk = new three.vector3(v.x * 50, v.y * 50, v.z * 50);\n// 运动50秒结束位置b\nconst b = a.clone().add(walk);\n\n\n\n# 向量方法.multiplyscalar()\n\n向量方法.multiplyscalar(50)表示向量x、y、z三个分量和参数分别相乘。\n\nv.clone().multiplyscalar(50)的含义和vector3(v.x * 50, v.y * 50, v.z * 50)是一样的。\n\n// `.multiplyscalar(50)`表示向量x、y、z三个分量和参数分别相乘\nconst walk = v.clone().multiplyscalar(50);\n// 运动50秒结束位置b\nconst b = a.clone().add(walk);\n",charsets:{cjk:!0}},{title:"3. 向量大小(Vector3长度.length())",frontmatter:{title:"3. 向量大小(Vector3长度.length())",date:"2023-06-03T14:52:05.000Z",permalink:"/pages/0a87db/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/01.1.%20%E6%95%B0%E5%AD%A6%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/03.%E5%90%91%E9%87%8F%E5%A4%A7%E5%B0%8F(Vector3%E9%95%BF%E5%BA%A6.length()).html",relativePath:"02.Three.js进阶教程/01.1. 数学几何计算基础/03.向量大小(Vector3长度.length()).md",key:"v-a8f143e2",path:"/pages/0a87db/",headers:[{level:3,title:"人从A点移动到B点移动",slug:"人从a点移动到b点移动",normalizedTitle:"人从a点移动到b点移动",charIndex:177},{level:3,title:"计算AB两点之间距离(初高中数学)",slug:"计算ab两点之间距离-初高中数学",normalizedTitle:"计算ab两点之间距离(初高中数学)",charIndex:369},{level:3,title:"向量Vector3表示位移量(A到B的移动)",slug:"向量vector3表示位移量-a到b的移动",normalizedTitle:"向量vector3表示位移量(a到b的移动)",charIndex:1201},{level:3,title:"向量减法运算.subVectors()",slug:"向量减法运算-subvectors",normalizedTitle:"向量减法运算.subvectors()",charIndex:1567},{level:3,title:"向量减法运算.sub()",slug:"向量减法运算-sub",normalizedTitle:"向量减法运算.sub()",charIndex:1785},{level:3,title:"向量AB的物理含义",slug:"向量ab的物理含义",normalizedTitle:"向量ab的物理含义",charIndex:1998},{level:3,title:"向量长度.length()",slug:"向量长度-length",normalizedTitle:"向量长度.length()",charIndex:2131},{level:3,title:"两点之间距离计算总结",slug:"两点之间距离计算总结",normalizedTitle:"两点之间距离计算总结",charIndex:2482},{level:3,title:"总结：向量分解为xyz三个方向",slug:"总结-向量分解为xyz三个方向",normalizedTitle:"总结：向量分解为xyz三个方向",charIndex:2783},{level:3,title:"总结：向量合成",slug:"总结-向量合成",normalizedTitle:"总结：向量合成",charIndex:2939},{level:3,title:"向量表示速度",slug:"向量表示速度",normalizedTitle:"向量表示速度",charIndex:3045},{level:3,title:"速度向量长度.length()含义",slug:"速度向量长度-length-含义",normalizedTitle:"速度向量长度.length()含义",charIndex:3272}],headersStr:"人从A点移动到B点移动 计算AB两点之间距离(初高中数学) 向量Vector3表示位移量(A到B的移动) 向量减法运算.subVectors() 向量减法运算.sub() 向量AB的物理含义 向量长度.length() 两点之间距离计算总结 总结：向量分解为xyz三个方向 总结：向量合成 向量表示速度 速度向量长度.length()含义",content:"# 向量大小(Vector3长度.length())\n\n本节课给大家介绍下向量长度(大小)的概念，并使用Three.js三维向量类Vector3的方法.length()计算向量长度，比如通过.length()计算3D空间中两点之间的距离。\n\n为了让大家更容易理解向量长度的概念，更容易理解.length()方法，下面举一个具体的应用场景来讲解。\n\n\n# 人从A点移动到B点移动\n\n\n\n已知人在3D空间中，从A点移动到B点，A点坐标是(30,30,0)，B点坐标是(130,80,0)。\n\nVector3作为标量，表示人的起始点位置坐标。\n\nconst A = new THREE.Vector3(30,30,0);// 人起点A\nconst B = new THREE.Vector3(130,80,0);// 人运动结束点B\n\n\n\n# 计算AB两点之间距离(初高中数学)\n\n为什么在这里强调初高中数学，主要是因为总有学员咨询，自己数学基础不好，能学习threejs吗？入门的话，无所谓，进阶的话，如果数学基础很好，结合文档自学没啥压力，跟着课程更快点，如果数学基础不好，自学肯定比较困难，如果是跟着咱们系统课程数学进阶部分学习的话，会极大降低你学习难度和节约学习时间。\n\n沿着A点绘制一条平行于x轴的直线，沿着B点绘制一条平行于y轴的直线，两条直线交叉点是O，AOB构成一个直角三角形。先不考虑z轴，三角形AOB位于XOY平面上。用你初中学过的勾股定理就可以计算出来AB线段的长度，也是人从A点移动B点的距离。\n\n\n\nconst x1 = A.x;\nconst x2 = B.x;\nconst y1 = A.y;\nconst y2 = B.y;\nconst AO = x2-x1;\nconst BO = y2-y1;\n// 勾股定理计算三角形斜边长度(初中数学)\nconst L = Math.sqrt(AO*AO + BO*BO);\n// 计算结果：50√5(111.803)\nconsole.log('L',L);\n\n\n把上面计算过程总结下，平面上两点距离计算公式\n\n\n\n推广到三维空间考虑x、y、z三个分量，和2D平面上长度计算逻辑是一样的，下面是3D空间两点之间距离公式(高中数学)\n\nA和B两点的x、y、z分量分别相减，相减结果平方，然后相加，最后平方根，就是AB长度。\n\n\n\nconst A = new THREE.Vector3(30, 30, 0);// 人起点A\nconst B = new THREE.Vector3(130,80,0);// 人运动结束点B\n// 3D空间，A和B两点之间的距离\nconst L = Math.sqrt(Math.pow(B.x-A.x,2) + Math.pow(B.y-A.y,2) + Math.pow(B.z-A.z,2));\n\n\n\n# 向量Vector3表示位移量(A到B的移动)\n\n从A点到B点的移动，可以用一个向量表示。\n\n\n\n已知人在3D空间中的坐标A点是(30,30,0),此人运动到B点(130,80,0)，已知AB在x轴上投影长度是100，y方向投影长度是50，这个变化可以用三维向量THREE.Vector3(100,50,0)表示,换句话说，你也可以理解为人从A点开始，沿着x轴走了100，沿着y方向走了50，到达B点。\n\nconst A = new THREE.Vector3(30, 30, 0);\nconst B = new THREE.Vector3(130,80,0);\nconst AB = new THREE.Vector3();\nAB.x = B.x-A.x;\nAB.y = B.y-A.y;\nAB.z = B.z-A.z;\n\n\n\n# 向量减法运算.subVectors()\n\nAB.subVectors(B,A);的含义表示B的xyz三个分量，与A的xyz三个分量分别相减，然后赋值给向量AB。\n\nconst A = new THREE.Vector3(30, 30, 0);\nconst B = new THREE.Vector3(130,80,0);\nconst AB = new THREE.Vector3();\nAB.subVectors(B,A);\n\n\n\n# 向量减法运算.sub()\n\nB.sub(A);表示B的xyz三个属性分别减去A的xyz三个属性，然后结果赋值给B自身的xyz属性\n\nB.sub(A);\nconsole.log('B',B);\n\n\n如果希望基于A和B两点位置，生成一个A指向B的向量，可以B克隆一个新对象，减去A。(如果B不克隆，B本身会被改变)\n\nconst AB = B.clone().sub(A);\nconsole.log('AB',AB);\n\n\n\n# 向量AB的物理含义\n\n * 方向\n * 长度(大小)\n\n向量AB包含了两层信息，一个是从A移动到B点的位移方向，另一层信息是AB两点的距离，你可以把AB两点之间的距离称为向量长度(大小)。\n\n\n\n总结：在该移动案例中，向量的长度就表示A和B两点之间的距离。\n\n\n# 向量长度.length()\n\nthreejs的类Vector3的封装了一个方法.length()，用于计算向量长度。\n\n向量长度.length()的内部代码，本质上就是x、y、z三个分量平方和的平方根。\n\nconst AB = B.clone().sub(A);\nconst L = AB.length();\nconsole.log('L',L);\n\n\nB.clone().sub(A)和AB.length()本质上表达的计算过程，就是上面介绍的两点之间的距离公式。.sub()表示了xyz分量分别相减，.length()表示相减结果，平方和的平方根。\n\n\n\nAB.length()计算的结果表示向量的长度，其实你对比下计算结果，就知道AB.length()计算的结果就表示A点到B点的距离。\n\n\n# 两点之间距离计算总结\n\n有了.sub()和.length()两个方法，两点之间距离计算，不需要自己写公式，直接用Threejs封装好的向量长度方法.length()即可，也就是用threejs封装好的方法简化计算代码。\n\n\n\nconst A = new THREE.Vector3(30, 30, 0);\nconst B = new THREE.Vector3(130,80,0);\n// 两点坐标构建一个向量AB\nconst AB = B.clone().sub(A);\n// 向量长度表示AB两点距离\nconst L = AB.length();\nconsole.log('L',L);\n\n\n\n# 总结：向量分解为xyz三个方向\n\n在三维空间中一个向量，使用Vector3()表示向量的规则，可以理解为一个向量在xyz三个轴上的投影长度。\n\n一个人从A点移动到B点，移动距离是√2米，移动方向是x、y正半轴的角平分线。\n\n\n\nconst AB = new THREE.Vector3(1,1,0);\n\n\n\n# 总结：向量合成\n\n已知Vector3(1,1,0)表示的位移向量，合成向量的方式比较简单，把多个xyz三个分量首尾相接。\n\n\n\nconst AB = new THREE.Vector3(1,1,0);\n\n\n\n# 向量表示速度\n\n刚刚咱们通过位移介绍了向量的大小，可以表示两点之间的距离。大家都知道向量不仅仅可以表示人或物体的位移，也可以表示速度、加速度、力等物理量。\n\n下面以速度为例进一步介绍，向量的物理含义。\n\n假设一个人的运动速度大小是√2,方向是x和y正半轴的角平分线，那么人的速度向量分解为xyz三个方向，可以用向量THREE.Vector3(1, 1, 0)表示。\n\nconst v = new THREE.Vector3(1, 1, 0);\n\n\n\n# 速度向量长度.length()含义\n\n已知人速度向量THREE.Vector3(1, 1, 0)，那么它的物理含义就是方向是x、y正半轴的角平分线，大小√2米每秒。\n\n\n\nconst v = new THREE.Vector3(1, 1, 0);\n\n\n速度向量，包含人的方向信息，也包含人的速度快慢信息，如果想获取速度大小信息，可以通过向量长度方法.length()快速计算。\n\n// v表示速度向量，v的长度.length()是就是速度的大小\nconst v = new THREE.Vector3(1, 1, 0);\nconst vL = v.length();\nconsole.log('vL',vL);\n",normalizedContent:"# 向量大小(vector3长度.length())\n\n本节课给大家介绍下向量长度(大小)的概念，并使用three.js三维向量类vector3的方法.length()计算向量长度，比如通过.length()计算3d空间中两点之间的距离。\n\n为了让大家更容易理解向量长度的概念，更容易理解.length()方法，下面举一个具体的应用场景来讲解。\n\n\n# 人从a点移动到b点移动\n\n\n\n已知人在3d空间中，从a点移动到b点，a点坐标是(30,30,0)，b点坐标是(130,80,0)。\n\nvector3作为标量，表示人的起始点位置坐标。\n\nconst a = new three.vector3(30,30,0);// 人起点a\nconst b = new three.vector3(130,80,0);// 人运动结束点b\n\n\n\n# 计算ab两点之间距离(初高中数学)\n\n为什么在这里强调初高中数学，主要是因为总有学员咨询，自己数学基础不好，能学习threejs吗？入门的话，无所谓，进阶的话，如果数学基础很好，结合文档自学没啥压力，跟着课程更快点，如果数学基础不好，自学肯定比较困难，如果是跟着咱们系统课程数学进阶部分学习的话，会极大降低你学习难度和节约学习时间。\n\n沿着a点绘制一条平行于x轴的直线，沿着b点绘制一条平行于y轴的直线，两条直线交叉点是o，aob构成一个直角三角形。先不考虑z轴，三角形aob位于xoy平面上。用你初中学过的勾股定理就可以计算出来ab线段的长度，也是人从a点移动b点的距离。\n\n\n\nconst x1 = a.x;\nconst x2 = b.x;\nconst y1 = a.y;\nconst y2 = b.y;\nconst ao = x2-x1;\nconst bo = y2-y1;\n// 勾股定理计算三角形斜边长度(初中数学)\nconst l = math.sqrt(ao*ao + bo*bo);\n// 计算结果：50√5(111.803)\nconsole.log('l',l);\n\n\n把上面计算过程总结下，平面上两点距离计算公式\n\n\n\n推广到三维空间考虑x、y、z三个分量，和2d平面上长度计算逻辑是一样的，下面是3d空间两点之间距离公式(高中数学)\n\na和b两点的x、y、z分量分别相减，相减结果平方，然后相加，最后平方根，就是ab长度。\n\n\n\nconst a = new three.vector3(30, 30, 0);// 人起点a\nconst b = new three.vector3(130,80,0);// 人运动结束点b\n// 3d空间，a和b两点之间的距离\nconst l = math.sqrt(math.pow(b.x-a.x,2) + math.pow(b.y-a.y,2) + math.pow(b.z-a.z,2));\n\n\n\n# 向量vector3表示位移量(a到b的移动)\n\n从a点到b点的移动，可以用一个向量表示。\n\n\n\n已知人在3d空间中的坐标a点是(30,30,0),此人运动到b点(130,80,0)，已知ab在x轴上投影长度是100，y方向投影长度是50，这个变化可以用三维向量three.vector3(100,50,0)表示,换句话说，你也可以理解为人从a点开始，沿着x轴走了100，沿着y方向走了50，到达b点。\n\nconst a = new three.vector3(30, 30, 0);\nconst b = new three.vector3(130,80,0);\nconst ab = new three.vector3();\nab.x = b.x-a.x;\nab.y = b.y-a.y;\nab.z = b.z-a.z;\n\n\n\n# 向量减法运算.subvectors()\n\nab.subvectors(b,a);的含义表示b的xyz三个分量，与a的xyz三个分量分别相减，然后赋值给向量ab。\n\nconst a = new three.vector3(30, 30, 0);\nconst b = new three.vector3(130,80,0);\nconst ab = new three.vector3();\nab.subvectors(b,a);\n\n\n\n# 向量减法运算.sub()\n\nb.sub(a);表示b的xyz三个属性分别减去a的xyz三个属性，然后结果赋值给b自身的xyz属性\n\nb.sub(a);\nconsole.log('b',b);\n\n\n如果希望基于a和b两点位置，生成一个a指向b的向量，可以b克隆一个新对象，减去a。(如果b不克隆，b本身会被改变)\n\nconst ab = b.clone().sub(a);\nconsole.log('ab',ab);\n\n\n\n# 向量ab的物理含义\n\n * 方向\n * 长度(大小)\n\n向量ab包含了两层信息，一个是从a移动到b点的位移方向，另一层信息是ab两点的距离，你可以把ab两点之间的距离称为向量长度(大小)。\n\n\n\n总结：在该移动案例中，向量的长度就表示a和b两点之间的距离。\n\n\n# 向量长度.length()\n\nthreejs的类vector3的封装了一个方法.length()，用于计算向量长度。\n\n向量长度.length()的内部代码，本质上就是x、y、z三个分量平方和的平方根。\n\nconst ab = b.clone().sub(a);\nconst l = ab.length();\nconsole.log('l',l);\n\n\nb.clone().sub(a)和ab.length()本质上表达的计算过程，就是上面介绍的两点之间的距离公式。.sub()表示了xyz分量分别相减，.length()表示相减结果，平方和的平方根。\n\n\n\nab.length()计算的结果表示向量的长度，其实你对比下计算结果，就知道ab.length()计算的结果就表示a点到b点的距离。\n\n\n# 两点之间距离计算总结\n\n有了.sub()和.length()两个方法，两点之间距离计算，不需要自己写公式，直接用threejs封装好的向量长度方法.length()即可，也就是用threejs封装好的方法简化计算代码。\n\n\n\nconst a = new three.vector3(30, 30, 0);\nconst b = new three.vector3(130,80,0);\n// 两点坐标构建一个向量ab\nconst ab = b.clone().sub(a);\n// 向量长度表示ab两点距离\nconst l = ab.length();\nconsole.log('l',l);\n\n\n\n# 总结：向量分解为xyz三个方向\n\n在三维空间中一个向量，使用vector3()表示向量的规则，可以理解为一个向量在xyz三个轴上的投影长度。\n\n一个人从a点移动到b点，移动距离是√2米，移动方向是x、y正半轴的角平分线。\n\n\n\nconst ab = new three.vector3(1,1,0);\n\n\n\n# 总结：向量合成\n\n已知vector3(1,1,0)表示的位移向量，合成向量的方式比较简单，把多个xyz三个分量首尾相接。\n\n\n\nconst ab = new three.vector3(1,1,0);\n\n\n\n# 向量表示速度\n\n刚刚咱们通过位移介绍了向量的大小，可以表示两点之间的距离。大家都知道向量不仅仅可以表示人或物体的位移，也可以表示速度、加速度、力等物理量。\n\n下面以速度为例进一步介绍，向量的物理含义。\n\n假设一个人的运动速度大小是√2,方向是x和y正半轴的角平分线，那么人的速度向量分解为xyz三个方向，可以用向量three.vector3(1, 1, 0)表示。\n\nconst v = new three.vector3(1, 1, 0);\n\n\n\n# 速度向量长度.length()含义\n\n已知人速度向量three.vector3(1, 1, 0)，那么它的物理含义就是方向是x、y正半轴的角平分线，大小√2米每秒。\n\n\n\nconst v = new three.vector3(1, 1, 0);\n\n\n速度向量，包含人的方向信息，也包含人的速度快慢信息，如果想获取速度大小信息，可以通过向量长度方法.length()快速计算。\n\n// v表示速度向量，v的长度.length()是就是速度的大小\nconst v = new three.vector3(1, 1, 0);\nconst vl = v.length();\nconsole.log('vl',vl);\n",charsets:{cjk:!0}},{title:"4. 向量方向(归一化.normalize)",frontmatter:{title:"4. 向量方向(归一化.normalize)",date:"2023-06-03T21:27:53.000Z",permalink:"/pages/d69d76/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/01.1.%20%E6%95%B0%E5%AD%A6%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/04.%E5%90%91%E9%87%8F%E6%96%B9%E5%90%91(%E5%BD%92%E4%B8%80%E5%8C%96.normalize).html",relativePath:"02.Three.js进阶教程/01.1. 数学几何计算基础/04.向量方向(归一化.normalize).md",key:"v-b17d2f24",path:"/pages/d69d76/",headers:[{level:3,title:"单位向量",slug:"单位向量",normalizedTitle:"单位向量",charIndex:139},{level:3,title:"向量归一化.normalize()",slug:"向量归一化-normalize",normalizedTitle:"向量归一化.normalize()",charIndex:305},{level:3,title:"单位向量表示方向",slug:"单位向量表示方向",normalizedTitle:"单位向量表示方向",charIndex:874},{level:3,title:"物体沿着直线AB平移：单位向量表示平移方向",slug:"物体沿着直线ab平移-单位向量表示平移方向",normalizedTitle:"物体沿着直线ab平移：单位向量表示平移方向",charIndex:1126},{level:3,title:"用向量表示平移过程",slug:"用向量表示平移过程",normalizedTitle:"用向量表示平移过程",charIndex:1385},{level:3,title:"向量加法.add()平移网格模型Mesh",slug:"向量加法-add-平移网格模型mesh",normalizedTitle:"向量加法.add()平移网格模型mesh",charIndex:1692},{level:3,title:"平移方法.translateOnAxis()",slug:"平移方法-translateonaxis",normalizedTitle:"平移方法.translateonaxis()",charIndex:1845}],headersStr:"单位向量 向量归一化.normalize() 单位向量表示方向 物体沿着直线AB平移：单位向量表示平移方向 用向量表示平移过程 向量加法.add()平移网格模型Mesh 平移方法.translateOnAxis()",content:"# 向量方向(归一化.normalize)\n\n\n\n * 向量方向\n * 向量长度(大小)\n\n上节课重点介绍了向量的长度(大小)相关概念，以及Vector3的方法.length()，下面给大家介绍向量的方向。\n\n通过向量方向解决一个问题，让物体沿着某直线，平移一定距离。\n\n\n# 单位向量\n\n单位向量是向量长度.length()为1的向量。\n\n// 单位向量v\nconst v = new THREE.Vector3(1,0,0);\nconsole.log('向量长度',v.length());\n\n\n// 非单位向量dir\nconst dir = new THREE.Vector3(1,1,0);\n\n\n\n# 向量归一化.normalize()\n\n向量归一化，就是等比例缩放向量的xyz三个分量，缩放到向量长度.length()为1。\n\n\n\nconst dir = new THREE.Vector3(1, 1, 0);\ndir.normalize(); //向量归一化\n//Vector3(√2/2, √2/2, 0)   Vector3(0.707, 0.707, 0)\nconsole.log('dir',dir);\n\n\n自己写代码实现归一化。\n\nconst dir = new THREE.Vector3(1, 1, 0);\nconst L = dir.length();\n// 归一化：三个分量分别除以向量长度\ndir.x = dir.x / L;\ndir.y = dir.y / L;\ndir.z = dir.z / L;\n//Vector3(√2/2, √2/2, 0)   Vector3(0.707, 0.707, 0)\nconsole.log('dir',dir);\n\n\nconst dir = new THREE.Vector3(1, 1, 0);\nconst L = v.length();\ndir.multiplyScalar(1 / L);//归一化\n// dir.divideScalar(L);//归一化\n\n\n\n# 单位向量表示方向\n\n一般写代码时候，可以用归一化的向量表示向量的方向。\n\n\n\nAB表示A点到B点位移的向量，AB.normalize()归一化后，单位向量可以表示位移方向。\n\nconst AB = new THREE.Vector3(100, 50, 0);\nAB.normalize(); //向量归一化\n\n\n\n\n速度向量归一化后的单位向量，可以用来表示速度的方向。\n\nconst V = new THREE.Vector3(1, 1, 0);\nV.normalize(); //向量归一化\n\n\n\n# 物体沿着直线AB平移：单位向量表示平移方向\n\n已知直线AB上两个坐标，A点(-50,0,-50)、B点(100,0,100)。物体默认在A点，希望从A点开始沿着直线AB移动距离100。\n\n//直线上两点坐标A和B\nconst A = new THREE.Vector3(-50,0,-50);\nconst B = new THREE.Vector3(100,0,100);\nconst AB = B.clone().sub(A);//AB向量\nAB.normalize();//AB归一化表示直线AB的方向\n\n\n\n# 用向量表示平移过程\n\n单位向量AB的xyz每个分量分别乘以100，可以用来表示沿着AB直线平移100过程的向量。\n\nconst T =  AB.clone().multiplyScalar(100);\n\n\n验证：单位向量每个分量乘以100，得到的向量长度就是100，相当于得到一个沿着AB方向移动100的向量，这就是单位向量的意义，单位向量长度位1，乘以任何一个值S，就可以得到一个长度为S的向量。\n\n// 单位向量AB的xyz每个分量分别乘以100\nconst T =  AB.clone().multiplyScalar(100);\nconsole.log('向量T长度',T.length());\n\n\n\n# 向量加法.add()平移网格模型Mesh\n\n沿着AB方向平移平移物体mesh距离100非常简单，把mesh.position的xyz三个分量分别加上向量T的xyz分量即可。\n\n// mesh.position的xyz三个分量分别加上向量T的xyz分量\nmesh.position.add(T);\n\n\n\n# 平移方法.translateOnAxis()\n\n//沿着AB方向平移100\nmesh.translateOnAxis(AB, 100);\n",normalizedContent:"# 向量方向(归一化.normalize)\n\n\n\n * 向量方向\n * 向量长度(大小)\n\n上节课重点介绍了向量的长度(大小)相关概念，以及vector3的方法.length()，下面给大家介绍向量的方向。\n\n通过向量方向解决一个问题，让物体沿着某直线，平移一定距离。\n\n\n# 单位向量\n\n单位向量是向量长度.length()为1的向量。\n\n// 单位向量v\nconst v = new three.vector3(1,0,0);\nconsole.log('向量长度',v.length());\n\n\n// 非单位向量dir\nconst dir = new three.vector3(1,1,0);\n\n\n\n# 向量归一化.normalize()\n\n向量归一化，就是等比例缩放向量的xyz三个分量，缩放到向量长度.length()为1。\n\n\n\nconst dir = new three.vector3(1, 1, 0);\ndir.normalize(); //向量归一化\n//vector3(√2/2, √2/2, 0)   vector3(0.707, 0.707, 0)\nconsole.log('dir',dir);\n\n\n自己写代码实现归一化。\n\nconst dir = new three.vector3(1, 1, 0);\nconst l = dir.length();\n// 归一化：三个分量分别除以向量长度\ndir.x = dir.x / l;\ndir.y = dir.y / l;\ndir.z = dir.z / l;\n//vector3(√2/2, √2/2, 0)   vector3(0.707, 0.707, 0)\nconsole.log('dir',dir);\n\n\nconst dir = new three.vector3(1, 1, 0);\nconst l = v.length();\ndir.multiplyscalar(1 / l);//归一化\n// dir.dividescalar(l);//归一化\n\n\n\n# 单位向量表示方向\n\n一般写代码时候，可以用归一化的向量表示向量的方向。\n\n\n\nab表示a点到b点位移的向量，ab.normalize()归一化后，单位向量可以表示位移方向。\n\nconst ab = new three.vector3(100, 50, 0);\nab.normalize(); //向量归一化\n\n\n\n\n速度向量归一化后的单位向量，可以用来表示速度的方向。\n\nconst v = new three.vector3(1, 1, 0);\nv.normalize(); //向量归一化\n\n\n\n# 物体沿着直线ab平移：单位向量表示平移方向\n\n已知直线ab上两个坐标，a点(-50,0,-50)、b点(100,0,100)。物体默认在a点，希望从a点开始沿着直线ab移动距离100。\n\n//直线上两点坐标a和b\nconst a = new three.vector3(-50,0,-50);\nconst b = new three.vector3(100,0,100);\nconst ab = b.clone().sub(a);//ab向量\nab.normalize();//ab归一化表示直线ab的方向\n\n\n\n# 用向量表示平移过程\n\n单位向量ab的xyz每个分量分别乘以100，可以用来表示沿着ab直线平移100过程的向量。\n\nconst t =  ab.clone().multiplyscalar(100);\n\n\n验证：单位向量每个分量乘以100，得到的向量长度就是100，相当于得到一个沿着ab方向移动100的向量，这就是单位向量的意义，单位向量长度位1，乘以任何一个值s，就可以得到一个长度为s的向量。\n\n// 单位向量ab的xyz每个分量分别乘以100\nconst t =  ab.clone().multiplyscalar(100);\nconsole.log('向量t长度',t.length());\n\n\n\n# 向量加法.add()平移网格模型mesh\n\n沿着ab方向平移平移物体mesh距离100非常简单，把mesh.position的xyz三个分量分别加上向量t的xyz分量即可。\n\n// mesh.position的xyz三个分量分别加上向量t的xyz分量\nmesh.position.add(t);\n\n\n\n# 平移方法.translateonaxis()\n\n//沿着ab方向平移100\nmesh.translateonaxis(ab, 100);\n",charsets:{cjk:!0}},{title:"6. 箭头ArrowHelper",frontmatter:{title:"6. 箭头ArrowHelper",date:"2023-06-04T20:31:47.000Z",permalink:"/pages/e24048/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/01.1.%20%E6%95%B0%E5%AD%A6%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/06.%E7%AE%AD%E5%A4%B4ArrowHelper.html",relativePath:"02.Three.js进阶教程/01.1. 数学几何计算基础/06.箭头ArrowHelper.md",key:"v-1db0392e",path:"/pages/e24048/",headers:[{level:3,title:"两个小球可视化A、B两点位置",slug:"两个小球可视化a、b两点位置",normalizedTitle:"两个小球可视化a、b两点位置",charIndex:186},{level:3,title:"生成一个A指向B的箭头",slug:"生成一个a指向b的箭头",normalizedTitle:"生成一个a指向b的箭头",charIndex:761},{level:3,title:"箭头可视化一个立方体的法线方向",slug:"箭头可视化一个立方体的法线方向",normalizedTitle:"箭头可视化一个立方体的法线方向",charIndex:994},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1617}],headersStr:"两个小球可视化A、B两点位置 生成一个A指向B的箭头 箭头可视化一个立方体的法线方向 总结",content:"# 箭头ArrowHelper\n\n基础课程中给大家介绍过一个three.js辅助开发的类，就是xyz三维坐标系AxesHelper,这节课给大家介绍一个新的辅助类，three.js的箭头ArrowHelper。\n\n介绍ArrowHelper的目的是，后面几何计算的过程或结果，可以用ArrowHelper可视化表示出来，这样更容易理解抽象的概念或抽象的数学计算。\n\n\n# 两个小球可视化A、B两点位置\n\nconst A = new THREE.Vector3(0, 30, 0);//A点\nconst B = new THREE.Vector3(80, 0, 0);//B点\n\n// 绿色小球可视化A点位置\nconst AMesh = createSphereMesh(0x00ff00,2);\nAMesh.position.copy(A);\n// 红色小球可视化B点位置\nconst BMesh = createSphereMesh(0xff0000,2);\nBMesh.position.copy(B);\n\nconst group = new THREE.Group();\ngroup.add(AMesh,BMesh);\n\nfunction createSphereMesh(color,R) {\n    const geometry = new THREE.SphereGeometry(R);\n    const material = new THREE.MeshLambertMaterial({\n        color: color,\n    });\n    const mesh = new THREE.Mesh(geometry, material);\n    return mesh;\n}\n\n\n\n# 生成一个A指向B的箭头\n\n\n\n// 绘制一个从A指向B的箭头\nconst AB = B.clone().sub(A);\nconst L = AB.length();//AB长度\nconst dir = AB.clone().normalize();//单位向量表示AB方向\n\n// 生成箭头从A指向B\nconst arrowHelper = new THREE.ArrowHelper(dir, A, L)\ngroup.add(arrowHelper);\n\n\n\n# 箭头可视化一个立方体的法线方向\n\n\n\nconst geometry = new THREE.BoxGeometry(50, 50, 50);\nconst material = new THREE.MeshLambertMaterial({\n    color: 0x00ffff,\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\nconst p = mesh.geometry.attributes.position;\nconst n = mesh.geometry.attributes.normal;\nconst count = p.count;//顶点数量\nfor (let i = 0; i < count; i++) {\n    // 顶点位置O\n    const O = new THREE.Vector3(p.getX(i), p.getY(i), p.getZ(i));\n    // 顶点位置O对应的顶点法线\n    const dir = new THREE.Vector3(n.getX(i), n.getY(i), n.getZ(i));\n    // 箭头可视化顶点法线\n    const arrowHelper = new THREE.ArrowHelper(dir, O, 20);\n    mesh.add(arrowHelper);\n}\n\n\n\n# 总结\n\n一般做一些数学计算的时候，可以借助小球、箭头等方式可视化你的几何数据，通过具象的图像，有助于理解抽象的代码。",normalizedContent:"# 箭头arrowhelper\n\n基础课程中给大家介绍过一个three.js辅助开发的类，就是xyz三维坐标系axeshelper,这节课给大家介绍一个新的辅助类，three.js的箭头arrowhelper。\n\n介绍arrowhelper的目的是，后面几何计算的过程或结果，可以用arrowhelper可视化表示出来，这样更容易理解抽象的概念或抽象的数学计算。\n\n\n# 两个小球可视化a、b两点位置\n\nconst a = new three.vector3(0, 30, 0);//a点\nconst b = new three.vector3(80, 0, 0);//b点\n\n// 绿色小球可视化a点位置\nconst amesh = createspheremesh(0x00ff00,2);\namesh.position.copy(a);\n// 红色小球可视化b点位置\nconst bmesh = createspheremesh(0xff0000,2);\nbmesh.position.copy(b);\n\nconst group = new three.group();\ngroup.add(amesh,bmesh);\n\nfunction createspheremesh(color,r) {\n    const geometry = new three.spheregeometry(r);\n    const material = new three.meshlambertmaterial({\n        color: color,\n    });\n    const mesh = new three.mesh(geometry, material);\n    return mesh;\n}\n\n\n\n# 生成一个a指向b的箭头\n\n\n\n// 绘制一个从a指向b的箭头\nconst ab = b.clone().sub(a);\nconst l = ab.length();//ab长度\nconst dir = ab.clone().normalize();//单位向量表示ab方向\n\n// 生成箭头从a指向b\nconst arrowhelper = new three.arrowhelper(dir, a, l)\ngroup.add(arrowhelper);\n\n\n\n# 箭头可视化一个立方体的法线方向\n\n\n\nconst geometry = new three.boxgeometry(50, 50, 50);\nconst material = new three.meshlambertmaterial({\n    color: 0x00ffff,\n});\nconst mesh = new three.mesh(geometry, material);\n\nconst p = mesh.geometry.attributes.position;\nconst n = mesh.geometry.attributes.normal;\nconst count = p.count;//顶点数量\nfor (let i = 0; i < count; i++) {\n    // 顶点位置o\n    const o = new three.vector3(p.getx(i), p.gety(i), p.getz(i));\n    // 顶点位置o对应的顶点法线\n    const dir = new three.vector3(n.getx(i), n.gety(i), n.getz(i));\n    // 箭头可视化顶点法线\n    const arrowhelper = new three.arrowhelper(dir, o, 20);\n    mesh.add(arrowhelper);\n}\n\n\n\n# 总结\n\n一般做一些数学计算的时候，可以借助小球、箭头等方式可视化你的几何数据，通过具象的图像，有助于理解抽象的代码。",charsets:{cjk:!0}},{title:"5. 相机沿着视线方向运动",frontmatter:{title:"5. 相机沿着视线方向运动",date:"2023-06-04T20:31:23.000Z",permalink:"/pages/a5e313/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/01.1.%20%E6%95%B0%E5%AD%A6%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/05.%E7%9B%B8%E6%9C%BA%E6%B2%BF%E7%9D%80%E8%A7%86%E7%BA%BF%E6%96%B9%E5%90%91%E8%BF%90%E5%8A%A8.html",relativePath:"02.Three.js进阶教程/01.1. 数学几何计算基础/05.相机沿着视线方向运动.md",key:"v-9c41d56c",path:"/pages/a5e313/",headers:[{level:3,title:"单位向量表示相机视线方向",slug:"单位向量表示相机视线方向",normalizedTitle:"单位向量表示相机视线方向",charIndex:65},{level:3,title:"camera.getWorldDirection()获取相机视线方向",slug:"camera-getworlddirection-获取相机视线方向",normalizedTitle:"camera.getworlddirection()获取相机视线方向",charIndex:425},{level:3,title:"相机沿着视线方向平移",slug:"相机沿着视线方向平移",normalizedTitle:"相机沿着视线方向平移",charIndex:704},{level:3,title:"相机沿着视线移动动画(tweenjs库辅助)",slug:"相机沿着视线移动动画-tweenjs库辅助",normalizedTitle:"相机沿着视线移动动画(tweenjs库辅助)",charIndex:836},{level:3,title:"GUI沿着相机视线方向拖动相机平移",slug:"gui沿着相机视线方向拖动相机平移",normalizedTitle:"gui沿着相机视线方向拖动相机平移",charIndex:1381}],headersStr:"单位向量表示相机视线方向 camera.getWorldDirection()获取相机视线方向 相机沿着视线方向平移 相机沿着视线移动动画(tweenjs库辅助) GUI沿着相机视线方向拖动相机平移",content:"# 相机沿着视线方向运动\n\n利用上节课讲解的向量方向知识，写一个练习案例，就是three.js相机沿着自身视线方向运动。\n\n\n# 单位向量表示相机视线方向\n\n相机目标观察点，也就是lookAt参数，和相机位置相减,获得一个沿着相机视线方向的向量，然后归一化，就可以获取一个表示相机视线方向的单位向量。\n\ncamera.position.set(202, 123, 125);\ncamera.lookAt(0, 0, 0);\n// 相机目标观察点和相机位置相减,获得一个沿着相机视线方向的向量\nconst dir = new THREE.Vector3(0 - 202,0 - 123,0 - 125);\n// 归一化,获取一个表示相机视线方向的单位向量。\ndir.normalize();\n\n\n浏览器控制台查看计算结果\n\nconsole.log('相机方向',dir);\nconsole.log('单位向量',dir.length());\n\n\n\n# camera.getWorldDirection()获取相机视线方向\n\n你通过相机对象的.getWorldDirection()方法，可以快速获取一个沿着相机视线方向的单位向量，不需要自己写代码计算视线方向了，.getWorldDirection()方法进行了相关的封装。\n\nconst dir = new THREE.Vector3();\n// 获取相机的视线方向\ncamera.getWorldDirection(dir);\nconsole.log('相机方向',dir);\nconsole.log('单位向量',dir.length());\n\n\n\n# 相机沿着视线方向平移\n\n// dis向量表示相机沿着相机视线方向平移200的位移量\nconst dis = dir.clone().multiplyScalar(200);\n// 相机沿着视线方向平移\ncamera.position.add(dis);\n\n\n\n# 相机沿着视线移动动画(tweenjs库辅助)\n\n下面借助tweenjs动画库，写一个相机沿着相机视线方向移动的动画。前面基础内容中讲解过tweenjs的使用，学习下面内容之前，确保你已经熟悉tweenjs。\n\nimport TWEEN from '@tweenjs/tween.js';\n\n\n相机沿着视线方向移动的动画。\n\nconst dir = new THREE.Vector3();\ncamera.getWorldDirection(dir);// 获取相机的视线方向\n// dis表示相机沿着相机视线方向平移200\nconst dis = dir.clone().multiplyScalar(200);\n// 相机动画:平移前坐标——>平移后坐标\nnew TWEEN.Tween(camera.position)\n.to(camera.position.clone().add(dis), 3000)\n.start()\n\n\nfunction render() {\n    TWEEN.update();\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# GUI沿着相机视线方向拖动相机平移\n\n// 从threejs扩展库引入gui.js\nimport { GUI } from 'three/addons/libs/lil-gui.module.min.js';\n\n\nconst pos0 = camera.position.clone();//记录相机初始位置\nconst gui = new GUI();\n// L：相机沿着视线移动距离，从0~200\ngui.add({L: 0}, 'L', 0, 200).onChange(function(v){\n    const dis = dir.clone().multiplyScalar(v);//相机沿着视线偏移长度v\n    const newPos = pos0.clone().add(dis);//相机初始位置+相机偏移向量    \n    camera.position.copy(newPos);//新的位置赋值给相机位置\n});\n",normalizedContent:"# 相机沿着视线方向运动\n\n利用上节课讲解的向量方向知识，写一个练习案例，就是three.js相机沿着自身视线方向运动。\n\n\n# 单位向量表示相机视线方向\n\n相机目标观察点，也就是lookat参数，和相机位置相减,获得一个沿着相机视线方向的向量，然后归一化，就可以获取一个表示相机视线方向的单位向量。\n\ncamera.position.set(202, 123, 125);\ncamera.lookat(0, 0, 0);\n// 相机目标观察点和相机位置相减,获得一个沿着相机视线方向的向量\nconst dir = new three.vector3(0 - 202,0 - 123,0 - 125);\n// 归一化,获取一个表示相机视线方向的单位向量。\ndir.normalize();\n\n\n浏览器控制台查看计算结果\n\nconsole.log('相机方向',dir);\nconsole.log('单位向量',dir.length());\n\n\n\n# camera.getworlddirection()获取相机视线方向\n\n你通过相机对象的.getworlddirection()方法，可以快速获取一个沿着相机视线方向的单位向量，不需要自己写代码计算视线方向了，.getworlddirection()方法进行了相关的封装。\n\nconst dir = new three.vector3();\n// 获取相机的视线方向\ncamera.getworlddirection(dir);\nconsole.log('相机方向',dir);\nconsole.log('单位向量',dir.length());\n\n\n\n# 相机沿着视线方向平移\n\n// dis向量表示相机沿着相机视线方向平移200的位移量\nconst dis = dir.clone().multiplyscalar(200);\n// 相机沿着视线方向平移\ncamera.position.add(dis);\n\n\n\n# 相机沿着视线移动动画(tweenjs库辅助)\n\n下面借助tweenjs动画库，写一个相机沿着相机视线方向移动的动画。前面基础内容中讲解过tweenjs的使用，学习下面内容之前，确保你已经熟悉tweenjs。\n\nimport tween from '@tweenjs/tween.js';\n\n\n相机沿着视线方向移动的动画。\n\nconst dir = new three.vector3();\ncamera.getworlddirection(dir);// 获取相机的视线方向\n// dis表示相机沿着相机视线方向平移200\nconst dis = dir.clone().multiplyscalar(200);\n// 相机动画:平移前坐标——>平移后坐标\nnew tween.tween(camera.position)\n.to(camera.position.clone().add(dis), 3000)\n.start()\n\n\nfunction render() {\n    tween.update();\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# gui沿着相机视线方向拖动相机平移\n\n// 从threejs扩展库引入gui.js\nimport { gui } from 'three/addons/libs/lil-gui.module.min.js';\n\n\nconst pos0 = camera.position.clone();//记录相机初始位置\nconst gui = new gui();\n// l：相机沿着视线移动距离，从0~200\ngui.add({l: 0}, 'l', 0, 200).onchange(function(v){\n    const dis = dir.clone().multiplyscalar(v);//相机沿着视线偏移长度v\n    const newpos = pos0.clone().add(dis);//相机初始位置+相机偏移向量    \n    camera.position.copy(newpos);//新的位置赋值给相机位置\n});\n",charsets:{cjk:!0}},{title:"1. 匀速动画(向量表示速度)",frontmatter:{title:"1. 匀速动画(向量表示速度)",date:"2023-06-04T20:30:37.000Z",permalink:"/pages/e3f92b/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/02.2.%E4%BD%8D%E7%A7%BB%E3%80%81%E9%80%9F%E5%BA%A6%E3%80%81%E5%8A%A0%E9%80%9F%E5%BA%A6(%E5%90%91%E9%87%8F)/01.%E5%8C%80%E9%80%9F%E5%8A%A8%E7%94%BB(%E5%90%91%E9%87%8F%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6).html",relativePath:"02.Three.js进阶教程/02.2.位移、速度、加速度(向量)/01.匀速动画(向量表示速度).md",key:"v-8b41caee",path:"/pages/e3f92b/",headers:[{level:3,title:"向量表示物体速度",slug:"向量表示物体速度",normalizedTitle:"向量表示物体速度",charIndex:128},{level:3,title:"知识回顾",slug:"知识回顾",normalizedTitle:"知识回顾",charIndex:189},{level:3,title:"速度 x 时间计算位移",slug:"速度-x-时间计算位移",normalizedTitle:"速度 x 时间计算位移",charIndex:448},{level:3,title:"速度 x 间隔时间，然后累加计算位移",slug:"速度-x-间隔时间-然后累加计算位移",normalizedTitle:"速度 x 间隔时间，然后累加计算位移",charIndex:953}],headersStr:"向量表示物体速度 知识回顾 速度 x 时间计算位移 速度 x 间隔时间，然后累加计算位移",content:"# 匀速动画(向量表示速度)\n\n前面几节课给大家介绍过threejs的Vector3类可以表示物体的位置，也可以表示物体速度、位移等有方向的量。\n\n下面给写一个物体匀速运动的动画案例，已知物体的初始位置、物体的速度，然后写一个物体的运动动画效果。\n\n\n# 向量表示物体速度\n\nconst v = new THREE.Vector3(10,0,10);//物体运动速度\n\n\n\n# 知识回顾\n\n回顾下基础部分1.11动画渲染循环讲解过的知识点，通过Clock类计算渲染循环两帧渲染间隔时间。\n\nconst clock = new THREE.Clock();//时钟对象\n// 渲染循环\nfunction render() {\n    const spt = clock.getDelta();//两帧渲染时间间隔(秒)\n\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 速度 x 时间计算位移\n\nconst v = new THREE.Vector3(10, 0, 10);//物体运动速度\nconst clock = new THREE.Clock();//时钟对象\nlet t = 0;\nconst pos0 = mesh.position.clone();//物体初始位置\n// 渲染循环\nfunction render() {\n    const spt = clock.getDelta();//两帧渲染时间间隔(秒)\n    t += spt;\n    // 在t时间内，以速度v运动的位移量\n    const dis = v.clone().multiplyScalar(t);\n    // 网格模型初始位置加上t时间段内运动的位移量\n    const newPos = pos0.clone().add(dis);\n    mesh.position.copy(newPos);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n\n# 速度 x 间隔时间，然后累加计算位移\n\nconst v = new THREE.Vector3(10,0,10);//物体运动速度\nconst clock = new THREE.Clock();//时钟对象\n// 渲染循环\nfunction render() {\n    const spt = clock.getDelta();//两帧渲染时间间隔(秒)\n    // 在spt时间内，以速度v运动的位移量\n    const dis = v.clone().multiplyScalar(spt);\n    // 网格模型当前的位置加上spt时间段内运动的位移量\n    mesh.position.add(dis);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# 匀速动画(向量表示速度)\n\n前面几节课给大家介绍过threejs的vector3类可以表示物体的位置，也可以表示物体速度、位移等有方向的量。\n\n下面给写一个物体匀速运动的动画案例，已知物体的初始位置、物体的速度，然后写一个物体的运动动画效果。\n\n\n# 向量表示物体速度\n\nconst v = new three.vector3(10,0,10);//物体运动速度\n\n\n\n# 知识回顾\n\n回顾下基础部分1.11动画渲染循环讲解过的知识点，通过clock类计算渲染循环两帧渲染间隔时间。\n\nconst clock = new three.clock();//时钟对象\n// 渲染循环\nfunction render() {\n    const spt = clock.getdelta();//两帧渲染时间间隔(秒)\n\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 速度 x 时间计算位移\n\nconst v = new three.vector3(10, 0, 10);//物体运动速度\nconst clock = new three.clock();//时钟对象\nlet t = 0;\nconst pos0 = mesh.position.clone();//物体初始位置\n// 渲染循环\nfunction render() {\n    const spt = clock.getdelta();//两帧渲染时间间隔(秒)\n    t += spt;\n    // 在t时间内，以速度v运动的位移量\n    const dis = v.clone().multiplyscalar(t);\n    // 网格模型初始位置加上t时间段内运动的位移量\n    const newpos = pos0.clone().add(dis);\n    mesh.position.copy(newpos);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n\n# 速度 x 间隔时间，然后累加计算位移\n\nconst v = new three.vector3(10,0,10);//物体运动速度\nconst clock = new three.clock();//时钟对象\n// 渲染循环\nfunction render() {\n    const spt = clock.getdelta();//两帧渲染时间间隔(秒)\n    // 在spt时间内，以速度v运动的位移量\n    const dis = v.clone().multiplyscalar(spt);\n    // 网格模型当前的位置加上spt时间段内运动的位移量\n    mesh.position.add(dis);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"2. 物体下落动画(重力加速度)",frontmatter:{title:"2. 物体下落动画(重力加速度)",date:"2023-06-04T20:30:46.000Z",permalink:"/pages/27de57/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/02.2.%E4%BD%8D%E7%A7%BB%E3%80%81%E9%80%9F%E5%BA%A6%E3%80%81%E5%8A%A0%E9%80%9F%E5%BA%A6(%E5%90%91%E9%87%8F)/02.%E7%89%A9%E4%BD%93%E4%B8%8B%E8%90%BD%E5%8A%A8%E7%94%BB(%E9%87%8D%E5%8A%9B%E5%8A%A0%E9%80%9F%E5%BA%A6).html",relativePath:"02.Three.js进阶教程/02.2.位移、速度、加速度(向量)/02.物体下落动画(重力加速度).md",key:"v-41afb39f",path:"/pages/27de57/",headers:[{level:3,title:"已知条件",slug:"已知条件",normalizedTitle:"已知条件",charIndex:79},{level:3,title:"物理加速度位移公式x = vt + 1/2gt^2计算位置",slug:"物理加速度位移公式x-vt-1-2gt-2计算位置",normalizedTitle:"物理加速度位移公式x = vt + 1/2gt^2计算位置",charIndex:241},{level:3,title:"速度 x 间隔时间，然后累加计算位移",slug:"速度-x-间隔时间-然后累加计算位移",normalizedTitle:"速度 x 间隔时间，然后累加计算位移",charIndex:1142},{level:3,title:"斜向上抛出去物体",slug:"斜向上抛出去物体",normalizedTitle:"斜向上抛出去物体",charIndex:1876}],headersStr:"已知条件 物理加速度位移公式x = vt + 1/2gt^2计算位置 速度 x 间隔时间，然后累加计算位移 斜向上抛出去物体",content:"# 物体下落动画(重力加速度)\n\n本节课给大家讲解一个物体抛出去落在地面的动画效果，注意学习本节课内容之前，确保你已经掌握上节课关于匀速动画的讲解。\n\n\n# 已知条件\n\n// 物体初始位置\nmesh.position.set(0,100,0);\n\n\n//物体初始速度\nconst v = new THREE.Vector3(30,0,0);\n\n\n重力加速度是y轴的负方向\n\n//重力加速度\nconst g = new THREE.Vector3(0, -9.8, 0);\n\n\n\n# 物理加速度位移公式x = vt + 1/2gt^2计算位置\n\n下面用three.js向量代码表示物理加速度的位移公式，如果你已经忘了高中物理知识，也没关系，也不用记忆，咱们的重点在于用threejs向量表达上面公式。\n\nconst v = new THREE.Vector3(30, 0, 0);//物体运动速度\nconst clock = new THREE.Clock();//时钟对象\nlet t = 0;\nconst g = new THREE.Vector3(0, -9.8, 0);\nconst pos0 = mesh.position.clone();\n// 渲染循环\nfunction render() {\n    const spt = clock.getDelta();//两帧渲染时间间隔(秒)\n    t += spt;\n    // 在t时间内，以速度v运动的位移量\n    const dis = v.clone().multiplyScalar(t).add(g.clone().multiplyScalar(0.5 * t * t));\n    // 网格模型当前的位置加上spt时间段内运动的位移量\n    const newPos = pos0.clone().add(dis);\n    mesh.position.copy(newPos);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n物体接触地面后，停止运动，不在进行下落计算。\n\n// 渲染循环\nfunction render() {\n    if (mesh.position.y > 0) {\n        ...\n        mesh.position.copy(newPos);\n    }\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 速度 x 间隔时间，然后累加计算位移\n\n * 速度v = 加速度g x 时间t\n\n * 位移x = 速度v x 时间t\n\n重力加速度乘以每次渲染时间，与原来的速度累加，可以更新当前的速度。\n\n位移写法和上节课类似，就是当前速度乘以每次渲染时间，累加即可。\n\nconst v = new THREE.Vector3(30, 0, 0);//物体初始速度\nconst clock = new THREE.Clock();//时钟对象\nconst g = new THREE.Vector3(0, -9.8, 0);\n// 渲染循环\nfunction render() {\n    if (mesh.position.y > 0) {\n        const spt = clock.getDelta();//两帧渲染时间间隔(秒)\n        //spV:重力加速度在时间spt内对速度的改变\n        const spV = g.clone().multiplyScalar(spt);\n        v.add(spV);//v = v + spV  更新当前速度\n        // 在spt时间内，以速度v运动的位移量\n        const dis = v.clone().multiplyScalar(spt);\n        // 网格模型当前的位置加上spt时间段内运动的位移量\n        mesh.position.add(dis);\n    }\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 斜向上抛出去物体\n\n你可以更改初速度，观察物体的运动轨迹效果\n\n//物体初始速度\nconst v = new THREE.Vector3(30, 20, 0);\n",normalizedContent:"# 物体下落动画(重力加速度)\n\n本节课给大家讲解一个物体抛出去落在地面的动画效果，注意学习本节课内容之前，确保你已经掌握上节课关于匀速动画的讲解。\n\n\n# 已知条件\n\n// 物体初始位置\nmesh.position.set(0,100,0);\n\n\n//物体初始速度\nconst v = new three.vector3(30,0,0);\n\n\n重力加速度是y轴的负方向\n\n//重力加速度\nconst g = new three.vector3(0, -9.8, 0);\n\n\n\n# 物理加速度位移公式x = vt + 1/2gt^2计算位置\n\n下面用three.js向量代码表示物理加速度的位移公式，如果你已经忘了高中物理知识，也没关系，也不用记忆，咱们的重点在于用threejs向量表达上面公式。\n\nconst v = new three.vector3(30, 0, 0);//物体运动速度\nconst clock = new three.clock();//时钟对象\nlet t = 0;\nconst g = new three.vector3(0, -9.8, 0);\nconst pos0 = mesh.position.clone();\n// 渲染循环\nfunction render() {\n    const spt = clock.getdelta();//两帧渲染时间间隔(秒)\n    t += spt;\n    // 在t时间内，以速度v运动的位移量\n    const dis = v.clone().multiplyscalar(t).add(g.clone().multiplyscalar(0.5 * t * t));\n    // 网格模型当前的位置加上spt时间段内运动的位移量\n    const newpos = pos0.clone().add(dis);\n    mesh.position.copy(newpos);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n物体接触地面后，停止运动，不在进行下落计算。\n\n// 渲染循环\nfunction render() {\n    if (mesh.position.y > 0) {\n        ...\n        mesh.position.copy(newpos);\n    }\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 速度 x 间隔时间，然后累加计算位移\n\n * 速度v = 加速度g x 时间t\n\n * 位移x = 速度v x 时间t\n\n重力加速度乘以每次渲染时间，与原来的速度累加，可以更新当前的速度。\n\n位移写法和上节课类似，就是当前速度乘以每次渲染时间，累加即可。\n\nconst v = new three.vector3(30, 0, 0);//物体初始速度\nconst clock = new three.clock();//时钟对象\nconst g = new three.vector3(0, -9.8, 0);\n// 渲染循环\nfunction render() {\n    if (mesh.position.y > 0) {\n        const spt = clock.getdelta();//两帧渲染时间间隔(秒)\n        //spv:重力加速度在时间spt内对速度的改变\n        const spv = g.clone().multiplyscalar(spt);\n        v.add(spv);//v = v + spv  更新当前速度\n        // 在spt时间内，以速度v运动的位移量\n        const dis = v.clone().multiplyscalar(spt);\n        // 网格模型当前的位置加上spt时间段内运动的位移量\n        mesh.position.add(dis);\n    }\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 斜向上抛出去物体\n\n你可以更改初速度，观察物体的运动轨迹效果\n\n//物体初始速度\nconst v = new three.vector3(30, 20, 0);\n",charsets:{cjk:!0}},{title:"1. 向量点乘dot",frontmatter:{title:"1. 向量点乘dot",date:"2023-06-05T18:43:41.000Z",permalink:"/pages/44b0ba/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/01.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98dot.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/01.向量点乘dot.md",key:"v-57df0166",path:"/pages/44b0ba/",headers:[{level:3,title:"已知向量a和向量b",slug:"已知向量a和向量b",normalizedTitle:"已知向量a和向量b",charIndex:184},{level:3,title:"向量点乘.dot()语法",slug:"向量点乘-dot-语法",normalizedTitle:"向量点乘.dot()语法",charIndex:300},{level:3,title:"点乘.dot()几何含义",slug:"点乘-dot-几何含义",normalizedTitle:"点乘.dot()几何含义",charIndex:456},{level:3,title:"单位向量点乘含义(计算向量夹角余弦值)",slug:"单位向量点乘含义-计算向量夹角余弦值",normalizedTitle:"单位向量点乘含义(计算向量夹角余弦值)",charIndex:722},{level:3,title:"夹角余弦值转角度值",slug:"夹角余弦值转角度值",normalizedTitle:"夹角余弦值转角度值",charIndex:1066}],headersStr:"已知向量a和向量b 向量点乘.dot()语法 点乘.dot()几何含义 单位向量点乘含义(计算向量夹角余弦值) 夹角余弦值转角度值",content:"# 向量点乘.dot()\n\n百科词条你可以看到关于点乘的介绍，不过这些理论不要求你掌握，换句话说，你有没有相关的数学基础，都不影响本节课内容的学习。\n\n点乘是向量的一种运算规则，点乘也有其它称呼，比如点积、数量积、标量积。\n\nthreejs三维向量Vector3封装了一个点乘相关的方法.dot()，本节课主要目的就是让大家能够灵活应用点乘方法.dot()。\n\n\n# 已知向量a和向量b\n\n已知两个向量a和b，默认夹角是45度。\n\nconst a = new THREE.Vector3(10, 10, 0);\nconst b = new THREE.Vector3(20, 0, 0);\n\n\n\n# 向量点乘.dot()语法\n\n下面先给大家说下点乘.dot()的语法，然后再讲解它的用途。\n\na.dot(b)表示向量a与向量b点乘，返回结果是一个数字(标量)。\n\n//向量a与向量b点乘，返回结果是一个数字\nconst dot = a.dot(b);\nconsole.log('点乘结果',dot);\n\n\n\n# 点乘.dot()几何含义\n\n\n\n你只需要记住a.dot(b)的几何含义是向量a在向量b上投影长度与向量b相乘，或者说向量a长度 * 向量b长度 * cos(ab夹角)。\n\nconst a = new THREE.Vector3(10, 10, 0);\nconst b = new THREE.Vector3(20, 0, 0);\n// dot几何含义：向量a长度 * 向量b长度 * cos(ab夹角)\nconst dot = a.dot(b);\nconsole.log('点乘结果',dot);//判断结果是不是200\n\n\n\n# 单位向量点乘含义(计算向量夹角余弦值)\n\n假设两个向量的夹角是θ，两个向量的单位向量进行点乘.dot()，返回的结果就是夹角θ的余弦值cos(θ)\n\n\n\nconst a = new THREE.Vector3(10, 10, 0);\nconst b = new THREE.Vector3(20, 0, 0);\n// a、b向量归一化后点乘\nconst cos =  a.normalize().dot(b.normalize());\nconsole.log('向量夹角余弦值',cos);\n\n\n如果不希望向量a和b被改变，注意克隆.clone()\n\nconst cos =  a.clone().normalize().dot(b.clone().normalize());\n\n\n\n# 夹角余弦值转角度值\n\n//反余弦计算向量夹角弧度\nconst rad = Math.acos(cos);\n\n\n// 弧度转角度\nconst angle = THREE.MathUtils.radToDeg(rad);\nconsole.log('向量夹角角度值',angle);\n\n\n修改向量a和b垂直，验证下，代码计算夹角是否正确。\n\nconst a = new THREE.Vector3(0, 10, 0);\nconst b = new THREE.Vector3(20, 0, 0);\n// 打印结果90度\nconsole.log('向量夹角角度值',angle);\n\n\n向量相反方向，夹角180度\n\nconst a = new THREE.Vector3(-10, 0, 0);\nconst b = new THREE.Vector3(20, 0, 0);\n\n\n向量同一个方向，夹角0度。\n\nconst a = new THREE.Vector3(10, 0, 0);\nconst b = new THREE.Vector3(20, 0, 0);\n",normalizedContent:"# 向量点乘.dot()\n\n百科词条你可以看到关于点乘的介绍，不过这些理论不要求你掌握，换句话说，你有没有相关的数学基础，都不影响本节课内容的学习。\n\n点乘是向量的一种运算规则，点乘也有其它称呼，比如点积、数量积、标量积。\n\nthreejs三维向量vector3封装了一个点乘相关的方法.dot()，本节课主要目的就是让大家能够灵活应用点乘方法.dot()。\n\n\n# 已知向量a和向量b\n\n已知两个向量a和b，默认夹角是45度。\n\nconst a = new three.vector3(10, 10, 0);\nconst b = new three.vector3(20, 0, 0);\n\n\n\n# 向量点乘.dot()语法\n\n下面先给大家说下点乘.dot()的语法，然后再讲解它的用途。\n\na.dot(b)表示向量a与向量b点乘，返回结果是一个数字(标量)。\n\n//向量a与向量b点乘，返回结果是一个数字\nconst dot = a.dot(b);\nconsole.log('点乘结果',dot);\n\n\n\n# 点乘.dot()几何含义\n\n\n\n你只需要记住a.dot(b)的几何含义是向量a在向量b上投影长度与向量b相乘，或者说向量a长度 * 向量b长度 * cos(ab夹角)。\n\nconst a = new three.vector3(10, 10, 0);\nconst b = new three.vector3(20, 0, 0);\n// dot几何含义：向量a长度 * 向量b长度 * cos(ab夹角)\nconst dot = a.dot(b);\nconsole.log('点乘结果',dot);//判断结果是不是200\n\n\n\n# 单位向量点乘含义(计算向量夹角余弦值)\n\n假设两个向量的夹角是θ，两个向量的单位向量进行点乘.dot()，返回的结果就是夹角θ的余弦值cos(θ)\n\n\n\nconst a = new three.vector3(10, 10, 0);\nconst b = new three.vector3(20, 0, 0);\n// a、b向量归一化后点乘\nconst cos =  a.normalize().dot(b.normalize());\nconsole.log('向量夹角余弦值',cos);\n\n\n如果不希望向量a和b被改变，注意克隆.clone()\n\nconst cos =  a.clone().normalize().dot(b.clone().normalize());\n\n\n\n# 夹角余弦值转角度值\n\n//反余弦计算向量夹角弧度\nconst rad = math.acos(cos);\n\n\n// 弧度转角度\nconst angle = three.mathutils.radtodeg(rad);\nconsole.log('向量夹角角度值',angle);\n\n\n修改向量a和b垂直，验证下，代码计算夹角是否正确。\n\nconst a = new three.vector3(0, 10, 0);\nconst b = new three.vector3(20, 0, 0);\n// 打印结果90度\nconsole.log('向量夹角角度值',angle);\n\n\n向量相反方向，夹角180度\n\nconst a = new three.vector3(-10, 0, 0);\nconst b = new three.vector3(20, 0, 0);\n\n\n向量同一个方向，夹角0度。\n\nconst a = new three.vector3(10, 0, 0);\nconst b = new three.vector3(20, 0, 0);\n",charsets:{cjk:!0}},{title:"2. 点乘练习-计算三角形夹角",frontmatter:{title:"2. 点乘练习-计算三角形夹角",date:"2023-06-05T18:43:50.000Z",permalink:"/pages/acc4b8/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/02.%E7%82%B9%E4%B9%98%E7%BB%83%E4%B9%A0-%E8%AE%A1%E7%AE%97%E4%B8%89%E8%A7%92%E5%BD%A2%E5%A4%B9%E8%A7%92.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/02.点乘练习-计算三角形夹角.md",key:"v-7d387f1c",path:"/pages/acc4b8/",headers:[{level:3,title:"已知三角形",slug:"已知三角形",normalizedTitle:"已知三角形",charIndex:85},{level:3,title:"三角形两条边构建向量",slug:"三角形两条边构建向量",normalizedTitle:"三角形两条边构建向量",charIndex:286},{level:3,title:"单位向量点乘.dot()计算夹角余弦值",slug:"单位向量点乘-dot-计算夹角余弦值",normalizedTitle:"单位向量点乘.dot()计算夹角余弦值",charIndex:442},{level:3,title:"夹角余弦值转角度值",slug:"夹角余弦值转角度值",normalizedTitle:"夹角余弦值转角度值",charIndex:600},{level:3,title:"注意向量方向对夹角计算的影响",slug:"注意向量方向对夹角计算的影响",normalizedTitle:"注意向量方向对夹角计算的影响",charIndex:742}],headersStr:"已知三角形 三角形两条边构建向量 单位向量点乘.dot()计算夹角余弦值 夹角余弦值转角度值 注意向量方向对夹角计算的影响",content:"# 点乘练习-计算三角形夹角\n\n上节课给介绍过threejs向量点乘方法.dot()，下面就应用点乘知识点，做一个案例练习，就是计算一个三角形的夹角角度值。\n\n\n\n\n# 已知三角形\n\n已知三角形三个顶点的坐标，计算其中一个顶点p1对应角度余弦值。\n\n// 三角形的三个点坐标p1，p2，p3\nconst p1 = new THREE.Vector3(0,0,0);// 点1坐标\nconst p2 = new THREE.Vector3(20,0,0);// 点2坐标\nconst p3 = new THREE.Vector3(10,10,0);// 点3坐标\n\n\n\n# 三角形两条边构建向量\n\n目标是计算p1点对应的角度值，所以使用另外两点p2、p3分别与点p1构建向量。\n\n// p1，p3两个点确定一个向量\nconst a = p3.clone().sub(p1);\n// p1，p2两个点确定一个向量\nconst b = p2.clone().sub(p1);\n\n\n\n\n\n# 单位向量点乘.dot()计算夹角余弦值\n\n\n\n利用上节课的结论，向量a、b归一化.normalize()变成单位向量后，再进行点乘.dot()，结果就是向量a和b夹角对应余弦值。\n\n// a、b向量归一化后点乘\nconst cos =  a.normalize().dot(b.normalize());\n\n\n\n# 夹角余弦值转角度值\n\n//反余弦计算向量夹角弧度\nconst rad = Math.acos(cos);\n// 弧度转角度\nconst angle = THREE.MathUtils.radToDeg(rad);\nconsole.log('向量夹角角度值',angle);\n\n\n\n# 注意向量方向对夹角计算的影响\n\n\n\n原来向量a和b的夹角45度\n\nconst a = p3.clone().sub(p1);//与b夹角45度\nconst b = p2.clone().sub(p1);\n\n\n改变向量p1、p3减法顺序，也就是使用p1.clone().sub(p3)代替原来p3.clone().sub(p1)，这样向量a就该变为相反的方向，重新计算角度值，a和b的夹角从45度变为135度。\n\nconst a = p1.clone().sub(p3);//与b夹角135度\nconst b = p2.clone().sub(p1);\n\n\n如果向量a和b反向都反过来，计算结果还是45度\n\nconst a = p1.clone().sub(p3);//与b夹角45度\nconst b = p1.clone().sub(p2);\n",normalizedContent:"# 点乘练习-计算三角形夹角\n\n上节课给介绍过threejs向量点乘方法.dot()，下面就应用点乘知识点，做一个案例练习，就是计算一个三角形的夹角角度值。\n\n\n\n\n# 已知三角形\n\n已知三角形三个顶点的坐标，计算其中一个顶点p1对应角度余弦值。\n\n// 三角形的三个点坐标p1，p2，p3\nconst p1 = new three.vector3(0,0,0);// 点1坐标\nconst p2 = new three.vector3(20,0,0);// 点2坐标\nconst p3 = new three.vector3(10,10,0);// 点3坐标\n\n\n\n# 三角形两条边构建向量\n\n目标是计算p1点对应的角度值，所以使用另外两点p2、p3分别与点p1构建向量。\n\n// p1，p3两个点确定一个向量\nconst a = p3.clone().sub(p1);\n// p1，p2两个点确定一个向量\nconst b = p2.clone().sub(p1);\n\n\n\n\n\n# 单位向量点乘.dot()计算夹角余弦值\n\n\n\n利用上节课的结论，向量a、b归一化.normalize()变成单位向量后，再进行点乘.dot()，结果就是向量a和b夹角对应余弦值。\n\n// a、b向量归一化后点乘\nconst cos =  a.normalize().dot(b.normalize());\n\n\n\n# 夹角余弦值转角度值\n\n//反余弦计算向量夹角弧度\nconst rad = math.acos(cos);\n// 弧度转角度\nconst angle = three.mathutils.radtodeg(rad);\nconsole.log('向量夹角角度值',angle);\n\n\n\n# 注意向量方向对夹角计算的影响\n\n\n\n原来向量a和b的夹角45度\n\nconst a = p3.clone().sub(p1);//与b夹角45度\nconst b = p2.clone().sub(p1);\n\n\n改变向量p1、p3减法顺序，也就是使用p1.clone().sub(p3)代替原来p3.clone().sub(p1)，这样向量a就该变为相反的方向，重新计算角度值，a和b的夹角从45度变为135度。\n\nconst a = p1.clone().sub(p3);//与b夹角135度\nconst b = p2.clone().sub(p1);\n\n\n如果向量a和b反向都反过来，计算结果还是45度\n\nconst a = p1.clone().sub(p3);//与b夹角45度\nconst b = p1.clone().sub(p2);\n",charsets:{cjk:!0}},{title:"3. 点乘判断物体在人前或人后",frontmatter:{title:"3. 点乘判断物体在人前或人后",date:"2023-06-05T22:53:58.000Z",permalink:"/pages/d32e58/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/03.%E7%82%B9%E4%B9%98%E5%88%A4%E6%96%AD%E7%89%A9%E4%BD%93%E5%9C%A8%E4%BA%BA%E5%89%8D%E6%88%96%E4%BA%BA%E5%90%8E.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/03.点乘判断物体在人前或人后.md",key:"v-6333d9f8",path:"/pages/d32e58/",headers:[{level:3,title:"已知条件",slug:"已知条件",normalizedTitle:"已知条件",charIndex:64},{level:3,title:"创建一个人指向物体的向量",slug:"创建一个人指向物体的向量",normalizedTitle:"创建一个人指向物体的向量",charIndex:230},{level:3,title:"向量夹角与人前后关系判断",slug:"向量夹角与人前后关系判断",normalizedTitle:"向量夹角与人前后关系判断",charIndex:327},{level:3,title:"0~180度三角函数余弦值规律",slug:"_0-180度三角函数余弦值规律",normalizedTitle:"0~180度三角函数余弦值规律",charIndex:621},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:678},{level:3,title:"调整物体到人后面测试代码",slug:"调整物体到人后面测试代码",normalizedTitle:"调整物体到人后面测试代码",charIndex:998}],headersStr:"已知条件 创建一个人指向物体的向量 向量夹角与人前后关系判断 0~180度三角函数余弦值规律 总结 调整物体到人后面测试代码",content:"# 点乘判断物体在人前或人后\n\n通过three.js向量Vector3点乘方法.dot()判断物体在人的前面还是后面。\n\n\n# 已知条件\n\n人的正前方沿着z轴负半轴方向\n\n// a向量：人的正前方沿着z轴负半轴\nconst a = new THREE.Vector3(0,0,-1);\n\n\n人的位置和物体的位置\n\nperson.position.set(0,0,2);//人位置\nmesh.position.set(2,0,-3);//物体位置\n\n\n\n\n\n# 创建一个人指向物体的向量\n\n物体坐标减去人坐标，创建一个人指向物体的向量\n\nconst b = mesh.position.clone().sub(person.position);\n\n\n\n# 向量夹角与人前后关系判断\n\n// a向量：人的正前方\nconst a = new THREE.Vector3(0,0,-1);\n// 人指向物体的向量\nconst b = mesh.position.clone().sub(person.position);\n\n\n物体绕着人360挪动位置，你创建不同位置人指向物体的向量b，你会发现向量b与向量a的夹角处于0~180度之间。\n\n\n\n0 ~ 90度：物体在人的前方,人指向物体的向量b与人正前方向量a夹角处于0 ~ 90之间。\n\n90 ~ 180度：物体在人的后方，人指向物体的向量b与人正前方向量a夹角处于90 ~ 180之间。\n\n\n# 0~180度三角函数余弦值规律\n\n * 0~90度，余弦值大于0\n * 90~180度，余弦值小于0\n\n\n\n\n# 总结\n\n\n\n向量a和b夹角，在0~180度的范围内的前提下：\n\n当a和b点乘a.dot(b)大于0,意味着cos(θ)大于0，cos(θ)大于0意味着夹角θ是0~90度，θ是0~90度说明物体在人的前方。\n\na和b点乘a.dot(b)小于0,意味着cos(θ)小于0，0~180度的范围内，cos(θ)小于0，意味着夹角θ是90~180度，θ是90~180度说明物体在人的后方。\n\nconst dot = a.dot(b);//向量a和b点乘\nif (dot > 0) {\n    console.log('物体在人前面');\n} else if (dot < 0) {\n    console.log('物体在人后面');\n}\n\n\n\n# 调整物体到人后面测试代码\n\n调整物体挪到人后面测试代码判断是否正确\n\nmesh.position.set(2, 0, 5);\n",normalizedContent:"# 点乘判断物体在人前或人后\n\n通过three.js向量vector3点乘方法.dot()判断物体在人的前面还是后面。\n\n\n# 已知条件\n\n人的正前方沿着z轴负半轴方向\n\n// a向量：人的正前方沿着z轴负半轴\nconst a = new three.vector3(0,0,-1);\n\n\n人的位置和物体的位置\n\nperson.position.set(0,0,2);//人位置\nmesh.position.set(2,0,-3);//物体位置\n\n\n\n\n\n# 创建一个人指向物体的向量\n\n物体坐标减去人坐标，创建一个人指向物体的向量\n\nconst b = mesh.position.clone().sub(person.position);\n\n\n\n# 向量夹角与人前后关系判断\n\n// a向量：人的正前方\nconst a = new three.vector3(0,0,-1);\n// 人指向物体的向量\nconst b = mesh.position.clone().sub(person.position);\n\n\n物体绕着人360挪动位置，你创建不同位置人指向物体的向量b，你会发现向量b与向量a的夹角处于0~180度之间。\n\n\n\n0 ~ 90度：物体在人的前方,人指向物体的向量b与人正前方向量a夹角处于0 ~ 90之间。\n\n90 ~ 180度：物体在人的后方，人指向物体的向量b与人正前方向量a夹角处于90 ~ 180之间。\n\n\n# 0~180度三角函数余弦值规律\n\n * 0~90度，余弦值大于0\n * 90~180度，余弦值小于0\n\n\n\n\n# 总结\n\n\n\n向量a和b夹角，在0~180度的范围内的前提下：\n\n当a和b点乘a.dot(b)大于0,意味着cos(θ)大于0，cos(θ)大于0意味着夹角θ是0~90度，θ是0~90度说明物体在人的前方。\n\na和b点乘a.dot(b)小于0,意味着cos(θ)小于0，0~180度的范围内，cos(θ)小于0，意味着夹角θ是90~180度，θ是90~180度说明物体在人的后方。\n\nconst dot = a.dot(b);//向量a和b点乘\nif (dot > 0) {\n    console.log('物体在人前面');\n} else if (dot < 0) {\n    console.log('物体在人后面');\n}\n\n\n\n# 调整物体到人后面测试代码\n\n调整物体挪到人后面测试代码判断是否正确\n\nmesh.position.set(2, 0, 5);\n",charsets:{cjk:!0}},{title:"4. 点乘判断是否在扇形内",frontmatter:{title:"4. 点乘判断是否在扇形内",date:"2023-06-06T15:40:10.000Z",permalink:"/pages/feb38e/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/04.%E7%82%B9%E4%B9%98%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%9C%A8%E6%89%87%E5%BD%A2%E5%86%85.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/04.点乘判断是否在扇形内.md",key:"v-0a966bc7",path:"/pages/feb38e/",headers:[{level:3,title:"已知条件",slug:"已知条件",normalizedTitle:"已知条件",charIndex:72},{level:3,title:"先通过人与物体距离排除，物体不在扇形范围内情况",slug:"先通过人与物体距离排除-物体不在扇形范围内情况",normalizedTitle:"先通过人与物体距离排除，物体不在扇形范围内情况",charIndex:318},{level:3,title:"角度θ在0 ~ 180度余弦值规律",slug:"角度θ在0-180度余弦值规律",normalizedTitle:"角度θ在0 ~ 180度余弦值规律",charIndex:601},{level:3,title:"比较夹角余弦值大小判断物体是否在扇形内",slug:"比较夹角余弦值大小判断物体是否在扇形内",normalizedTitle:"比较夹角余弦值大小判断物体是否在扇形内",charIndex:740}],headersStr:"已知条件 先通过人与物体距离排除，物体不在扇形范围内情况 角度θ在0 ~ 180度余弦值规律 比较夹角余弦值大小判断物体是否在扇形内",content:"# 点乘判断是否在扇形内\n\n通过three.js向量Vector3点乘方法.dot()判断一个点(物体)是否在人前方的扇形范围内。\n\n\n\n\n# 已知条件\n\n判断一个点(物体)是否在人前方扇形范围内(半径R、扇形角度angle)。\n\n// 已知数据\nperson.position.set(0, 0, 2);//人位置\nmesh.position.set(2, 0, -3);//物体位置\n// a向量：人的正前方沿着z轴负半轴\nconst a = new THREE.Vector3(0, 0, -1);\n// 扇形范围\nconst R = 20;//人前方扇形半径\nconst angle = 60;//人前方扇形角度\n\n\n\n\n\n# 先通过人与物体距离排除，物体不在扇形范围内情况\n\n计算物体与人的距离\n\n// 物体坐标减去人坐标，创建一个人指向物体的向量\nconst b = mesh.position.clone().sub(person.position);\nconst L = b.length();//物体与人的距离\n\n\n比较距离L与扇形半径的关系，排除物体不在扇形范围内的情况。\n\nif (L < R) {//物体与人的距离在半径R以内\n    console.log('物体与人距离小于扇形半径');\n}else{\n    console.log('不在扇形区域内');\n}\n\n\n\n# 角度θ在0 ~ 180度余弦值规律\n\n上节课给大家总结过，人指向物体的向量b和表示人正前方的向量a加载在0~180度之间\n\n\n\n角度θ在0 ~ 180度范围内，随着θ度数的增加，角度θ余弦值cos(θ)下降。换句话说，向量b与向量a夹角越小，对应的余弦值越大。\n\n\n\n\n\n\n# 比较夹角余弦值大小判断物体是否在扇形内\n\n\n\n向量点乘a.dot(b)点乘计算向量a和b的夹角余弦值cos。\n\nb.normalize();//归一化\nconst cos = a.dot(b);//向量a和b夹角余弦值\n\n\n在扇形范围内，从人所在位置，向外沿着扇形半径方向绘制向量c，你会发现向量c与向量a最大夹角就是扇形角度一半。\n\n// 角度转弧度\nconst rad = THREE.MathUtils.degToRad(angle);\n// 扇形角度一半的余弦值\nconst rangeCos = Math.cos(rad / 2)\n\n\n比较向量a、b夹角余弦值cos和扇形角度一半的余弦值rangeCos大小，判断物体是否在扇形内。\n\nif (L < R) {\n    if (cos > rangeCos) {//物体在人前方扇形里面\n        console.log('cos',cos);\n        console.log('人在半径为R，角度为angle的扇形区域内');\n    }else{\n        console.log('不在扇形区域内');\n    }\n}else{\n    console.log('不在扇形区域内');\n}\n",normalizedContent:"# 点乘判断是否在扇形内\n\n通过three.js向量vector3点乘方法.dot()判断一个点(物体)是否在人前方的扇形范围内。\n\n\n\n\n# 已知条件\n\n判断一个点(物体)是否在人前方扇形范围内(半径r、扇形角度angle)。\n\n// 已知数据\nperson.position.set(0, 0, 2);//人位置\nmesh.position.set(2, 0, -3);//物体位置\n// a向量：人的正前方沿着z轴负半轴\nconst a = new three.vector3(0, 0, -1);\n// 扇形范围\nconst r = 20;//人前方扇形半径\nconst angle = 60;//人前方扇形角度\n\n\n\n\n\n# 先通过人与物体距离排除，物体不在扇形范围内情况\n\n计算物体与人的距离\n\n// 物体坐标减去人坐标，创建一个人指向物体的向量\nconst b = mesh.position.clone().sub(person.position);\nconst l = b.length();//物体与人的距离\n\n\n比较距离l与扇形半径的关系，排除物体不在扇形范围内的情况。\n\nif (l < r) {//物体与人的距离在半径r以内\n    console.log('物体与人距离小于扇形半径');\n}else{\n    console.log('不在扇形区域内');\n}\n\n\n\n# 角度θ在0 ~ 180度余弦值规律\n\n上节课给大家总结过，人指向物体的向量b和表示人正前方的向量a加载在0~180度之间\n\n\n\n角度θ在0 ~ 180度范围内，随着θ度数的增加，角度θ余弦值cos(θ)下降。换句话说，向量b与向量a夹角越小，对应的余弦值越大。\n\n\n\n\n\n\n# 比较夹角余弦值大小判断物体是否在扇形内\n\n\n\n向量点乘a.dot(b)点乘计算向量a和b的夹角余弦值cos。\n\nb.normalize();//归一化\nconst cos = a.dot(b);//向量a和b夹角余弦值\n\n\n在扇形范围内，从人所在位置，向外沿着扇形半径方向绘制向量c，你会发现向量c与向量a最大夹角就是扇形角度一半。\n\n// 角度转弧度\nconst rad = three.mathutils.degtorad(angle);\n// 扇形角度一半的余弦值\nconst rangecos = math.cos(rad / 2)\n\n\n比较向量a、b夹角余弦值cos和扇形角度一半的余弦值rangecos大小，判断物体是否在扇形内。\n\nif (l < r) {\n    if (cos > rangecos) {//物体在人前方扇形里面\n        console.log('cos',cos);\n        console.log('人在半径为r，角度为angle的扇形区域内');\n    }else{\n        console.log('不在扇形区域内');\n    }\n}else{\n    console.log('不在扇形区域内');\n}\n",charsets:{cjk:!0}},{title:"5. 向量叉乘cross",frontmatter:{title:"5. 向量叉乘cross",date:"2023-06-07T17:30:51.000Z",permalink:"/pages/4558d6/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/05.%E5%90%91%E9%87%8F%E5%8F%89%E4%B9%98cross.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/05.向量叉乘cross.md",key:"v-0e2ab762",path:"/pages/4558d6/",headers:[{level:3,title:"已知两个向量a、b",slug:"已知两个向量a、b",normalizedTitle:"已知两个向量a、b",charIndex:206},{level:3,title:"箭头可视化向量a、b",slug:"箭头可视化向量a、b",normalizedTitle:"箭头可视化向量a、b",charIndex:317},{level:3,title:"向量叉乘方法.crossVectors()",slug:"向量叉乘方法-crossvectors",normalizedTitle:"向量叉乘方法.crossvectors()",charIndex:621},{level:3,title:"可视化叉乘结果c",slug:"可视化叉乘结果c",normalizedTitle:"可视化叉乘结果c",charIndex:881},{level:3,title:"叉乘结果向量c几何含义",slug:"叉乘结果向量c几何含义",normalizedTitle:"叉乘结果向量c几何含义",charIndex:1054},{level:3,title:"向量b叉乘向量a.crossVectors(b,a)",slug:"向量b叉乘向量a-crossvectors-b-a",normalizedTitle:"向量b叉乘向量a.crossvectors(b,a)",charIndex:1310},{level:3,title:"总结：叉乘不满足交换律",slug:"总结-叉乘不满足交换律",normalizedTitle:"总结：叉乘不满足交换律",charIndex:1572},{level:3,title:"叉乘方向(右手螺旋定则判断)",slug:"叉乘方向-右手螺旋定则判断",normalizedTitle:"叉乘方向(右手螺旋定则判断)",charIndex:1695},{level:3,title:"叉乘.cross()",slug:"叉乘-cross",normalizedTitle:"叉乘.cross()",charIndex:2089}],headersStr:"已知两个向量a、b 箭头可视化向量a、b 向量叉乘方法.crossVectors() 可视化叉乘结果c 叉乘结果向量c几何含义 向量b叉乘向量a.crossVectors(b,a) 总结：叉乘不满足交换律 叉乘方向(右手螺旋定则判断) 叉乘.cross()",content:"# 向量叉乘 .cross()\n\nthreejs三维向量Vector3提供了叉乘的两个相关方法.crossVectors()和.cross()。\n\n叉乘也有其它称呼，比如向量积、外积、叉积、矢积。\n\n大学高等数学一般会介绍叉乘，如果你没有学习过，或者已经忘了，直接去查看百科关于叉乘介绍，你可能也不知道在说什么，不过这没关系，咱们课程会用具体的threejs案例，让你从零掌握和理解抽象的数学概念叉乘。\n\n\n# 已知两个向量a、b\n\n已知3D空间中两个向量a、b\n\nconst a = new THREE.Vector3(50, 0, 0);\nconst b = new THREE.Vector3(30, 0, 30);\n\n\n\n# 箭头可视化向量a、b\n\n使用箭头THREE.ArrowHelper可视化表示向量。\n\n//给箭头设置一个起点(随便给个位置就行)\nconst O = new THREE.Vector3(0, 0, 0);\n// 红色箭头表示向量a\nconst arrowA = new THREE.ArrowHelper(a.clone().normalize(), O, a.length(),0xff0000);\n// 绿色箭头表示向量b\nconst arrowB = new THREE.ArrowHelper(b.clone().normalize(), O, b.length(),0x00ff00);\n\n\n\n# 向量叉乘方法.crossVectors()\n\n先给大家解释下向量Vector3叉乘方法.crossVectors()的语法，然后再给大家解释叉乘的数学几何含义。\n\nc.crossVectors(a,b)向量a和b叉乘的结果是一个新的向量c。\n\n// 创建一个向量c，用来保存叉乘结果\nconst c = new THREE.Vector3();\n//向量a叉乘b，结果保存在向量c\nc.crossVectors(a,b);\nconsole.log('叉乘结果',c);//叉乘结果是一个向量对象Vector3\n\n\n\n# 可视化叉乘结果c\n\n// 可视化向量a和b叉乘结果：向量c\nconst arrowC = new THREE.ArrowHelper(c.clone().normalize(), O, c.length()/30,0x0000ff);\n\n\n这时候你会直观的发现向量c垂直于向量a、b构成的平面，或者说向量c同时垂直于向量a、向量b。\n\n\n\n\n# 叉乘结果向量c几何含义\n\n一方面是向量方向，刚刚通过可视化箭头给大家总结过，向量a叉乘向量b，得到一个新的向量c，向量c垂直于向量a和b构成的平面，或者说向量c同时垂直于向量a、向量b。\n\n另一方面是向量长度，假设向量a和b的夹角是θ，a和b叉乘结果是c，c的长度c.length()是a长度a.length()乘b长度b.length()乘夹角θ的正弦值sin(θ)\n\nc.crossVectors(a,b);\nc.length() = a.length()*b.length()*sin(θ)\n\n\n\n\n\n# 向量b叉乘向量a.crossVectors(b,a)\n\nc.crossVectors(a,b);//a叉乘b\nc.crossVectors(b,a);//b叉乘a\n\n\n箭头可视化向量b叉乘ac.crossVectors(b,a)的结果，你会发现向量c与原来向量a叉乘bc.crossVectors(a,b)的方向反过来。\n\n// 可视化向量b和a叉乘结果：向量c\nnew THREE.ArrowHelper(c.clone().normalize(), O, c.length()/30,0x0000ff);\n\n\n\n\n\n# 总结：叉乘不满足交换律\n\n你通过比较向量a叉乘b与向量b叉乘a区别，顺序不同结果不同，也就是说叉乘不满足交换律。\n\n// a叉乘b\nc.crossVectors(a,b);\n// b叉乘a\nc.crossVectors(b,a);\n\n\n\n\n\n# 叉乘方向(右手螺旋定则判断)\n\n首先明确一定，向量a、b叉乘，得到一个向量c，向量c垂直于向量a、b。\n\n假设向量a和向量b在水平地上，那么向量c，要么竖直向上，要么竖直向下。如果想具体判定向量c的朝向，最简单的方式，就是用箭头ArrowHelper可视化c，一看便知。\n\n偏理论的方式就是通过右手螺旋定则，判断叉乘结果c的方向，没有threejs箭头简单直观，如果你不想掌握，也没关系，写代码时候，用ArrowHelper类辅助判断。\n\n\n\n你先把向量c想象成一根筷子，尝试用手去握住它。具体过程就是，把右手手掌展平，四指并拢，大拇指与四指垂直，假设向量a和b处于水平平面上，向量c就是竖直方向，让大拇指沿着c，大拇指朝上还是朝下，随便先选个方向，让四指沿着向量a的方向，去开始握住向量c，这时候如果四指旋转的方向靠近向量b，那么说明大拇指的指向方向是向量c的方向，否则反之。\n\n\n# 叉乘.cross()\n\n.cross()和.crossVectors()都是向量对象的叉乘计算方法，功能一样，只是使用的细节有些不同，向量对象叉乘的结果仍然是向量对象。\n\nconst c = new THREE.Vector3();\nc.crossVectors(a,b);\n\n\na.clone()克隆一个和a一样的向量，和b叉乘a.cross(b)后，作为结果c。\n\nconst c = a.clone().cross(b);\n",normalizedContent:"# 向量叉乘 .cross()\n\nthreejs三维向量vector3提供了叉乘的两个相关方法.crossvectors()和.cross()。\n\n叉乘也有其它称呼，比如向量积、外积、叉积、矢积。\n\n大学高等数学一般会介绍叉乘，如果你没有学习过，或者已经忘了，直接去查看百科关于叉乘介绍，你可能也不知道在说什么，不过这没关系，咱们课程会用具体的threejs案例，让你从零掌握和理解抽象的数学概念叉乘。\n\n\n# 已知两个向量a、b\n\n已知3d空间中两个向量a、b\n\nconst a = new three.vector3(50, 0, 0);\nconst b = new three.vector3(30, 0, 30);\n\n\n\n# 箭头可视化向量a、b\n\n使用箭头three.arrowhelper可视化表示向量。\n\n//给箭头设置一个起点(随便给个位置就行)\nconst o = new three.vector3(0, 0, 0);\n// 红色箭头表示向量a\nconst arrowa = new three.arrowhelper(a.clone().normalize(), o, a.length(),0xff0000);\n// 绿色箭头表示向量b\nconst arrowb = new three.arrowhelper(b.clone().normalize(), o, b.length(),0x00ff00);\n\n\n\n# 向量叉乘方法.crossvectors()\n\n先给大家解释下向量vector3叉乘方法.crossvectors()的语法，然后再给大家解释叉乘的数学几何含义。\n\nc.crossvectors(a,b)向量a和b叉乘的结果是一个新的向量c。\n\n// 创建一个向量c，用来保存叉乘结果\nconst c = new three.vector3();\n//向量a叉乘b，结果保存在向量c\nc.crossvectors(a,b);\nconsole.log('叉乘结果',c);//叉乘结果是一个向量对象vector3\n\n\n\n# 可视化叉乘结果c\n\n// 可视化向量a和b叉乘结果：向量c\nconst arrowc = new three.arrowhelper(c.clone().normalize(), o, c.length()/30,0x0000ff);\n\n\n这时候你会直观的发现向量c垂直于向量a、b构成的平面，或者说向量c同时垂直于向量a、向量b。\n\n\n\n\n# 叉乘结果向量c几何含义\n\n一方面是向量方向，刚刚通过可视化箭头给大家总结过，向量a叉乘向量b，得到一个新的向量c，向量c垂直于向量a和b构成的平面，或者说向量c同时垂直于向量a、向量b。\n\n另一方面是向量长度，假设向量a和b的夹角是θ，a和b叉乘结果是c，c的长度c.length()是a长度a.length()乘b长度b.length()乘夹角θ的正弦值sin(θ)\n\nc.crossvectors(a,b);\nc.length() = a.length()*b.length()*sin(θ)\n\n\n\n\n\n# 向量b叉乘向量a.crossvectors(b,a)\n\nc.crossvectors(a,b);//a叉乘b\nc.crossvectors(b,a);//b叉乘a\n\n\n箭头可视化向量b叉乘ac.crossvectors(b,a)的结果，你会发现向量c与原来向量a叉乘bc.crossvectors(a,b)的方向反过来。\n\n// 可视化向量b和a叉乘结果：向量c\nnew three.arrowhelper(c.clone().normalize(), o, c.length()/30,0x0000ff);\n\n\n\n\n\n# 总结：叉乘不满足交换律\n\n你通过比较向量a叉乘b与向量b叉乘a区别，顺序不同结果不同，也就是说叉乘不满足交换律。\n\n// a叉乘b\nc.crossvectors(a,b);\n// b叉乘a\nc.crossvectors(b,a);\n\n\n\n\n\n# 叉乘方向(右手螺旋定则判断)\n\n首先明确一定，向量a、b叉乘，得到一个向量c，向量c垂直于向量a、b。\n\n假设向量a和向量b在水平地上，那么向量c，要么竖直向上，要么竖直向下。如果想具体判定向量c的朝向，最简单的方式，就是用箭头arrowhelper可视化c，一看便知。\n\n偏理论的方式就是通过右手螺旋定则，判断叉乘结果c的方向，没有threejs箭头简单直观，如果你不想掌握，也没关系，写代码时候，用arrowhelper类辅助判断。\n\n\n\n你先把向量c想象成一根筷子，尝试用手去握住它。具体过程就是，把右手手掌展平，四指并拢，大拇指与四指垂直，假设向量a和b处于水平平面上，向量c就是竖直方向，让大拇指沿着c，大拇指朝上还是朝下，随便先选个方向，让四指沿着向量a的方向，去开始握住向量c，这时候如果四指旋转的方向靠近向量b，那么说明大拇指的指向方向是向量c的方向，否则反之。\n\n\n# 叉乘.cross()\n\n.cross()和.crossvectors()都是向量对象的叉乘计算方法，功能一样，只是使用的细节有些不同，向量对象叉乘的结果仍然是向量对象。\n\nconst c = new three.vector3();\nc.crossvectors(a,b);\n\n\na.clone()克隆一个和a一样的向量，和b叉乘a.cross(b)后，作为结果c。\n\nconst c = a.clone().cross(b);\n",charsets:{cjk:!0}},{title:"6. 叉乘判断人左右",frontmatter:{title:"6. 叉乘判断人左右",date:"2023-06-11T21:23:28.000Z",permalink:"/pages/9babd7/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/06.%E5%8F%89%E4%B9%98%E5%88%A4%E6%96%AD%E4%BA%BA%E5%B7%A6%E5%8F%B3.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/06.叉乘判断人左右.md",key:"v-2287542e",path:"/pages/9babd7/",headers:[{level:3,title:"已知条件",slug:"已知条件",normalizedTitle:"已知条件",charIndex:73},{level:3,title:"创建人指向物体的向量b",slug:"创建人指向物体的向量b",normalizedTitle:"创建人指向物体的向量b",charIndex:500},{level:3,title:"a叉乘b",slug:"a叉乘b",normalizedTitle:"a叉乘b",charIndex:721},{level:3,title:"叉乘方向总结",slug:"叉乘方向总结",normalizedTitle:"叉乘方向总结",charIndex:863},{level:3,title:"根据向量c方向判断物体在人左侧还是右侧",slug:"根据向量c方向判断物体在人左侧还是右侧",normalizedTitle:"根据向量c方向判断物体在人左侧还是右侧",charIndex:1168}],headersStr:"已知条件 创建人指向物体的向量b a叉乘b 叉乘方向总结 根据向量c方向判断物体在人左侧还是右侧",content:"# 叉乘判断人左右\n\n继续three.js叉乘.cross()的讲解，咱们这节课通过探索叉乘的方向规律，判断一个物体在人的左侧还是右侧。\n\n\n# 已知条件\n\n假设人和物体在XOZ水平面上，下面在XOZ平面上，随机选择了两个坐标，作为人和物体的位置，选择一个方向作为人的正前方。\n\nperson.position.set(0, 0, 2);//人位置\n// a向量：假设人的正前方沿着z轴负半轴\nconst a = new THREE.Vector3(0, 0, -5);\n\n\n// 箭头可视化向量a\nconst arrowA = new THREE.ArrowHelper(a.clone().normalize(), person.position, a.length(),0xff0000);\nmodel.add(arrowA);\n\n\n物体位置选择了两种情况，一个在人的左侧(左前方)，一个在人的右侧(右前方)。\n\nmesh.position.set(2, 0, -3);//物体位置在人右边     \nmesh.position.set(-2, 0, -3);//物体位置在人左边 \n\n\n\n# 创建人指向物体的向量b\n\n物体两个位置对应的两个向量b，分别位于向量a左右两侧。\n\nconst b = mesh.position.clone().sub(person.position);\n\n\nconst arrowB = new THREE.ArrowHelper(b.clone().normalize(), person.position, b.length(),0x00ff00);\nmodel.add(arrowB);\n\n\n\n# a叉乘b\n\nconst c = a.clone().cross(b);\nc.normalize()\n\n\n// 可视化向量c方向\nconst arrowC = new THREE.ArrowHelper(c, person.position, 2.5 ,0x0000ff);\n\n\n\n# 叉乘方向总结\n\n假设向量a和b在水平面上，向量a叉乘b得到结果向量c。\n\n对比物体两种位置情况，你会发现当向量b在向量a右侧(物体在人右侧)时，向量c竖直向下，当向量b在向量a左侧(物体在人左侧)时，向量c竖直向上。\n\n\n\n向量旋转不超过180度情况下，向量b在向量a右侧，说明向量a顺时针旋转与b重合，向量c竖直向下，当向量b在向量a左侧时，说明向量a逆时针旋转与b重合，向量c竖直向上。\n\n\n\n你只需要记住，一个向量a与其他向量相乘，如果其他向量，位于向量a同一侧，叉乘方向相同，如果不同一侧，方向不同，如果具体判断方向，可以通过右手螺旋定则，如果想省事，就直接写代码测试，或者来查电子书的插图。\n\n\n# 根据向量c方向判断物体在人左侧还是右侧\n\n// 根据向量c方向，判断物体在人的左侧还是右侧。\nif(c.y < 0){\n    console.log('物体在人右侧');\n}else if(c.y > 0){\n    console.log('物体在人左侧');\n}\n",normalizedContent:"# 叉乘判断人左右\n\n继续three.js叉乘.cross()的讲解，咱们这节课通过探索叉乘的方向规律，判断一个物体在人的左侧还是右侧。\n\n\n# 已知条件\n\n假设人和物体在xoz水平面上，下面在xoz平面上，随机选择了两个坐标，作为人和物体的位置，选择一个方向作为人的正前方。\n\nperson.position.set(0, 0, 2);//人位置\n// a向量：假设人的正前方沿着z轴负半轴\nconst a = new three.vector3(0, 0, -5);\n\n\n// 箭头可视化向量a\nconst arrowa = new three.arrowhelper(a.clone().normalize(), person.position, a.length(),0xff0000);\nmodel.add(arrowa);\n\n\n物体位置选择了两种情况，一个在人的左侧(左前方)，一个在人的右侧(右前方)。\n\nmesh.position.set(2, 0, -3);//物体位置在人右边     \nmesh.position.set(-2, 0, -3);//物体位置在人左边 \n\n\n\n# 创建人指向物体的向量b\n\n物体两个位置对应的两个向量b，分别位于向量a左右两侧。\n\nconst b = mesh.position.clone().sub(person.position);\n\n\nconst arrowb = new three.arrowhelper(b.clone().normalize(), person.position, b.length(),0x00ff00);\nmodel.add(arrowb);\n\n\n\n# a叉乘b\n\nconst c = a.clone().cross(b);\nc.normalize()\n\n\n// 可视化向量c方向\nconst arrowc = new three.arrowhelper(c, person.position, 2.5 ,0x0000ff);\n\n\n\n# 叉乘方向总结\n\n假设向量a和b在水平面上，向量a叉乘b得到结果向量c。\n\n对比物体两种位置情况，你会发现当向量b在向量a右侧(物体在人右侧)时，向量c竖直向下，当向量b在向量a左侧(物体在人左侧)时，向量c竖直向上。\n\n\n\n向量旋转不超过180度情况下，向量b在向量a右侧，说明向量a顺时针旋转与b重合，向量c竖直向下，当向量b在向量a左侧时，说明向量a逆时针旋转与b重合，向量c竖直向上。\n\n\n\n你只需要记住，一个向量a与其他向量相乘，如果其他向量，位于向量a同一侧，叉乘方向相同，如果不同一侧，方向不同，如果具体判断方向，可以通过右手螺旋定则，如果想省事，就直接写代码测试，或者来查电子书的插图。\n\n\n# 根据向量c方向判断物体在人左侧还是右侧\n\n// 根据向量c方向，判断物体在人的左侧还是右侧。\nif(c.y < 0){\n    console.log('物体在人右侧');\n}else if(c.y > 0){\n    console.log('物体在人左侧');\n}\n",charsets:{cjk:!0}},{title:"7. 点乘判断平行向量方向异同",frontmatter:{title:"7. 点乘判断平行向量方向异同",date:"2023-06-11T21:23:37.000Z",permalink:"/pages/b03f77/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/07.%E7%82%B9%E4%B9%98%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%8C%E5%90%91%E9%87%8F%E6%96%B9%E5%90%91%E5%BC%82%E5%90%8C.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/07.点乘判断平行向量方向异同.md",key:"v-f13a2722",path:"/pages/b03f77/",headers:[{level:3,title:"已知条件",slug:"已知条件",normalizedTitle:"已知条件",charIndex:79},{level:3,title:"夹角余弦值与向量",slug:"夹角余弦值与向量",normalizedTitle:"夹角余弦值与向量",charIndex:255},{level:3,title:"知识点回顾",slug:"知识点回顾",normalizedTitle:"知识点回顾",charIndex:341},{level:3,title:"通过点乘判断平行向量方向异同",slug:"通过点乘判断平行向量方向异同",normalizedTitle:"通过点乘判断平行向量方向异同",charIndex:578}],headersStr:"已知条件 夹角余弦值与向量 知识点回顾 通过点乘判断平行向量方向异同",content:"# 点乘判断平行向量方向异同\n\n本节课做一个点乘相关的练习题，就是通过three.js点乘方法.dot()判断两个平行的向量，方向是相同还是不同的。\n\n\n# 已知条件\n\n// 已知条件：判断两个平行的向量方向是否相同\nconst a = new THREE.Vector3(10, 0, 0);\nconst b = new THREE.Vector3(200, 0, 0);//与a平行且方向相同\nconst b = new THREE.Vector3(-50, 0, 0);//与a平行且方向相反\n\n\n\n# 夹角余弦值与向量\n\n两个平行向量方向相同，意味着夹角0度，夹角余弦值cosθ等于1。\n\n两个平行向量方向相反，意味着夹角180度，夹角余弦值cosθ等于-1。\n\n\n\n\n# 知识点回顾\n\n假设两个向量的夹角是θ，两个向量的单位向量进行点乘.dot()，返回的结果就是夹角θ的余弦值cos(θ)\n\n\n\nconst a = new THREE.Vector3(10, 10, 0);\nconst b = new THREE.Vector3(20, 0, 0);\n// a、b向量归一化后点乘\nconst cos =  a.normalize().dot(b.normalize());\nconsole.log('向量夹角余弦值',cos);\n\n\n\n# 通过点乘判断平行向量方向异同\n\n// a、b向量归一化后点乘\nconst cos =  a.normalize().dot(b.normalize());\n\n//注意判断的前提是，两个向量是平行的，余弦值要么1，要么-1\nif(cos>0.5){\n    console.log('方向相同');\n}else{\n    console.log('方向相反');\n}\n",normalizedContent:"# 点乘判断平行向量方向异同\n\n本节课做一个点乘相关的练习题，就是通过three.js点乘方法.dot()判断两个平行的向量，方向是相同还是不同的。\n\n\n# 已知条件\n\n// 已知条件：判断两个平行的向量方向是否相同\nconst a = new three.vector3(10, 0, 0);\nconst b = new three.vector3(200, 0, 0);//与a平行且方向相同\nconst b = new three.vector3(-50, 0, 0);//与a平行且方向相反\n\n\n\n# 夹角余弦值与向量\n\n两个平行向量方向相同，意味着夹角0度，夹角余弦值cosθ等于1。\n\n两个平行向量方向相反，意味着夹角180度，夹角余弦值cosθ等于-1。\n\n\n\n\n# 知识点回顾\n\n假设两个向量的夹角是θ，两个向量的单位向量进行点乘.dot()，返回的结果就是夹角θ的余弦值cos(θ)\n\n\n\nconst a = new three.vector3(10, 10, 0);\nconst b = new three.vector3(20, 0, 0);\n// a、b向量归一化后点乘\nconst cos =  a.normalize().dot(b.normalize());\nconsole.log('向量夹角余弦值',cos);\n\n\n\n# 通过点乘判断平行向量方向异同\n\n// a、b向量归一化后点乘\nconst cos =  a.normalize().dot(b.normalize());\n\n//注意判断的前提是，两个向量是平行的，余弦值要么1，要么-1\nif(cos>0.5){\n    console.log('方向相同');\n}else{\n    console.log('方向相反');\n}\n",charsets:{cjk:!0}},{title:"9. 叉乘计算三角形法线",frontmatter:{title:"9. 叉乘计算三角形法线",date:"2023-06-11T21:24:08.000Z",permalink:"/pages/d574b7/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/09.%E5%8F%89%E4%B9%98%E8%AE%A1%E7%AE%97%E4%B8%89%E8%A7%92%E5%BD%A2%E6%B3%95%E7%BA%BF.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/09.叉乘计算三角形法线.md",key:"v-1672bc36",path:"/pages/d574b7/",headers:[{level:3,title:"已知条件",slug:"已知条件",normalizedTitle:"已知条件",charIndex:72},{level:3,title:"叉乘.cross()计算法线",slug:"叉乘-cross-计算法线",normalizedTitle:"叉乘.cross()计算法线",charIndex:387},{level:3,title:"第二组三角形数据测试法线计算",slug:"第二组三角形数据测试法线计算",normalizedTitle:"第二组三角形数据测试法线计算",charIndex:1034}],headersStr:"已知条件 叉乘.cross()计算法线 第二组三角形数据测试法线计算",content:"# 叉乘计算三角形法线\n\n利用前面讲解的threejs叉乘.cross()知识，做一个练习题，具体内容就是计算三角形的法线或说着垂线。\n\n\n# 已知条件\n\nconst geometry = new THREE.BufferGeometry();\n// 两个三角形的顶点坐标\nconst vertices = new Float32Array([\n    0, 0, 0, //顶点1坐标\n    50, 0, 0, //顶点2坐标\n    0, 100, 0, //顶点3坐标\n    0, 0, 10, //顶点4坐标\n    0, 0, 100, //顶点5坐标\n    50, 0, 10, //顶点6坐标\n]);\ngeometry.attributes.position = new THREE.BufferAttribute(vertices, 3);\n\n\n\n# 叉乘.cross()计算法线\n\n通过前面叉乘学习，咱们知道，向量a、b叉乘得到的向量c，会垂直于向量a和b构成的平面。\n\n\n\n思路非常简单，可以把通过三角形的三个顶点构建两个向量，两个向量叉乘，就会得到一个垂直三角形的向量c。不过注意一点，如果两个向量，随意构建，实际计算结果向量c虽然都垂直a和b但是方向可能有两种情况。所以，三个顶点构建两个向量，按照三角形顶点的顺序，构建1指向2的向量，2指向3的向量,这样可以向量叉乘结果可以反应三角形三个点位置顺序关系。\n\n// 已知三角形三个顶点的坐标，计算三角形法线方向\nconst p1 = new THREE.Vector3(0, 0, 0);\nconst p2 = new THREE.Vector3(50, 0, 0);\nconst p3 = new THREE.Vector3(0, 100, 0);\n\n// 三个顶点构建两个向量，按照三角形顶点的顺序，构建1指向2的向量，2指向3的向量\nconst a = p2.clone().sub(p1);\nconst b = p3.clone().sub(p2);\n\nconst c = a.clone().cross(b);\nc.normalize();//向量c归一化表示三角形法线方向\n\n// 可视化向量a和b叉乘结果：向量c\nconst arrow = new THREE.ArrowHelper(c, p3, 50, 0xff0000);\nmesh.add(arrow);\n\n\n\n# 第二组三角形数据测试法线计算\n\nconst p1 = new THREE.Vector3(0, 0, 10);\nconst p2 = new THREE.Vector3(0, 0, 100);\nconst p3 = new THREE.Vector3(50, 0, 10);\n",normalizedContent:"# 叉乘计算三角形法线\n\n利用前面讲解的threejs叉乘.cross()知识，做一个练习题，具体内容就是计算三角形的法线或说着垂线。\n\n\n# 已知条件\n\nconst geometry = new three.buffergeometry();\n// 两个三角形的顶点坐标\nconst vertices = new float32array([\n    0, 0, 0, //顶点1坐标\n    50, 0, 0, //顶点2坐标\n    0, 100, 0, //顶点3坐标\n    0, 0, 10, //顶点4坐标\n    0, 0, 100, //顶点5坐标\n    50, 0, 10, //顶点6坐标\n]);\ngeometry.attributes.position = new three.bufferattribute(vertices, 3);\n\n\n\n# 叉乘.cross()计算法线\n\n通过前面叉乘学习，咱们知道，向量a、b叉乘得到的向量c，会垂直于向量a和b构成的平面。\n\n\n\n思路非常简单，可以把通过三角形的三个顶点构建两个向量，两个向量叉乘，就会得到一个垂直三角形的向量c。不过注意一点，如果两个向量，随意构建，实际计算结果向量c虽然都垂直a和b但是方向可能有两种情况。所以，三个顶点构建两个向量，按照三角形顶点的顺序，构建1指向2的向量，2指向3的向量,这样可以向量叉乘结果可以反应三角形三个点位置顺序关系。\n\n// 已知三角形三个顶点的坐标，计算三角形法线方向\nconst p1 = new three.vector3(0, 0, 0);\nconst p2 = new three.vector3(50, 0, 0);\nconst p3 = new three.vector3(0, 100, 0);\n\n// 三个顶点构建两个向量，按照三角形顶点的顺序，构建1指向2的向量，2指向3的向量\nconst a = p2.clone().sub(p1);\nconst b = p3.clone().sub(p2);\n\nconst c = a.clone().cross(b);\nc.normalize();//向量c归一化表示三角形法线方向\n\n// 可视化向量a和b叉乘结果：向量c\nconst arrow = new three.arrowhelper(c, p3, 50, 0xff0000);\nmesh.add(arrow);\n\n\n\n# 第二组三角形数据测试法线计算\n\nconst p1 = new three.vector3(0, 0, 10);\nconst p2 = new three.vector3(0, 0, 100);\nconst p3 = new three.vector3(50, 0, 10);\n",charsets:{cjk:!0}},{title:"8. 判断两个点是否在线段同一侧",frontmatter:{title:"8. 判断两个点是否在线段同一侧",date:"2023-06-11T21:24:00.000Z",permalink:"/pages/8da3bf/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/08.%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E7%BA%BF%E6%AE%B5%E5%90%8C%E4%B8%80%E4%BE%A7.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/08.判断两个点是否在线段同一侧.md",key:"v-18951d86",path:"/pages/8da3bf/",headers:[{level:3,title:"已知条件",slug:"已知条件",normalizedTitle:"已知条件",charIndex:59},{level:3,title:"可视化表示出来四个点的坐标和线段",slug:"可视化表示出来四个点的坐标和线段",normalizedTitle:"可视化表示出来四个点的坐标和线段",charIndex:362},{level:3,title:"思路讲解",slug:"思路讲解",normalizedTitle:"思路讲解",charIndex:1403},{level:3,title:"叉乘计算向量c1、c2",slug:"叉乘计算向量c1、c2",normalizedTitle:"叉乘计算向量c1、c2",charIndex:1610},{level:3,title:"箭头可视化所有向量辅助判断",slug:"箭头可视化所有向量辅助判断",normalizedTitle:"箭头可视化所有向量辅助判断",charIndex:1898},{level:3,title:"判断向量c1、c2方向异同",slug:"判断向量c1、c2方向异同",normalizedTitle:"判断向量c1、c2方向异同",charIndex:2432}],headersStr:"已知条件 可视化表示出来四个点的坐标和线段 思路讲解 叉乘计算向量c1、c2 箭头可视化所有向量辅助判断 判断向量c1、c2方向异同",content:"# 判断两个点是否在线段同一侧\n\n通过叉乘.cross()、点乘.dot()综合判断两个点是否在线段同一侧。\n\n\n# 已知条件\n\n下面所有点的坐标都在XOZ平面上。\n\n// 已知条件\n// 一条线段两点坐标A、B\nconst A = new THREE.Vector3(0, 0, 10);\nconst B = new THREE.Vector3(100, 0, 10);\n\n// 判断p1、p2两点位于线段AB同一侧，还是异侧\nconst p1 = new THREE.Vector3(20, 0, 40);\nconst p2 = new THREE.Vector3(80, 0, 40);//与p1同侧\n\n\nconst p2 = new THREE.Vector3(80, 0, -30);//与p1异侧\n\n\n\n\n\n# 可视化表示出来四个点的坐标和线段\n\n实际开发，为了方便查看几何关系，可以尝试可视化表示一些数据，便于观察，课件源码演示文件中已经提前准备好。\n\n// 小球可视化四个坐标点\nconst group = new THREE.Group();\nconst AMesh = createSphereMesh(0xffff00,2);\nAMesh.position.copy(A);\nconst BMesh = createSphereMesh(0xffff00,2);\nBMesh.position.copy(B);\nconst p1Mesh = createSphereMesh(0xff0000,2);\np1Mesh.position.copy(p1);\nconst p2Mesh = createSphereMesh(0xff0000,2);\np2Mesh.position.copy(p2);\ngroup.add(AMesh,BMesh,p1Mesh,p2Mesh);\n\nfunction createSphereMesh(color,R) {\n    const geometry = new THREE.SphereGeometry(R);\n    const material = new THREE.MeshLambertMaterial({\n        color: color,\n    });\n    const mesh = new THREE.Mesh(geometry, material);\n    return mesh;\n}\n\n\n// Line可视化线段AB\nconst geometry = new THREE.BufferGeometry(); \nconst vertices = new Float32Array([\n    A.x, A.y, A.z, \n    B.x, B.y, B.z, \n]);\ngeometry.attributes.position = new THREE.BufferAttribute(vertices, 3);\nconst material = new THREE.LineBasicMaterial({\n    color: 0xffff00, \n});\nconst line = new THREE.LineLoop(geometry, material); \ngroup.add(line);\n\n\n\n# 思路讲解\n\np1分别向线段AB两点创建两条向量a1、b1\n\np2分别向线段AB两点创建两条向量a2、b2\n\n你会发现，p1、p2同侧时候，a1转向b1与a2转向b2方向一致，如果是异侧，方向不一致。\n\n换句话说，a1叉乘b1得到向量c1，与a2叉乘b2得到向量c2，如果p1、p2同侧，那么c1和c2方向一样，否则方向不同。\n\n\n\n总结，这意味着我们可以通过叉乘方向是否相同来推断两点是否位于线段同一侧。\n\n\n# 叉乘计算向量c1、c2\n\n// p1分别向线段AB两点创建两条向量a1、b1\nconst a1 = A.clone().sub(p1);\nconst b1 = B.clone().sub(p1);\n// p2分别向线段AB两点创建两条向量a2、b2\nconst a2 = A.clone().sub(p2);\nconst b2 = B.clone().sub(p2);\n\n// 通过c1、c2方向是否相同来推断两点是否位于线段同一侧\nconst c1 = a1.clone().cross(b1);\nconst c2 = a2.clone().cross(b2);\n\n\n\n# 箭头可视化所有向量辅助判断\n\n箭头ArrowHelper可视化所有向量，辅助判断，更具体。\n\ngroup.add(new THREE.ArrowHelper(a1.clone().normalize(), p1, a1.length(),0xff0000))\ngroup.add(new THREE.ArrowHelper(b1.clone().normalize(), p1, b1.length(),0x00ff00))\ngroup.add(new THREE.ArrowHelper(a2.clone().normalize(), p2, a2.length(),0xff0000))\ngroup.add(new THREE.ArrowHelper(b2.clone().normalize(), p2, b2.length(),0x00ff00))\ngroup.add(new THREE.ArrowHelper(c1.clone().normalize(), p1, 50, 0x0000ff))\ngroup.add(new THREE.ArrowHelper(c2.clone().normalize(), p2, 50, 0x0000ff))\n\n\n\n# 判断向量c1、c2方向异同\n\n参考上节课内容讲解\n\n// 向量c1与c2夹角余弦值：用来推断向量c1与c2方向是否相同\nconst cos =  c1.normalize().dot(c2.normalize());\nif(cos>0.5){//方向相同时候，余弦值1>0.5\n    console.log('方向相同，两点在线段同侧');\n}else{//方向相反时候，余弦值-1<0.5\n    console.log('方向相反，两点在线段异侧');\n}\n",normalizedContent:"# 判断两个点是否在线段同一侧\n\n通过叉乘.cross()、点乘.dot()综合判断两个点是否在线段同一侧。\n\n\n# 已知条件\n\n下面所有点的坐标都在xoz平面上。\n\n// 已知条件\n// 一条线段两点坐标a、b\nconst a = new three.vector3(0, 0, 10);\nconst b = new three.vector3(100, 0, 10);\n\n// 判断p1、p2两点位于线段ab同一侧，还是异侧\nconst p1 = new three.vector3(20, 0, 40);\nconst p2 = new three.vector3(80, 0, 40);//与p1同侧\n\n\nconst p2 = new three.vector3(80, 0, -30);//与p1异侧\n\n\n\n\n\n# 可视化表示出来四个点的坐标和线段\n\n实际开发，为了方便查看几何关系，可以尝试可视化表示一些数据，便于观察，课件源码演示文件中已经提前准备好。\n\n// 小球可视化四个坐标点\nconst group = new three.group();\nconst amesh = createspheremesh(0xffff00,2);\namesh.position.copy(a);\nconst bmesh = createspheremesh(0xffff00,2);\nbmesh.position.copy(b);\nconst p1mesh = createspheremesh(0xff0000,2);\np1mesh.position.copy(p1);\nconst p2mesh = createspheremesh(0xff0000,2);\np2mesh.position.copy(p2);\ngroup.add(amesh,bmesh,p1mesh,p2mesh);\n\nfunction createspheremesh(color,r) {\n    const geometry = new three.spheregeometry(r);\n    const material = new three.meshlambertmaterial({\n        color: color,\n    });\n    const mesh = new three.mesh(geometry, material);\n    return mesh;\n}\n\n\n// line可视化线段ab\nconst geometry = new three.buffergeometry(); \nconst vertices = new float32array([\n    a.x, a.y, a.z, \n    b.x, b.y, b.z, \n]);\ngeometry.attributes.position = new three.bufferattribute(vertices, 3);\nconst material = new three.linebasicmaterial({\n    color: 0xffff00, \n});\nconst line = new three.lineloop(geometry, material); \ngroup.add(line);\n\n\n\n# 思路讲解\n\np1分别向线段ab两点创建两条向量a1、b1\n\np2分别向线段ab两点创建两条向量a2、b2\n\n你会发现，p1、p2同侧时候，a1转向b1与a2转向b2方向一致，如果是异侧，方向不一致。\n\n换句话说，a1叉乘b1得到向量c1，与a2叉乘b2得到向量c2，如果p1、p2同侧，那么c1和c2方向一样，否则方向不同。\n\n\n\n总结，这意味着我们可以通过叉乘方向是否相同来推断两点是否位于线段同一侧。\n\n\n# 叉乘计算向量c1、c2\n\n// p1分别向线段ab两点创建两条向量a1、b1\nconst a1 = a.clone().sub(p1);\nconst b1 = b.clone().sub(p1);\n// p2分别向线段ab两点创建两条向量a2、b2\nconst a2 = a.clone().sub(p2);\nconst b2 = b.clone().sub(p2);\n\n// 通过c1、c2方向是否相同来推断两点是否位于线段同一侧\nconst c1 = a1.clone().cross(b1);\nconst c2 = a2.clone().cross(b2);\n\n\n\n# 箭头可视化所有向量辅助判断\n\n箭头arrowhelper可视化所有向量，辅助判断，更具体。\n\ngroup.add(new three.arrowhelper(a1.clone().normalize(), p1, a1.length(),0xff0000))\ngroup.add(new three.arrowhelper(b1.clone().normalize(), p1, b1.length(),0x00ff00))\ngroup.add(new three.arrowhelper(a2.clone().normalize(), p2, a2.length(),0xff0000))\ngroup.add(new three.arrowhelper(b2.clone().normalize(), p2, b2.length(),0x00ff00))\ngroup.add(new three.arrowhelper(c1.clone().normalize(), p1, 50, 0x0000ff))\ngroup.add(new three.arrowhelper(c2.clone().normalize(), p2, 50, 0x0000ff))\n\n\n\n# 判断向量c1、c2方向异同\n\n参考上节课内容讲解\n\n// 向量c1与c2夹角余弦值：用来推断向量c1与c2方向是否相同\nconst cos =  c1.normalize().dot(c2.normalize());\nif(cos>0.5){//方向相同时候，余弦值1>0.5\n    console.log('方向相同，两点在线段同侧');\n}else{//方向相反时候，余弦值-1<0.5\n    console.log('方向相反，两点在线段异侧');\n}\n",charsets:{cjk:!0}},{title:"11. 练习—计算物体的表面积",frontmatter:{title:"11. 练习—计算物体的表面积",date:"2023-06-11T21:24:24.000Z",permalink:"/pages/ab63ef/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/11.%E7%BB%83%E4%B9%A0%E2%80%94%E8%AE%A1%E7%AE%97%E7%89%A9%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/11.练习—计算物体的表面积.md",key:"v-54519bd0",path:"/pages/ab63ef/",headers:[{level:3,title:"知识点回顾：三角形面积",slug:"知识点回顾-三角形面积",normalizedTitle:"知识点回顾：三角形面积",charIndex:63},{level:3,title:"知识点回顾：网格模型的三角形",slug:"知识点回顾-网格模型的三角形",normalizedTitle:"知识点回顾：网格模型的三角形",charIndex:238},{level:3,title:"Geometry有顶点索引数据",slug:"geometry有顶点索引数据",normalizedTitle:"geometry有顶点索引数据",charIndex:479},{level:3,title:"Geometry没有顶点索引数据",slug:"geometry没有顶点索引数据",normalizedTitle:"geometry没有顶点索引数据",charIndex:1721}],headersStr:"知识点回顾：三角形面积 知识点回顾：网格模型的三角形 Geometry有顶点索引数据 Geometry没有顶点索引数据",content:"# 练习—计算物体的表面积\n\n你可以尝试利用上节课的三角形面积公式，计算一个网格模型几何体Geometry的表面积。\n\n\n# 知识点回顾：三角形面积\n\n叉乘.cross()和.length()计算三角形面积公式\n\n\n\nconst a = p2.clone().sub(p1);\nconst b = p3.clone().sub(p1);\nconst c = a.clone().cross(b);\nconst S = 0.5*c.length();// 三角形面积\n\n\n\n# 知识点回顾：网格模型的三角形\n\n几何体BufferGeometry结构：http://www.webgl3d.cn/pages/32785a/\n\n网格模型Mesh其实就一个一个三角形拼接构成，这意味着，我们可以通过计算Mesh所有三角形面积，然后累加，就可以获取模型的表面积。\n\n\n\n下面用一个立方体给大家进行测试验证，实际开发，你也可以从外部加载模型。几何体结构分为两种情况，一种有顶点索引index数据，一种没有，整体思路相同，只是注意获取顶点位置数据的语法细节不同。\n\n\n# Geometry有顶点索引数据\n\n//三角形面积计算\nfunction AreaOfTriangle(p1, p2, p3) {\n    // 三角形两条边构建两个向量\n    const a = p2.clone().sub(p1);\n    const b = p3.clone().sub(p1);\n    // 两个向量叉乘结果c的几何含义：a.length()*b.length()*sin(θ)\n    const c = a.clone().cross(b);\n    // 三角形面积计算\n    const S = 0.5 * c.length();\n    return S\n}\n\n\n获取模型对象所有的三角形，分别计算某个三角形对应的面积，然后所有三角形面积累加，就可以获取模型的表面积。\n\nconst pos = geometry.attributes.position;\nconst index = geometry.index;\nconsole.log('geometry',geometry);\nlet S = 0;//表示物体表面积\nfor (var i = 0; i < index.count; i += 3) {\n    // 获取当前三角形对应三个顶点的索引\n    const i1 = index.getX(i);\n    const i2 = index.getX(i + 1);\n    const i3 = index.getX(i + 2);\n\n    //获取三个顶点的坐标 \n    const p1 = new THREE.Vector3(pos.getX(i1), pos.getY(i1), pos.getZ(i1));\n    const p2 = new THREE.Vector3(pos.getX(i2), pos.getY(i2), pos.getZ(i2));\n    const p3 = new THREE.Vector3(pos.getX(i3), pos.getY(i3), pos.getZ(i3));\n    S += AreaOfTriangle(p1, p2, p3); \n}\nconsole.log('S',S);\n\n//三角形面积计算\nfunction AreaOfTriangle(p1, p2, p3) {\n    // 三角形两条边构建两个向量\n    const a = p2.clone().sub(p1);\n    const b = p3.clone().sub(p1);\n    // 两个向量叉乘结果c的几何含义：a.length()*b.length()*sin(θ)\n    const c = a.clone().cross(b);\n    // 三角形面积计算\n    const S = 0.5 * c.length();\n    return S\n}\n\n\n\n# Geometry没有顶点索引数据\n\nGeometry没有顶点索引数据,直接从顶点位置属性获取每间隔三个点作为一个三角形数据。\n\nconst pos = geometry.attributes.position;\nlet S = 0;//表示物体表面积\nfor (let i = 0; i < pos.count; i += 3) {\n    const p1 = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i));\n    const p2 = new THREE.Vector3(pos.getX(i + 1), pos.getY(i + 1), pos.getZ(i + 1));\n    const p3 = new THREE.Vector3(pos.getX(i + 2), pos.getY(i + 2), pos.getZ(i + 2));\n    S += AreaOfTriangle(p1, p2, p3);//所有三角形面积累加\n}\nconsole.log('S', S);\n//三角形面积计算\nfunction AreaOfTriangle(p1, p2, p3) {\n    // 三角形两条边构建两个向量\n    const a = p2.clone().sub(p1);\n    const b = p3.clone().sub(p1);\n    // 两个向量叉乘结果c的几何含义：a.length()*b.length()*sin(θ)\n    const c = a.clone().cross(b);\n    // 三角形面积计算\n    const S = 0.5 * c.length();\n    return S;\n}\n",normalizedContent:"# 练习—计算物体的表面积\n\n你可以尝试利用上节课的三角形面积公式，计算一个网格模型几何体geometry的表面积。\n\n\n# 知识点回顾：三角形面积\n\n叉乘.cross()和.length()计算三角形面积公式\n\n\n\nconst a = p2.clone().sub(p1);\nconst b = p3.clone().sub(p1);\nconst c = a.clone().cross(b);\nconst s = 0.5*c.length();// 三角形面积\n\n\n\n# 知识点回顾：网格模型的三角形\n\n几何体buffergeometry结构：http://www.webgl3d.cn/pages/32785a/\n\n网格模型mesh其实就一个一个三角形拼接构成，这意味着，我们可以通过计算mesh所有三角形面积，然后累加，就可以获取模型的表面积。\n\n\n\n下面用一个立方体给大家进行测试验证，实际开发，你也可以从外部加载模型。几何体结构分为两种情况，一种有顶点索引index数据，一种没有，整体思路相同，只是注意获取顶点位置数据的语法细节不同。\n\n\n# geometry有顶点索引数据\n\n//三角形面积计算\nfunction areaoftriangle(p1, p2, p3) {\n    // 三角形两条边构建两个向量\n    const a = p2.clone().sub(p1);\n    const b = p3.clone().sub(p1);\n    // 两个向量叉乘结果c的几何含义：a.length()*b.length()*sin(θ)\n    const c = a.clone().cross(b);\n    // 三角形面积计算\n    const s = 0.5 * c.length();\n    return s\n}\n\n\n获取模型对象所有的三角形，分别计算某个三角形对应的面积，然后所有三角形面积累加，就可以获取模型的表面积。\n\nconst pos = geometry.attributes.position;\nconst index = geometry.index;\nconsole.log('geometry',geometry);\nlet s = 0;//表示物体表面积\nfor (var i = 0; i < index.count; i += 3) {\n    // 获取当前三角形对应三个顶点的索引\n    const i1 = index.getx(i);\n    const i2 = index.getx(i + 1);\n    const i3 = index.getx(i + 2);\n\n    //获取三个顶点的坐标 \n    const p1 = new three.vector3(pos.getx(i1), pos.gety(i1), pos.getz(i1));\n    const p2 = new three.vector3(pos.getx(i2), pos.gety(i2), pos.getz(i2));\n    const p3 = new three.vector3(pos.getx(i3), pos.gety(i3), pos.getz(i3));\n    s += areaoftriangle(p1, p2, p3); \n}\nconsole.log('s',s);\n\n//三角形面积计算\nfunction areaoftriangle(p1, p2, p3) {\n    // 三角形两条边构建两个向量\n    const a = p2.clone().sub(p1);\n    const b = p3.clone().sub(p1);\n    // 两个向量叉乘结果c的几何含义：a.length()*b.length()*sin(θ)\n    const c = a.clone().cross(b);\n    // 三角形面积计算\n    const s = 0.5 * c.length();\n    return s\n}\n\n\n\n# geometry没有顶点索引数据\n\ngeometry没有顶点索引数据,直接从顶点位置属性获取每间隔三个点作为一个三角形数据。\n\nconst pos = geometry.attributes.position;\nlet s = 0;//表示物体表面积\nfor (let i = 0; i < pos.count; i += 3) {\n    const p1 = new three.vector3(pos.getx(i), pos.gety(i), pos.getz(i));\n    const p2 = new three.vector3(pos.getx(i + 1), pos.gety(i + 1), pos.getz(i + 1));\n    const p3 = new three.vector3(pos.getx(i + 2), pos.gety(i + 2), pos.getz(i + 2));\n    s += areaoftriangle(p1, p2, p3);//所有三角形面积累加\n}\nconsole.log('s', s);\n//三角形面积计算\nfunction areaoftriangle(p1, p2, p3) {\n    // 三角形两条边构建两个向量\n    const a = p2.clone().sub(p1);\n    const b = p3.clone().sub(p1);\n    // 两个向量叉乘结果c的几何含义：a.length()*b.length()*sin(θ)\n    const c = a.clone().cross(b);\n    // 三角形面积计算\n    const s = 0.5 * c.length();\n    return s;\n}\n",charsets:{cjk:!0}},{title:"12. 点到直线的距离",frontmatter:{title:"12. 点到直线的距离",date:"2023-06-11T21:24:31.000Z",permalink:"/pages/1e8af7/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/12.%E7%82%B9%E5%88%B0%E7%9B%B4%E7%BA%BF%E7%9A%84%E8%B7%9D%E7%A6%BB.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/12.点到直线的距离.md",key:"v-763b4e35",path:"/pages/1e8af7/",headers:[{level:3,title:"已知条件",slug:"已知条件",normalizedTitle:"已知条件",charIndex:58},{level:3,title:"ApB构成一个三角形，计算三角形面积",slug:"apb构成一个三角形-计算三角形面积",normalizedTitle:"apb构成一个三角形，计算三角形面积",charIndex:244},{level:3,title:"计算三角形ApB底边AB的长度",slug:"计算三角形apb底边ab的长度",normalizedTitle:"计算三角形apb底边ab的长度",charIndex:455},{level:3,title:"计算三角形高度(点到直线的距离)",slug:"计算三角形高度-点到直线的距离",normalizedTitle:"计算三角形高度(点到直线的距离)",charIndex:541},{level:3,title:"点p到直线AB距离最终代码",slug:"点p到直线ab距离最终代码",normalizedTitle:"点p到直线ab距离最终代码",charIndex:747}],headersStr:"已知条件 ApB构成一个三角形，计算三角形面积 计算三角形ApB底边AB的长度 计算三角形高度(点到直线的距离) 点p到直线AB距离最终代码",content:"# 点到直线的距离\n\n通过threejs叉乘方法.cross()和点乘方法.dot()计算点到直线的距离。\n\n\n# 已知条件\n\n直线上的两个点的坐标，和直线外的的一点坐标。\n\n// 已知条件\n// 直线经过两点坐标A、B\nconst A = new THREE.Vector3(0, 0, 0);\nconst B = new THREE.Vector3(100, 0, 0);\n// 直线外一点p\nconst p = new THREE.Vector3(50, 0, 30);\n\n\n\n# ApB构成一个三角形，计算三角形面积\n\n向量ApB构建一个三角形，计算三角形面积。\n\n\n\n// ApB构建一个三角形，其中两条边构建向量a、向量b\nconst a = A.clone().sub(p);\nconst b = B.clone().sub(p);\nconst c = a.clone().cross(b);\nconst S = 0.5*c.length();//叉乘结果长度一半是三角形ApB的面积\n\n\n\n# 计算三角形ApB底边AB的长度\n\nconst AB = B.clone().sub(A);\nconst width = AB.length();//AB两点距离\n\n\n\n# 计算三角形高度(点到直线的距离)\n\n点p到AB直线的距离，就是三角形ApB在AB上的高度。\n\n\n\n//叉乘结果长度一半是三角形ApB的面积\nconst S = 0.5*c.length();\n//AB两点距离\nconst width = AB.length();\nconst H = S / width * 2;//三角形高度，也就是点到直线的距离\nconsole.log('点到直线的距离',H);\n\n\n\n# 点p到直线AB距离最终代码\n\nconst AB = B.clone().sub(A);\nconst width = AB.length();//AB两点距离\n// ApB构建一个三角形，其中两条边构建向量a、向量b\nconst a = A.clone().sub(p);\nconst b = B.clone().sub(p);\nconst c = a.clone().cross(b);\nconst H  = c.length()/width;//点到直线的距离\n",normalizedContent:"# 点到直线的距离\n\n通过threejs叉乘方法.cross()和点乘方法.dot()计算点到直线的距离。\n\n\n# 已知条件\n\n直线上的两个点的坐标，和直线外的的一点坐标。\n\n// 已知条件\n// 直线经过两点坐标a、b\nconst a = new three.vector3(0, 0, 0);\nconst b = new three.vector3(100, 0, 0);\n// 直线外一点p\nconst p = new three.vector3(50, 0, 30);\n\n\n\n# apb构成一个三角形，计算三角形面积\n\n向量apb构建一个三角形，计算三角形面积。\n\n\n\n// apb构建一个三角形，其中两条边构建向量a、向量b\nconst a = a.clone().sub(p);\nconst b = b.clone().sub(p);\nconst c = a.clone().cross(b);\nconst s = 0.5*c.length();//叉乘结果长度一半是三角形apb的面积\n\n\n\n# 计算三角形apb底边ab的长度\n\nconst ab = b.clone().sub(a);\nconst width = ab.length();//ab两点距离\n\n\n\n# 计算三角形高度(点到直线的距离)\n\n点p到ab直线的距离，就是三角形apb在ab上的高度。\n\n\n\n//叉乘结果长度一半是三角形apb的面积\nconst s = 0.5*c.length();\n//ab两点距离\nconst width = ab.length();\nconst h = s / width * 2;//三角形高度，也就是点到直线的距离\nconsole.log('点到直线的距离',h);\n\n\n\n# 点p到直线ab距离最终代码\n\nconst ab = b.clone().sub(a);\nconst width = ab.length();//ab两点距离\n// apb构建一个三角形，其中两条边构建向量a、向量b\nconst a = a.clone().sub(p);\nconst b = b.clone().sub(p);\nconst c = a.clone().cross(b);\nconst h  = c.length()/width;//点到直线的距离\n",charsets:{cjk:!0}},{title:"10. 叉乘计算三角形面积",frontmatter:{title:"10. 叉乘计算三角形面积",date:"2023-06-11T21:24:18.000Z",permalink:"/pages/03073e/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/03.3.%E5%90%91%E9%87%8F%E7%82%B9%E4%B9%98%E3%80%81%E5%8F%89%E4%B9%98/10.%E5%8F%89%E4%B9%98%E8%AE%A1%E7%AE%97%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF.html",relativePath:"02.Three.js进阶教程/03.3.向量点乘、叉乘/10.叉乘计算三角形面积.md",key:"v-740abe3c",path:"/pages/03073e/",headers:[{level:3,title:"知识回顾：向量叉乘几何意义",slug:"知识回顾-向量叉乘几何意义",normalizedTitle:"知识回顾：向量叉乘几何意义",charIndex:46},{level:3,title:"三角形两条边与夹角正弦值相乘的几何含义",slug:"三角形两条边与夹角正弦值相乘的几何含义",normalizedTitle:"三角形两条边与夹角正弦值相乘的几何含义",charIndex:214},{level:3,title:"叉乘.cross()和.length()计算三角形面积公式",slug:"叉乘-cross-和-length-计算三角形面积公式",normalizedTitle:"叉乘.cross()和.length()计算三角形面积公式",charIndex:325}],headersStr:"知识回顾：向量叉乘几何意义 三角形两条边与夹角正弦值相乘的几何含义 叉乘.cross()和.length()计算三角形面积公式",content:"# 叉乘计算三角形面积\n\n通过three.js叉乘.cross()计算三角形面积。\n\n\n# 知识回顾：向量叉乘几何意义\n\n假设向量a和b的夹角是θ，a和b叉乘结果是c，c的长度c.length()是a长度a.length()乘b长度b.length()乘夹角θ的正弦值sin(θ)\n\nc.crossVectors(a,b);\nc.length() = a.length()*b.length()*sin(θ)\n\n\n\n\n\n\n\n# 三角形两条边与夹角正弦值相乘的几何含义\n\nL1 x L2 x sin（θ）= h x L2 = 三角形面积2倍\n\n\n\n这提醒我们，可以用三角形的两条边构建两个向量进行叉乘，叉乘的结果c的长度就表示三角形面积的2倍\n\n\n# 叉乘.cross()和.length()计算三角形面积公式\n\n\n\n// 三角形两条边构建两个向量\nconst a = p2.clone().sub(p1);\nconst b = p3.clone().sub(p1);\n// 两个向量叉乘结果c的几何含义：a.length()*b.length()*sin(θ)\nconst c = a.clone().cross(b);\n\n// 三角形面积计算\nconst S = 0.5*c.length();\n\nconsole.log('S',S);\n\n",normalizedContent:"# 叉乘计算三角形面积\n\n通过three.js叉乘.cross()计算三角形面积。\n\n\n# 知识回顾：向量叉乘几何意义\n\n假设向量a和b的夹角是θ，a和b叉乘结果是c，c的长度c.length()是a长度a.length()乘b长度b.length()乘夹角θ的正弦值sin(θ)\n\nc.crossvectors(a,b);\nc.length() = a.length()*b.length()*sin(θ)\n\n\n\n\n\n\n\n# 三角形两条边与夹角正弦值相乘的几何含义\n\nl1 x l2 x sin（θ）= h x l2 = 三角形面积2倍\n\n\n\n这提醒我们，可以用三角形的两条边构建两个向量进行叉乘，叉乘的结果c的长度就表示三角形面积的2倍\n\n\n# 叉乘.cross()和.length()计算三角形面积公式\n\n\n\n// 三角形两条边构建两个向量\nconst a = p2.clone().sub(p1);\nconst b = p3.clone().sub(p1);\n// 两个向量叉乘结果c的几何含义：a.length()*b.length()*sin(θ)\nconst c = a.clone().cross(b);\n\n// 三角形面积计算\nconst s = 0.5*c.length();\n\nconsole.log('s',s);\n\n",charsets:{cjk:!0}},{title:"1. 欧拉角Euler",frontmatter:{title:"1. 欧拉角Euler",date:"2023-06-22T08:59:21.000Z",permalink:"/pages/4b4a0b/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/04.4.%E5%9B%9B%E5%85%83%E6%95%B0%E3%80%81%E6%AC%A7%E6%8B%89%E8%A7%92(%E8%A7%92%E5%BA%A6%E5%A7%BF%E6%80%81)/01.%E6%AC%A7%E6%8B%89%E8%A7%92Euler.html",relativePath:"02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/01.欧拉角Euler.md",key:"v-4217aa3d",path:"/pages/4b4a0b/",headers:[{level:3,title:"可视化本地坐标系(局部坐标系)",slug:"可视化本地坐标系-局部坐标系",normalizedTitle:"可视化本地坐标系(局部坐标系)",charIndex:98},{level:3,title:"创建一个欧拉角表示特定旋转角度",slug:"创建一个欧拉角表示特定旋转角度",normalizedTitle:"创建一个欧拉角表示特定旋转角度",charIndex:312},{level:3,title:"欧拉角改变物体姿态角度(.rotation属性)",slug:"欧拉角改变物体姿态角度-rotation属性",normalizedTitle:"欧拉角改变物体姿态角度(.rotation属性)",charIndex:483},{level:3,title:"物体旋转顺序.order",slug:"物体旋转顺序-order",normalizedTitle:"物体旋转顺序.order",charIndex:770},{level:3,title:".rotation.order",slug:"rotation-order",normalizedTitle:".rotation.order",charIndex:1255}],headersStr:"可视化本地坐标系(局部坐标系) 创建一个欧拉角表示特定旋转角度 欧拉角改变物体姿态角度(.rotation属性) 物体旋转顺序.order .rotation.order",content:"# 欧拉角Euler\n\n欧拉角Euler是用来表述物体空间姿态角度的一种数学工具，Three.js也提供了相关的类Euler。\n\n基础课程中介简单介绍过欧拉角，本节课再给大家详细介绍下。\n\n\n# 可视化本地坐标系(局部坐标系)\n\n在前面Three.js基础课程关于层级模型的讲解中，介绍过本地坐标和世界坐标。\n\n//相对世界坐标系坐标原点偏移\nfly.position.set(10, 10, 0);\n\n\n用一个坐标轴AxesHelper可视化模型的局部坐标系(本地坐标系)\n\nconst axesHelper = new THREE.AxesHelper(10);\nfly.add(axesHelper);\n\n\n\n\n\n# 创建一个欧拉角表示特定旋转角度\n\n//创建一个欧拉角对象，表示绕x轴旋转60度\nconst Euler = new THREE.Euler();\nEuler.x = Math.PI / 3;\n\n\nEuler.y = Math.PI / 3;//绕y轴旋转60度\n\n\nEuler.z = Math.PI / 3;//绕z轴旋转60度\n\n\n\n# 欧拉角改变物体姿态角度(.rotation属性)\n\nthreejs模型对象都有一个角度属性.rotation，.rotation的值其实就是欧拉角对象Euler。你可以改变.rotation对应欧拉角x、y或z属性值，查看物体姿态角度变化。\n\n// 物体fly绕x轴旋转60度\nfly.rotation.x = Math.PI / 3;\n\n\nconst Euler = new THREE.Euler();\nEuler.x = Math.PI / 3;\n// 复制欧拉角的值，赋值给物体的.rotation属性\nfly.rotation.copy(Euler);\n\n\n\n# 物体旋转顺序.order\n\n物体先后绕x、y、z轴旋转，旋转的顺序不同，物体的姿态角度也可能不同。\n\n欧拉角对象的.order属性是用来定义旋转顺序的，也就是说你同时设置欧拉对象的x、y、z三个属性，在旋转的时候，先绕哪个轴，后绕那个轴旋转。\n\n下面两段代码，欧拉角xyz属性是一样的，区别是.order表示的旋转顺序不同，你可以对比不同旋转顺序，物体旋转后姿态角度是否相同。\n\nconst Euler = new THREE.Euler();\nEuler.x = Math.PI / 3;\nEuler.y = Math.PI / 3;\n//先绕X轴旋转，在绕Y、Z轴旋转\nEuler.order = 'XYZ';\nfly.rotation.copy(Euler);\n\n\nconst Euler = new THREE.Euler();\nEuler.x = Math.PI / 3;\nEuler.y = Math.PI / 3;\n//先绕Y轴旋转，在绕X、Z轴旋转\nEuler.order = 'YXZ';\nfly.rotation.copy(Euler);\n\n\n\n# .rotation.order\n\nconst Euler = new THREE.Euler();\nEuler.x = Math.PI / 3;\nEuler.y = Math.PI / 3;\n//先绕Y轴旋转，在绕X、Z轴旋转\nEuler.order = 'YXZ';\nfly.rotation.copy(Euler);\n\n\n直接修改.rotation.order,和上面代码一样功能。\n\n// 直接修改fly.rotation\nfly.rotation.order = 'YXZ';\nfly.rotation.x = Math.PI / 3;\nfly.rotation.y = Math.PI / 3;\n",normalizedContent:"# 欧拉角euler\n\n欧拉角euler是用来表述物体空间姿态角度的一种数学工具，three.js也提供了相关的类euler。\n\n基础课程中介简单介绍过欧拉角，本节课再给大家详细介绍下。\n\n\n# 可视化本地坐标系(局部坐标系)\n\n在前面three.js基础课程关于层级模型的讲解中，介绍过本地坐标和世界坐标。\n\n//相对世界坐标系坐标原点偏移\nfly.position.set(10, 10, 0);\n\n\n用一个坐标轴axeshelper可视化模型的局部坐标系(本地坐标系)\n\nconst axeshelper = new three.axeshelper(10);\nfly.add(axeshelper);\n\n\n\n\n\n# 创建一个欧拉角表示特定旋转角度\n\n//创建一个欧拉角对象，表示绕x轴旋转60度\nconst euler = new three.euler();\neuler.x = math.pi / 3;\n\n\neuler.y = math.pi / 3;//绕y轴旋转60度\n\n\neuler.z = math.pi / 3;//绕z轴旋转60度\n\n\n\n# 欧拉角改变物体姿态角度(.rotation属性)\n\nthreejs模型对象都有一个角度属性.rotation，.rotation的值其实就是欧拉角对象euler。你可以改变.rotation对应欧拉角x、y或z属性值，查看物体姿态角度变化。\n\n// 物体fly绕x轴旋转60度\nfly.rotation.x = math.pi / 3;\n\n\nconst euler = new three.euler();\neuler.x = math.pi / 3;\n// 复制欧拉角的值，赋值给物体的.rotation属性\nfly.rotation.copy(euler);\n\n\n\n# 物体旋转顺序.order\n\n物体先后绕x、y、z轴旋转，旋转的顺序不同，物体的姿态角度也可能不同。\n\n欧拉角对象的.order属性是用来定义旋转顺序的，也就是说你同时设置欧拉对象的x、y、z三个属性，在旋转的时候，先绕哪个轴，后绕那个轴旋转。\n\n下面两段代码，欧拉角xyz属性是一样的，区别是.order表示的旋转顺序不同，你可以对比不同旋转顺序，物体旋转后姿态角度是否相同。\n\nconst euler = new three.euler();\neuler.x = math.pi / 3;\neuler.y = math.pi / 3;\n//先绕x轴旋转，在绕y、z轴旋转\neuler.order = 'xyz';\nfly.rotation.copy(euler);\n\n\nconst euler = new three.euler();\neuler.x = math.pi / 3;\neuler.y = math.pi / 3;\n//先绕y轴旋转，在绕x、z轴旋转\neuler.order = 'yxz';\nfly.rotation.copy(euler);\n\n\n\n# .rotation.order\n\nconst euler = new three.euler();\neuler.x = math.pi / 3;\neuler.y = math.pi / 3;\n//先绕y轴旋转，在绕x、z轴旋转\neuler.order = 'yxz';\nfly.rotation.copy(euler);\n\n\n直接修改.rotation.order,和上面代码一样功能。\n\n// 直接修改fly.rotation\nfly.rotation.order = 'yxz';\nfly.rotation.x = math.pi / 3;\nfly.rotation.y = math.pi / 3;\n",charsets:{cjk:!0}},{title:"2. 四元数Quaternion",frontmatter:{title:"2. 四元数Quaternion",date:"2023-06-22T08:59:32.000Z",permalink:"/pages/1fea5e/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/04.4.%E5%9B%9B%E5%85%83%E6%95%B0%E3%80%81%E6%AC%A7%E6%8B%89%E8%A7%92(%E8%A7%92%E5%BA%A6%E5%A7%BF%E6%80%81)/02.%E5%9B%9B%E5%85%83%E6%95%B0Quaternion.html",relativePath:"02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/02.四元数Quaternion.md",key:"v-5195a875",path:"/pages/1fea5e/",headers:[{level:3,title:"实例化Quaternion",slug:"实例化quaternion",normalizedTitle:"实例化quaternion",charIndex:260},{level:3,title:"四元数方法.setFromAxisAngle()",slug:"四元数方法-setfromaxisangle",normalizedTitle:"四元数方法.setfromaxisangle()",charIndex:361},{level:3,title:"需要旋转的A点坐标",slug:"需要旋转的a点坐标",normalizedTitle:"需要旋转的a点坐标",charIndex:745},{level:3,title:"四元数旋转A点坐标",slug:"四元数旋转a点坐标",normalizedTitle:"四元数旋转a点坐标",charIndex:1212}],headersStr:"实例化Quaternion 四元数方法.setFromAxisAngle() 需要旋转的A点坐标 四元数旋转A点坐标",content:"# 四元数Quaternion\n\n接着上节课欧拉角Euler的讲解，本节课给大家介绍threejs一个新的类,四元数Quaternion。\n\n四元数Quaternion和欧拉角Euler一样，可以用来计算或表示物体在3D空间中的旋转姿态角度。\n\nThree.js对四元数的数学细节和算法进行了封装，提供了一个四元数相关的类，平时写一些姿态角度的代码，可以使用Quaternion辅助。本节课，咱们就结合具体的threejs代码科普这个抽象的四元数概念，有了具体代码辅助，这样更容易使用四元数表示物体的姿态角度。\n\n\n# 实例化Quaternion\n\n实例化类Quaternion，你可以一个四元数对象Quaternion。\n\nconst quaternion = new THREE.Quaternion();\n\n\n\n# 四元数方法.setFromAxisAngle()\n\n.setFromAxisAngle()是四元数的一个方法，可以用来辅助生成表示特定旋转的四元数。\n\n.setFromAxisAngle(axis, angle)生成的四元数表示绕axis旋转，旋转角度是angle。\n\n.setFromAxisAngle()可以生成一个四元数，绕任意轴，旋转任意角度，并不局限于x、y、z轴。\n\nconst quaternion = new THREE.Quaternion();\n// 旋转轴new THREE.Vector3(0,0,1)\n// 旋转角度Math.PI/2\n// 绕z轴旋转90度\nquaternion.setFromAxisAngle(new THREE.Vector3(0,0,1),Math.PI/2);\n\n\n接下来用这个生成的四元数进行旋转计算。\n\n\n# 需要旋转的A点坐标\n\n// A表示3D空间一个点的位置坐标\nconst A = new THREE.Vector3(30, 0, 0);\n\n\n为了方便观察，可以把旋转A点的位置用一个小球Mesh可视化表示出来\n\n// 黄色小球可视化坐标点A \nconst Amesh = createSphereMesh(0xffff00,2);\nAmesh.position.copy(A);\ngroup.add(Amesh);\n// 创建小球mesh\nfunction createSphereMesh(color,R) {\n    const geometry = new THREE.SphereGeometry(R);\n    const material = new THREE.MeshLambertMaterial({\n        color: color,\n    });\n    const mesh = new THREE.Mesh(geometry, material);\n    return mesh;\n}\n\n\n\n# 四元数旋转A点坐标\n\nthreejs三维向量Vector3具有一个方法.applyQuaternion(quaternion)，该方法的功能就是通过参数quaternion对Vector3进行旋转，比如Vector3表示A点的xyz坐标，执行A.applyQuaternion(quaternion),相当于通过quaternion表示的四元数旋转A。\n\nconst quaternion = new THREE.Quaternion();\n// 绕z轴旋转90度\nquaternion.setFromAxisAngle(new THREE.Vector3(0,0,1),Math.PI/2);\n// 通过四元数旋转A点：把A点绕z轴旋转90度生成一个新的坐标点B\nconst B = A.clone().applyQuaternion(quaternion);\nconsole.log('B',B);//查看旋转后坐标\n\n\n你可以创建一个小球可视化查看B点位置\n\n// 红色小球可视化坐标点B \nconst Bmesh = createSphereMesh(0xff0000,2);\nBmesh.position.copy(B);\ngroup.add(Bmesh);\n",normalizedContent:"# 四元数quaternion\n\n接着上节课欧拉角euler的讲解，本节课给大家介绍threejs一个新的类,四元数quaternion。\n\n四元数quaternion和欧拉角euler一样，可以用来计算或表示物体在3d空间中的旋转姿态角度。\n\nthree.js对四元数的数学细节和算法进行了封装，提供了一个四元数相关的类，平时写一些姿态角度的代码，可以使用quaternion辅助。本节课，咱们就结合具体的threejs代码科普这个抽象的四元数概念，有了具体代码辅助，这样更容易使用四元数表示物体的姿态角度。\n\n\n# 实例化quaternion\n\n实例化类quaternion，你可以一个四元数对象quaternion。\n\nconst quaternion = new three.quaternion();\n\n\n\n# 四元数方法.setfromaxisangle()\n\n.setfromaxisangle()是四元数的一个方法，可以用来辅助生成表示特定旋转的四元数。\n\n.setfromaxisangle(axis, angle)生成的四元数表示绕axis旋转，旋转角度是angle。\n\n.setfromaxisangle()可以生成一个四元数，绕任意轴，旋转任意角度，并不局限于x、y、z轴。\n\nconst quaternion = new three.quaternion();\n// 旋转轴new three.vector3(0,0,1)\n// 旋转角度math.pi/2\n// 绕z轴旋转90度\nquaternion.setfromaxisangle(new three.vector3(0,0,1),math.pi/2);\n\n\n接下来用这个生成的四元数进行旋转计算。\n\n\n# 需要旋转的a点坐标\n\n// a表示3d空间一个点的位置坐标\nconst a = new three.vector3(30, 0, 0);\n\n\n为了方便观察，可以把旋转a点的位置用一个小球mesh可视化表示出来\n\n// 黄色小球可视化坐标点a \nconst amesh = createspheremesh(0xffff00,2);\namesh.position.copy(a);\ngroup.add(amesh);\n// 创建小球mesh\nfunction createspheremesh(color,r) {\n    const geometry = new three.spheregeometry(r);\n    const material = new three.meshlambertmaterial({\n        color: color,\n    });\n    const mesh = new three.mesh(geometry, material);\n    return mesh;\n}\n\n\n\n# 四元数旋转a点坐标\n\nthreejs三维向量vector3具有一个方法.applyquaternion(quaternion)，该方法的功能就是通过参数quaternion对vector3进行旋转，比如vector3表示a点的xyz坐标，执行a.applyquaternion(quaternion),相当于通过quaternion表示的四元数旋转a。\n\nconst quaternion = new three.quaternion();\n// 绕z轴旋转90度\nquaternion.setfromaxisangle(new three.vector3(0,0,1),math.pi/2);\n// 通过四元数旋转a点：把a点绕z轴旋转90度生成一个新的坐标点b\nconst b = a.clone().applyquaternion(quaternion);\nconsole.log('b',b);//查看旋转后坐标\n\n\n你可以创建一个小球可视化查看b点位置\n\n// 红色小球可视化坐标点b \nconst bmesh = createspheremesh(0xff0000,2);\nbmesh.position.copy(b);\ngroup.add(bmesh);\n",charsets:{cjk:!0}},{title:"4. 四元数乘法运算",frontmatter:{title:"4. 四元数乘法运算",date:"2023-06-22T16:46:05.000Z",permalink:"/pages/435568/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/04.4.%E5%9B%9B%E5%85%83%E6%95%B0%E3%80%81%E6%AC%A7%E6%8B%89%E8%A7%92(%E8%A7%92%E5%BA%A6%E5%A7%BF%E6%80%81)/04.%E5%9B%9B%E5%85%83%E6%95%B0%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97.html",relativePath:"02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/04.四元数乘法运算.md",key:"v-22a792ce",path:"/pages/435568/",headers:[{level:3,title:"四元数乘法.multiply()含义",slug:"四元数乘法-multiply-含义",normalizedTitle:"四元数乘法.multiply()含义",charIndex:177},{level:3,title:"四元数乘法顺序",slug:"四元数乘法顺序",normalizedTitle:"四元数乘法顺序",charIndex:685},{level:3,title:".multiply()与.copy()总结",slug:"multiply-与-copy-总结",normalizedTitle:".multiply()与.copy()总结",charIndex:1783}],headersStr:"四元数乘法.multiply()含义 四元数乘法顺序 .multiply()与.copy()总结",content:"# 四元数乘法运算.multiply()\n\n下面给大家介绍四元数的乘法运算，Three.js四元数Quaternion提供了多个用于四元数乘法运算的方法，比如.multiply()、.multiplyQuaternions()、.premultiply()，这些方法本质上都一样，只是语法细节不同，本节课以.multiply()为例给大家讲解。\n\n\n# 四元数乘法.multiply()含义\n\n两个四元数分别表示一个旋转，如果相乘，会得到一个新的四元数，新四元数表示两个旋转的组合旋转。\n\n// 在物体原来姿态基础上，进行旋转\nconst q1 = new THREE.Quaternion();\nq1.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);\nfly.quaternion.multiply(q1);\n// 在物体上次旋转基础上，进行旋转\nconst q2 = new THREE.Quaternion();\nq2.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);\nfly.quaternion.multiply(q2);\n// 在物体上次旋转基础上，进行旋转\nconst q3 = new THREE.Quaternion();\nq3.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI / 2);\nfly.quaternion.multiply(q3);\n\n\n\n# 四元数乘法顺序\n\n四元数乘法不满足交换律，q1.clone().multiply(q2)和q2.clone().multiply(q1)表示的旋转结果不同。\n\n// 在物体原来姿态基础上，进行旋转\nconst q1 = new THREE.Quaternion();\nq1.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);\nfly.quaternion.multiply(q1);\n// 在物体上次旋转基础上，进行旋转\nconst q2 = new THREE.Quaternion();\nq2.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);\nfly.quaternion.multiply(q2);\n\n\n先变换q1,后变换q2，和上面代码效果一样\n\nconst q1 = new THREE.Quaternion();\nq1.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);\nconst q2 = new THREE.Quaternion();\nq2.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);\nconst newQ= q1.clone().multiply(q2);\nfly.quaternion.multiply(newQ);\n\n\n先变换q2,后变换q1，和上面代码效果不一样，q2.clone().multiply(q1)与q1.clone().multiply(q2)的表示旋转过程顺序不同\n\n// 先变换q2,后变换q1，和上面代码效果不一样，\n// q2.clone().multiply(q1)与q1.clone().multiply(q2)表示的旋转过程顺序不同\nconst q1 = new THREE.Quaternion();\nq1.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);\nconst q2 = new THREE.Quaternion();\nq2.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);\nconst newQ= q2.clone().multiply(q1);\nfly.quaternion.multiply(newQ);\n\n\n\n# .multiply()与.copy()总结\n\nA.multiply(B)表示A乘以B，结果赋值给A，在A的基础上旋转B。\n\nA.copy(B)表示用B的值替换A的值，A表示的旋转会被B替换。\n\n可以先通过欧拉角改变物体的姿态，先物体一个初始的角度状态。\n\n//改变物体欧拉角，四元数属性也会同步改变\nfly.rotation.x = Math.PI/2;\n\n\n创建一个四元数表示一个旋转过程。\n\nconst quaternion = new THREE.Quaternion();\nquaternion.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI / 2);\n\n\n执行fly.quaternion.copy(quaternion)，参数quaternion表示的旋转会完全覆盖已有的旋转fly.quaternion。无论物体原来的姿态角度是什么样，都会被参数quaternion表示新的姿态角度覆盖。\n\n//quaternion表示旋转角度复制给物体.quaternion\nfly.quaternion.copy(quaternion);\n\n\n.quaternion.multiply(quaternion)表示在自身已有旋转的基础上，增加参数quaternion表示的旋转。\n\nfly.quaternion.multiply(quaternion);\n",normalizedContent:"# 四元数乘法运算.multiply()\n\n下面给大家介绍四元数的乘法运算，three.js四元数quaternion提供了多个用于四元数乘法运算的方法，比如.multiply()、.multiplyquaternions()、.premultiply()，这些方法本质上都一样，只是语法细节不同，本节课以.multiply()为例给大家讲解。\n\n\n# 四元数乘法.multiply()含义\n\n两个四元数分别表示一个旋转，如果相乘，会得到一个新的四元数，新四元数表示两个旋转的组合旋转。\n\n// 在物体原来姿态基础上，进行旋转\nconst q1 = new three.quaternion();\nq1.setfromaxisangle(new three.vector3(1, 0, 0), math.pi / 2);\nfly.quaternion.multiply(q1);\n// 在物体上次旋转基础上，进行旋转\nconst q2 = new three.quaternion();\nq2.setfromaxisangle(new three.vector3(0, 1, 0), math.pi / 2);\nfly.quaternion.multiply(q2);\n// 在物体上次旋转基础上，进行旋转\nconst q3 = new three.quaternion();\nq3.setfromaxisangle(new three.vector3(0, 0, 1), math.pi / 2);\nfly.quaternion.multiply(q3);\n\n\n\n# 四元数乘法顺序\n\n四元数乘法不满足交换律，q1.clone().multiply(q2)和q2.clone().multiply(q1)表示的旋转结果不同。\n\n// 在物体原来姿态基础上，进行旋转\nconst q1 = new three.quaternion();\nq1.setfromaxisangle(new three.vector3(1, 0, 0), math.pi / 2);\nfly.quaternion.multiply(q1);\n// 在物体上次旋转基础上，进行旋转\nconst q2 = new three.quaternion();\nq2.setfromaxisangle(new three.vector3(0, 1, 0), math.pi / 2);\nfly.quaternion.multiply(q2);\n\n\n先变换q1,后变换q2，和上面代码效果一样\n\nconst q1 = new three.quaternion();\nq1.setfromaxisangle(new three.vector3(1, 0, 0), math.pi / 2);\nconst q2 = new three.quaternion();\nq2.setfromaxisangle(new three.vector3(0, 1, 0), math.pi / 2);\nconst newq= q1.clone().multiply(q2);\nfly.quaternion.multiply(newq);\n\n\n先变换q2,后变换q1，和上面代码效果不一样，q2.clone().multiply(q1)与q1.clone().multiply(q2)的表示旋转过程顺序不同\n\n// 先变换q2,后变换q1，和上面代码效果不一样，\n// q2.clone().multiply(q1)与q1.clone().multiply(q2)表示的旋转过程顺序不同\nconst q1 = new three.quaternion();\nq1.setfromaxisangle(new three.vector3(1, 0, 0), math.pi / 2);\nconst q2 = new three.quaternion();\nq2.setfromaxisangle(new three.vector3(0, 1, 0), math.pi / 2);\nconst newq= q2.clone().multiply(q1);\nfly.quaternion.multiply(newq);\n\n\n\n# .multiply()与.copy()总结\n\na.multiply(b)表示a乘以b，结果赋值给a，在a的基础上旋转b。\n\na.copy(b)表示用b的值替换a的值，a表示的旋转会被b替换。\n\n可以先通过欧拉角改变物体的姿态，先物体一个初始的角度状态。\n\n//改变物体欧拉角，四元数属性也会同步改变\nfly.rotation.x = math.pi/2;\n\n\n创建一个四元数表示一个旋转过程。\n\nconst quaternion = new three.quaternion();\nquaternion.setfromaxisangle(new three.vector3(0, 0, 1), math.pi / 2);\n\n\n执行fly.quaternion.copy(quaternion)，参数quaternion表示的旋转会完全覆盖已有的旋转fly.quaternion。无论物体原来的姿态角度是什么样，都会被参数quaternion表示新的姿态角度覆盖。\n\n//quaternion表示旋转角度复制给物体.quaternion\nfly.quaternion.copy(quaternion);\n\n\n.quaternion.multiply(quaternion)表示在自身已有旋转的基础上，增加参数quaternion表示的旋转。\n\nfly.quaternion.multiply(quaternion);\n",charsets:{cjk:!0}},{title:"5. 四元数表示两个向量旋转",frontmatter:{title:"5. 四元数表示两个向量旋转",date:"2023-06-22T16:46:36.000Z",permalink:"/pages/72cb3f/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/04.4.%E5%9B%9B%E5%85%83%E6%95%B0%E3%80%81%E6%AC%A7%E6%8B%89%E8%A7%92(%E8%A7%92%E5%BA%A6%E5%A7%BF%E6%80%81)/05.%E5%9B%9B%E5%85%83%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%B8%A4%E4%B8%AA%E5%90%91%E9%87%8F%E6%97%8B%E8%BD%AC.html",relativePath:"02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/05.四元数表示两个向量旋转.md",key:"v-0717c793",path:"/pages/72cb3f/",headers:[{level:3,title:"已知条件",slug:"已知条件",normalizedTitle:"已知条件",charIndex:126},{level:3,title:"箭头可视化飞机旋转前后的方向",slug:"箭头可视化飞机旋转前后的方向",normalizedTitle:"箭头可视化飞机旋转前后的方向",charIndex:598},{level:3,title:".setFromUnitVectors(a, b)生成四元数旋转飞机",slug:"setfromunitvectors-a-b-生成四元数旋转飞机",normalizedTitle:".setfromunitvectors(a, b)生成四元数旋转飞机",charIndex:910},{level:3,title:"练习题：人旋转",slug:"练习题-人旋转",normalizedTitle:"练习题：人旋转",charIndex:1369}],headersStr:"已知条件 箭头可视化飞机旋转前后的方向 .setFromUnitVectors(a, b)生成四元数旋转飞机 练习题：人旋转",content:'# 四元数表示两个向量旋转\n\n\n\n3D空间中有两个向量，一个向量向另外一个向量旋转，这个过程可以用一个四元数表示。\n\n下面给大家介绍一个四元数Quaternion的方法.setFromUnitVectors(a, b),计算参数a到b的旋转。\n\n\n# 已知条件\n\n已知飞行原来的飞行方向是a表示的方向，需要把飞机飞行方向旋转到向量b表示的方向。\n\n\n\nconst model = new THREE.Group();\nloader.load("../飞机.glb", function (gltf) {\n    const fly = gltf.scene\n    model.add(fly);\n    fly.position.set(10, 10, 0);//相对世界坐标系坐标原点偏移\n    const axesHelper = new THREE.AxesHelper(10);\n    fly.add(axesHelper);//用一个坐标轴可视化模型的局部坐标系(本地坐标系)\n\n\n    const a = new THREE.Vector3(0, 0, -1);//飞机初始姿态飞行方向\n    // 飞机姿态绕自身坐标原点旋转到b指向的方向\n    const b = new THREE.Vector3(-1, -1, -1).normalize();\n\n})\n\n\n\n# 箭头可视化飞机旋转前后的方向\n\n// 可视化飞机方向\nconst a = new THREE.Vector3(0, 0, -1);//飞机初始姿态飞行方向\nconst O = fly.position.clone();//飞机位置坐标箭头起点\nmodel.add(new THREE.ArrowHelper(a, O, 30, 0xff0000));\n// 飞机姿态绕自身坐标原点旋转到b指向的方向\nconst b = new THREE.Vector3(-1, -1, -1).normalize();\nmodel.add(new THREE.ArrowHelper(b, O, 30, 0x00ff00));\n\n\n\n# .setFromUnitVectors(a, b)生成四元数旋转飞机\n\n四元数Quaternion的方法.setFromUnitVectors(a, b)可以通过两个向量参数a和b，创建一个四元数，表示从向量a表示的方向旋转到向量b表示的方向。(参数a, b是单位向量)\n\n//飞机初始姿态飞行方向a\nconst a = new THREE.Vector3(0, 0, -1);\n// 飞机姿态绕自身坐标原点旋转到b指向的方向\nconst b = new THREE.Vector3(-1, -1, -1).normalize();\n// a旋转到b构成的四元数\nconst quaternion = new THREE.Quaternion();\n//注意两个参数的顺序\nquaternion.setFromUnitVectors(a, b);\n// quaternion表示的是变化过程，在原来基础上乘以quaternion即可\nfly.quaternion.multiply(quaternion);\n\n\n\n# 练习题：人旋转\n\n已知人原来的正前方是a表示的方向，需要把人正前方旋转到向量b表示的方向。\n\n\n\n这个旋转过程，可通过.setFromUnitVectors(a, b)\n\n//人正前方从向量a表示方向旋转到向量b表示方向\nconst q = new THREE.Quaternion();\nq.setFromUnitVectors(a,b);//a转向b\nperson.quaternion.multiply(q);\n',normalizedContent:'# 四元数表示两个向量旋转\n\n\n\n3d空间中有两个向量，一个向量向另外一个向量旋转，这个过程可以用一个四元数表示。\n\n下面给大家介绍一个四元数quaternion的方法.setfromunitvectors(a, b),计算参数a到b的旋转。\n\n\n# 已知条件\n\n已知飞行原来的飞行方向是a表示的方向，需要把飞机飞行方向旋转到向量b表示的方向。\n\n\n\nconst model = new three.group();\nloader.load("../飞机.glb", function (gltf) {\n    const fly = gltf.scene\n    model.add(fly);\n    fly.position.set(10, 10, 0);//相对世界坐标系坐标原点偏移\n    const axeshelper = new three.axeshelper(10);\n    fly.add(axeshelper);//用一个坐标轴可视化模型的局部坐标系(本地坐标系)\n\n\n    const a = new three.vector3(0, 0, -1);//飞机初始姿态飞行方向\n    // 飞机姿态绕自身坐标原点旋转到b指向的方向\n    const b = new three.vector3(-1, -1, -1).normalize();\n\n})\n\n\n\n# 箭头可视化飞机旋转前后的方向\n\n// 可视化飞机方向\nconst a = new three.vector3(0, 0, -1);//飞机初始姿态飞行方向\nconst o = fly.position.clone();//飞机位置坐标箭头起点\nmodel.add(new three.arrowhelper(a, o, 30, 0xff0000));\n// 飞机姿态绕自身坐标原点旋转到b指向的方向\nconst b = new three.vector3(-1, -1, -1).normalize();\nmodel.add(new three.arrowhelper(b, o, 30, 0x00ff00));\n\n\n\n# .setfromunitvectors(a, b)生成四元数旋转飞机\n\n四元数quaternion的方法.setfromunitvectors(a, b)可以通过两个向量参数a和b，创建一个四元数，表示从向量a表示的方向旋转到向量b表示的方向。(参数a, b是单位向量)\n\n//飞机初始姿态飞行方向a\nconst a = new three.vector3(0, 0, -1);\n// 飞机姿态绕自身坐标原点旋转到b指向的方向\nconst b = new three.vector3(-1, -1, -1).normalize();\n// a旋转到b构成的四元数\nconst quaternion = new three.quaternion();\n//注意两个参数的顺序\nquaternion.setfromunitvectors(a, b);\n// quaternion表示的是变化过程，在原来基础上乘以quaternion即可\nfly.quaternion.multiply(quaternion);\n\n\n\n# 练习题：人旋转\n\n已知人原来的正前方是a表示的方向，需要把人正前方旋转到向量b表示的方向。\n\n\n\n这个旋转过程，可通过.setfromunitvectors(a, b)\n\n//人正前方从向量a表示方向旋转到向量b表示方向\nconst q = new three.quaternion();\nq.setfromunitvectors(a,b);//a转向b\nperson.quaternion.multiply(q);\n',charsets:{cjk:!0}},{title:"3. 四元数表示物体姿态",frontmatter:{title:"3. 四元数表示物体姿态",date:"2023-06-22T08:59:39.000Z",permalink:"/pages/44207d/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/04.4.%E5%9B%9B%E5%85%83%E6%95%B0%E3%80%81%E6%AC%A7%E6%8B%89%E8%A7%92(%E8%A7%92%E5%BA%A6%E5%A7%BF%E6%80%81)/03.%E5%9B%9B%E5%85%83%E6%95%B0%E8%A1%A8%E7%A4%BA%E7%89%A9%E4%BD%93%E5%A7%BF%E6%80%81.html",relativePath:"02.Three.js进阶教程/04.4.四元数、欧拉角(角度姿态)/03.四元数表示物体姿态.md",key:"v-1f67061d",path:"/pages/44207d/",headers:[{level:3,title:"创建一个四元数",slug:"创建一个四元数",normalizedTitle:"创建一个四元数",charIndex:121},{level:3,title:".quaternion属性",slug:"quaternion属性",normalizedTitle:".quaternion属性",charIndex:93},{level:3,title:"总结：物体角度属性.rotation和四元数属性.quaternion",slug:"总结-物体角度属性-rotation和四元数属性-quaternion",normalizedTitle:"总结：物体角度属性.rotation和四元数属性.quaternion",charIndex:622}],headersStr:"创建一个四元数 .quaternion属性 总结：物体角度属性.rotation和四元数属性.quaternion",content:"# 四元数Quaternion表示物体姿态\n\nThree.js模型对象都有一个属性.quaternion，.quaternion的属性值就是四元数对象Quaternion。你可以通过物体.quaternion属性改变物体的姿态角度。\n\n\n# 创建一个四元数\n\n创建一个绕x轴旋转90度的四元数\n\n// 四元数表示姿态角度\nconst quaternion = new THREE.Quaternion();\n// 旋转轴new THREE.Vector3(1,0,0)\n// 旋转角度Math.PI/2\nquaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);\n\n\n\n# .quaternion属性\n\n改变物体的四元数属性.quaternion，也就是改变物体的姿态角度。\n\n.copy()是四元数的一个方法，A.copy(B)表示把A四元数设置为B四元数的值，或者说把B的值复制给A。\n\nconst quaternion = new THREE.Quaternion();\nquaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);\n//quaternion表示旋转角度复制给物体.quaternion\nfly.quaternion.copy(quaternion);\n\n\n\n# 总结：物体角度属性.rotation和四元数属性.quaternion\n\n\n\nthree.js模型对象的角度.rotation和四元数.quaternion属性都是用来表示物体姿态角度的，只是表达形式不同而已，.rotation和.quaternion两个属性的值，一个改变，另一个也会同步改变。\n\nconst quaternion = new THREE.Quaternion();\nquaternion.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI / 2);\nfly.quaternion.copy(quaternion);\n// 四元数属性改变后，查看角度属性(欧拉角)变化\n// .quaternion改变，.rotation同步改变\nconsole.log('角度属性',fly.rotation.z);\n",normalizedContent:"# 四元数quaternion表示物体姿态\n\nthree.js模型对象都有一个属性.quaternion，.quaternion的属性值就是四元数对象quaternion。你可以通过物体.quaternion属性改变物体的姿态角度。\n\n\n# 创建一个四元数\n\n创建一个绕x轴旋转90度的四元数\n\n// 四元数表示姿态角度\nconst quaternion = new three.quaternion();\n// 旋转轴new three.vector3(1,0,0)\n// 旋转角度math.pi/2\nquaternion.setfromaxisangle(new three.vector3(1, 0, 0), math.pi / 2);\n\n\n\n# .quaternion属性\n\n改变物体的四元数属性.quaternion，也就是改变物体的姿态角度。\n\n.copy()是四元数的一个方法，a.copy(b)表示把a四元数设置为b四元数的值，或者说把b的值复制给a。\n\nconst quaternion = new three.quaternion();\nquaternion.setfromaxisangle(new three.vector3(1, 0, 0), math.pi / 2);\n//quaternion表示旋转角度复制给物体.quaternion\nfly.quaternion.copy(quaternion);\n\n\n\n# 总结：物体角度属性.rotation和四元数属性.quaternion\n\n\n\nthree.js模型对象的角度.rotation和四元数.quaternion属性都是用来表示物体姿态角度的，只是表达形式不同而已，.rotation和.quaternion两个属性的值，一个改变，另一个也会同步改变。\n\nconst quaternion = new three.quaternion();\nquaternion.setfromaxisangle(new three.vector3(0, 0, 1), math.pi / 2);\nfly.quaternion.copy(quaternion);\n// 四元数属性改变后，查看角度属性(欧拉角)变化\n// .quaternion改变，.rotation同步改变\nconsole.log('角度属性',fly.rotation.z);\n",charsets:{cjk:!0}},{title:"1. 数学基础(平移、旋转、缩放矩阵)",frontmatter:{title:"1. 数学基础(平移、旋转、缩放矩阵)",date:"2023-06-22T08:59:02.000Z",permalink:"/pages/0be3f8/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/05.5.%E7%9F%A9%E9%98%B5/01.%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80(%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5).html",relativePath:"02.Three.js进阶教程/05.5.矩阵/01.数学基础(平移、旋转、缩放矩阵).md",key:"v-a2b567ae",path:"/pages/0be3f8/",headersStr:null,content:"# 数学基础(平移、旋转、缩放矩阵)\n\n矩阵介绍，参考WebGPU中讲解，矩阵内容是一样的。\n\n数学基础(平移、旋转、缩放矩阵)：http://www.webgl3d.cn/pages/38777d/",normalizedContent:"# 数学基础(平移、旋转、缩放矩阵)\n\n矩阵介绍，参考webgpu中讲解，矩阵内容是一样的。\n\n数学基础(平移、旋转、缩放矩阵)：http://www.webgl3d.cn/pages/38777d/",charsets:{cjk:!0}},{title:"2. 模型矩阵",frontmatter:{title:"2. 模型矩阵",date:"2023-06-22T08:58:52.000Z",permalink:"/pages/f6ddf9/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/05.5.%E7%9F%A9%E9%98%B5/02.%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5.html",relativePath:"02.Three.js进阶教程/05.5.矩阵/02.模型矩阵.md",key:"v-64b14f88",path:"/pages/f6ddf9/",headersStr:null,content:"# 模型矩阵\n\n关于模型矩阵介绍，参考WebGPU中讲解，内容是一样的。\n\n2. 模型矩阵：http://www.webgl3d.cn/pages/47d092/",normalizedContent:"# 模型矩阵\n\n关于模型矩阵介绍，参考webgpu中讲解，内容是一样的。\n\n2. 模型矩阵：http://www.webgl3d.cn/pages/47d092/",charsets:{cjk:!0}},{title:"3. Three.js矩阵Matrix4",frontmatter:{title:"3. Three.js矩阵Matrix4",date:"2023-06-29T18:01:01.000Z",permalink:"/pages/adcb9e/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/05.5.%E7%9F%A9%E9%98%B5/03.Three.js%E7%9F%A9%E9%98%B5Matrix4.html",relativePath:"02.Three.js进阶教程/05.5.矩阵/03.Three.js矩阵Matrix4.md",key:"v-5c0fecb8",path:"/pages/adcb9e/",headers:[{level:3,title:"创建4x4矩阵Matrix4对象",slug:"创建4x4矩阵matrix4对象",normalizedTitle:"创建4x4矩阵matrix4对象",charIndex:156},{level:3,title:"属性.elements设置平移矩阵",slug:"属性-elements设置平移矩阵",normalizedTitle:"属性.elements设置平移矩阵",charIndex:227},{level:3,title:"顶点坐标进行矩阵变换Vector3.applyMatrix4()",slug:"顶点坐标进行矩阵变换vector3-applymatrix4",normalizedTitle:"顶点坐标进行矩阵变换vector3.applymatrix4()",charIndex:702},{level:3,title:"快速生成平移、旋转、缩放矩阵",slug:"快速生成平移、旋转、缩放矩阵",normalizedTitle:"快速生成平移、旋转、缩放矩阵",charIndex:1008}],headersStr:"创建4x4矩阵Matrix4对象 属性.elements设置平移矩阵 顶点坐标进行矩阵变换Vector3.applyMatrix4() 快速生成平移、旋转、缩放矩阵",content:"# Three.js矩阵Matrix4\n\n前面两节课，给大家介绍了模型矩阵的数学基础理论，下面给大家介绍Three.js的一个矩阵相关类Matrix4(4x4矩阵)，并用Matrix4创建平移矩阵、旋转矩阵、缩放矩阵。\n\n查看4x4矩阵Matrix4文档，你可以看到很多相关矩阵相关的数学几何计算方法。\n\n\n# 创建4x4矩阵Matrix4对象\n\n// 创建一个4x4矩阵对象\nconst mat4 = new THREE.Matrix4()\n\n\n\n# 属性.elements设置平移矩阵\n\n\n\n通过4x4矩阵Matrix4的属性.elements设置矩阵的值，比如设置一个平移矩阵。\n\n.elements属性值是一个数组，数组的元素就是4x4矩阵的16个数字，数字在数组中按照矩阵列的顺序，一列一节输入数组中。\n\n// 平移矩阵，沿着x轴平移50\n// 1, 0, 0, x,\n// 0, 1, 0, y,\n// 0, 0, 1, z,\n// 0, 0, 0, 1\nconst mat4 = new THREE.Matrix4()\nmat4.elements=[1,0,0,0, 0,1,0,0, 0,0,1,0, 50, 0, 0, 1];\n\n\n.elements属性不设置，默认是单位矩阵。\n\nconst mat4 = new THREE.Matrix4()\n// 默认值单位矩阵\n// 1, 0, 0, 0,\n// 0, 1, 0, 0,\n// 0, 0, 1, 0,\n// 0, 0, 0, 1\nconsole.log('.elements默认值', mat4.elements);\n\n\n\n# 顶点坐标进行矩阵变换Vector3.applyMatrix4()\n\n.applyMatrix4()是三维向量Vector3的一个方法，如果Vector3表示一个顶点xyz坐标，Vector3执行.applyMatrix4()方法意味着通过矩阵对顶点坐标进行矩阵变换，比如平移、旋转、缩放。\n\n// 空间中p点坐标\nconst p = new THREE.Vector3(50,0,0);\n// 矩阵对p点坐标进行平移变换\np.applyMatrix4(mat4);\nconsole.log('查看平移后p点坐标',p);\n\n\n\n\n//用小球可视化p点位置\nmesh.position.copy(p);\n\n\n\n# 快速生成平移、旋转、缩放矩阵\n\n使用threejs平移矩阵、旋转矩阵、缩放矩阵，可以不用自己直接设置.elements的值。threejs提供了一些更为简单的方法，辅助创建各种几何变换矩阵。\n\n你可以分别测试下面方法，作为练习，去改变一个坐标点，并用小球可视化变换后的坐标位置。\n\n * 平移矩阵.makeTranslation(Tx,Ty,Tz)\n * 缩放矩阵.makeScale(Sx,Sy,Sz)\n * 绕x轴的旋转矩阵.makeRotationX(angleX)\n * 绕y轴的旋转矩阵.makeRotationY(angleY)\n * 绕z轴的旋转矩阵.makeRotationZ(angleZ)\n\nconst mat4 = new THREE.Matrix4();\n// 生成平移矩阵(沿着x轴平移50)\nmat4.makeTranslation(50,0,0);\n// 结果和.elements=[1,0,0,0,...... 50, 0, 0, 1]一样\nconsole.log('查看矩阵的值',mat4.elements);\n\n\n平移矩阵案例\n\nconst mat4 = new THREE.Matrix4();\n// 生成平移矩阵(沿着x轴平移50)\n// mat4.makeTranslation(50,0,0);\nconsole.log('查看矩阵的值',mat4.elements);\n\n\n旋转矩阵案例\n\nconst mat4 = new THREE.Matrix4();\n//生成绕z轴旋转90度的矩阵\nmat4.makeRotationZ(Math.PI/2);\n",normalizedContent:"# three.js矩阵matrix4\n\n前面两节课，给大家介绍了模型矩阵的数学基础理论，下面给大家介绍three.js的一个矩阵相关类matrix4(4x4矩阵)，并用matrix4创建平移矩阵、旋转矩阵、缩放矩阵。\n\n查看4x4矩阵matrix4文档，你可以看到很多相关矩阵相关的数学几何计算方法。\n\n\n# 创建4x4矩阵matrix4对象\n\n// 创建一个4x4矩阵对象\nconst mat4 = new three.matrix4()\n\n\n\n# 属性.elements设置平移矩阵\n\n\n\n通过4x4矩阵matrix4的属性.elements设置矩阵的值，比如设置一个平移矩阵。\n\n.elements属性值是一个数组，数组的元素就是4x4矩阵的16个数字，数字在数组中按照矩阵列的顺序，一列一节输入数组中。\n\n// 平移矩阵，沿着x轴平移50\n// 1, 0, 0, x,\n// 0, 1, 0, y,\n// 0, 0, 1, z,\n// 0, 0, 0, 1\nconst mat4 = new three.matrix4()\nmat4.elements=[1,0,0,0, 0,1,0,0, 0,0,1,0, 50, 0, 0, 1];\n\n\n.elements属性不设置，默认是单位矩阵。\n\nconst mat4 = new three.matrix4()\n// 默认值单位矩阵\n// 1, 0, 0, 0,\n// 0, 1, 0, 0,\n// 0, 0, 1, 0,\n// 0, 0, 0, 1\nconsole.log('.elements默认值', mat4.elements);\n\n\n\n# 顶点坐标进行矩阵变换vector3.applymatrix4()\n\n.applymatrix4()是三维向量vector3的一个方法，如果vector3表示一个顶点xyz坐标，vector3执行.applymatrix4()方法意味着通过矩阵对顶点坐标进行矩阵变换，比如平移、旋转、缩放。\n\n// 空间中p点坐标\nconst p = new three.vector3(50,0,0);\n// 矩阵对p点坐标进行平移变换\np.applymatrix4(mat4);\nconsole.log('查看平移后p点坐标',p);\n\n\n\n\n//用小球可视化p点位置\nmesh.position.copy(p);\n\n\n\n# 快速生成平移、旋转、缩放矩阵\n\n使用threejs平移矩阵、旋转矩阵、缩放矩阵，可以不用自己直接设置.elements的值。threejs提供了一些更为简单的方法，辅助创建各种几何变换矩阵。\n\n你可以分别测试下面方法，作为练习，去改变一个坐标点，并用小球可视化变换后的坐标位置。\n\n * 平移矩阵.maketranslation(tx,ty,tz)\n * 缩放矩阵.makescale(sx,sy,sz)\n * 绕x轴的旋转矩阵.makerotationx(anglex)\n * 绕y轴的旋转矩阵.makerotationy(angley)\n * 绕z轴的旋转矩阵.makerotationz(anglez)\n\nconst mat4 = new three.matrix4();\n// 生成平移矩阵(沿着x轴平移50)\nmat4.maketranslation(50,0,0);\n// 结果和.elements=[1,0,0,0,...... 50, 0, 0, 1]一样\nconsole.log('查看矩阵的值',mat4.elements);\n\n\n平移矩阵案例\n\nconst mat4 = new three.matrix4();\n// 生成平移矩阵(沿着x轴平移50)\n// mat4.maketranslation(50,0,0);\nconsole.log('查看矩阵的值',mat4.elements);\n\n\n旋转矩阵案例\n\nconst mat4 = new three.matrix4();\n//生成绕z轴旋转90度的矩阵\nmat4.makerotationz(math.pi/2);\n",charsets:{cjk:!0}},{title:"4. 矩阵乘法multiply",frontmatter:{title:"4. 矩阵乘法multiply",date:"2023-06-29T18:01:13.000Z",permalink:"/pages/6d4b1f/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/05.5.%E7%9F%A9%E9%98%B5/04.%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95multiply.html",relativePath:"02.Three.js进阶教程/05.5.矩阵/04.矩阵乘法multiply.md",key:"v-63de3e24",path:"/pages/6d4b1f/",headers:[{level:3,title:"回顾矩阵创建知识",slug:"回顾矩阵创建知识",normalizedTitle:"回顾矩阵创建知识",charIndex:247},{level:3,title:"矩阵乘法.multiply()含义",slug:"矩阵乘法-multiply-含义",normalizedTitle:"矩阵乘法.multiply()含义",charIndex:726},{level:3,title:"矩阵乘法顺序",slug:"矩阵乘法顺序",normalizedTitle:"矩阵乘法顺序",charIndex:1181}],headersStr:"回顾矩阵创建知识 矩阵乘法.multiply()含义 矩阵乘法顺序",content:"# 矩阵乘法运算.multiply()\n\n下面给大家介绍矩阵的乘法运算，查看文档，你可看到Three.js矩阵Matrix4类直接提供的矩阵乘法运算方法，比如.multiply()、.multiplyMatrices()、.premultiply()，这三个方法功能相同，只是语法细节有差异而已。\n\n * c.multiplyMatrices(a,b):axb，结果保存在c\n * a.multiply(b):axb，保存在a\n * a.premultiply(b):bxa，保存在a\n\n\n# 回顾矩阵创建知识\n\n先回顾下，上节课创建平移、旋转、缩放矩阵的知识点。\n\n * 平移矩阵.makeTranslation(Tx,Ty,Tz)\n * 缩放矩阵.makeScale(Sx,Sy,Sz)\n * 绕x轴的旋转矩阵.makeRotationX(angleX)\n * 绕y轴的旋转矩阵.makeRotationY(angleY)\n * 绕z轴的旋转矩阵.makeRotationZ(angleZ)\n\n// 空间中p点坐标\nconst p = new THREE.Vector3(50,0,0);\n\nconst T = new THREE.Matrix4();\nT.makeTranslation(50,0,0);//平移矩阵\nconst R = new THREE.Matrix4();\nR.makeRotationZ(Math.PI/2);//旋转矩阵\n// p点矩阵变换\np.applyMatrix4(T);//先平移\np.applyMatrix4(R);//后旋转\n\nmesh.position.copy(p);//用小球可视化p点位置\n\n\n\n# 矩阵乘法.multiply()含义\n\n关于平移矩阵、旋转矩阵和缩放矩阵乘法的含义，前面给大家讲解过，咱们这里再强调一遍。\n\n比如两个矩阵，一个是平移矩阵T、一个是旋转矩阵R，两个矩阵相乘的结果，就表示旋转和平移的复合变换。\n\n下面代码先把旋转矩阵和平移矩阵相乘，然后再对坐标进行变换，你可以看到结果上面代码相同。\n\nconst T = new THREE.Matrix4();\nT.makeTranslation(50,0,0);//平移矩阵\nconst R = new THREE.Matrix4();\nR.makeRotationZ(Math.PI/2);//旋转矩阵\n\n// p点矩阵变换\n// p.applyMatrix4(T);//先平移\n// p.applyMatrix4(R);//后旋转\n\n// 旋转矩阵和平移矩阵相乘得到一个复合模型矩阵\nconst modelMatrix = R.clone().multiply(T);\np.applyMatrix4(modelMatrix);\n\n\n\n# 矩阵乘法顺序\n\n矩阵乘法除特殊情况外，一般不满足交换律，R.clone().multiply(T)和T.clone().multiply(R)表示的结果不同，也就是R * T和T * R计算结果不同。\n\nR * T * p表示p点先平移、后旋转\n\n// R * T * p:先平移、后旋转\nconst modelMatrix = R.clone().multiply(T);\np.applyMatrix4(modelMatrix);\n\n\nT * R * p表示p点先旋转、后平移\n\n// T * R * p：先旋转、后平移\nconst modelMatrix = R.clone().multiply(T);\np.applyMatrix4(modelMatrix);\n\n\n哪个几何变换先发生，在矩阵乘法公式中，对应矩阵更靠近p点，或者说根据矩阵变换顺序，从右往左写。",normalizedContent:"# 矩阵乘法运算.multiply()\n\n下面给大家介绍矩阵的乘法运算，查看文档，你可看到three.js矩阵matrix4类直接提供的矩阵乘法运算方法，比如.multiply()、.multiplymatrices()、.premultiply()，这三个方法功能相同，只是语法细节有差异而已。\n\n * c.multiplymatrices(a,b):axb，结果保存在c\n * a.multiply(b):axb，保存在a\n * a.premultiply(b):bxa，保存在a\n\n\n# 回顾矩阵创建知识\n\n先回顾下，上节课创建平移、旋转、缩放矩阵的知识点。\n\n * 平移矩阵.maketranslation(tx,ty,tz)\n * 缩放矩阵.makescale(sx,sy,sz)\n * 绕x轴的旋转矩阵.makerotationx(anglex)\n * 绕y轴的旋转矩阵.makerotationy(angley)\n * 绕z轴的旋转矩阵.makerotationz(anglez)\n\n// 空间中p点坐标\nconst p = new three.vector3(50,0,0);\n\nconst t = new three.matrix4();\nt.maketranslation(50,0,0);//平移矩阵\nconst r = new three.matrix4();\nr.makerotationz(math.pi/2);//旋转矩阵\n// p点矩阵变换\np.applymatrix4(t);//先平移\np.applymatrix4(r);//后旋转\n\nmesh.position.copy(p);//用小球可视化p点位置\n\n\n\n# 矩阵乘法.multiply()含义\n\n关于平移矩阵、旋转矩阵和缩放矩阵乘法的含义，前面给大家讲解过，咱们这里再强调一遍。\n\n比如两个矩阵，一个是平移矩阵t、一个是旋转矩阵r，两个矩阵相乘的结果，就表示旋转和平移的复合变换。\n\n下面代码先把旋转矩阵和平移矩阵相乘，然后再对坐标进行变换，你可以看到结果上面代码相同。\n\nconst t = new three.matrix4();\nt.maketranslation(50,0,0);//平移矩阵\nconst r = new three.matrix4();\nr.makerotationz(math.pi/2);//旋转矩阵\n\n// p点矩阵变换\n// p.applymatrix4(t);//先平移\n// p.applymatrix4(r);//后旋转\n\n// 旋转矩阵和平移矩阵相乘得到一个复合模型矩阵\nconst modelmatrix = r.clone().multiply(t);\np.applymatrix4(modelmatrix);\n\n\n\n# 矩阵乘法顺序\n\n矩阵乘法除特殊情况外，一般不满足交换律，r.clone().multiply(t)和t.clone().multiply(r)表示的结果不同，也就是r * t和t * r计算结果不同。\n\nr * t * p表示p点先平移、后旋转\n\n// r * t * p:先平移、后旋转\nconst modelmatrix = r.clone().multiply(t);\np.applymatrix4(modelmatrix);\n\n\nt * r * p表示p点先旋转、后平移\n\n// t * r * p：先旋转、后平移\nconst modelmatrix = r.clone().multiply(t);\np.applymatrix4(modelmatrix);\n\n\n哪个几何变换先发生，在矩阵乘法公式中，对应矩阵更靠近p点，或者说根据矩阵变换顺序，从右往左写。",charsets:{cjk:!0}},{title:"5. 模型本地矩阵、世界矩阵",frontmatter:{title:"5. 模型本地矩阵、世界矩阵",date:"2023-06-29T18:01:21.000Z",permalink:"/pages/c5b6bb/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/05.5.%E7%9F%A9%E9%98%B5/05.%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0%E7%9F%A9%E9%98%B5%E3%80%81%E4%B8%96%E7%95%8C%E7%9F%A9%E9%98%B5.html",relativePath:"02.Three.js进阶教程/05.5.矩阵/05.模型本地矩阵、世界矩阵.md",key:"v-8eb408b8",path:"/pages/c5b6bb/",headers:[{level:3,title:"本地矩阵.matrix、世界矩阵.matrixWorld",slug:"本地矩阵-matrix、世界矩阵-matrixworld",normalizedTitle:"本地矩阵.matrix、世界矩阵.matrixworld",charIndex:2},{level:3,title:"知识回顾：模型位置、缩放、角度属性",slug:"知识回顾-模型位置、缩放、角度属性",normalizedTitle:"知识回顾：模型位置、缩放、角度属性",charIndex:104},{level:3,title:"模型本地矩阵属性.matrix",slug:"模型本地矩阵属性-matrix",normalizedTitle:"模型本地矩阵属性.matrix",charIndex:282},{level:3,title:"平移、旋转、缩放，查看.matrix变化",slug:"平移、旋转、缩放-查看-matrix变化",normalizedTitle:"平移、旋转、缩放，查看.matrix变化",charIndex:433},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1078},{level:3,title:"世界矩阵.matrixWorld",slug:"世界矩阵-matrixworld",normalizedTitle:"世界矩阵.matrixworld",charIndex:14},{level:3,title:"不执行.updateMatrixWorld()，.render()之后查看矩阵",slug:"不执行-updatematrixworld-render-之后查看矩阵",normalizedTitle:"不执行.updatematrixworld()，.render()之后查看矩阵",charIndex:1900}],headersStr:"本地矩阵.matrix、世界矩阵.matrixWorld 知识回顾：模型位置、缩放、角度属性 模型本地矩阵属性.matrix 平移、旋转、缩放，查看.matrix变化 总结 世界矩阵.matrixWorld 不执行.updateMatrixWorld()，.render()之后查看矩阵",content:"# 本地矩阵.matrix、世界矩阵.matrixWorld\n\n查看Three.js文档，模型对象的父类Object3D，你可以看到本地矩阵.matrix和世界矩阵.matrixWorld两个属性。\n\n\n# 知识回顾：模型位置、缩放、角度属性\n\n通过基础部分学习，大家知道，通过位置属性.position可以平移模型，通过.scale属性可以缩放物体，通过四元数.quaternion或角度.rotation属性旋转改变物体的姿态角度。四元数.quaternion或角度.rotation属性都是用来表示物体姿态角度的，一个变化，另一个也会跟着变化。\n\n\n\n\n# 模型本地矩阵属性.matrix\n\n模型本地矩阵属性.matrix的属性值是一个4x4矩阵Matrix4。\n\nconsole.log('mesh.matrix',mesh.matrix);\n\n\n当你没有对模型进行旋转、缩放、平移的时候，模型本地矩阵属性.matrix的默认值是一个单位矩阵。\n\n\n\n\n# 平移、旋转、缩放，查看.matrix变化\n\n你可以尝试改变three.js模型对象的.position、.scale或.rotation(.quaternion)任何一个属性，查看查看mesh.matrix值的变化。\n\n1.仅改变mesh.position,你会发现mesh.matrix的值会从单位矩阵变成一个平移矩阵(沿着xyz轴分别平移2、3、4)😭)\n\n// 不执行renderer.render(scene, camera);情况下测试\nmesh.position.set(2,3,4);\nmesh.updateMatrix();//更新矩阵，.matrix会变化\nconsole.log('本地矩阵',mesh.matrix);\n\n\n\n\n2.仅改变mesh.scale,你会发现mesh.matrix的值会从单位矩阵变成一个缩放矩阵(沿着xyz轴三个方向分别缩放6、6、6倍);\n\nmesh.scale.set(6,6,6);\nmesh.updateMatrix();\nconsole.log('本地矩阵',mesh.matrix);\n\n\n\n\n3.同时平移和缩放，查看.matrix变化，你可以看到mesh.matrix是平移矩阵和缩放矩阵的复合矩阵。\n\nmesh.position.set(2,3,4);\nmesh.scale.set(6,6,6);\nmesh.updateMatrix();\nconsole.log('本地矩阵',mesh.matrix);\n\n\n\n\n\n# 总结\n\n当你改变模型位置.position、缩放.scale或角度.rotation(.quaternion)任何一个属性的时候，都会影响.matrix的值。.matrix就是本质上就是旋转矩阵、缩放矩阵、平移矩阵的复合矩阵。\n\n\n\n\n# 世界矩阵.matrixWorld\n\n了解世界矩阵属性.matrixWorld之前，先回顾下前面基础内容讲解的知识点本地坐标和世界坐标：http://www.webgl3d.cn/pages/00ddfa/\n\n位置属性.position表示一个模型相对父对象的偏移，或者说相对本地坐标系的位置。\n\nconsole.log('本地坐标',mesh.position);\n\n\n通过.getWorldPosition()获取的世界坐标，是模型相对世界坐标系的坐标，也就是该对象及其父对象所有.position属性值的累加。\n\nconst worldPosition = new THREE.Vector3();\nmesh.getWorldPosition(worldPosition)\nconsole.log('世界坐标',worldPosition);\n\n\n一个模型对象的世界矩阵属性.matrixWorld是自身及其所有父对象本地矩阵属性.matrix的复合矩阵。\n\n\n\n// 你可以通过下面代码测试上面结论\nmesh.position.set(2,3,4);\nconst group = new THREE.Group();\ngroup.add(mesh);\ngroup.position.set(2,3,4);\n\n//执行updateMatrixWorld()方法，模型的本地矩阵和世界属性都会更新\nmesh.updateMatrixWorld();\nconsole.log('本地矩阵',mesh.matrix);\nconsole.log('世界矩阵',mesh.matrixWorld);\n\n\n\n# 不执行.updateMatrixWorld()，.render()之后查看矩阵\n\n当你改变.position、.scale等属性，不执行.updateMatrixWorld()更新矩阵矩阵，在.render之后查看本地矩阵和世界矩阵的值，你会发现发生了变化。这说明three.js默认情况下，在执行.render()的时候，会自动获取.position、.scale等属性的值，更新模型的本地矩阵、世界矩阵属性。\n\nconst scene = new THREE.Scene();\nmesh.position.set(2,3,4);\nconst group = new THREE.Group();\ngroup.position.set(2,3,4);\ngroup.add(mesh);\nscene.add(group);\n\n// render渲染时候，会获取模型`.position`等属性更新计算模型矩阵值\nrenderer.render(scene, camera);\n\nconsole.log('本地矩阵',mesh.matrix);\nconsole.log('世界矩阵',mesh.matrixWorld);\n",normalizedContent:"# 本地矩阵.matrix、世界矩阵.matrixworld\n\n查看three.js文档，模型对象的父类object3d，你可以看到本地矩阵.matrix和世界矩阵.matrixworld两个属性。\n\n\n# 知识回顾：模型位置、缩放、角度属性\n\n通过基础部分学习，大家知道，通过位置属性.position可以平移模型，通过.scale属性可以缩放物体，通过四元数.quaternion或角度.rotation属性旋转改变物体的姿态角度。四元数.quaternion或角度.rotation属性都是用来表示物体姿态角度的，一个变化，另一个也会跟着变化。\n\n\n\n\n# 模型本地矩阵属性.matrix\n\n模型本地矩阵属性.matrix的属性值是一个4x4矩阵matrix4。\n\nconsole.log('mesh.matrix',mesh.matrix);\n\n\n当你没有对模型进行旋转、缩放、平移的时候，模型本地矩阵属性.matrix的默认值是一个单位矩阵。\n\n\n\n\n# 平移、旋转、缩放，查看.matrix变化\n\n你可以尝试改变three.js模型对象的.position、.scale或.rotation(.quaternion)任何一个属性，查看查看mesh.matrix值的变化。\n\n1.仅改变mesh.position,你会发现mesh.matrix的值会从单位矩阵变成一个平移矩阵(沿着xyz轴分别平移2、3、4)😭)\n\n// 不执行renderer.render(scene, camera);情况下测试\nmesh.position.set(2,3,4);\nmesh.updatematrix();//更新矩阵，.matrix会变化\nconsole.log('本地矩阵',mesh.matrix);\n\n\n\n\n2.仅改变mesh.scale,你会发现mesh.matrix的值会从单位矩阵变成一个缩放矩阵(沿着xyz轴三个方向分别缩放6、6、6倍);\n\nmesh.scale.set(6,6,6);\nmesh.updatematrix();\nconsole.log('本地矩阵',mesh.matrix);\n\n\n\n\n3.同时平移和缩放，查看.matrix变化，你可以看到mesh.matrix是平移矩阵和缩放矩阵的复合矩阵。\n\nmesh.position.set(2,3,4);\nmesh.scale.set(6,6,6);\nmesh.updatematrix();\nconsole.log('本地矩阵',mesh.matrix);\n\n\n\n\n\n# 总结\n\n当你改变模型位置.position、缩放.scale或角度.rotation(.quaternion)任何一个属性的时候，都会影响.matrix的值。.matrix就是本质上就是旋转矩阵、缩放矩阵、平移矩阵的复合矩阵。\n\n\n\n\n# 世界矩阵.matrixworld\n\n了解世界矩阵属性.matrixworld之前，先回顾下前面基础内容讲解的知识点本地坐标和世界坐标：http://www.webgl3d.cn/pages/00ddfa/\n\n位置属性.position表示一个模型相对父对象的偏移，或者说相对本地坐标系的位置。\n\nconsole.log('本地坐标',mesh.position);\n\n\n通过.getworldposition()获取的世界坐标，是模型相对世界坐标系的坐标，也就是该对象及其父对象所有.position属性值的累加。\n\nconst worldposition = new three.vector3();\nmesh.getworldposition(worldposition)\nconsole.log('世界坐标',worldposition);\n\n\n一个模型对象的世界矩阵属性.matrixworld是自身及其所有父对象本地矩阵属性.matrix的复合矩阵。\n\n\n\n// 你可以通过下面代码测试上面结论\nmesh.position.set(2,3,4);\nconst group = new three.group();\ngroup.add(mesh);\ngroup.position.set(2,3,4);\n\n//执行updatematrixworld()方法，模型的本地矩阵和世界属性都会更新\nmesh.updatematrixworld();\nconsole.log('本地矩阵',mesh.matrix);\nconsole.log('世界矩阵',mesh.matrixworld);\n\n\n\n# 不执行.updatematrixworld()，.render()之后查看矩阵\n\n当你改变.position、.scale等属性，不执行.updatematrixworld()更新矩阵矩阵，在.render之后查看本地矩阵和世界矩阵的值，你会发现发生了变化。这说明three.js默认情况下，在执行.render()的时候，会自动获取.position、.scale等属性的值，更新模型的本地矩阵、世界矩阵属性。\n\nconst scene = new three.scene();\nmesh.position.set(2,3,4);\nconst group = new three.group();\ngroup.position.set(2,3,4);\ngroup.add(mesh);\nscene.add(group);\n\n// render渲染时候，会获取模型`.position`等属性更新计算模型矩阵值\nrenderer.render(scene, camera);\n\nconsole.log('本地矩阵',mesh.matrix);\nconsole.log('世界矩阵',mesh.matrixworld);\n",charsets:{cjk:!0}},{title:"1. 射线Ray(复习前面内容)",frontmatter:{title:"1. 射线Ray(复习前面内容)",date:"2023-09-03T22:41:45.000Z",permalink:"/pages/c1c0e7/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/06.6.%E5%B0%84%E7%BA%BF/01.%20%E5%B0%84%E7%BA%BFRay(%E5%A4%8D%E4%B9%A0%E5%89%8D%E9%9D%A2%E5%86%85%E5%AE%B9).html",relativePath:"02.Three.js进阶教程/06.6.射线/01. 射线Ray(复习前面内容).md",key:"v-4332b628",path:"/pages/c1c0e7/",headersStr:null,content:"01. 射线Ray地址：http://www.webgl3d.cn/pages/500511/",normalizedContent:"01. 射线ray地址：http://www.webgl3d.cn/pages/500511/",charsets:{cjk:!0}},{title:"6. 视图矩阵、投影矩阵",frontmatter:{title:"6. 视图矩阵、投影矩阵",date:"2023-08-23T11:14:54.000Z",permalink:"/pages/bf26f8/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/05.5.%E7%9F%A9%E9%98%B5/06.%E8%A7%86%E5%9B%BE%E7%9F%A9%E9%98%B5%E3%80%81%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5.html",relativePath:"02.Three.js进阶教程/05.5.矩阵/06.视图矩阵、投影矩阵.md",key:"v-05494578",path:"/pages/bf26f8/",headers:[{level:3,title:"模型矩阵知识点回顾",slug:"模型矩阵知识点回顾",normalizedTitle:"模型矩阵知识点回顾",charIndex:188},{level:3,title:"相机知识点回顾",slug:"相机知识点回顾",normalizedTitle:"相机知识点回顾",charIndex:368},{level:3,title:"两种旋转三维场景方式对比测试",slug:"两种旋转三维场景方式对比测试",normalizedTitle:"两种旋转三维场景方式对比测试",charIndex:702},{level:3,title:"两种缩放三维场景方式对比测试",slug:"两种缩放三维场景方式对比测试",normalizedTitle:"两种缩放三维场景方式对比测试",charIndex:1453},{level:3,title:"测试总结",slug:"测试总结",normalizedTitle:"测试总结",charIndex:2035},{level:3,title:"相机视图矩阵.matrixWorldInverse",slug:"相机视图矩阵-matrixworldinverse",normalizedTitle:"相机视图矩阵.matrixworldinverse",charIndex:2234},{level:3,title:"相机投影矩阵.projectionMatrix",slug:"相机投影矩阵-projectionmatrix",normalizedTitle:"相机投影矩阵.projectionmatrix",charIndex:2388},{level:3,title:"更新透视投影矩阵.updateProjectionMatrix()",slug:"更新透视投影矩阵-updateprojectionmatrix",normalizedTitle:"更新透视投影矩阵.updateprojectionmatrix()",charIndex:2643},{level:3,title:"扩展：矩阵对顶点变换",slug:"扩展-矩阵对顶点变换",normalizedTitle:"扩展：矩阵对顶点变换",charIndex:3147}],headersStr:"模型矩阵知识点回顾 相机知识点回顾 两种旋转三维场景方式对比测试 两种缩放三维场景方式对比测试 测试总结 相机视图矩阵.matrixWorldInverse 相机投影矩阵.projectionMatrix 更新透视投影矩阵.updateProjectionMatrix() 扩展：矩阵对顶点变换",content:"# 视图矩阵、投影矩阵\n\n这节课给大家介绍Three.js相机对象Camera的两个属性视图矩阵.matrixWorldInverse和投影矩阵.projectionMatrix。\n\n如果你有图形学基础，我提到视图矩阵或投影矩阵，你基本上都有概念，那么本节课，你可以快进学习，如果你没有相关的基础，就跟着视频通过具体theeejs代码，来认识相机矩阵相关的抽象概念。\n\n\n# 模型矩阵知识点回顾\n\n上节课给大家讲解过，Three.js内部渲染的时候，会把置.position、缩放.scale或角度.rotation(.quaternion)属性的值转为自己模型矩阵(本地矩阵.matrix、世界矩阵.matrixWorld)。\n\nThree.js内部会通过模型的矩阵.matrixWorld旋转、缩放、平移模型自身。\n\n\n\n\n\n\n# 相机知识点回顾\n\n学习本节课内容之前，你可以先把以前学习的相机知识点，回顾一遍。\n\n1.5 透视投影相机\n\n// 透视投影相机\nPerspectiveCamera( fov, aspect, near, far )\n\n\n10.1正投影相机\n\n// 正投影相机\nOrthographicCamera( left, right, top, bottom, near, far )\n\n\n相机动画(.position和.lookAt())\n\n不同方向的投影视图\n\n旋转渲染结果(.up相机上方向)\n\ncamera.up.set(0,-1,0);\ncamera.position.set(292, 223, 185);\ncamera.lookAt(0, 0, 0);\n\n\n\n# 两种旋转三维场景方式对比测试\n\n改变模型或者场景自身的角度属性，旋转三维场景。\n\n// 渲染循环\nfunction render() {\n    // model.rotation.y+=0.01;\n    scene.rotation.y+=0.01;\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender()\n\n\n改变相机位置属性.position让相机绕场景中心旋转，和上面代码效果相似，都是旋转整个三维场景。\n\n你把相机的位置改变，绕着目标观察点做圆周运动，你会发现threejs场景中的模型进行了旋转，其实在threejs内部渲染过程中，threejs会获取相机参数，生成相关矩阵，对场景模型进行了旋转变换。\n\n// 渲染循环\nlet angle = 0; //用于圆周运动计算的角度值\nconst R = 260; //相机圆周运动的半径\nfunction render() {\n    angle += 0.01;\n    // 相机y坐标不变，在XOZ平面上做圆周运动\n    camera.position.x = R * Math.cos(angle);\n    camera.position.z = R * Math.sin(angle);\n    // 相机圆周运动过程，如果希望视线始终指向圆心，位置改变后必须重新执行lookAt指向圆心\n    camera.lookAt(0,0,0);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 两种缩放三维场景方式对比测试\n\n你想缩放整个三维场景，可以直接通过模型.scale属性控制\n\n// 放大工厂模型(换句话说，能观察的范围更小了，工厂周边东西不能看到那么多了)\nmodel.scale.set(2,2,2);\n\n\n另一方面，以透视投影相机为例，你如果改变相机的位置距离目标观察点更近，你会发现能够看到目标观察点周围的范围更小，其实本质上相当于threejs渲染时候，内部通过相机参数，生成对应矩阵，对场景进行了缩放。\n\n// 放大工厂模型(换句话说，能观察的范围更小了，工厂周边东西不能看到那么多了)\n// model.scale.set(2,2,2);\n//相机\nconst width = window.innerWidth;\nconst height = window.innerHeight;\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\n// camera.position.set(202, 123, 125);\n// 相机距离目标观察点更近(能观察到范围变小，在画布上工厂放大了)\ncamera.position.set(202*0.5, 123*0.5, 125*0.5);\ncamera.lookAt(0, 0, 0);\n\n\n\n# 测试总结\n\n通过改变Three.js相机的参数对三维场景进行旋转、缩放或平移变换，threejs内部会获取相机参数，生成相关矩阵，对场景物体进行旋转缩放平移变换，就像模型矩阵对模型的旋转缩放平移变换。\n\n咱们上面的测试，目的就是为了让大家通过具体代码测试，知道threejs相机参数的变化，本质上就是通过相机参数生成的矩阵，对场景模型进行旋转、缩放、平移。至于具体影响，下面会给大家说明。\n\n\n# 相机视图矩阵.matrixWorldInverse\n\n在three.js内部，threejs会把相机的位置.position、lookAt指向目标观察点、上方向.up，生成一个视图矩阵.matrixWorldInverse,在threejs渲染的时候，生成的视图矩阵会被用来对模型顶点进行几何变换。\n\n\n# 相机投影矩阵.projectionMatrix\n\n影响透视投影相机投影矩阵属性的参数( fov, aspect, near, far )\n\n// 透视投影相机\nPerspectiveCamera( fov, aspect, near, far )\n\n\n影响正投影相机投影矩阵属性的参数( left, right, top, bottom, near, far )\n\n// 正投影相机\nOrthographicCamera( left, right, top, bottom, near, far )\n\n\n\n# 更新透视投影矩阵.updateProjectionMatrix()\n\n在Three.js内部，渲染期间，透视投影矩阵threejs并不会始终读取相机的参数，计算，这样太浪费CPU计算资源了，为了性能考虑，threejs默认就是计算一次生成投影矩阵的值，所以如果你因为某种需要，改变了相机的相关参数，就要执行.updateProjectionMatrix()告诉threejs重新合成透视投影矩阵的值.projectionMatrix。\n\n// onresize 事件会在窗口被调整大小时发生\nwindow.onresize = function () {\n    // 重置渲染器输出画布canvas尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    // 全屏情况下：设置观察范围长宽比aspect为窗口宽高比\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n};\n\n\n\n# 扩展：矩阵对顶点变换\n\n大家都知道模型本质上都是由几何体的顶点构成的，threejs渲染的时候，内部会读取模型和相机的矩阵属性，对顶点进行几何变换，具体应用案例咱们在后面shader课程中给大家讲解。\n\n投影矩阵 * 视图矩阵 * 模型矩阵 * 模型顶点坐标\n",normalizedContent:"# 视图矩阵、投影矩阵\n\n这节课给大家介绍three.js相机对象camera的两个属性视图矩阵.matrixworldinverse和投影矩阵.projectionmatrix。\n\n如果你有图形学基础，我提到视图矩阵或投影矩阵，你基本上都有概念，那么本节课，你可以快进学习，如果你没有相关的基础，就跟着视频通过具体theeejs代码，来认识相机矩阵相关的抽象概念。\n\n\n# 模型矩阵知识点回顾\n\n上节课给大家讲解过，three.js内部渲染的时候，会把置.position、缩放.scale或角度.rotation(.quaternion)属性的值转为自己模型矩阵(本地矩阵.matrix、世界矩阵.matrixworld)。\n\nthree.js内部会通过模型的矩阵.matrixworld旋转、缩放、平移模型自身。\n\n\n\n\n\n\n# 相机知识点回顾\n\n学习本节课内容之前，你可以先把以前学习的相机知识点，回顾一遍。\n\n1.5 透视投影相机\n\n// 透视投影相机\nperspectivecamera( fov, aspect, near, far )\n\n\n10.1正投影相机\n\n// 正投影相机\northographiccamera( left, right, top, bottom, near, far )\n\n\n相机动画(.position和.lookat())\n\n不同方向的投影视图\n\n旋转渲染结果(.up相机上方向)\n\ncamera.up.set(0,-1,0);\ncamera.position.set(292, 223, 185);\ncamera.lookat(0, 0, 0);\n\n\n\n# 两种旋转三维场景方式对比测试\n\n改变模型或者场景自身的角度属性，旋转三维场景。\n\n// 渲染循环\nfunction render() {\n    // model.rotation.y+=0.01;\n    scene.rotation.y+=0.01;\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender()\n\n\n改变相机位置属性.position让相机绕场景中心旋转，和上面代码效果相似，都是旋转整个三维场景。\n\n你把相机的位置改变，绕着目标观察点做圆周运动，你会发现threejs场景中的模型进行了旋转，其实在threejs内部渲染过程中，threejs会获取相机参数，生成相关矩阵，对场景模型进行了旋转变换。\n\n// 渲染循环\nlet angle = 0; //用于圆周运动计算的角度值\nconst r = 260; //相机圆周运动的半径\nfunction render() {\n    angle += 0.01;\n    // 相机y坐标不变，在xoz平面上做圆周运动\n    camera.position.x = r * math.cos(angle);\n    camera.position.z = r * math.sin(angle);\n    // 相机圆周运动过程，如果希望视线始终指向圆心，位置改变后必须重新执行lookat指向圆心\n    camera.lookat(0,0,0);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 两种缩放三维场景方式对比测试\n\n你想缩放整个三维场景，可以直接通过模型.scale属性控制\n\n// 放大工厂模型(换句话说，能观察的范围更小了，工厂周边东西不能看到那么多了)\nmodel.scale.set(2,2,2);\n\n\n另一方面，以透视投影相机为例，你如果改变相机的位置距离目标观察点更近，你会发现能够看到目标观察点周围的范围更小，其实本质上相当于threejs渲染时候，内部通过相机参数，生成对应矩阵，对场景进行了缩放。\n\n// 放大工厂模型(换句话说，能观察的范围更小了，工厂周边东西不能看到那么多了)\n// model.scale.set(2,2,2);\n//相机\nconst width = window.innerwidth;\nconst height = window.innerheight;\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\n// camera.position.set(202, 123, 125);\n// 相机距离目标观察点更近(能观察到范围变小，在画布上工厂放大了)\ncamera.position.set(202*0.5, 123*0.5, 125*0.5);\ncamera.lookat(0, 0, 0);\n\n\n\n# 测试总结\n\n通过改变three.js相机的参数对三维场景进行旋转、缩放或平移变换，threejs内部会获取相机参数，生成相关矩阵，对场景物体进行旋转缩放平移变换，就像模型矩阵对模型的旋转缩放平移变换。\n\n咱们上面的测试，目的就是为了让大家通过具体代码测试，知道threejs相机参数的变化，本质上就是通过相机参数生成的矩阵，对场景模型进行旋转、缩放、平移。至于具体影响，下面会给大家说明。\n\n\n# 相机视图矩阵.matrixworldinverse\n\n在three.js内部，threejs会把相机的位置.position、lookat指向目标观察点、上方向.up，生成一个视图矩阵.matrixworldinverse,在threejs渲染的时候，生成的视图矩阵会被用来对模型顶点进行几何变换。\n\n\n# 相机投影矩阵.projectionmatrix\n\n影响透视投影相机投影矩阵属性的参数( fov, aspect, near, far )\n\n// 透视投影相机\nperspectivecamera( fov, aspect, near, far )\n\n\n影响正投影相机投影矩阵属性的参数( left, right, top, bottom, near, far )\n\n// 正投影相机\northographiccamera( left, right, top, bottom, near, far )\n\n\n\n# 更新透视投影矩阵.updateprojectionmatrix()\n\n在three.js内部，渲染期间，透视投影矩阵threejs并不会始终读取相机的参数，计算，这样太浪费cpu计算资源了，为了性能考虑，threejs默认就是计算一次生成投影矩阵的值，所以如果你因为某种需要，改变了相机的相关参数，就要执行.updateprojectionmatrix()告诉threejs重新合成透视投影矩阵的值.projectionmatrix。\n\n// onresize 事件会在窗口被调整大小时发生\nwindow.onresize = function () {\n    // 重置渲染器输出画布canvas尺寸\n    renderer.setsize(window.innerwidth, window.innerheight);\n    // 全屏情况下：设置观察范围长宽比aspect为窗口宽高比\n    camera.aspect = window.innerwidth / window.innerheight;\n    camera.updateprojectionmatrix();\n};\n\n\n\n# 扩展：矩阵对顶点变换\n\n大家都知道模型本质上都是由几何体的顶点构成的，threejs渲染的时候，内部会读取模型和相机的矩阵属性，对顶点进行几何变换，具体应用案例咱们在后面shader课程中给大家讲解。\n\n投影矩阵 * 视图矩阵 * 模型矩阵 * 模型顶点坐标\n",charsets:{cjk:!0}},{title:"2. 射线拾取模型(复习前面)",frontmatter:{title:"2. 射线拾取模型(复习前面)",date:"2023-09-03T22:42:06.000Z",permalink:"/pages/bbc7ce/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/06.6.%E5%B0%84%E7%BA%BF/02.%E5%B0%84%E7%BA%BF%E6%8B%BE%E5%8F%96%E6%A8%A1%E5%9E%8B(%E5%A4%8D%E4%B9%A0%E5%89%8D%E9%9D%A2).html",relativePath:"02.Three.js进阶教程/06.6.射线/02.射线拾取模型(复习前面).md",key:"v-803ffe94",path:"/pages/bbc7ce/",headersStr:null,content:"2. Raycaster(射线拾取模型)地址：http://www.webgl3d.cn/pages/a448b6/",normalizedContent:"2. raycaster(射线拾取模型)地址：http://www.webgl3d.cn/pages/a448b6/",charsets:{cjk:!0}},{title:"1. 包围盒Box3(复习前面)",frontmatter:{title:"1. 包围盒Box3(复习前面)",date:"2023-09-03T22:43:35.000Z",permalink:"/pages/515d43/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/07.7.%E5%8C%85%E5%9B%B4%E7%9B%92/01.%E5%8C%85%E5%9B%B4%E7%9B%92Box3(%E5%A4%8D%E4%B9%A0%E5%89%8D%E9%9D%A2).html",relativePath:"02.Three.js进阶教程/07.7.包围盒/01.包围盒Box3(复习前面).md",key:"v-57df0643",path:"/pages/515d43/",headersStr:null,content:"7.包围盒地址：http://www.webgl3d.cn/pages/13d359/",normalizedContent:"7.包围盒地址：http://www.webgl3d.cn/pages/13d359/",charsets:{cjk:!0}},{title:"1. 键盘WASD按键状态记录",frontmatter:{title:"1. 键盘WASD按键状态记录",date:"2023-09-03T22:44:14.000Z",permalink:"/pages/bb25ee/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/01.%E9%94%AE%E7%9B%98WASD%E6%8C%89%E9%94%AE%E7%8A%B6%E6%80%81%E8%AE%B0%E5%BD%95.html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/01.键盘WASD按键状态记录.md",key:"v-7c9b722a",path:"/pages/bb25ee/",headers:[{level:3,title:"键盘事件",slug:"键盘事件",normalizedTitle:"键盘事件",charIndex:96},{level:3,title:"记录键盘按键WASD状态",slug:"记录键盘按键wasd状态",normalizedTitle:"记录键盘按键wasd状态",charIndex:509},{level:3,title:"测试键盘状态",slug:"测试键盘状态",normalizedTitle:"测试键盘状态",charIndex:1264},{level:3,title:"其他写法(可以跳过)",slug:"其他写法-可以跳过",normalizedTitle:"其他写法(可以跳过)",charIndex:1612}],headersStr:"键盘事件 记录键盘按键WASD状态 测试键盘状态 其他写法(可以跳过)",content:"# 键盘WASD按键状态记录\n\n如果你玩过游戏，一般都知道，通过键盘的W、A、S、D按键可以控制玩家角色在3D场景中运动，比如控制一个人前后左右运动，比如控制一辆车前后左右运动。\n\n\n\n\n# 键盘事件\n\n如果你不熟悉HTML5前端鼠标、键盘事件，可以去学习下,下面主要说下思路，不在一行一行演示。\n\n下面代码功能是当你按下随便一个键盘按键，就会触发参数2表示的函数执行，并log打印对应按键名字相关信息。\n\n// 监听鼠标按下事件\ndocument.addEventListener('keydown', (event) => {\n    console.log('event.code',event.code);\n})\n\n\n执行上面代码后，你可以分别按下键盘W、A、S、D、空格键测试，你可以看到浏览器控制台打印输出对应键盘按键名字，也就是KeyW、KeyA、KeyS、KeyD、Space。\n\n// 监听鼠标松开事件\ndocument.addEventListener('keyup', (event) => {\n    console.log('event.code',event.code);\n})\n\n\n\n# 记录键盘按键WASD状态\n\n// 声明一个对象keyStates用来记录键盘事件状态\nconst keyStates = {\n    // 使用W、A、S、D按键来控制前、后、左、右运动\n    // false表示没有按下，true表示按下状态\n    W: false,\n    A: false,\n    S: false,\n    D: false,\n};\n// 当某个键盘按下设置对应属性设置为true\ndocument.addEventListener('keydown', (event) => {\n    if (event.code === 'KeyW') keyStates.W = true;\n    if (event.code === 'KeyA') keyStates.A = true;\n    if (event.code === 'KeyS') keyStates.S = true;\n    if (event.code === 'KeyD') keyStates.D = true;\n});\n// 当某个键盘抬起设置对应属性设置为false\ndocument.addEventListener('keyup', (event) => {\n    if (event.code === 'KeyW') keyStates.W = false;\n    if (event.code === 'KeyA') keyStates.A = false;\n    if (event.code === 'KeyS') keyStates.S = false;\n    if (event.code === 'KeyD') keyStates.D = false;\n});\n\n\n\n# 测试键盘状态\n\n在循环执行的函数中查看键盘状态值。\n\n// 循环执行的函数render\nfunction render() {\n    requestAnimationFrame(render);\n}\nrender();\n\n\n你可以执行下面代码，然后反复按下或松开W键，浏览器控制台查看keyStates.W的变化。\n\n// 循环执行的函数中测试W键盘状态值\nfunction render() {\n    if(keyStates.W){\n        console.log('W键按下');\n    }else{\n        console.log('W键松开');\n    }\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 其他写法(可以跳过)\n\n批量记录所有键盘事件状态\n\n// 声明一个对象keyStates用来记录键盘事件状态\nconst keyStates = {\n    // // false表示没有按下，true表示按下状态\n    // keyW:false,\n    // keyA:false,\n    // keyS:false,\n    // keyD:false,\n};\n\n// 当某个键盘按下设置对应属性设置为true\ndocument.addEventListener('keydown', (event) => {\n    keyStates[event.code] = true;\n});\n// 当某个键盘抬起设置对应属性设置为false\ndocument.addEventListener('keyup', (event) => {\n    keyStates[event.code] = false;\n});\n",normalizedContent:"# 键盘wasd按键状态记录\n\n如果你玩过游戏，一般都知道，通过键盘的w、a、s、d按键可以控制玩家角色在3d场景中运动，比如控制一个人前后左右运动，比如控制一辆车前后左右运动。\n\n\n\n\n# 键盘事件\n\n如果你不熟悉html5前端鼠标、键盘事件，可以去学习下,下面主要说下思路，不在一行一行演示。\n\n下面代码功能是当你按下随便一个键盘按键，就会触发参数2表示的函数执行，并log打印对应按键名字相关信息。\n\n// 监听鼠标按下事件\ndocument.addeventlistener('keydown', (event) => {\n    console.log('event.code',event.code);\n})\n\n\n执行上面代码后，你可以分别按下键盘w、a、s、d、空格键测试，你可以看到浏览器控制台打印输出对应键盘按键名字，也就是keyw、keya、keys、keyd、space。\n\n// 监听鼠标松开事件\ndocument.addeventlistener('keyup', (event) => {\n    console.log('event.code',event.code);\n})\n\n\n\n# 记录键盘按键wasd状态\n\n// 声明一个对象keystates用来记录键盘事件状态\nconst keystates = {\n    // 使用w、a、s、d按键来控制前、后、左、右运动\n    // false表示没有按下，true表示按下状态\n    w: false,\n    a: false,\n    s: false,\n    d: false,\n};\n// 当某个键盘按下设置对应属性设置为true\ndocument.addeventlistener('keydown', (event) => {\n    if (event.code === 'keyw') keystates.w = true;\n    if (event.code === 'keya') keystates.a = true;\n    if (event.code === 'keys') keystates.s = true;\n    if (event.code === 'keyd') keystates.d = true;\n});\n// 当某个键盘抬起设置对应属性设置为false\ndocument.addeventlistener('keyup', (event) => {\n    if (event.code === 'keyw') keystates.w = false;\n    if (event.code === 'keya') keystates.a = false;\n    if (event.code === 'keys') keystates.s = false;\n    if (event.code === 'keyd') keystates.d = false;\n});\n\n\n\n# 测试键盘状态\n\n在循环执行的函数中查看键盘状态值。\n\n// 循环执行的函数render\nfunction render() {\n    requestanimationframe(render);\n}\nrender();\n\n\n你可以执行下面代码，然后反复按下或松开w键，浏览器控制台查看keystates.w的变化。\n\n// 循环执行的函数中测试w键盘状态值\nfunction render() {\n    if(keystates.w){\n        console.log('w键按下');\n    }else{\n        console.log('w键松开');\n    }\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 其他写法(可以跳过)\n\n批量记录所有键盘事件状态\n\n// 声明一个对象keystates用来记录键盘事件状态\nconst keystates = {\n    // // false表示没有按下，true表示按下状态\n    // keyw:false,\n    // keya:false,\n    // keys:false,\n    // keyd:false,\n};\n\n// 当某个键盘按下设置对应属性设置为true\ndocument.addeventlistener('keydown', (event) => {\n    keystates[event.code] = true;\n});\n// 当某个键盘抬起设置对应属性设置为false\ndocument.addeventlistener('keyup', (event) => {\n    keystates[event.code] = false;\n});\n",charsets:{cjk:!0}},{title:"2. W键控制角色模型运动",frontmatter:{title:"2. W键控制角色模型运动",date:"2023-09-03T22:44:27.000Z",permalink:"/pages/8d3d09/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/02.W%E9%94%AE%E6%8E%A7%E5%88%B6%E8%A7%92%E8%89%B2%E6%A8%A1%E5%9E%8B%E8%BF%90%E5%8A%A8.html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/02.W键控制角色模型运动.md",key:"v-2f97d739",path:"/pages/8d3d09/",headers:[{level:3,title:"演示文件",slug:"演示文件",normalizedTitle:"演示文件",charIndex:114},{level:3,title:"知识回顾",slug:"知识回顾",normalizedTitle:"知识回顾",charIndex:215},{level:3,title:"W键控制人物模型运动",slug:"w键控制人物模型运动",normalizedTitle:"w键控制人物模型运动",charIndex:864}],headersStr:"演示文件 知识回顾 W键控制人物模型运动",content:"# W键控制角色模型运动\n\nWASD的综合控制比较复杂，本节课，先给大家演示下，怎么通过W监控人物模型沿着Z轴运动。\n\n当W键一直处于按下状态时，人物模型沿着Z轴向前运动，松开的时候，不在运动(你可以测试课件的源码)。\n\n\n# 演示文件\n\n演示文件里面给大家提供了一个基本的文件，加载了一个人物模型，设置一个简单网格线地面，关于人物模型的骨骼动画，你可以参考前面基础课程章节16讲解：16.4. 解析外部模型关键帧动画;\n\n\n# 知识回顾\n\n上节课给大家讲解过，怎么通过一个对象的属性，记录W、A、S、D四个按键的状态。\n\nconst keyStates = {\n    W: false,\n    A: false,\n    S: false,\n    D: false,\n};\ndocument.addEventListener('keydown', (event) => {\n    if (event.code === 'KeyW') keyStates.W = true;\n    if (event.code === 'KeyA') keyStates.A = true;\n    if (event.code === 'KeyS') keyStates.S = true;\n    if (event.code === 'KeyD') keyStates.D = true;\n});\ndocument.addEventListener('keyup', (event) => {\n    if (event.code === 'KeyW') keyStates.W = false;\n    if (event.code === 'KeyA') keyStates.A = false;\n    if (event.code === 'KeyS') keyStates.S = false;\n    if (event.code === 'KeyD') keyStates.D = false;\n});\n\n\n\n# W键控制人物模型运动\n\n你先回顾下，本课程章节2关于位移、速度、加速的讲解，更好理解接下来要讲解的内容。\n\n// 用三维向量表示玩家角色(人)运动漫游速度\n//按下W键对应的人运动速度\nconst v = new THREE.Vector3(0, 0, 3);\n\n\n渲染循环里面，通过时间*速度,来更新人模型位置。\n\n// 渲染循环\nconst clock = new THREE.Clock();\nfunction render() {\n    const deltaTime = clock.getDelta();\n    if (keyStates.W) {\n        // 在间隔deltaTime时间内，玩家角色位移变化计算(速度*时间)\n        const deltaPos = v.clone().multiplyScalar(deltaTime);\n        player.position.add(deltaPos);//更新玩家角色的位置\n    }\n    mixer.update(deltaTime);// 更新播放器相关的时间\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# w键控制角色模型运动\n\nwasd的综合控制比较复杂，本节课，先给大家演示下，怎么通过w监控人物模型沿着z轴运动。\n\n当w键一直处于按下状态时，人物模型沿着z轴向前运动，松开的时候，不在运动(你可以测试课件的源码)。\n\n\n# 演示文件\n\n演示文件里面给大家提供了一个基本的文件，加载了一个人物模型，设置一个简单网格线地面，关于人物模型的骨骼动画，你可以参考前面基础课程章节16讲解：16.4. 解析外部模型关键帧动画;\n\n\n# 知识回顾\n\n上节课给大家讲解过，怎么通过一个对象的属性，记录w、a、s、d四个按键的状态。\n\nconst keystates = {\n    w: false,\n    a: false,\n    s: false,\n    d: false,\n};\ndocument.addeventlistener('keydown', (event) => {\n    if (event.code === 'keyw') keystates.w = true;\n    if (event.code === 'keya') keystates.a = true;\n    if (event.code === 'keys') keystates.s = true;\n    if (event.code === 'keyd') keystates.d = true;\n});\ndocument.addeventlistener('keyup', (event) => {\n    if (event.code === 'keyw') keystates.w = false;\n    if (event.code === 'keya') keystates.a = false;\n    if (event.code === 'keys') keystates.s = false;\n    if (event.code === 'keyd') keystates.d = false;\n});\n\n\n\n# w键控制人物模型运动\n\n你先回顾下，本课程章节2关于位移、速度、加速的讲解，更好理解接下来要讲解的内容。\n\n// 用三维向量表示玩家角色(人)运动漫游速度\n//按下w键对应的人运动速度\nconst v = new three.vector3(0, 0, 3);\n\n\n渲染循环里面，通过时间*速度,来更新人模型位置。\n\n// 渲染循环\nconst clock = new three.clock();\nfunction render() {\n    const deltatime = clock.getdelta();\n    if (keystates.w) {\n        // 在间隔deltatime时间内，玩家角色位移变化计算(速度*时间)\n        const deltapos = v.clone().multiplyscalar(deltatime);\n        player.position.add(deltapos);//更新玩家角色的位置\n    }\n    mixer.update(deltatime);// 更新播放器相关的时间\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"3. 加速度(按键给玩家加速)",frontmatter:{title:"3. 加速度(按键给玩家加速)",date:"2023-09-03T22:44:35.000Z",permalink:"/pages/e8e668/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/03.%E5%8A%A0%E9%80%9F%E5%BA%A6(%E6%8C%89%E9%94%AE%E7%BB%99%E7%8E%A9%E5%AE%B6%E5%8A%A0%E9%80%9F).html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/03.加速度(按键给玩家加速).md",key:"v-3ca61054",path:"/pages/e8e668/",headers:[{level:3,title:"设置加速度",slug:"设置加速度",normalizedTitle:"设置加速度",charIndex:386},{level:3,title:"限制最高速度",slug:"限制最高速度",normalizedTitle:"限制最高速度",charIndex:1024}],headersStr:"设置加速度 限制最高速度",content:"# 加速度(按键给玩家加速)\n\n上节课给大家讲解过，当你按下W键的时候，玩家角色模型，会运动，松开W键，人会停下来。但是这个运动效果是突然运动和突然停止，没有一个加速或减速的过程，本节课以W键为例，设置玩家加速过程,也就是当你按下W键以后，人的速度从0慢慢提升上来。\n\nconst v = new THREE.Vector3(0, 0, 3);\nfunction render() {\n    if (keyStates.W) {\n        // 在间隔deltaTime时间内，玩家角色位移变化计算(速度*时间)\n        const deltaPos = v.clone().multiplyScalar(deltaTime);\n        player.position.add(deltaPos);//更新玩家角色的位置\n    }\n}\n\n\n\n# 设置加速度\n\n// 用三维向量表示玩家角色(人)运动漫游速度\nconst v = new THREE.Vector3(0, 0, 0);//初始速度设置为0\nconst a = 12;//加速度：调节按键加速快慢\n// 渲染循环\nconst clock = new THREE.Clock();\nfunction render() {\n    const deltaTime = clock.getDelta();\n    if (keyStates.W) {\n        //先假设W键对应运动方向为z\n        const front = new THREE.Vector3(0,0,1);\n        // W键按下时候，速度随着时间增加\n        v.add(front.multiplyScalar(a * deltaTime));\n        // 在间隔deltaTime时间内，玩家角色位移变化计算(速度*时间)\n        const deltaPos = v.clone().multiplyScalar(deltaTime);\n        player.position.add(deltaPos);//更新玩家角色的位置\n    }\n    \n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 限制最高速度\n\n执行上面代码，当你按下W键的时候，v会一直加速，这时候可以通过v.length()计算速度v的值，当然速度小一个临界值的时候，才增加速度v的大小。\n\nconst vMax = 5;//限制玩家角色最大速度\n...\nif (v.length() < vMax) {//限制最高速度\n    // W键按下时候，速度随着时间增加\n    v.add(front.multiplyScalar(a * deltaTime));\n}\n",normalizedContent:"# 加速度(按键给玩家加速)\n\n上节课给大家讲解过，当你按下w键的时候，玩家角色模型，会运动，松开w键，人会停下来。但是这个运动效果是突然运动和突然停止，没有一个加速或减速的过程，本节课以w键为例，设置玩家加速过程,也就是当你按下w键以后，人的速度从0慢慢提升上来。\n\nconst v = new three.vector3(0, 0, 3);\nfunction render() {\n    if (keystates.w) {\n        // 在间隔deltatime时间内，玩家角色位移变化计算(速度*时间)\n        const deltapos = v.clone().multiplyscalar(deltatime);\n        player.position.add(deltapos);//更新玩家角色的位置\n    }\n}\n\n\n\n# 设置加速度\n\n// 用三维向量表示玩家角色(人)运动漫游速度\nconst v = new three.vector3(0, 0, 0);//初始速度设置为0\nconst a = 12;//加速度：调节按键加速快慢\n// 渲染循环\nconst clock = new three.clock();\nfunction render() {\n    const deltatime = clock.getdelta();\n    if (keystates.w) {\n        //先假设w键对应运动方向为z\n        const front = new three.vector3(0,0,1);\n        // w键按下时候，速度随着时间增加\n        v.add(front.multiplyscalar(a * deltatime));\n        // 在间隔deltatime时间内，玩家角色位移变化计算(速度*时间)\n        const deltapos = v.clone().multiplyscalar(deltatime);\n        player.position.add(deltapos);//更新玩家角色的位置\n    }\n    \n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 限制最高速度\n\n执行上面代码，当你按下w键的时候，v会一直加速，这时候可以通过v.length()计算速度v的值，当然速度小一个临界值的时候，才增加速度v的大小。\n\nconst vmax = 5;//限制玩家角色最大速度\n...\nif (v.length() < vmax) {//限制最高速度\n    // w键按下时候，速度随着时间增加\n    v.add(front.multiplyscalar(a * deltatime));\n}\n",charsets:{cjk:!0}},{title:"4. 阻尼(玩家角色逐渐减速停止)",frontmatter:{title:"4. 阻尼(玩家角色逐渐减速停止)",date:"2023-09-03T22:44:43.000Z",permalink:"/pages/24d3be/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/04.%E9%98%BB%E5%B0%BC(%E7%8E%A9%E5%AE%B6%E8%A7%92%E8%89%B2%E9%80%90%E6%B8%90%E5%87%8F%E9%80%9F%E5%81%9C%E6%AD%A2).html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/04.阻尼(玩家角色逐渐减速停止).md",key:"v-e00e8ad8",path:"/pages/24d3be/",headers:[{level:3,title:"设置阻尼减速",slug:"设置阻尼减速",normalizedTitle:"设置阻尼减速",charIndex:444},{level:3,title:"验证阻尼是否生效",slug:"验证阻尼是否生效",normalizedTitle:"验证阻尼是否生效",charIndex:919}],headersStr:"设置阻尼减速 验证阻尼是否生效",content:"# 阻尼(玩家角色逐渐减速停止)\n\n继续上节课内容讲解，上节课以W键为例，给大家讲解了怎么通过WASD按键，给玩家角色模型加速，本节课给大家讲解，怎么设置阻尼，具体说，就是当没有WASD按键加速时候，玩家角色模型，会在阻尼作用下逐渐减速停止，就像地面上滚动的球逐渐停下来。\n\nif (keyStates.W) {\n    //先假设W键对应运动方向为z\n    const front = new THREE.Vector3(0,0,1);\n    // W键按下时候，速度随着时间增加\n    v.add(front.multiplyScalar(a * deltaTime));\n    // 在间隔deltaTime时间内，玩家角色位移变化计算(速度*时间)\n    const deltaPos = v.clone().multiplyScalar(deltaTime);\n    player.position.add(deltaPos);//更新玩家角色的位置\n}\n\n\n\n# 设置阻尼减速\n\n大家可以思考下，当你没有按下WASD的时候，怎么给运动的物体减速。\n\n其实很简单，可以在渲染循环中，重复执行速度v乘以一个小于1的数值，这样重复多次执行以后，速度就会逼近0。比如v* (1 - 0.04) = v * 0.96,多次循环乘以0.96(v*0.96*0.96*0.96...)，v就会无限逼近于0。\n\nconst damping = -0.04;\nfunction render() {\n    if (keyStates.W) {\n        ...\n    }\n    // v*(1 + damping) = v* (1 - 0.04) = v * 0.96\n    // 多次循环乘以0.96(v*0.96*0.96*0.96...),v就会无限逼近于0。\n    // v*(1 + damping) = v + v * damping\n    v.addScaledVector(v, damping);//阻尼减速\n\n    requestAnimationFrame(render);\n}\n\n\n\n# 验证阻尼是否生效\n\n把if (keyStates.W){}里面玩家角色位置更新的代码，挪到外面，你可以发现，当按键W松开，玩家角色会慢慢停下来，原因很简单，虽然一直在执行速度*时间更新玩家位置，但是在阻尼作用下，速度慢慢逼近0了，位移变化量自然逼近0。\n\n// 用三维向量表示玩家角色(人)运动漫游速度\nconst v = new THREE.Vector3(0, 0, 0);//初始速度设置为0\nconst a = 12;//WASD按键的加速度：调节按键加速快慢\nconst damping = -0.04;//阻尼 当没有WASD加速的时候，人、车等玩家角色慢慢减速停下来\n// 渲染循环\nconst clock = new THREE.Clock();\nfunction render() {\n    const deltaTime = clock.getDelta();\n    if (keyStates.W) {\n        //先假设W键对应运动方向为z\n        const front = new THREE.Vector3(0, 0, 1);\n        if (v.length() < 5) {//限制最高速度\n            // W键按下时候，速度随着时间增加\n            v.add(front.multiplyScalar(a * deltaTime));\n        }\n    }\n\n    // 阻尼减速\n    v.addScaledVector(v, damping);\n\n    //更新玩家角色的位置  当v是0的时候，位置更新也不会变化\n    const deltaPos = v.clone().multiplyScalar(deltaTime);\n    player.position.add(deltaPos);\n\n    mixer.update(deltaTime);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# 阻尼(玩家角色逐渐减速停止)\n\n继续上节课内容讲解，上节课以w键为例，给大家讲解了怎么通过wasd按键，给玩家角色模型加速，本节课给大家讲解，怎么设置阻尼，具体说，就是当没有wasd按键加速时候，玩家角色模型，会在阻尼作用下逐渐减速停止，就像地面上滚动的球逐渐停下来。\n\nif (keystates.w) {\n    //先假设w键对应运动方向为z\n    const front = new three.vector3(0,0,1);\n    // w键按下时候，速度随着时间增加\n    v.add(front.multiplyscalar(a * deltatime));\n    // 在间隔deltatime时间内，玩家角色位移变化计算(速度*时间)\n    const deltapos = v.clone().multiplyscalar(deltatime);\n    player.position.add(deltapos);//更新玩家角色的位置\n}\n\n\n\n# 设置阻尼减速\n\n大家可以思考下，当你没有按下wasd的时候，怎么给运动的物体减速。\n\n其实很简单，可以在渲染循环中，重复执行速度v乘以一个小于1的数值，这样重复多次执行以后，速度就会逼近0。比如v* (1 - 0.04) = v * 0.96,多次循环乘以0.96(v*0.96*0.96*0.96...)，v就会无限逼近于0。\n\nconst damping = -0.04;\nfunction render() {\n    if (keystates.w) {\n        ...\n    }\n    // v*(1 + damping) = v* (1 - 0.04) = v * 0.96\n    // 多次循环乘以0.96(v*0.96*0.96*0.96...),v就会无限逼近于0。\n    // v*(1 + damping) = v + v * damping\n    v.addscaledvector(v, damping);//阻尼减速\n\n    requestanimationframe(render);\n}\n\n\n\n# 验证阻尼是否生效\n\n把if (keystates.w){}里面玩家角色位置更新的代码，挪到外面，你可以发现，当按键w松开，玩家角色会慢慢停下来，原因很简单，虽然一直在执行速度*时间更新玩家位置，但是在阻尼作用下，速度慢慢逼近0了，位移变化量自然逼近0。\n\n// 用三维向量表示玩家角色(人)运动漫游速度\nconst v = new three.vector3(0, 0, 0);//初始速度设置为0\nconst a = 12;//wasd按键的加速度：调节按键加速快慢\nconst damping = -0.04;//阻尼 当没有wasd加速的时候，人、车等玩家角色慢慢减速停下来\n// 渲染循环\nconst clock = new three.clock();\nfunction render() {\n    const deltatime = clock.getdelta();\n    if (keystates.w) {\n        //先假设w键对应运动方向为z\n        const front = new three.vector3(0, 0, 1);\n        if (v.length() < 5) {//限制最高速度\n            // w键按下时候，速度随着时间增加\n            v.add(front.multiplyscalar(a * deltatime));\n        }\n    }\n\n    // 阻尼减速\n    v.addscaledvector(v, damping);\n\n    //更新玩家角色的位置  当v是0的时候，位置更新也不会变化\n    const deltapos = v.clone().multiplyscalar(deltatime);\n    player.position.add(deltapos);\n\n    mixer.update(deltatime);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"5. 按键S退后运动",frontmatter:{title:"5. 按键S退后运动",date:"2023-09-03T22:44:52.000Z",permalink:"/pages/99cd6d/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/05.%E6%8C%89%E9%94%AES%E9%80%80%E5%90%8E%E8%BF%90%E5%8A%A8.html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/05.按键S退后运动.md",key:"v-625ca383",path:"/pages/99cd6d/",headers:[{level:3,title:"S键退后",slug:"s键退后",normalizedTitle:"s键退后",charIndex:83}],headersStr:"S键退后",content:"# 按键S退后运动\n\n这些内容非常简单，算是一个练习题，你可以在前面几节课基础上，增加一个S按键，玩家角色模型的退后运动，学习视频之前，可以自己先动手写下。\n\n\n# S键退后\n\nfunction render() {\n    if (v.length() < vMax) {//限制最高速度\n        if (keyStates.W) {\n            //先假设W键对应运动方向为z\n            const front = new THREE.Vector3(0, 0, 1);\n            v.add(front.multiplyScalar(a * deltaTime));\n        }\n        if (keyStates.S) {\n            // 与W按键相反方向\n            const front = new THREE.Vector3(0, 0, -1);\n            v.add(front.multiplyScalar(a * deltaTime));\n        }\n    }\n    v.addScaledVector(v, damping);//阻尼减速\n    //更新玩家角色的位置\n    const deltaPos = v.clone().multiplyScalar(deltaTime);\n    player.position.add(deltaPos);\n}\n\n\n下面是更多具体代码\n\nconst keyStates = {\n    W: false,\n    S: false,\n};\ndocument.addEventListener('keydown', (event) => {\n    if (event.code === 'KeyW') keyStates.W = true;\n    if (event.code === 'KeyA') keyStates.A = true;\n});\ndocument.addEventListener('keyup', (event) => {\n    if (event.code === 'KeyW') keyStates.W = false;\n    if (event.code === 'KeyA') keyStates.A = false;\n});\n\n\n// 用三维向量表示玩家角色(人)运动漫游速度\nconst v = new THREE.Vector3(0, 0, 0);//初始速度设置为0\nconst a = 12;//WASD按键的加速度：调节按键加速快慢\nconst damping = -0.04;//阻尼 当没有WASD加速的时候，人、车等玩家角色慢慢减速停下来\nconst vMax = 5;//限制玩家角色最大速度\n// 渲染循环\nconst clock = new THREE.Clock();\nfunction render() {\n    const deltaTime = clock.getDelta();\n    if (v.length() < vMax) {//限制最高速度\n        if (keyStates.W) {\n            const front = new THREE.Vector3(0, 0, 1);//先假设W键对应运动方向为z\n            v.add(front.multiplyScalar(a * deltaTime));\n        }\n        if (keyStates.S) {\n            // 与W按键相反方向\n            const front = new THREE.Vector3(0, 0, -1);\n            v.add(front.multiplyScalar(a * deltaTime));\n        }\n    }\n    // v*(1 + damping) = v* (1 - 0.04) = v * 0.96\n    // 多次循环乘以0.96(v*0.96*0.96*0.96...),v就会无限逼近于0。\n    // v*(1 + damping) = v + v * damping\n    v.addScaledVector(v, damping);//阻尼减速\n\n    //更新玩家角色的位置   当v是0的时候，位置更新也不会变化\n    const deltaPos = v.clone().multiplyScalar(deltaTime);\n    player.position.add(deltaPos);\n\n    mixer.update(deltaTime);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# 按键s退后运动\n\n这些内容非常简单，算是一个练习题，你可以在前面几节课基础上，增加一个s按键，玩家角色模型的退后运动，学习视频之前，可以自己先动手写下。\n\n\n# s键退后\n\nfunction render() {\n    if (v.length() < vmax) {//限制最高速度\n        if (keystates.w) {\n            //先假设w键对应运动方向为z\n            const front = new three.vector3(0, 0, 1);\n            v.add(front.multiplyscalar(a * deltatime));\n        }\n        if (keystates.s) {\n            // 与w按键相反方向\n            const front = new three.vector3(0, 0, -1);\n            v.add(front.multiplyscalar(a * deltatime));\n        }\n    }\n    v.addscaledvector(v, damping);//阻尼减速\n    //更新玩家角色的位置\n    const deltapos = v.clone().multiplyscalar(deltatime);\n    player.position.add(deltapos);\n}\n\n\n下面是更多具体代码\n\nconst keystates = {\n    w: false,\n    s: false,\n};\ndocument.addeventlistener('keydown', (event) => {\n    if (event.code === 'keyw') keystates.w = true;\n    if (event.code === 'keya') keystates.a = true;\n});\ndocument.addeventlistener('keyup', (event) => {\n    if (event.code === 'keyw') keystates.w = false;\n    if (event.code === 'keya') keystates.a = false;\n});\n\n\n// 用三维向量表示玩家角色(人)运动漫游速度\nconst v = new three.vector3(0, 0, 0);//初始速度设置为0\nconst a = 12;//wasd按键的加速度：调节按键加速快慢\nconst damping = -0.04;//阻尼 当没有wasd加速的时候，人、车等玩家角色慢慢减速停下来\nconst vmax = 5;//限制玩家角色最大速度\n// 渲染循环\nconst clock = new three.clock();\nfunction render() {\n    const deltatime = clock.getdelta();\n    if (v.length() < vmax) {//限制最高速度\n        if (keystates.w) {\n            const front = new three.vector3(0, 0, 1);//先假设w键对应运动方向为z\n            v.add(front.multiplyscalar(a * deltatime));\n        }\n        if (keystates.s) {\n            // 与w按键相反方向\n            const front = new three.vector3(0, 0, -1);\n            v.add(front.multiplyscalar(a * deltatime));\n        }\n    }\n    // v*(1 + damping) = v* (1 - 0.04) = v * 0.96\n    // 多次循环乘以0.96(v*0.96*0.96*0.96...),v就会无限逼近于0。\n    // v*(1 + damping) = v + v * damping\n    v.addscaledvector(v, damping);//阻尼减速\n\n    //更新玩家角色的位置   当v是0的时候，位置更新也不会变化\n    const deltapos = v.clone().multiplyscalar(deltatime);\n    player.position.add(deltapos);\n\n    mixer.update(deltatime);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"6. 相机跟着玩家走(第三人称漫游)",frontmatter:{title:"6. 相机跟着玩家走(第三人称漫游)",date:"2023-09-03T22:45:02.000Z",permalink:"/pages/7fe7e3/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/06.%E7%9B%B8%E6%9C%BA%E8%B7%9F%E7%9D%80%E7%8E%A9%E5%AE%B6%E8%B5%B0(%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8).html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/06.相机跟着玩家走(第三人称漫游).md",key:"v-c98105f0",path:"/pages/7fe7e3/",headers:[{level:3,title:"层级模型知识点回顾",slug:"层级模型知识点回顾",normalizedTitle:"层级模型知识点回顾",charIndex:276},{level:3,title:"相机对象父类Object3D",slug:"相机对象父类object3d",normalizedTitle:"相机对象父类object3d",charIndex:606},{level:3,title:"注释相机空间OrbitControls代码",slug:"注释相机空间orbitcontrols代码",normalizedTitle:"注释相机空间orbitcontrols代码",charIndex:864},{level:3,title:"相机作为玩家角色子对象",slug:"相机作为玩家角色子对象",normalizedTitle:"相机作为玩家角色子对象",charIndex:1032},{level:3,title:"第三人称漫游",slug:"第三人称漫游",normalizedTitle:"第三人称漫游",charIndex:10},{level:3,title:"补充：相机视角参数fov影响相机位置设置！！！",slug:"补充-相机视角参数fov影响相机位置设置",normalizedTitle:"补充：相机视角参数fov影响相机位置设置！！！",charIndex:1562}],headersStr:"层级模型知识点回顾 相机对象父类Object3D 注释相机空间OrbitControls代码 相机作为玩家角色子对象 第三人称漫游 补充：相机视角参数fov影响相机位置设置！！！",content:"# 相机跟着玩家走(第三人称漫游)\n\n前面案例，通过按键控制玩家角色模型运动的时候，并没有控制相机移动。下面给大家讲解怎么控制相机运动产生漫游的感觉。\n\nconst camera = new THREE.PerspectiveCamera();\ncamera.position.set(8, 10, 14);\ncamera.lookAt(0, 0, 0);\n\nfunction render() {\n    ...\n    //更新玩家角色的位置\n    player.position.add(deltaPos);\n}\nrender();\n\n\n\n# 层级模型知识点回顾\n\n4.1 层级模型\n\n4.3. 本地坐标和世界坐标\n\n\n\nconst mesh1 = new THREE.Mesh();\nconst group = new THREE.Group();\ngroup.add(mesh1);\nscene.add(group);\n\n\nmesh1的父对象group移动，mesh1会跟着移动\n\ngroup.position.y = 10;\n\n\nmesh1.position表示mesh1局部坐标，也就是相对父对象group的位置。mesh1在三维场景scene中的实际位置(世界坐标)就是group.position的mesh1.position叠加。\n\nmesh1.position.y = 10;\n\n\n\n# 相机对象父类Object3D\n\n相机对象Camera的父类和mesh、group一样，都是Object3D，这意味着，如果你把相机作为某个模型的子对象，相机的位置和姿态同样受到模型的影响。\n\nconst group = new THREE.Group();\ngroup.add(camera);//相机作为group子对象\n// 父对象group平移，相机跟着平移\ngroup.position.y = 10;\n// 父对象group旋转，相机跟着旋转\ngroup.rotateY(Math.PI/6);\n\n\n\n# 注释相机空间OrbitControls代码\n\n注释相机空间OrbitControls代码，避免影响相机W、A、S、D对相机的控制，原来用OrbitControls只是为了方便观察测试3D场景。\n\nconst controls = new OrbitControls(camera, renderer.domElement);\n\n\n\n# 相机作为玩家角色子对象\n\n相机作为玩家角色子对象，可以实现相机对玩家角色模型的跟随运动，使相机运动，模拟人漫游3D场景的感觉。\n\n// 把相机作为玩家角色的子对象，这样相机的位置和姿态就会跟着玩家角色改变\nplayer.add(camera);//相机作为人的子对象，会跟着人运动\n\n\n你可以根据需要放相机相对玩家角色的位置，比如我这里相机与人高度相近(你可以在blender中测量下人的高度)，把相机放在人后脑勺，拉开一定距离，然后相机镜头对准人的后脑勺。\n\n下面尺寸是以相机的父对象玩家角色模型的局部坐标系坐标原点为参照的。\n\ncamera.position.set(0, 1.6, -5.5);//玩家角色后面一点\ncamera.lookAt(0, 1.6, 0);//对着人身上某个点  视线大致沿着人的正前方\n\n\n\n\n我这里是以一个人为例写的相机位置，如果你换成一个车，模拟人在驾驶位上的感觉，也可以把相机高度设置在车辆高度附近。\n\n\n# 第三人称漫游\n\n这里所谓的第三人称，你可以简单的理解为相机在运动漫游的过程中，你可以看到玩家角色模型，比如你能看到运动的人、车等角色模型，就是上面咱们写的代码，把相机放在玩家角色模型后面一点即可。\n\n\n\n\n# 补充：相机视角参数fov影响相机位置设置！！！\n\nconst camera = new THREE.PerspectiveCamera(30,...);\nplayer.add(camera);//相机作为人的子对象\n//玩家角色后面一点  对应fov 30度\ncamera.position.set(0, 1.6, -5.5);\ncamera.lookAt(0, 1.6, 0);//对着人身上某个点\n\n\n根据透视投影相机规律，fov变大，能够看到的视野范围角度更大。\n\nconst camera = new THREE.PerspectiveCamera(70,...);\n//玩家角色后面一点  对应fov 70度\ncamera.position.set(0, 1.6, -2.3);\n",normalizedContent:"# 相机跟着玩家走(第三人称漫游)\n\n前面案例，通过按键控制玩家角色模型运动的时候，并没有控制相机移动。下面给大家讲解怎么控制相机运动产生漫游的感觉。\n\nconst camera = new three.perspectivecamera();\ncamera.position.set(8, 10, 14);\ncamera.lookat(0, 0, 0);\n\nfunction render() {\n    ...\n    //更新玩家角色的位置\n    player.position.add(deltapos);\n}\nrender();\n\n\n\n# 层级模型知识点回顾\n\n4.1 层级模型\n\n4.3. 本地坐标和世界坐标\n\n\n\nconst mesh1 = new three.mesh();\nconst group = new three.group();\ngroup.add(mesh1);\nscene.add(group);\n\n\nmesh1的父对象group移动，mesh1会跟着移动\n\ngroup.position.y = 10;\n\n\nmesh1.position表示mesh1局部坐标，也就是相对父对象group的位置。mesh1在三维场景scene中的实际位置(世界坐标)就是group.position的mesh1.position叠加。\n\nmesh1.position.y = 10;\n\n\n\n# 相机对象父类object3d\n\n相机对象camera的父类和mesh、group一样，都是object3d，这意味着，如果你把相机作为某个模型的子对象，相机的位置和姿态同样受到模型的影响。\n\nconst group = new three.group();\ngroup.add(camera);//相机作为group子对象\n// 父对象group平移，相机跟着平移\ngroup.position.y = 10;\n// 父对象group旋转，相机跟着旋转\ngroup.rotatey(math.pi/6);\n\n\n\n# 注释相机空间orbitcontrols代码\n\n注释相机空间orbitcontrols代码，避免影响相机w、a、s、d对相机的控制，原来用orbitcontrols只是为了方便观察测试3d场景。\n\nconst controls = new orbitcontrols(camera, renderer.domelement);\n\n\n\n# 相机作为玩家角色子对象\n\n相机作为玩家角色子对象，可以实现相机对玩家角色模型的跟随运动，使相机运动，模拟人漫游3d场景的感觉。\n\n// 把相机作为玩家角色的子对象，这样相机的位置和姿态就会跟着玩家角色改变\nplayer.add(camera);//相机作为人的子对象，会跟着人运动\n\n\n你可以根据需要放相机相对玩家角色的位置，比如我这里相机与人高度相近(你可以在blender中测量下人的高度)，把相机放在人后脑勺，拉开一定距离，然后相机镜头对准人的后脑勺。\n\n下面尺寸是以相机的父对象玩家角色模型的局部坐标系坐标原点为参照的。\n\ncamera.position.set(0, 1.6, -5.5);//玩家角色后面一点\ncamera.lookat(0, 1.6, 0);//对着人身上某个点  视线大致沿着人的正前方\n\n\n\n\n我这里是以一个人为例写的相机位置，如果你换成一个车，模拟人在驾驶位上的感觉，也可以把相机高度设置在车辆高度附近。\n\n\n# 第三人称漫游\n\n这里所谓的第三人称，你可以简单的理解为相机在运动漫游的过程中，你可以看到玩家角色模型，比如你能看到运动的人、车等角色模型，就是上面咱们写的代码，把相机放在玩家角色模型后面一点即可。\n\n\n\n\n# 补充：相机视角参数fov影响相机位置设置！！！\n\nconst camera = new three.perspectivecamera(30,...);\nplayer.add(camera);//相机作为人的子对象\n//玩家角色后面一点  对应fov 30度\ncamera.position.set(0, 1.6, -5.5);\ncamera.lookat(0, 1.6, 0);//对着人身上某个点\n\n\n根据透视投影相机规律，fov变大，能够看到的视野范围角度更大。\n\nconst camera = new three.perspectivecamera(70,...);\n//玩家角色后面一点  对应fov 70度\ncamera.position.set(0, 1.6, -2.3);\n",charsets:{cjk:!0}},{title:"7. 鼠标左右拖动改变玩家视角",frontmatter:{title:"7. 鼠标左右拖动改变玩家视角",date:"2023-09-03T22:45:11.000Z",permalink:"/pages/ef6fe2/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/07.%E9%BC%A0%E6%A0%87%E5%B7%A6%E5%8F%B3%E6%8B%96%E5%8A%A8%E6%94%B9%E5%8F%98%E7%8E%A9%E5%AE%B6%E8%A7%86%E8%A7%92.html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/07.鼠标左右拖动改变玩家视角.md",key:"v-744c40be",path:"/pages/ef6fe2/",headers:[{level:3,title:"了解鼠标滑动事件规则",slug:"了解鼠标滑动事件规则",normalizedTitle:"了解鼠标滑动事件规则",charIndex:63},{level:3,title:"鼠标控制玩家转向",slug:"鼠标控制玩家转向",normalizedTitle:"鼠标控制玩家转向",charIndex:435},{level:3,title:"鼠标左键拖动时候，旋转玩家角色",slug:"鼠标左键拖动时候-旋转玩家角色",normalizedTitle:"鼠标左键拖动时候，旋转玩家角色",charIndex:663},{level:3,title:"测试上节课代码：相机随着player旋转",slug:"测试上节课代码-相机随着player旋转",normalizedTitle:"测试上节课代码：相机随着player旋转",charIndex:1107}],headersStr:"了解鼠标滑动事件规则 鼠标控制玩家转向 鼠标左键拖动时候，旋转玩家角色 测试上节课代码：相机随着player旋转",content:"# 鼠标左右拖动改变玩家视角\n\n本节课给大家讲解一个新功能，就是你按住鼠标左键，左右拖动，改变玩家角色和相机的视角。\n\n\n# 了解鼠标滑动事件规则\n\n如果你不了解前端HTML5鼠标滑动事件的规则，可以跟着视频学习一遍，如果你非常熟悉，可以直接快进到下一步。\n\n// 鼠标滑动期间，会不停地多次触发鼠滑动事件，直到不再滑动\ndocument.addEventListener('mousemove', (event) => {\n    console.log('触发1次');\n});\n\n\n鼠标持续滑动时候，会多次触发滑动事件。event.movementX表示本次触发事件相对上次，鼠标左右方向滑动的距离，单位是像素，往右滑动是正，往左滑动是负。\n\ndocument.addEventListener('mousemove', (event) => {\n    console.log('鼠标每次x方向移动距离', event.movementX);\n});\n\n\n\n# 鼠标控制玩家转向\n\n通过鼠标左右滑动距离控制玩家角色模型player旋转。\n\ndocument.addEventListener('mousemove', (event) => {\n    // 注意rotation.y += 与 -= 区别，左右旋转时候方向相反\n    //event.movementX缩小一定倍数改变旋转控制的灵敏度\n    player.rotation.y -= event.movementX / 600;\n});\n\n\n\n# 鼠标左键拖动时候，旋转玩家角色\n\n鼠标左键拖动定义：鼠标左键按下，不松开，左右滑动\n\n 1. 记录鼠标左键状态\n\nlet leftButtonBool = false;//记录鼠标左键状态\ndocument.addEventListener('mousedown', () => {\n    leftButtonBool = true;\n});\ndocument.addEventListener('mouseup', () => {\n    leftButtonBool = false;\n});\n\n\n 2. 判断鼠标左键状态，决定是否旋转玩家角色\n\ndocument.addEventListener('mousemove', (event) => {\n    //鼠标左键按下时候，才旋转玩家角色\n    if(leftButtonBool){\n        player.rotation.y -= event.movementX / 600;\n    } \n});\n\n\n\n# 测试上节课代码：相机随着player旋转\n\n上节课，给大家讲解过，相机对象是玩家角色模型的子对象，玩家角色player旋转的时候，子对象相机自然跟着同步旋转，你可以测试下执行player.add(camera)与不执行的区别。\n\n//相机作为player子对象，会跟着player平移或旋转\nplayer.add(camera);\ncamera.position.set(0, 1.6, -5.5);\ncamera.lookAt(0, 1.6, 0);\n\n\n",normalizedContent:"# 鼠标左右拖动改变玩家视角\n\n本节课给大家讲解一个新功能，就是你按住鼠标左键，左右拖动，改变玩家角色和相机的视角。\n\n\n# 了解鼠标滑动事件规则\n\n如果你不了解前端html5鼠标滑动事件的规则，可以跟着视频学习一遍，如果你非常熟悉，可以直接快进到下一步。\n\n// 鼠标滑动期间，会不停地多次触发鼠滑动事件，直到不再滑动\ndocument.addeventlistener('mousemove', (event) => {\n    console.log('触发1次');\n});\n\n\n鼠标持续滑动时候，会多次触发滑动事件。event.movementx表示本次触发事件相对上次，鼠标左右方向滑动的距离，单位是像素，往右滑动是正，往左滑动是负。\n\ndocument.addeventlistener('mousemove', (event) => {\n    console.log('鼠标每次x方向移动距离', event.movementx);\n});\n\n\n\n# 鼠标控制玩家转向\n\n通过鼠标左右滑动距离控制玩家角色模型player旋转。\n\ndocument.addeventlistener('mousemove', (event) => {\n    // 注意rotation.y += 与 -= 区别，左右旋转时候方向相反\n    //event.movementx缩小一定倍数改变旋转控制的灵敏度\n    player.rotation.y -= event.movementx / 600;\n});\n\n\n\n# 鼠标左键拖动时候，旋转玩家角色\n\n鼠标左键拖动定义：鼠标左键按下，不松开，左右滑动\n\n 1. 记录鼠标左键状态\n\nlet leftbuttonbool = false;//记录鼠标左键状态\ndocument.addeventlistener('mousedown', () => {\n    leftbuttonbool = true;\n});\ndocument.addeventlistener('mouseup', () => {\n    leftbuttonbool = false;\n});\n\n\n 2. 判断鼠标左键状态，决定是否旋转玩家角色\n\ndocument.addeventlistener('mousemove', (event) => {\n    //鼠标左键按下时候，才旋转玩家角色\n    if(leftbuttonbool){\n        player.rotation.y -= event.movementx / 600;\n    } \n});\n\n\n\n# 测试上节课代码：相机随着player旋转\n\n上节课，给大家讲解过，相机对象是玩家角色模型的子对象，玩家角色player旋转的时候，子对象相机自然跟着同步旋转，你可以测试下执行player.add(camera)与不执行的区别。\n\n//相机作为player子对象，会跟着player平移或旋转\nplayer.add(camera);\ncamera.position.set(0, 1.6, -5.5);\ncamera.lookat(0, 1.6, 0);\n\n\n",charsets:{cjk:!0}},{title:"8. 获取玩家(相机)正前方方向",frontmatter:{title:"8. 获取玩家(相机)正前方方向",date:"2023-09-03T22:45:19.000Z",permalink:"/pages/c5d199/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/08.%E8%8E%B7%E5%8F%96%E7%8E%A9%E5%AE%B6(%E7%9B%B8%E6%9C%BA)%E6%AD%A3%E5%89%8D%E6%96%B9%E6%96%B9%E5%90%91.html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/08.获取玩家(相机)正前方方向.md",key:"v-18333ca2",path:"/pages/c5d199/",headers:[{level:3,title:".getWorldDirection()",slug:"getworlddirection",normalizedTitle:".getworlddirection()",charIndex:280},{level:3,title:".getWorldDirection()获取玩家角色正前方",slug:"getworlddirection-获取玩家角色正前方",normalizedTitle:".getworlddirection()获取玩家角色正前方",charIndex:790},{level:3,title:"S键运动方向",slug:"s键运动方向",normalizedTitle:"s键运动方向",charIndex:1077}],headersStr:".getWorldDirection() .getWorldDirection()获取玩家角色正前方 S键运动方向",content:"# 获取玩家(相机)正前方方向\n\n实际开发，玩家角色的视角或者说相机的视角，会随着鼠标左右移动变化的，不过前面几节课，为了降低学习难度，代码给的是固定方向。\n\nfunction render() {\n    if (keyStates.W) {\n        //先假设W键对应运动方向为z\n        const front = new THREE.Vector3(0, 0, 1);\n        // 改变玩家速度\n        v.add(front.multiplyScalar(a * deltaTime));\n    }\n}\n\n\n\n# .getWorldDirection()\n\nObject3D类有一个获取模型局部z轴方向相关的方法.getWorldDirection()。\n\nobj.getWorldDirection()表示的获取obj对象自身z轴正方向在世界坐标空间中的方向。\n\n模型没有任何旋转情况，.getWorldDirection()获取的结果(0,0,1)\n\nconst mesh = new THREE.Mesh();\nconst dir = new THREE.Vector3();\nmesh.getWorldDirection(dir);\nconsole.log('dir', dir);\n\n\n模型绕y旋转90度情况，.getWorldDirection()获取的结果(1,0,0)\n\nconst mesh = new THREE.Mesh();\nmesh.rotateY(Math.PI / 2);\nconst dir = new THREE.Vector3();\nmesh.getWorldDirection(dir);\n// 模型没有任何选择打印结果(1,0,0)\nconsole.log('dir', dir);\n\n\n\n# .getWorldDirection()获取玩家角色正前方\n\n注意：threejs加载的玩家角色gltf模型，自身.rotation没有任何旋转的情况下，注意玩家角色正前方方向最好和z轴方向一致,这样就可以直接用.getWorldDirection()获取的结果表示人的正前方。\n\n// 按下W键，实时计算当前玩家角色的正前方向\nif (keyStates.W) {\n    const front = new THREE.Vector3();\n    //获取玩家角色(相机)正前方\n    player.getWorldDirection(front);\n}\n\n\n\n# S键运动方向\n\n注意S键运动方向与W的正前方相反，这时候很简单，可以计算方向的时候，把front取反，或者最简单加速度设置一个负号front.multiplyScalar(- a * deltaTime)\n\nfunction render() {\n    if (v.length() < vMax) {//限制最高速度\n        if (keyStates.W) {\n            const front = new THREE.Vector3();\n            player.getWorldDirection(front);//获取玩家角色(相机)正前方\n            v.add(front.multiplyScalar(a * deltaTime));\n        }\n        if (keyStates.S) {\n            const front = new THREE.Vector3();\n            player.getWorldDirection(front);\n            // - a：与W按键反向相反\n            v.add(front.multiplyScalar(- a * deltaTime));\n        }\n    }\n}    \n",normalizedContent:"# 获取玩家(相机)正前方方向\n\n实际开发，玩家角色的视角或者说相机的视角，会随着鼠标左右移动变化的，不过前面几节课，为了降低学习难度，代码给的是固定方向。\n\nfunction render() {\n    if (keystates.w) {\n        //先假设w键对应运动方向为z\n        const front = new three.vector3(0, 0, 1);\n        // 改变玩家速度\n        v.add(front.multiplyscalar(a * deltatime));\n    }\n}\n\n\n\n# .getworlddirection()\n\nobject3d类有一个获取模型局部z轴方向相关的方法.getworlddirection()。\n\nobj.getworlddirection()表示的获取obj对象自身z轴正方向在世界坐标空间中的方向。\n\n模型没有任何旋转情况，.getworlddirection()获取的结果(0,0,1)\n\nconst mesh = new three.mesh();\nconst dir = new three.vector3();\nmesh.getworlddirection(dir);\nconsole.log('dir', dir);\n\n\n模型绕y旋转90度情况，.getworlddirection()获取的结果(1,0,0)\n\nconst mesh = new three.mesh();\nmesh.rotatey(math.pi / 2);\nconst dir = new three.vector3();\nmesh.getworlddirection(dir);\n// 模型没有任何选择打印结果(1,0,0)\nconsole.log('dir', dir);\n\n\n\n# .getworlddirection()获取玩家角色正前方\n\n注意：threejs加载的玩家角色gltf模型，自身.rotation没有任何旋转的情况下，注意玩家角色正前方方向最好和z轴方向一致,这样就可以直接用.getworlddirection()获取的结果表示人的正前方。\n\n// 按下w键，实时计算当前玩家角色的正前方向\nif (keystates.w) {\n    const front = new three.vector3();\n    //获取玩家角色(相机)正前方\n    player.getworlddirection(front);\n}\n\n\n\n# s键运动方向\n\n注意s键运动方向与w的正前方相反，这时候很简单，可以计算方向的时候，把front取反，或者最简单加速度设置一个负号front.multiplyscalar(- a * deltatime)\n\nfunction render() {\n    if (v.length() < vmax) {//限制最高速度\n        if (keystates.w) {\n            const front = new three.vector3();\n            player.getworlddirection(front);//获取玩家角色(相机)正前方\n            v.add(front.multiplyscalar(a * deltatime));\n        }\n        if (keystates.s) {\n            const front = new three.vector3();\n            player.getworlddirection(front);\n            // - a：与w按键反向相反\n            v.add(front.multiplyscalar(- a * deltatime));\n        }\n    }\n}    \n",charsets:{cjk:!0}},{title:"9. 鼠标上下移动只改变相机视角",frontmatter:{title:"9. 鼠标上下移动只改变相机视角",date:"2023-09-03T22:45:27.000Z",permalink:"/pages/15d00d/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/09.%E9%BC%A0%E6%A0%87%E4%B8%8A%E4%B8%8B%E7%A7%BB%E5%8A%A8%E5%8F%AA%E6%94%B9%E5%8F%98%E7%9B%B8%E6%9C%BA%E8%A7%86%E8%A7%92.html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/09.鼠标上下移动只改变相机视角.md",key:"v-9709b4ce",path:"/pages/15d00d/",headers:[{level:3,title:"有问题：通过player改变相机上下俯仰视角",slug:"有问题-通过player改变相机上下俯仰视角",normalizedTitle:"有问题：通过player改变相机上下俯仰视角",charIndex:319},{level:3,title:"鼠标上下移动只改变相机视角，不改变player角度",slug:"鼠标上下移动只改变相机视角-不改变player角度",normalizedTitle:"鼠标上下移动只改变相机视角，不改变player角度",charIndex:698},{level:3,title:"限制视线上下浮动范围",slug:"限制视线上下浮动范围",normalizedTitle:"限制视线上下浮动范围",charIndex:1324}],headersStr:"有问题：通过player改变相机上下俯仰视角 鼠标上下移动只改变相机视角，不改变player角度 限制视线上下浮动范围",content:"# 鼠标上下移动只改变相机视角\n\n8.7小节给大家讲解了，通过鼠标左右移动，旋转玩家角色模型player，相机跟着player同步旋转。\n\nplayer.add(camera);//相机作为player子对象\n\ndocument.addEventListener('mousemove', (event) => {\n    if(leftButtonBool){\n        player.rotation.y -= event.movementX / 600;\n    } \n});\n\n\n本节课给大家讲解，鼠标上下移动后，只改变相机视角，但是不改变玩家角色模型的姿态角度,换句话说，就是玩家角色模型始终站在地面上不会倾斜。\n\n\n# 有问题：通过player改变相机上下俯仰视角\n\nevent.movementY的值改变player.rotation.x的值，这样虽然可以通过player控制子对象相机视角上下俯仰，但是玩家角色模型也必须跟着旋转，这样会改变人与地面位置关系，你可以思考下，该怎么解决？\n\ndocument.addEventListener('mousemove', (event) => {\n    if(leftButtonBool){\n        // 左右旋转\n        player.rotation.y -= event.movementX / 600;\n        // 玩家角色绕x轴旋转  视角上下俯仰\n        player.rotation.x -= event.movementY / 600;\n    } \n});\n\n\n\n\n\n# 鼠标上下移动只改变相机视角，不改变player角度\n\n可以在相机camera和玩家角色模型player之间，嵌入一个子节点cameraGroup，作为相机的父对象，作为玩家角色模型player的子对象。\n\n// 层级关系：player  <—— camera\nplayer.add(camera);//相机作为player子对象\n\n\n// 层级关系：player <—— cameraGroup <—— camera\nconst cameraGroup = new THREE.Group();\ncameraGroup.add(camera);\nplayer.add(cameraGroup);\n\n\n通过camera的父对象cameraGroup控制相机姿态角度变化。\n\ndocument.addEventListener('mousemove', (event) => {\n    if(leftButtonBool){\n        // 左右旋转\n        player.rotation.y -= event.movementX / 600;\n        // 鼠标上下滑动，让相机视线上下转动\n        // 相机父对象cameraGroup绕着x轴旋转,camera跟着转动\n        cameraGroup.rotation.x -= event.movementY / 600;\n    } \n});\n\n\n\n# 限制视线上下浮动范围\n\n你可以根据需要，约束上下浮动角度范围，比如我设置上下俯仰范围-15度~15度，共30度。\n\n思路很简单，一旦判断.rotation.x小于-15度，就设置为-15度，大于15度，就设置为15度。\n\n// 上下俯仰角度范围\nconst angleMin = THREE.MathUtils.degToRad(-15);//角度转弧度\nconst angleMax = THREE.MathUtils.degToRad(15);\ndocument.addEventListener('mousemove', (event) => {\n    if(leftButtonBool){\n        // 左右旋转\n        player.rotation.y -= event.movementX / 600;\n        // 鼠标上下滑动，让相机视线上下转动\n        // 相机父对象cameraGroup绕着x轴旋转,camera跟着转动\n        cameraGroup.rotation.x -= event.movementY / 600;\n        // 一旦判断.rotation.x小于-15，就设置为-15，大于15，就设置为15\n        if (cameraGroup.rotation.x < angleMin) {\n            cameraGroup.rotation.x = angleMin;\n        }\n        if (cameraGroup.rotation.x > angleMax) {\n            cameraGroup.rotation.x = angleMax\n        };\n    } \n});\n\n\n\n",normalizedContent:"# 鼠标上下移动只改变相机视角\n\n8.7小节给大家讲解了，通过鼠标左右移动，旋转玩家角色模型player，相机跟着player同步旋转。\n\nplayer.add(camera);//相机作为player子对象\n\ndocument.addeventlistener('mousemove', (event) => {\n    if(leftbuttonbool){\n        player.rotation.y -= event.movementx / 600;\n    } \n});\n\n\n本节课给大家讲解，鼠标上下移动后，只改变相机视角，但是不改变玩家角色模型的姿态角度,换句话说，就是玩家角色模型始终站在地面上不会倾斜。\n\n\n# 有问题：通过player改变相机上下俯仰视角\n\nevent.movementy的值改变player.rotation.x的值，这样虽然可以通过player控制子对象相机视角上下俯仰，但是玩家角色模型也必须跟着旋转，这样会改变人与地面位置关系，你可以思考下，该怎么解决？\n\ndocument.addeventlistener('mousemove', (event) => {\n    if(leftbuttonbool){\n        // 左右旋转\n        player.rotation.y -= event.movementx / 600;\n        // 玩家角色绕x轴旋转  视角上下俯仰\n        player.rotation.x -= event.movementy / 600;\n    } \n});\n\n\n\n\n\n# 鼠标上下移动只改变相机视角，不改变player角度\n\n可以在相机camera和玩家角色模型player之间，嵌入一个子节点cameragroup，作为相机的父对象，作为玩家角色模型player的子对象。\n\n// 层级关系：player  <—— camera\nplayer.add(camera);//相机作为player子对象\n\n\n// 层级关系：player <—— cameragroup <—— camera\nconst cameragroup = new three.group();\ncameragroup.add(camera);\nplayer.add(cameragroup);\n\n\n通过camera的父对象cameragroup控制相机姿态角度变化。\n\ndocument.addeventlistener('mousemove', (event) => {\n    if(leftbuttonbool){\n        // 左右旋转\n        player.rotation.y -= event.movementx / 600;\n        // 鼠标上下滑动，让相机视线上下转动\n        // 相机父对象cameragroup绕着x轴旋转,camera跟着转动\n        cameragroup.rotation.x -= event.movementy / 600;\n    } \n});\n\n\n\n# 限制视线上下浮动范围\n\n你可以根据需要，约束上下浮动角度范围，比如我设置上下俯仰范围-15度~15度，共30度。\n\n思路很简单，一旦判断.rotation.x小于-15度，就设置为-15度，大于15度，就设置为15度。\n\n// 上下俯仰角度范围\nconst anglemin = three.mathutils.degtorad(-15);//角度转弧度\nconst anglemax = three.mathutils.degtorad(15);\ndocument.addeventlistener('mousemove', (event) => {\n    if(leftbuttonbool){\n        // 左右旋转\n        player.rotation.y -= event.movementx / 600;\n        // 鼠标上下滑动，让相机视线上下转动\n        // 相机父对象cameragroup绕着x轴旋转,camera跟着转动\n        cameragroup.rotation.x -= event.movementy / 600;\n        // 一旦判断.rotation.x小于-15，就设置为-15，大于15，就设置为15\n        if (cameragroup.rotation.x < anglemin) {\n            cameragroup.rotation.x = anglemin;\n        }\n        if (cameragroup.rotation.x > anglemax) {\n            cameragroup.rotation.x = anglemax\n        };\n    } \n});\n\n\n\n",charsets:{cjk:!0}},{title:"10. 玩家角色左右运动(叉乘)",frontmatter:{title:"10. 玩家角色左右运动(叉乘)",date:"2023-09-03T22:45:55.000Z",permalink:"/pages/adb8cb/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/10.%E7%8E%A9%E5%AE%B6%E8%A7%92%E8%89%B2%E5%B7%A6%E5%8F%B3%E8%BF%90%E5%8A%A8(%E5%8F%89%E4%B9%98).html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/10.玩家角色左右运动(叉乘).md",key:"v-49244fca",path:"/pages/adb8cb/",headers:[{level:3,title:"知识点回顾",slug:"知识点回顾",normalizedTitle:"知识点回顾",charIndex:75},{level:3,title:"叉乘计算左右方向",slug:"叉乘计算左右方向",normalizedTitle:"叉乘计算左右方向",charIndex:499}],headersStr:"知识点回顾 叉乘计算左右方向",content:"# 玩家角色左右运动(叉乘)\n\n前面给大家讲解过，通过W和S按键控制玩家角色的前后运动，本节课给大家讲解通过A和D键控制玩家的左右运动。\n\n\n\n\n# 知识点回顾\n\n8.8小节给大家讲解过，执行player.getWorldDirection(front);，可以获取玩家角色模型，当前视线正前方方向，用于W键和S键的前后运动控制。\n\nif (keyStates.W) {\n    const front = new THREE.Vector3();\n    player.getWorldDirection(front);//获取玩家角色(相机)正前方\n    v.add(front.multiplyScalar(a * deltaTime));\n}\nif (keyStates.S) {\n    const front = new THREE.Vector3();\n    player.getWorldDirection(front);\n    // - a：与W按键反向相反\n    v.add(front.multiplyScalar(- a * deltaTime));\n}\n\n\n\n# 叉乘计算左右方向\n\n你可以先回顾下，前面3.5节 向量叉乘的知识点。\n\n两个向量a、b叉乘有一个特点，叉乘结果是一个同时垂直于a和b的向量。这就是说只要知道玩家角色模型人正前方方向和高度方向向量，就可以计算出来人的左右方向。\n\n小技巧：叉乘获得垂直于向量up和front的向量,左右方向与叉乘顺序有关,左右方向，可以用右手螺旋定责判断，但是比较麻烦，如果你懒得思考，干脆不用右手螺旋定则判断，代码测试测试下最简单，先随便写一个叉乘顺序，如果不对，就把up和front叉乘顺序换下。\n\n\n\n玩家角色的正前方\n\nconst front = new THREE.Vector3();\nplayer.getWorldDirection(front);\n\n\n玩家角色的高度方向(竖直方向)\n\nconst up = new THREE.Vector3(0, 1, 0);//y方向\n\n\nA和D按键对应的方向计算代码。\n\nif (keyStates.A) {//向左运动\n    const front = new THREE.Vector3();\n    player.getWorldDirection(front);\n    const up = new THREE.Vector3(0, 1, 0);//y方向\n\n    const left = up.clone().cross(front);\n    v.add(left.multiplyScalar(a * deltaTime));\n}\nif (keyStates.D) {//向右运动\n    const front = new THREE.Vector3();\n    player.getWorldDirection(front);\n    const up = new THREE.Vector3(0, 1, 0);//y方向\n    //叉乘获得垂直于向量up和front的向量 左右与叉乘顺序有关,可以用右手螺旋定则判断，也可以代码测试结合3D场景观察验证\n    const right = front.clone().cross(up);\n    v.add(right.multiplyScalar(a * deltaTime));\n}\n",normalizedContent:"# 玩家角色左右运动(叉乘)\n\n前面给大家讲解过，通过w和s按键控制玩家角色的前后运动，本节课给大家讲解通过a和d键控制玩家的左右运动。\n\n\n\n\n# 知识点回顾\n\n8.8小节给大家讲解过，执行player.getworlddirection(front);，可以获取玩家角色模型，当前视线正前方方向，用于w键和s键的前后运动控制。\n\nif (keystates.w) {\n    const front = new three.vector3();\n    player.getworlddirection(front);//获取玩家角色(相机)正前方\n    v.add(front.multiplyscalar(a * deltatime));\n}\nif (keystates.s) {\n    const front = new three.vector3();\n    player.getworlddirection(front);\n    // - a：与w按键反向相反\n    v.add(front.multiplyscalar(- a * deltatime));\n}\n\n\n\n# 叉乘计算左右方向\n\n你可以先回顾下，前面3.5节 向量叉乘的知识点。\n\n两个向量a、b叉乘有一个特点，叉乘结果是一个同时垂直于a和b的向量。这就是说只要知道玩家角色模型人正前方方向和高度方向向量，就可以计算出来人的左右方向。\n\n小技巧：叉乘获得垂直于向量up和front的向量,左右方向与叉乘顺序有关,左右方向，可以用右手螺旋定责判断，但是比较麻烦，如果你懒得思考，干脆不用右手螺旋定则判断，代码测试测试下最简单，先随便写一个叉乘顺序，如果不对，就把up和front叉乘顺序换下。\n\n\n\n玩家角色的正前方\n\nconst front = new three.vector3();\nplayer.getworlddirection(front);\n\n\n玩家角色的高度方向(竖直方向)\n\nconst up = new three.vector3(0, 1, 0);//y方向\n\n\na和d按键对应的方向计算代码。\n\nif (keystates.a) {//向左运动\n    const front = new three.vector3();\n    player.getworlddirection(front);\n    const up = new three.vector3(0, 1, 0);//y方向\n\n    const left = up.clone().cross(front);\n    v.add(left.multiplyscalar(a * deltatime));\n}\nif (keystates.d) {//向右运动\n    const front = new three.vector3();\n    player.getworlddirection(front);\n    const up = new three.vector3(0, 1, 0);//y方向\n    //叉乘获得垂直于向量up和front的向量 左右与叉乘顺序有关,可以用右手螺旋定则判断，也可以代码测试结合3d场景观察验证\n    const right = front.clone().cross(up);\n    v.add(right.multiplyscalar(a * deltatime));\n}\n",charsets:{cjk:!0}},{title:"11. 鼠标滑动改变视角(指针锁定模式)",frontmatter:{title:"11. 鼠标滑动改变视角(指针锁定模式)",date:"2023-09-03T22:46:03.000Z",permalink:"/pages/920120/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/11.%E9%BC%A0%E6%A0%87%E6%BB%91%E5%8A%A8%E6%94%B9%E5%8F%98%E8%A7%86%E8%A7%92(%E6%8C%87%E9%92%88%E9%94%81%E5%AE%9A%E6%A8%A1%E5%BC%8F).html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/11.鼠标滑动改变视角(指针锁定模式).md",key:"v-bdf3a312",path:"/pages/920120/",headers:[{level:3,title:"知识点回顾",slug:"知识点回顾",normalizedTitle:"知识点回顾",charIndex:97},{level:3,title:"体验案例源码",slug:"体验案例源码",normalizedTitle:"体验案例源码",charIndex:641},{level:3,title:"请求指针锁定requestPointerLock",slug:"请求指针锁定requestpointerlock",normalizedTitle:"请求指针锁定requestpointerlock",charIndex:755},{level:3,title:"在指针锁定模式下，改变玩家人姿态角度",slug:"在指针锁定模式下-改变玩家人姿态角度",normalizedTitle:"在指针锁定模式下，改变玩家人姿态角度",charIndex:1151},{level:3,title:"退出指针锁定模式",slug:"退出指针锁定模式",normalizedTitle:"退出指针锁定模式",charIndex:1644}],headersStr:"知识点回顾 体验案例源码 请求指针锁定requestPointerLock 在指针锁定模式下，改变玩家人姿态角度 退出指针锁定模式",content:"# 鼠标滑动改变视角(指针锁定模式)\n\n前面改变相机左右和上下视角，用的是鼠标拖动方式，本节课给大家演示一个游戏、元宇宙项目中，常用的不用拖动，鼠标直接滑动改变相机玩家角色或相机视角。\n\n\n# 知识点回顾\n\n你可以把原来鼠标左键拖动改变视角的代码if (leftButtonBool) {}，if条件去掉，只剩下鼠标滑动改变视角，你会发现并不是很好控制，有个问题，鼠标离开网页后，无法在旋转玩家视角，那么怎么解决？请看下面关于指针锁定模式的介绍。\n\nlet leftButtonBool = false;//记录鼠标左键状态\ndocument.addEventListener('mousedown', (event) => {\n    leftButtonBool = true;\n});\ndocument.addEventListener('mouseup', () => {\n    leftButtonBool = false;\n});\n\ndocument.addEventListener('mousemove', (event) => {\n    if (leftButtonBool) {//根据左键按下拖动才起作用\n        player.rotation.y -= event.movementX / 600;\n        cameraGroup.rotation.x -= event.movementY / 600;\n\n    }\n});\n\n\n\n# 体验案例源码\n\n你可以打开本节课案例源码，然后鼠标点击页面随便一个位置，就会进入指针锁定模式，人话说，这时候，你发现鼠标箭头不见了，鼠标可以上下左右无限滑动，如果你按下键盘左上角Esc按键，鼠标指针箭头恢复到原来状态。\n\n\n# 请求指针锁定requestPointerLock\n\n鼠标滑动时候，会受到浏览器网页页面窗口范围限制，不能无限制移动，这时候可以通过执行requestPointerLock()请求指针锁定。\n\n// 当鼠标左键按下后进入指针锁定模式(鼠标无限滑动)\naddEventListener( 'mousedown', () => {\n    document.body.requestPointerLock();//body页面指针锁定\n});\n\n\n你执行document.body.requestPointerLock();以后，意味着document.pointerLockElement属性，会拥有一个值document.body\n\nif(document.pointerLockElement == document.body){\n    // 指针锁定模式下，才能执行的代码\n}\n\n\n\n# 在指针锁定模式下，改变玩家人姿态角度\n\n进入指针模式后，才能根据鼠标位置控制人旋转\n\n通过document.pointerLockElement判断web页面是否进入指针锁定模式。\n\n鼠标点击页面进入指针锁定模式的时候，点击位置默认鼠标的坐标为原点，左右方向是x坐标.movementX(单位像素)，上下方面是y坐标.movementY。\n\n// 人和相机初始姿态正前方：沿着z轴正半轴方向\n//鼠标左右移动，人绕y轴旋转\naddEventListener('mousemove', (event) => {\n    // 进入指针模式后，才能根据鼠标位置控制人旋转\n    if (document.pointerLockElement == document.body) {\n        // 鼠标左右滑动，让人左右转向(绕y轴旋转)，相机会父对象人绕左右转向\n        //加减法根据左右方向对应关系设置，缩放倍数根据，相应敏感度设置\n        person.rotation.y -= event.movementX / 500;\n    }\n});\n\n\n\n# 退出指针锁定模式\n\n执行document.exitPointerLock();可以退出指针锁定,或者键盘键盘Esc退出指针锁定模式，就像你玩游戏一样。",normalizedContent:"# 鼠标滑动改变视角(指针锁定模式)\n\n前面改变相机左右和上下视角，用的是鼠标拖动方式，本节课给大家演示一个游戏、元宇宙项目中，常用的不用拖动，鼠标直接滑动改变相机玩家角色或相机视角。\n\n\n# 知识点回顾\n\n你可以把原来鼠标左键拖动改变视角的代码if (leftbuttonbool) {}，if条件去掉，只剩下鼠标滑动改变视角，你会发现并不是很好控制，有个问题，鼠标离开网页后，无法在旋转玩家视角，那么怎么解决？请看下面关于指针锁定模式的介绍。\n\nlet leftbuttonbool = false;//记录鼠标左键状态\ndocument.addeventlistener('mousedown', (event) => {\n    leftbuttonbool = true;\n});\ndocument.addeventlistener('mouseup', () => {\n    leftbuttonbool = false;\n});\n\ndocument.addeventlistener('mousemove', (event) => {\n    if (leftbuttonbool) {//根据左键按下拖动才起作用\n        player.rotation.y -= event.movementx / 600;\n        cameragroup.rotation.x -= event.movementy / 600;\n\n    }\n});\n\n\n\n# 体验案例源码\n\n你可以打开本节课案例源码，然后鼠标点击页面随便一个位置，就会进入指针锁定模式，人话说，这时候，你发现鼠标箭头不见了，鼠标可以上下左右无限滑动，如果你按下键盘左上角esc按键，鼠标指针箭头恢复到原来状态。\n\n\n# 请求指针锁定requestpointerlock\n\n鼠标滑动时候，会受到浏览器网页页面窗口范围限制，不能无限制移动，这时候可以通过执行requestpointerlock()请求指针锁定。\n\n// 当鼠标左键按下后进入指针锁定模式(鼠标无限滑动)\naddeventlistener( 'mousedown', () => {\n    document.body.requestpointerlock();//body页面指针锁定\n});\n\n\n你执行document.body.requestpointerlock();以后，意味着document.pointerlockelement属性，会拥有一个值document.body\n\nif(document.pointerlockelement == document.body){\n    // 指针锁定模式下，才能执行的代码\n}\n\n\n\n# 在指针锁定模式下，改变玩家人姿态角度\n\n进入指针模式后，才能根据鼠标位置控制人旋转\n\n通过document.pointerlockelement判断web页面是否进入指针锁定模式。\n\n鼠标点击页面进入指针锁定模式的时候，点击位置默认鼠标的坐标为原点，左右方向是x坐标.movementx(单位像素)，上下方面是y坐标.movementy。\n\n// 人和相机初始姿态正前方：沿着z轴正半轴方向\n//鼠标左右移动，人绕y轴旋转\naddeventlistener('mousemove', (event) => {\n    // 进入指针模式后，才能根据鼠标位置控制人旋转\n    if (document.pointerlockelement == document.body) {\n        // 鼠标左右滑动，让人左右转向(绕y轴旋转)，相机会父对象人绕左右转向\n        //加减法根据左右方向对应关系设置，缩放倍数根据，相应敏感度设置\n        person.rotation.y -= event.movementx / 500;\n    }\n});\n\n\n\n# 退出指针锁定模式\n\n执行document.exitpointerlock();可以退出指针锁定,或者键盘键盘esc退出指针锁定模式，就像你玩游戏一样。",charsets:{cjk:!0}},{title:"12. 快捷键切换第一、第三人称",frontmatter:{title:"12. 快捷键切换第一、第三人称",date:"2023-09-03T22:46:17.000Z",permalink:"/pages/c9f808/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/12.%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%87%E6%8D%A2%E7%AC%AC%E4%B8%80%E3%80%81%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0.html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/12.快捷键切换第一、第三人称.md",key:"v-c22b68d6",path:"/pages/c9f808/",headers:[{level:3,title:"知识回顾：第三人称",slug:"知识回顾-第三人称",normalizedTitle:"知识回顾：第三人称",charIndex:58},{level:3,title:"第一人称",slug:"第一人称",normalizedTitle:"第一人称",charIndex:364},{level:3,title:"第一、第三人称切换",slug:"第一、第三人称切换",normalizedTitle:"第一、第三人称切换",charIndex:754}],headersStr:"知识回顾：第三人称 第一人称 第一、第三人称切换",content:"# 快捷键切换第一、第三人称\n\n你可以先复习下前面8.6.相机跟着玩家走(第三人称漫游)在学习本节课内容。\n\n\n# 知识回顾：第三人称\n\n\n\n注意一点透视投影相机fov视野的角度值会影响，相机与人距离的设置。\n\nconst camera = new THREE.PerspectiveCamera(30,...);\n//玩家角色后面一点  对应fov 30度\ncamera.position.set(0, 1.6, -5.5);\n\n\n根据透视投影相机规律，fov变大，能够看到的视野范围角度更大。\n\nconst camera = new THREE.PerspectiveCamera(70,...);\n//玩家角色后面一点  对应fov 70度\ncamera.position.set(0, 1.6, -2.3);\n\n\n\n# 第一人称\n\n第一人称，简单点说，就是看不到玩家角色的模型，相当于把相机放在人的前面。\n\n// camera.position.set(0, 1.6, -2.3);//第三人称\n// camera.lookAt(0, 1.6, 0);\ncamera.position.set(0, 1.6, 1);//第一人称\ncamera.lookAt(0, 1.6, 2);//目标观察点注意在相机位置前面一点\n\n\n如果lookAt后面执行第一人称代码，不重新执行camera.lookAt,视线方向还是原来的。\n\n// z距离人远近具体值，可以根据模型尺寸去测试调节\ncamera.position.set(0, 1.6, -2.3);//第三人称\ncamera.lookAt(0, 1.6, 0);\ncamera.position.set(0, 1.6, 1);//第一人称\n\n\n\n\n\n# 第一、第三人称切换\n\n第一、第三人称，快捷键v切换的完整代码。\n\nlet viewBool = true;//true表示第三人称，false表示第一人称\ndocument.addEventListener('keydown', (event) => {\n    if (event.code === 'KeyV') {\n        if (viewBool) {\n            // 切换到第一人称\n            camera.position.z = 1;//相机在人前面一点 看不到人模型即可\n        } else {\n            // 切换到第三人称\n            camera.position.z = -2.3;//相机在人后面一点\n        }\n        viewBool = !viewBool;\n    }\n});\n",normalizedContent:"# 快捷键切换第一、第三人称\n\n你可以先复习下前面8.6.相机跟着玩家走(第三人称漫游)在学习本节课内容。\n\n\n# 知识回顾：第三人称\n\n\n\n注意一点透视投影相机fov视野的角度值会影响，相机与人距离的设置。\n\nconst camera = new three.perspectivecamera(30,...);\n//玩家角色后面一点  对应fov 30度\ncamera.position.set(0, 1.6, -5.5);\n\n\n根据透视投影相机规律，fov变大，能够看到的视野范围角度更大。\n\nconst camera = new three.perspectivecamera(70,...);\n//玩家角色后面一点  对应fov 70度\ncamera.position.set(0, 1.6, -2.3);\n\n\n\n# 第一人称\n\n第一人称，简单点说，就是看不到玩家角色的模型，相当于把相机放在人的前面。\n\n// camera.position.set(0, 1.6, -2.3);//第三人称\n// camera.lookat(0, 1.6, 0);\ncamera.position.set(0, 1.6, 1);//第一人称\ncamera.lookat(0, 1.6, 2);//目标观察点注意在相机位置前面一点\n\n\n如果lookat后面执行第一人称代码，不重新执行camera.lookat,视线方向还是原来的。\n\n// z距离人远近具体值，可以根据模型尺寸去测试调节\ncamera.position.set(0, 1.6, -2.3);//第三人称\ncamera.lookat(0, 1.6, 0);\ncamera.position.set(0, 1.6, 1);//第一人称\n\n\n\n\n\n# 第一、第三人称切换\n\n第一、第三人称，快捷键v切换的完整代码。\n\nlet viewbool = true;//true表示第三人称，false表示第一人称\ndocument.addeventlistener('keydown', (event) => {\n    if (event.code === 'keyv') {\n        if (viewbool) {\n            // 切换到第一人称\n            camera.position.z = 1;//相机在人前面一点 看不到人模型即可\n        } else {\n            // 切换到第三人称\n            camera.position.z = -2.3;//相机在人后面一点\n        }\n        viewbool = !viewbool;\n    }\n});\n",charsets:{cjk:!0}},{title:"13. 骨骼动画与运动状态关联",frontmatter:{title:"13. 骨骼动画与运动状态关联",date:"2023-09-03T22:46:29.000Z",permalink:"/pages/dd3bfe/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/08.8.%E7%AC%AC%E4%B8%80%E3%80%81%E4%B8%89%E4%BA%BA%E7%A7%B0%E6%BC%AB%E6%B8%B8/13.%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BF%90%E5%8A%A8%E7%8A%B6%E6%80%81%E5%85%B3%E8%81%94.html",relativePath:"02.Three.js进阶教程/08.8.第一、三人称漫游/13.骨骼动画与运动状态关联.md",key:"v-0d5aab1a",path:"/pages/dd3bfe/",headers:[{level:3,title:"查看模型所有骨骼动画数据",slug:"查看模型所有骨骼动画数据",normalizedTitle:"查看模型所有骨骼动画数据",charIndex:126},{level:3,title:"站着休息和步行两个动作切换",slug:"站着休息和步行两个动作切换",normalizedTitle:"站着休息和步行两个动作切换",charIndex:1027},{level:3,title:"阻尼和加速度调节",slug:"阻尼和加速度调节",normalizedTitle:"阻尼和加速度调节",charIndex:1809},{level:3,title:"练习题：休息、步行、跑步三个动作",slug:"练习题-休息、步行、跑步三个动作",normalizedTitle:"练习题：休息、步行、跑步三个动作",charIndex:2172},{level:3,title:"作业练习：批量解析全部骨骼动画动作",slug:"作业练习-批量解析全部骨骼动画动作",normalizedTitle:"作业练习：批量解析全部骨骼动画动作",charIndex:3298}],headersStr:"查看模型所有骨骼动画数据 站着休息和步行两个动作切换 阻尼和加速度调节 练习题：休息、步行、跑步三个动作 作业练习：批量解析全部骨骼动画动作",content:"# 骨骼动画与运动状态关联\n\n学习本节课之前，首先确保你已经熟悉前面基础内容16. 关键帧动画，要不然大部分代码你也看不懂，也跟不上视频。\n\n骨骼动画有休息、步行、跑步等动作，本节课大家简单讲解下，根据玩家角色的运动状态来执行对应的骨骼动画。\n\n\n# 查看模型所有骨骼动画数据\n\nconst gltf = await loader.loadAsync(\"../../人.glb\");\nconst player = gltf.scene;//玩家角色模型\n\n//包含关键帧动画的模型作为参数创建一个播放器\nconst mixer = new THREE.AnimationMixer(player);\nconsole.log('所有骨骼动画数据', gltf.animations);\n// 骨骼动画动画名字和对应含义，名字是可以在bledner中随意命名的\n//Idle  休息\n//Run   跑步\n//Walk  走路\n//休息动作\nconst IdleAction = mixer.clipAction(gltf.animations[5]);\n//步行动作\nconst WalkAction = mixer.clipAction(gltf.animations[13]);\n//跑步动作\nconst RunAction = mixer.clipAction(gltf.animations[0]);\n\n\n查看gltf.animations，你可以看到不同clip动画的名字等数据\n\nconsole.log('所有骨骼动画数据', gltf.animations);\n// 骨骼动画动画名字和对应含义，名字是可以在bledner中随意命名的\n//Idle  休息\n//Run   跑步\n//Walk  走路\n\n\n不同clip动画数据的索引值，可以在浏览器控制台打印gltf.animations查看\n\n不同模型不同，你根据自己项目模型，灵活应对即可。\n\n//休息动作\nconst IdleAction = mixer.clipAction(gltf.animations[5]);\n//步行动作\nconst WalkAction = mixer.clipAction(gltf.animations[13]);\n//跑步动作\nconst RunAction = mixer.clipAction(gltf.animations[0]);\n\n\n\n# 站着休息和步行两个动作切换\n\n具体思路：你参考前面基础课程11. 骨骼动画不同动作切换里面案例2即可。\n\n//休息动作\nconst IdleAction = mixer.clipAction(gltf.animations[5]);\n//步行动作\nconst WalkAction = mixer.clipAction(gltf.animations[13]);\nIdleAction.play();\nWalkAction.play();\nIdleAction.weight = 1.0;//默认休息状态\nWalkAction.weight = 0.0;\n\n\n在站着休息和步行两个动作之间切换\n\nfunction changeAction(name){\n    if (name=='Idle'){\n        IdleAction.weight = 1.0;//休息状态\n        WalkAction.weight = 0.0;\n    }else if (name == 'Walk') {\n        IdleAction.weight = 0.0;\n        WalkAction.weight = 1.0;//步行状态\n    } \n}\n\n\n根据玩家速度v的大小v.length(),控制使用休息和步行那个动作。\n\nfunction playerUpdate(deltaTime) {\n    const vL = v.length();\n    if (vL < 0.2) {//速度小于0.2切换到站着休息状态\n        changeAction('Idle');\n    } else if (vL >= 0.2) {//步行状态\n        changeAction('Walk');\n    } \n}\n\n\n\n# 阻尼和加速度调节\n\n当不在使用WASD加速的时候，如果你希望玩家快速减速，可以适当提升阻尼。\n\nconst damping = -0.1;\nv.addScaledVector(v, damping);//阻尼减速\n\n\nWASD按键加速的同时，也会通过阻尼减速，所以阻尼的存在会限制最大速度。如果达不到自己想要的最大速度，可以把加速度a的值提升。\n\nconst a = 30;//WASD按键的加速度：调节按键加速快慢\nconst damping = -0.1;\nconst vMax = 10;//限制玩家角色最大速度\n\nconst vL = v.length();\nconsole.log('vL', vL);//浏览器控制查看速度大小\n\nv.addScaledVector(v, damping);//阻尼减速\n\n\n\n# 练习题：休息、步行、跑步三个动作\n\n//休息动作\nconst IdleAction = mixer.clipAction(gltf.animations[5]);\n//步行动作\nconst WalkAction = mixer.clipAction(gltf.animations[13]);\n//跑步动作\nconst RunAction = mixer.clipAction(gltf.animations[0]);\nIdleAction.play();\nWalkAction.play();\nRunAction.play();\nIdleAction.weight = 1.0;//默认休息状态\nWalkAction.weight = 0.0;\nRunAction.weight = 0.0;\n\n\nfunction changeAction(name) {\n    if (name == 'Idle') {\n        IdleAction.weight = 1.0;\n        WalkAction.weight = 0.0;\n        RunAction.weight = 0.0;\n    } else if (name == 'Walk') {\n        IdleAction.weight = 0.0;\n        WalkAction.weight = 1.0;\n        RunAction.weight = 0.0;\n    } else if (name == 'Run') {\n        IdleAction.weight = 0.0;\n        WalkAction.weight = 0.0;\n        RunAction.weight = 1.0;\n    }\n}\n\n\n不同速度设置三个动画状态，测试上面骨骼动画效果\n\nfunction playerUpdate(deltaTime) {\n    const vL = v.length();\n    if (vL < 0.2) {//速度小于0.2切换到站着休息状态\n        // 注释如果当前就是Idle状态，不要再次执行changeAction\n        changeAction('Idle');\n    } else if (vL > 0.2 && vL < 4) {//步行状态\n        changeAction('Walk');\n    } else if (vL >= 4) {//跑步状态\n        changeAction('Run');\n    }\n}    \n\n\n\n# 作业练习：批量解析全部骨骼动画动作\n\n如果动作多了你会发现一个一个写，比较麻烦，其实你也可以通过for循环批量解析所有骨骼动画动作。\n\nconst clipArr = gltf.animations;//所有骨骼动画\nconst actionObj = {};//包含所有动作action\nfor (let i = 0; i < clipArr.length; i++) {\n    const clip = aniArr[i];//休息、步行、跑步等动画的clip数据\n    const action = mixer.clipAction(clip);//clip生成action\n    action.name = clip.name;//action命名name\n    // 批量设置所有动画动作的权重\n    if (action.name === 'Idle') {\n        action.weight = 1.0;//这样默认播放Idle对应的休息动画\n    } else {\n        action.weight = 0.0;\n    }\n    action.play();\n    // action动画动作名字作为actionObj的属性\n    actionObj[action.name] = action;\n}\n\n\n动作切换函数\n\nlet currentAction = actionObj['Idle'];//记录当前播放的动作\n// 切换不同动作\nfunction changeAction(actionName) {\n    currentAction.weight = 0.0;//原来动作权重为0，不播放\n    const action = actionObj[actionName];//新的需要播放的动作\n    action.weight = 1.0;//将要播放的动作权重为1\n    currentAction = action;//替换记录的动作\n}\n\n\n根据玩家角色速度v设置休息和步行动作。\n\nfunction playerUpdate(deltaTime) {\n    const vL = v.length();\n    if (vL < 0.2) {//速度小于0.2切换到站着休息状态\n        // 如果当前就是Idle状态，不需要再次执行changeAction\n        if (currentAction.name != 'Idle') changeAction('Idle');\n    } else {//步行状态\n        if (currentAction.name != 'Walk') changeAction('Walk');\n    }\n}\n",normalizedContent:"# 骨骼动画与运动状态关联\n\n学习本节课之前，首先确保你已经熟悉前面基础内容16. 关键帧动画，要不然大部分代码你也看不懂，也跟不上视频。\n\n骨骼动画有休息、步行、跑步等动作，本节课大家简单讲解下，根据玩家角色的运动状态来执行对应的骨骼动画。\n\n\n# 查看模型所有骨骼动画数据\n\nconst gltf = await loader.loadasync(\"../../人.glb\");\nconst player = gltf.scene;//玩家角色模型\n\n//包含关键帧动画的模型作为参数创建一个播放器\nconst mixer = new three.animationmixer(player);\nconsole.log('所有骨骼动画数据', gltf.animations);\n// 骨骼动画动画名字和对应含义，名字是可以在bledner中随意命名的\n//idle  休息\n//run   跑步\n//walk  走路\n//休息动作\nconst idleaction = mixer.clipaction(gltf.animations[5]);\n//步行动作\nconst walkaction = mixer.clipaction(gltf.animations[13]);\n//跑步动作\nconst runaction = mixer.clipaction(gltf.animations[0]);\n\n\n查看gltf.animations，你可以看到不同clip动画的名字等数据\n\nconsole.log('所有骨骼动画数据', gltf.animations);\n// 骨骼动画动画名字和对应含义，名字是可以在bledner中随意命名的\n//idle  休息\n//run   跑步\n//walk  走路\n\n\n不同clip动画数据的索引值，可以在浏览器控制台打印gltf.animations查看\n\n不同模型不同，你根据自己项目模型，灵活应对即可。\n\n//休息动作\nconst idleaction = mixer.clipaction(gltf.animations[5]);\n//步行动作\nconst walkaction = mixer.clipaction(gltf.animations[13]);\n//跑步动作\nconst runaction = mixer.clipaction(gltf.animations[0]);\n\n\n\n# 站着休息和步行两个动作切换\n\n具体思路：你参考前面基础课程11. 骨骼动画不同动作切换里面案例2即可。\n\n//休息动作\nconst idleaction = mixer.clipaction(gltf.animations[5]);\n//步行动作\nconst walkaction = mixer.clipaction(gltf.animations[13]);\nidleaction.play();\nwalkaction.play();\nidleaction.weight = 1.0;//默认休息状态\nwalkaction.weight = 0.0;\n\n\n在站着休息和步行两个动作之间切换\n\nfunction changeaction(name){\n    if (name=='idle'){\n        idleaction.weight = 1.0;//休息状态\n        walkaction.weight = 0.0;\n    }else if (name == 'walk') {\n        idleaction.weight = 0.0;\n        walkaction.weight = 1.0;//步行状态\n    } \n}\n\n\n根据玩家速度v的大小v.length(),控制使用休息和步行那个动作。\n\nfunction playerupdate(deltatime) {\n    const vl = v.length();\n    if (vl < 0.2) {//速度小于0.2切换到站着休息状态\n        changeaction('idle');\n    } else if (vl >= 0.2) {//步行状态\n        changeaction('walk');\n    } \n}\n\n\n\n# 阻尼和加速度调节\n\n当不在使用wasd加速的时候，如果你希望玩家快速减速，可以适当提升阻尼。\n\nconst damping = -0.1;\nv.addscaledvector(v, damping);//阻尼减速\n\n\nwasd按键加速的同时，也会通过阻尼减速，所以阻尼的存在会限制最大速度。如果达不到自己想要的最大速度，可以把加速度a的值提升。\n\nconst a = 30;//wasd按键的加速度：调节按键加速快慢\nconst damping = -0.1;\nconst vmax = 10;//限制玩家角色最大速度\n\nconst vl = v.length();\nconsole.log('vl', vl);//浏览器控制查看速度大小\n\nv.addscaledvector(v, damping);//阻尼减速\n\n\n\n# 练习题：休息、步行、跑步三个动作\n\n//休息动作\nconst idleaction = mixer.clipaction(gltf.animations[5]);\n//步行动作\nconst walkaction = mixer.clipaction(gltf.animations[13]);\n//跑步动作\nconst runaction = mixer.clipaction(gltf.animations[0]);\nidleaction.play();\nwalkaction.play();\nrunaction.play();\nidleaction.weight = 1.0;//默认休息状态\nwalkaction.weight = 0.0;\nrunaction.weight = 0.0;\n\n\nfunction changeaction(name) {\n    if (name == 'idle') {\n        idleaction.weight = 1.0;\n        walkaction.weight = 0.0;\n        runaction.weight = 0.0;\n    } else if (name == 'walk') {\n        idleaction.weight = 0.0;\n        walkaction.weight = 1.0;\n        runaction.weight = 0.0;\n    } else if (name == 'run') {\n        idleaction.weight = 0.0;\n        walkaction.weight = 0.0;\n        runaction.weight = 1.0;\n    }\n}\n\n\n不同速度设置三个动画状态，测试上面骨骼动画效果\n\nfunction playerupdate(deltatime) {\n    const vl = v.length();\n    if (vl < 0.2) {//速度小于0.2切换到站着休息状态\n        // 注释如果当前就是idle状态，不要再次执行changeaction\n        changeaction('idle');\n    } else if (vl > 0.2 && vl < 4) {//步行状态\n        changeaction('walk');\n    } else if (vl >= 4) {//跑步状态\n        changeaction('run');\n    }\n}    \n\n\n\n# 作业练习：批量解析全部骨骼动画动作\n\n如果动作多了你会发现一个一个写，比较麻烦，其实你也可以通过for循环批量解析所有骨骼动画动作。\n\nconst cliparr = gltf.animations;//所有骨骼动画\nconst actionobj = {};//包含所有动作action\nfor (let i = 0; i < cliparr.length; i++) {\n    const clip = aniarr[i];//休息、步行、跑步等动画的clip数据\n    const action = mixer.clipaction(clip);//clip生成action\n    action.name = clip.name;//action命名name\n    // 批量设置所有动画动作的权重\n    if (action.name === 'idle') {\n        action.weight = 1.0;//这样默认播放idle对应的休息动画\n    } else {\n        action.weight = 0.0;\n    }\n    action.play();\n    // action动画动作名字作为actionobj的属性\n    actionobj[action.name] = action;\n}\n\n\n动作切换函数\n\nlet currentaction = actionobj['idle'];//记录当前播放的动作\n// 切换不同动作\nfunction changeaction(actionname) {\n    currentaction.weight = 0.0;//原来动作权重为0，不播放\n    const action = actionobj[actionname];//新的需要播放的动作\n    action.weight = 1.0;//将要播放的动作权重为1\n    currentaction = action;//替换记录的动作\n}\n\n\n根据玩家角色速度v设置休息和步行动作。\n\nfunction playerupdate(deltatime) {\n    const vl = v.length();\n    if (vl < 0.2) {//速度小于0.2切换到站着休息状态\n        // 如果当前就是idle状态，不需要再次执行changeaction\n        if (currentaction.name != 'idle') changeaction('idle');\n    } else {//步行状态\n        if (currentaction.name != 'walk') changeaction('walk');\n    }\n}\n",charsets:{cjk:!0}},{title:"1. 八叉树Octree扩展库介绍",frontmatter:{title:"1. 八叉树Octree扩展库介绍",date:"2023-09-28T23:21:46.000Z",permalink:"/pages/db8906/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/09.9.%E6%BC%AB%E6%B8%B8-%E5%85%AB%E5%8F%89%E6%A0%91%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/01.%E5%85%AB%E5%8F%89%E6%A0%91Octree%E6%89%A9%E5%B1%95%E5%BA%93%E4%BB%8B%E7%BB%8D.html",relativePath:"02.Three.js进阶教程/09.9.漫游-八叉树碰撞检测/01.八叉树Octree扩展库介绍.md",key:"v-2e90a37d",path:"/pages/db8906/",headers:[{level:3,title:"八叉树基本原理解释",slug:"八叉树基本原理解释",normalizedTitle:"八叉树基本原理解释",charIndex:300},{level:3,title:"项目引入Octree.js",slug:"项目引入octree-js",normalizedTitle:"项目引入octree.js",charIndex:842},{level:3,title:"生成八叉树.fromGraphNode()",slug:"生成八叉树-fromgraphnode",normalizedTitle:"生成八叉树.fromgraphnode()",charIndex:1348},{level:3,title:"浏览器控制台打印八叉树",slug:"浏览器控制台打印八叉树",normalizedTitle:"浏览器控制台打印八叉树",charIndex:1916},{level:3,title:"OctreeHelper可视化八叉树",slug:"octreehelper可视化八叉树",normalizedTitle:"octreehelper可视化八叉树",charIndex:2139}],headersStr:"八叉树基本原理解释 项目引入Octree.js 生成八叉树.fromGraphNode() 浏览器控制台打印八叉树 OctreeHelper可视化八叉树",content:"# 八叉树Octree扩展库介绍\n\n本章节学习八叉树Octree目的，是为了实现漫游的碰撞检测功能，比如遇到装障碍物被挡住、比如爬坡和上楼梯。\n\n你可以打开本节课的工厂漫游案例体验测试。\n\n本节课内容会比较多，不过大部分只是作为了解和扩展学习，你只需要你掌握下面3行代码即可。\n\n// 引入八叉树扩展库\nimport { Octree } from 'three/examples/jsm/math/Octree.js';\nconst worldOctree = new Octree();\n// 分割模型，生成八叉树节点\nworldOctree.fromGraphNode(模型对象);\n\n\n\n# 八叉树基本原理解释\n\n下面给大家简单介绍下八叉树概念，初学者不要求记住具体细节，先有个印象就行。\n\n通过前面基础内容2.3. 网格模型(三角形概念)的学习，大家都知道网格模型Mesh本质是由三角形构成，三角形由顶点构成，这些三角形和自己的顶点数据分布在3D空间中。\n\nconst geometry = new THREE.BoxGeometry(50,50,50);\nconsole.log('顶点位置数据',geometry.attributes.position);\nconsole.log('三角形顶点索引数据',geometry.index);\n\n\n\n\n如果整个3D模型用一个长方体空间来表示，在三维空间xyz三个方向，都分割一次，这样就可以得到8个小的长方体子空间。\n\n\n\n一个3D模型的三角形(顶点)分布在三维空间中，如果你用一个长方体来表示整个3d场景，当你分割为8个子空间的时候，每个子空间可以包含对应的三角形(顶点)数据。\n\n每个子空间如果三角形(顶点)数量比较多，还可以继续分割，具体分割规则，你可以自定义，比如你可以规定，一个子空间包含的三角形数量只要大于8个就继续分割。这样一个个子空间可以构成一个树结构，整体来看，每个节点，分叉出来八个子节点。\n\n\n\n\n# 项目引入Octree.js\n\nThree.js在目录/examples/jsm/math/下提供了一个八叉树相关的扩展库Octree.js。 npm安装threejs情况下，Octree.js扩展库引入路径。\n\n// 引入/examples/jsm/math/目录下八叉树扩展库\nimport { Octree } from 'three/examples/jsm/math/Octree.js';\n\n\n在.html文件中，你也可以配置为其它任意路径引入方式\n\n<script type=\"importmap\">\n    {\n\t\t\"imports\": {\n\t\t\t\"three\": \"../../../three.js/build/three.module.js\",\n            \"three/addons/\": \"../../../three.js/examples/jsm/\"\n\t\t}\n\t}\n<\/script>\n<script  type=\"module\">\nimport { Octree } from 'three/addons/math/Octree.js';\n<\/script>\n\n\n\n# 生成八叉树.fromGraphNode()\n\n实例化一个八叉树对象。\n\nconst worldOctree = new Octree();\n\n\n.fromGraphNode()的参数是模型对象，比如一个mesh，或者多个mesh构成的层级模型。\n\nconst gltf = await loader.loadAsync(\"../地形.glb\");\nworldOctree.fromGraphNode(gltf.scene);\n\n\n执行.fromGraphNode()会对模型进行分割，分割为一个一个的小的长方体空间，构成一个八叉树。\n\n\n\n执行.fromGraphNode()会把一个3D模型，分割为8个子空间，每个子空间都包含对应的三角形或者说顶点数据，每个子空间还可以继续分割。\n\n具体分割规则非常复杂，不要求掌握，如果你有兴趣可以阅读Octree.js的源码，比如Octree.js会根据三角形数量决定是否分割一个子空间，比如一个子空间包含的三角形数量小于等于8个就不在分割，当然你也可以修改规则，作为初学者，也不要求记住，先有个印象就行。\n\nOctree.js文件中部分源码截取\n\nif ( len > 8 && level < 16 ) {\n\tsubTrees[ i ].split( level + 1 );\n}\n\n\n\n# 浏览器控制台打印八叉树\n\n浏览器控制台打印八叉树，查看分割的结果(不要求掌握,过一遍即可)。\n\nconsole.log('查看八叉树结构', worldOctree);\n\n\n * .box属性是包围盒Box3，描述当前分割的子空间位置和尺寸\n * .subTrees属性表示八叉树的子节点，类似threejs层级模型的children属性\n * 查看叶子结点(最后一层没有子对象的节点).triangles属性,可以看到包含的三角形数据\n\n\n# OctreeHelper可视化八叉树\n\nThree.js在目录/examples/jsm/helpers/下提供了一个可视化八叉树相关的扩展库OctreeHelper.js。\n\nimport { OctreeHelper } from 'three/examples/jsm/helpers/OctreeHelper.js';\n\n\n//课程案例源码里面配置的路径\nimport { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';\n\n\nconst helper = new OctreeHelper( worldOctree );\nscene.add( helper );\n\n\n\n\n",normalizedContent:"# 八叉树octree扩展库介绍\n\n本章节学习八叉树octree目的，是为了实现漫游的碰撞检测功能，比如遇到装障碍物被挡住、比如爬坡和上楼梯。\n\n你可以打开本节课的工厂漫游案例体验测试。\n\n本节课内容会比较多，不过大部分只是作为了解和扩展学习，你只需要你掌握下面3行代码即可。\n\n// 引入八叉树扩展库\nimport { octree } from 'three/examples/jsm/math/octree.js';\nconst worldoctree = new octree();\n// 分割模型，生成八叉树节点\nworldoctree.fromgraphnode(模型对象);\n\n\n\n# 八叉树基本原理解释\n\n下面给大家简单介绍下八叉树概念，初学者不要求记住具体细节，先有个印象就行。\n\n通过前面基础内容2.3. 网格模型(三角形概念)的学习，大家都知道网格模型mesh本质是由三角形构成，三角形由顶点构成，这些三角形和自己的顶点数据分布在3d空间中。\n\nconst geometry = new three.boxgeometry(50,50,50);\nconsole.log('顶点位置数据',geometry.attributes.position);\nconsole.log('三角形顶点索引数据',geometry.index);\n\n\n\n\n如果整个3d模型用一个长方体空间来表示，在三维空间xyz三个方向，都分割一次，这样就可以得到8个小的长方体子空间。\n\n\n\n一个3d模型的三角形(顶点)分布在三维空间中，如果你用一个长方体来表示整个3d场景，当你分割为8个子空间的时候，每个子空间可以包含对应的三角形(顶点)数据。\n\n每个子空间如果三角形(顶点)数量比较多，还可以继续分割，具体分割规则，你可以自定义，比如你可以规定，一个子空间包含的三角形数量只要大于8个就继续分割。这样一个个子空间可以构成一个树结构，整体来看，每个节点，分叉出来八个子节点。\n\n\n\n\n# 项目引入octree.js\n\nthree.js在目录/examples/jsm/math/下提供了一个八叉树相关的扩展库octree.js。 npm安装threejs情况下，octree.js扩展库引入路径。\n\n// 引入/examples/jsm/math/目录下八叉树扩展库\nimport { octree } from 'three/examples/jsm/math/octree.js';\n\n\n在.html文件中，你也可以配置为其它任意路径引入方式\n\n<script type=\"importmap\">\n    {\n\t\t\"imports\": {\n\t\t\t\"three\": \"../../../three.js/build/three.module.js\",\n            \"three/addons/\": \"../../../three.js/examples/jsm/\"\n\t\t}\n\t}\n<\/script>\n<script  type=\"module\">\nimport { octree } from 'three/addons/math/octree.js';\n<\/script>\n\n\n\n# 生成八叉树.fromgraphnode()\n\n实例化一个八叉树对象。\n\nconst worldoctree = new octree();\n\n\n.fromgraphnode()的参数是模型对象，比如一个mesh，或者多个mesh构成的层级模型。\n\nconst gltf = await loader.loadasync(\"../地形.glb\");\nworldoctree.fromgraphnode(gltf.scene);\n\n\n执行.fromgraphnode()会对模型进行分割，分割为一个一个的小的长方体空间，构成一个八叉树。\n\n\n\n执行.fromgraphnode()会把一个3d模型，分割为8个子空间，每个子空间都包含对应的三角形或者说顶点数据，每个子空间还可以继续分割。\n\n具体分割规则非常复杂，不要求掌握，如果你有兴趣可以阅读octree.js的源码，比如octree.js会根据三角形数量决定是否分割一个子空间，比如一个子空间包含的三角形数量小于等于8个就不在分割，当然你也可以修改规则，作为初学者，也不要求记住，先有个印象就行。\n\noctree.js文件中部分源码截取\n\nif ( len > 8 && level < 16 ) {\n\tsubtrees[ i ].split( level + 1 );\n}\n\n\n\n# 浏览器控制台打印八叉树\n\n浏览器控制台打印八叉树，查看分割的结果(不要求掌握,过一遍即可)。\n\nconsole.log('查看八叉树结构', worldoctree);\n\n\n * .box属性是包围盒box3，描述当前分割的子空间位置和尺寸\n * .subtrees属性表示八叉树的子节点，类似threejs层级模型的children属性\n * 查看叶子结点(最后一层没有子对象的节点).triangles属性,可以看到包含的三角形数据\n\n\n# octreehelper可视化八叉树\n\nthree.js在目录/examples/jsm/helpers/下提供了一个可视化八叉树相关的扩展库octreehelper.js。\n\nimport { octreehelper } from 'three/examples/jsm/helpers/octreehelper.js';\n\n\n//课程案例源码里面配置的路径\nimport { octreehelper } from 'three/addons/helpers/octreehelper.js';\n\n\nconst helper = new octreehelper( worldoctree );\nscene.add( helper );\n\n\n\n\n",charsets:{cjk:!0}},{title:"2. 八叉树与胶囊Capsule交叉计算",frontmatter:{title:"2. 八叉树与胶囊Capsule交叉计算",date:"2023-09-28T23:22:20.000Z",permalink:"/pages/f92da6/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/09.9.%E6%BC%AB%E6%B8%B8-%E5%85%AB%E5%8F%89%E6%A0%91%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B/02.%E5%85%AB%E5%8F%89%E6%A0%91%E4%B8%8E%E8%83%B6%E5%9B%8ACapsule%E4%BA%A4%E5%8F%89%E8%AE%A1%E7%AE%97.html",relativePath:"02.Three.js进阶教程/09.9.漫游-八叉树碰撞检测/02.八叉树与胶囊Capsule交叉计算.md",key:"v-ec6f9786",path:"/pages/f92da6/",headers:[{level:3,title:"项目引入胶囊碰撞体Capsule.js",slug:"项目引入胶囊碰撞体capsule-js",normalizedTitle:"项目引入胶囊碰撞体capsule.js",charIndex:154},{level:3,title:"创建胶囊几何体",slug:"创建胶囊几何体",normalizedTitle:"创建胶囊几何体",charIndex:461},{level:3,title:"练习：Mesh可视化上面胶囊几何体",slug:"练习-mesh可视化上面胶囊几何体",normalizedTitle:"练习：mesh可视化上面胶囊几何体",charIndex:732},{level:3,title:"平移胶囊几何体",slug:"平移胶囊几何体",normalizedTitle:"平移胶囊几何体",charIndex:1727},{level:3,title:"交叉计算",slug:"交叉计算",normalizedTitle:"交叉计算",charIndex:15},{level:3,title:"胶囊放在斜面上",slug:"胶囊放在斜面上",normalizedTitle:"胶囊放在斜面上",charIndex:2322},{level:3,title:"根据交叉碰撞数据，平移碰撞体",slug:"根据交叉碰撞数据-平移碰撞体",normalizedTitle:"根据交叉碰撞数据，平移碰撞体",charIndex:2500},{level:3,title:"胶囊与楼梯交叉",slug:"胶囊与楼梯交叉",normalizedTitle:"胶囊与楼梯交叉",charIndex:2817},{level:3,title:"胶囊向上平移，与地面没有接触，查看交叉计算结果",slug:"胶囊向上平移-与地面没有接触-查看交叉计算结果",normalizedTitle:"胶囊向上平移，与地面没有接触，查看交叉计算结果",charIndex:3050}],headersStr:"项目引入胶囊碰撞体Capsule.js 创建胶囊几何体 练习：Mesh可视化上面胶囊几何体 平移胶囊几何体 交叉计算 胶囊放在斜面上 根据交叉碰撞数据，平移碰撞体 胶囊与楼梯交叉 胶囊向上平移，与地面没有接触，查看交叉计算结果",content:"# 八叉树与胶囊Capsule交叉计算\n\nCapsule表示胶囊形状的几何体，具体说就是上面一个半球、中间一个圆柱、下面一个半球拼接构成的胶囊形状几何体。\n\n下面给大家讲解胶囊形状几何体apsule与八叉树表示的3D模型进行交叉计算，你可以类比以前的射线交叉计算，虽然不同，都是都是交叉相关的计算。\n\n\n# 项目引入胶囊碰撞体Capsule.js\n\nThree.js在目录/examples/jsm/math/下提供了一个胶囊形状的几何体Capsule.js。\n\nnpm安装threejs情况下，Capsule.js扩展库引入路径。\n\n// 引入/examples/jsm/math/目录下胶囊扩展库Capsule.js\nimport { Capsule } from 'three/examples/jsm/math/Capsule.js';\n\n\n本课程案例源码.html里面自定义了新的路径。\n\nimport { Capsule } from 'three/addons/math/Capsule.js';\n\n\n\n# 创建胶囊几何体\n\n创建胶囊几何体：让胶囊底部半球与y=0的平面刚好相切即可。\n\nconst R = 0.4;//胶囊半径\nconst H = 1.7;//胶囊总高度\nconst start = new THREE.Vector3(0, R, 0);//底部半球球心坐标\nconst end = new THREE.Vector3(0, H - R, 0);//顶部半球球心坐标\nconst capsule = new Capsule(start, end, R);\nconsole.log('capsule', capsule);\n\n\n\n# 练习：Mesh可视化上面胶囊几何体\n\n// 可视化胶囊几何体\nconst capsuleHelper = CapsuleHelper(R, H);\nmodel.add(capsuleHelper);\n\n\nfunction CapsuleHelper(R, H) {\n    const group = new THREE.Group();\n    const material = new THREE.MeshLambertMaterial({\n        color: 0x00ffff,\n        transparent: true,\n        opacity: 0.5,\n    });\n    // 底部半球\n    const geometry = new THREE.SphereGeometry(R, 25, 25, 0, 2 * Math.PI, 0, Math.PI / 2);\n    geometry.rotateX(Math.PI);\n    const mesh = new THREE.Mesh(geometry, material);\n    mesh.position.y = R;\n    group.add(mesh)\n    // 顶部半球\n    const geometry2 = new THREE.SphereGeometry(R, 25, 25, 0, 2 * Math.PI, 0, Math.PI / 2);\n    const mesh2 = new THREE.Mesh(geometry2, material);\n    mesh2.position.set(0, H - R, 0)\n    group.add(mesh2)\n    // 中间圆柱\n    const h = H - 2 * R\n    const geometry3 = new THREE.CylinderGeometry(R, R, h,32,1,true);\n    geometry3.translate(0, h / 2+R,0)\n    const mesh3 = new THREE.Mesh(geometry3, material);\n    group.add(mesh3)\n    return group;\n}\n\n\n\n# 平移胶囊几何体\n\n平移胶囊碰撞体,使底部半球位于y=0的平面以下。\n\ncapsule.translate(new THREE.Vector3(0, -R, 0));\n\n\n可视化胶囊的模型对象同步平移\n\ncapsuleHelper.position.y += -R;\n\n\n换一种平移方式\n\ncapsuleHelper.position.copy(capsule.start)\ncapsuleHelper.position.y -= R;\n\n\n\n# 交叉计算\n\nOctree.capsuleIntersect(capsule)可以计算Octree表示的3D模型与胶囊几何体capsule是否重合交叉，如果有重合交叉，返回交叉相关的信息，具体说就是在某个方向上交叉重合的深度是多少。\n\n// 碰撞检测：几何体交叉计算\n// Octree表示的3D模型和Capsule交叉计算\nconst result = worldOctree.capsuleIntersect(capsule);\nconsole.log('碰撞检测结果', result);\n\n\n * .depth交叉重合的深度\n * .normal深度对应的方向\n\n先与八叉树里面的包围盒子节点进行交叉计算，在与相交叉的包围盒包含的三角形进行交叉计算。借助八叉树，相比较，for循环所有模型所有三角形分别进行交叉计算，更节约时间。\n\n\n# 胶囊放在斜面上\n\n平移胶囊放在斜面上，查看交叉重合计算结果。\n\ncapsule.translate(new THREE.Vector3(0, 0, -3*H));\ncapsuleHelper.position.z += -3 * H;\n\n\n你可以看到交叉方向不再是垂直于平面\n\n * .depth交叉重合的深度\n * .normal深度对应的方向\n\n\n# 根据交叉碰撞数据，平移碰撞体\n\n根据交叉碰撞数据，平移碰撞体，让胶囊碰撞体不在于八叉树对应模型重合。\n\n * .depth交叉重合的深度\n * .normal深度对应的方向\n\n总结：.normal数据的特点就是让胶囊沿着.normal方向，平移.depth距离，就能刚好确保交叉重合深度为0\n\n// 根据碰撞结果平移胶囊碰撞体，使交叉重合深度为0\ncapsule.translate(result.normal.multiplyScalar(result.depth));\ncapsuleHelper.position.copy(capsule.start);\ncapsuleHelper.position.y -= R;\n\n\n\n# 胶囊与楼梯交叉\n\n// 根据碰撞结果平移胶囊碰撞体，使交叉重合深度为0\ncapsule.translate(result.normal.multiplyScalar(result.depth));\ncapsuleHelper.position.copy(capsule.start);\ncapsuleHelper.position.y -= R;\n\n\n平移后，不在于楼梯交叉，上升偏离地面了(如果运动起来，这个特点可以让胶囊产生上楼梯的效果，下节课会讲解)\n\n\n# 胶囊向上平移，与地面没有接触，查看交叉计算结果\n\n胶囊向上平移，与地面没有接触\n\n// 胶囊向上平移，与地面不交叉情况，查看计算结果\ncapsule.translate(new THREE.Vector3(0, R, 0));\ncapsuleHelper.position.y += R;\n\n\n交叉计算结果返回值false\n\nconst result = worldOctree.capsuleIntersect(capsule);\nconsole.log('碰撞检测结果', result);\n",normalizedContent:"# 八叉树与胶囊capsule交叉计算\n\ncapsule表示胶囊形状的几何体，具体说就是上面一个半球、中间一个圆柱、下面一个半球拼接构成的胶囊形状几何体。\n\n下面给大家讲解胶囊形状几何体apsule与八叉树表示的3d模型进行交叉计算，你可以类比以前的射线交叉计算，虽然不同，都是都是交叉相关的计算。\n\n\n# 项目引入胶囊碰撞体capsule.js\n\nthree.js在目录/examples/jsm/math/下提供了一个胶囊形状的几何体capsule.js。\n\nnpm安装threejs情况下，capsule.js扩展库引入路径。\n\n// 引入/examples/jsm/math/目录下胶囊扩展库capsule.js\nimport { capsule } from 'three/examples/jsm/math/capsule.js';\n\n\n本课程案例源码.html里面自定义了新的路径。\n\nimport { capsule } from 'three/addons/math/capsule.js';\n\n\n\n# 创建胶囊几何体\n\n创建胶囊几何体：让胶囊底部半球与y=0的平面刚好相切即可。\n\nconst r = 0.4;//胶囊半径\nconst h = 1.7;//胶囊总高度\nconst start = new three.vector3(0, r, 0);//底部半球球心坐标\nconst end = new three.vector3(0, h - r, 0);//顶部半球球心坐标\nconst capsule = new capsule(start, end, r);\nconsole.log('capsule', capsule);\n\n\n\n# 练习：mesh可视化上面胶囊几何体\n\n// 可视化胶囊几何体\nconst capsulehelper = capsulehelper(r, h);\nmodel.add(capsulehelper);\n\n\nfunction capsulehelper(r, h) {\n    const group = new three.group();\n    const material = new three.meshlambertmaterial({\n        color: 0x00ffff,\n        transparent: true,\n        opacity: 0.5,\n    });\n    // 底部半球\n    const geometry = new three.spheregeometry(r, 25, 25, 0, 2 * math.pi, 0, math.pi / 2);\n    geometry.rotatex(math.pi);\n    const mesh = new three.mesh(geometry, material);\n    mesh.position.y = r;\n    group.add(mesh)\n    // 顶部半球\n    const geometry2 = new three.spheregeometry(r, 25, 25, 0, 2 * math.pi, 0, math.pi / 2);\n    const mesh2 = new three.mesh(geometry2, material);\n    mesh2.position.set(0, h - r, 0)\n    group.add(mesh2)\n    // 中间圆柱\n    const h = h - 2 * r\n    const geometry3 = new three.cylindergeometry(r, r, h,32,1,true);\n    geometry3.translate(0, h / 2+r,0)\n    const mesh3 = new three.mesh(geometry3, material);\n    group.add(mesh3)\n    return group;\n}\n\n\n\n# 平移胶囊几何体\n\n平移胶囊碰撞体,使底部半球位于y=0的平面以下。\n\ncapsule.translate(new three.vector3(0, -r, 0));\n\n\n可视化胶囊的模型对象同步平移\n\ncapsulehelper.position.y += -r;\n\n\n换一种平移方式\n\ncapsulehelper.position.copy(capsule.start)\ncapsulehelper.position.y -= r;\n\n\n\n# 交叉计算\n\noctree.capsuleintersect(capsule)可以计算octree表示的3d模型与胶囊几何体capsule是否重合交叉，如果有重合交叉，返回交叉相关的信息，具体说就是在某个方向上交叉重合的深度是多少。\n\n// 碰撞检测：几何体交叉计算\n// octree表示的3d模型和capsule交叉计算\nconst result = worldoctree.capsuleintersect(capsule);\nconsole.log('碰撞检测结果', result);\n\n\n * .depth交叉重合的深度\n * .normal深度对应的方向\n\n先与八叉树里面的包围盒子节点进行交叉计算，在与相交叉的包围盒包含的三角形进行交叉计算。借助八叉树，相比较，for循环所有模型所有三角形分别进行交叉计算，更节约时间。\n\n\n# 胶囊放在斜面上\n\n平移胶囊放在斜面上，查看交叉重合计算结果。\n\ncapsule.translate(new three.vector3(0, 0, -3*h));\ncapsulehelper.position.z += -3 * h;\n\n\n你可以看到交叉方向不再是垂直于平面\n\n * .depth交叉重合的深度\n * .normal深度对应的方向\n\n\n# 根据交叉碰撞数据，平移碰撞体\n\n根据交叉碰撞数据，平移碰撞体，让胶囊碰撞体不在于八叉树对应模型重合。\n\n * .depth交叉重合的深度\n * .normal深度对应的方向\n\n总结：.normal数据的特点就是让胶囊沿着.normal方向，平移.depth距离，就能刚好确保交叉重合深度为0\n\n// 根据碰撞结果平移胶囊碰撞体，使交叉重合深度为0\ncapsule.translate(result.normal.multiplyscalar(result.depth));\ncapsulehelper.position.copy(capsule.start);\ncapsulehelper.position.y -= r;\n\n\n\n# 胶囊与楼梯交叉\n\n// 根据碰撞结果平移胶囊碰撞体，使交叉重合深度为0\ncapsule.translate(result.normal.multiplyscalar(result.depth));\ncapsulehelper.position.copy(capsule.start);\ncapsulehelper.position.y -= r;\n\n\n平移后，不在于楼梯交叉，上升偏离地面了(如果运动起来，这个特点可以让胶囊产生上楼梯的效果，下节课会讲解)\n\n\n# 胶囊向上平移，与地面没有接触，查看交叉计算结果\n\n胶囊向上平移，与地面没有接触\n\n// 胶囊向上平移，与地面不交叉情况，查看计算结果\ncapsule.translate(new three.vector3(0, r, 0));\ncapsulehelper.position.y += r;\n\n\n交叉计算结果返回值false\n\nconst result = worldoctree.capsuleintersect(capsule);\nconsole.log('碰撞检测结果', result);\n",charsets:{cjk:!0}},{title:"2. CannonJS自由落体计算",frontmatter:{title:"2. CannonJS自由落体计算",date:"2023-10-01T14:08:35.000Z",permalink:"/pages/e80014/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/02.CannonJS%E8%87%AA%E7%94%B1%E8%90%BD%E4%BD%93%E8%AE%A1%E7%AE%97.html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/02.CannonJS自由落体计算.md",key:"v-f5e61cc8",path:"/pages/e80014/",headers:[{level:3,title:"物理引擎概念解释",slug:"物理引擎概念解释",normalizedTitle:"物理引擎概念解释",charIndex:80},{level:3,title:"引入物理引擎cannon-es",slug:"引入物理引擎cannon-es",normalizedTitle:"引入物理引擎cannon-es",charIndex:224},{level:3,title:"碰撞体Body",slug:"碰撞体body",normalizedTitle:"碰撞体body",charIndex:313},{level:3,title:"设置Body的物理属性",slug:"设置body的物理属性",normalizedTitle:"设置body的物理属性",charIndex:461},{level:3,title:"碰撞体Body几何形状",slug:"碰撞体body几何形状",normalizedTitle:"碰撞体body几何形状",charIndex:733},{level:3,title:"CANNON.World创建一个物理世界",slug:"cannon-world创建一个物理世界",normalizedTitle:"cannon.world创建一个物理世界",charIndex:1121},{level:3,title:".addBody()把物体添加到物理世界",slug:"addbody-把物体添加到物理世界",normalizedTitle:".addbody()把物体添加到物理世界",charIndex:1457},{level:3,title:"world.step()物理世界更新计算",slug:"world-step-物理世界更新计算",normalizedTitle:"world.step()物理世界更新计算",charIndex:1583},{level:3,title:"浏览器控制台查看计算结果",slug:"浏览器控制台查看计算结果",normalizedTitle:"浏览器控制台查看计算结果",charIndex:1880},{level:3,title:"浏览器控制辅助开发",slug:"浏览器控制辅助开发",normalizedTitle:"浏览器控制辅助开发",charIndex:2150},{level:3,title:"语法总结：访问或设置Body属性",slug:"语法总结-访问或设置body属性",normalizedTitle:"语法总结：访问或设置body属性",charIndex:2574}],headersStr:"物理引擎概念解释 引入物理引擎cannon-es 碰撞体Body 设置Body的物理属性 碰撞体Body几何形状 CANNON.World创建一个物理世界 .addBody()把物体添加到物理世界 world.step()物理世界更新计算 浏览器控制台查看计算结果 浏览器控制辅助开发 语法总结：访问或设置Body属性",content:"# CannonJS自由落体计算\n\n正式使用物理引擎CannonJS与Threejs结合之前，先用CannonJS模拟一个小球自由落体运动的物理计算。\n\n\n# 物理引擎概念解释\n\n所谓物理引擎，就是通过代码模拟物理世界。举个简单例子，比如你初高中都学过物理学，其中力、速度、加速度、位移都是比较常见的物理量，咱们通过CannonJS等物理引擎，都可以辅助你计算生活中物体的速度、位移，比如计算一个小球在地球重力的作用下，下落的速度和位置。\n\n\n# 引入物理引擎cannon-es\n\n上节课给大家讲解过，怎么引入物理引擎cannon-es。\n\nimport * as CANNON from \"cannon-es\";\n\n\n\n# 碰撞体Body\n\n通过CANNON.Body类，可以创建一个用于物体物理模拟计算，比如用Body表示一个球、一个箱子、一张桌子，你可以计算Body的位置、速度等物理量。\n\n你可以也把Body称为碰撞体collider。\n\nconst body = new CANNON.Body();\n\n\n\n# 设置Body的物理属性\n\n设置Body的一些物理属性，比如质量mass\n\nconst body = new CANNON.Body({\n    mass: 0.3, // 碰撞体质量0.3kg\n});\n\n\n设置物体body的位置，CannonJS的三维向量Vec3和threejs名称不同，不过使用方式相似。\n\nconst body = new CANNON.Body({\n    mass: 0.3,\n     // 碰撞体的三维空间中位置\n    position: new CANNON.Vec3(0, 100, 0)\n});\n\n\n\n# 碰撞体Body几何形状\n\n第一次接触Body，你可以类比threejs的Mesh去联想记忆，网格模型表示一个物体，需要通过几何体Geometry定义Mesh的几何外形，对于Body同样道理，你需要设置物体Body的几何形状。\n\nCannonJS定义几何体形状的API有很多种，比如比如长方体Box、球体Sphere等等，本节课先给大家介绍球体Sphere。\n\n// 1m半径球体\nconst bodyShape = new CANNON.Sphere(1);\n// 可以把Body称为碰撞体,用来模拟生活中的物体\nconst body = new CANNON.Body({\n    mass: 0.3, \n    position: new CANNON.Vec3(0, 100, 0),\n    shape: bodyShape,//碰撞体的几何体形状\n});\n\n\n\n# CANNON.World创建一个物理世界\n\n通过CANNON.World类创建一个物理世界。\n\n// CANNON.World创建物理世界对象\nconst world = new CANNON.World();\n\n\n定义物理世界的物理属性，比如设置重力加速度。\n\n重力加速度的属性gravity类似body的位置，是一个三维向量Vec3。\n\n重力加速度x、y、z分量值，实际开发根据自己项目和坐标系设置即可，咱们假设小球所在的场景，y轴竖直向上，这样重力就速度就是y方向负方向。\n\nconst world = new CANNON.World();\n// 设置物理世界重力加速度\nworld.gravity.set(0, -9.8, 0); //单位：m/s²\n\n\n\n# .addBody()把物体添加到物理世界\n\n物理球body添加到物理世界中，这样body就会受到物理世界加速度的影响World。\n\nconst world = new CANNON.World();\nworld.addBody(body);\n\n\n\n# world.step()物理世界更新计算\n\n最后不要忘记周期性执行world.step()方法，world.step()方法第一个参数表示固定时间步长，一般可以设置为1/60秒，用于近似计算。\n\nfunction render() {\n    world.step(1/60);//更新物理计算\n    requestAnimationFrame(render);\n}\nrender()\n\n\n//固定的时间步长1/60秒\nconst fixedTimeStep = 1/60;\nfunction render() {\n    world.step(fixedTimeStep);\n}\n\n\n\n# 浏览器控制台查看计算结果\n\n你可以查看物体对象body的位置.position、速度.velocity属性。\n\nfunction render() {\n    console.log('球位置', body.position);\n    console.log('球速度', body.velocity);\n    console.log('y方向球位置', body.position.y);\n    world.step(1/60);//更新物理计算\n    requestAnimationFrame(render);\n}\n\n\n\n# 浏览器控制辅助开发\n\n除了查看文档，你还可以通过浏览器控制台，查看CannonJS某个类的属性或方法。\n\nBody具有位置.position、重量.mass、几何形状.shapes等属性\n\nconst body = new CANNON.Body();\nconsole.log('body', body);\n\n\nconst body = new CANNON.Body({\n    mass: 0.3, \n    position: new CANNON.Vec3(0, 100, 0),\n    shape: new CANNON.Sphere(1),\n});\n\n\n比如body.position位置属性的属性值是三维向量Vec3，Vec3具有x、y、z属性和set等多个方法。\n\nconst body = new CANNON.Body();\nconsole.log('body.position', body.position);\n\n\n\n# 语法总结：访问或设置Body属性\n\n通过函数选项设置body对象\n\nconst body = new CANNON.Body({\n    mass: 0.3, \n    position: new CANNON.Vec3(0, 100, 0),\n    shape: new CANNON.Sphere(0.1),\n});\n\n\n部分属性也可以直接访问设置。\n\nconst body = new CANNON.Body();\nbody.mass = 0.3;\nbody.position = new CANNON.Vec3(0, 100, 0);\n\n\nbody没有.shape属性，而是.shapes属性，Body类提供了方法.addShape()设置几何体，执行.addShape()方法会改变.shapes属性。\n\nconst body = new CANNON.Body();\nbody.addShape(new CANNON.Sphere(1));\n",normalizedContent:"# cannonjs自由落体计算\n\n正式使用物理引擎cannonjs与threejs结合之前，先用cannonjs模拟一个小球自由落体运动的物理计算。\n\n\n# 物理引擎概念解释\n\n所谓物理引擎，就是通过代码模拟物理世界。举个简单例子，比如你初高中都学过物理学，其中力、速度、加速度、位移都是比较常见的物理量，咱们通过cannonjs等物理引擎，都可以辅助你计算生活中物体的速度、位移，比如计算一个小球在地球重力的作用下，下落的速度和位置。\n\n\n# 引入物理引擎cannon-es\n\n上节课给大家讲解过，怎么引入物理引擎cannon-es。\n\nimport * as cannon from \"cannon-es\";\n\n\n\n# 碰撞体body\n\n通过cannon.body类，可以创建一个用于物体物理模拟计算，比如用body表示一个球、一个箱子、一张桌子，你可以计算body的位置、速度等物理量。\n\n你可以也把body称为碰撞体collider。\n\nconst body = new cannon.body();\n\n\n\n# 设置body的物理属性\n\n设置body的一些物理属性，比如质量mass\n\nconst body = new cannon.body({\n    mass: 0.3, // 碰撞体质量0.3kg\n});\n\n\n设置物体body的位置，cannonjs的三维向量vec3和threejs名称不同，不过使用方式相似。\n\nconst body = new cannon.body({\n    mass: 0.3,\n     // 碰撞体的三维空间中位置\n    position: new cannon.vec3(0, 100, 0)\n});\n\n\n\n# 碰撞体body几何形状\n\n第一次接触body，你可以类比threejs的mesh去联想记忆，网格模型表示一个物体，需要通过几何体geometry定义mesh的几何外形，对于body同样道理，你需要设置物体body的几何形状。\n\ncannonjs定义几何体形状的api有很多种，比如比如长方体box、球体sphere等等，本节课先给大家介绍球体sphere。\n\n// 1m半径球体\nconst bodyshape = new cannon.sphere(1);\n// 可以把body称为碰撞体,用来模拟生活中的物体\nconst body = new cannon.body({\n    mass: 0.3, \n    position: new cannon.vec3(0, 100, 0),\n    shape: bodyshape,//碰撞体的几何体形状\n});\n\n\n\n# cannon.world创建一个物理世界\n\n通过cannon.world类创建一个物理世界。\n\n// cannon.world创建物理世界对象\nconst world = new cannon.world();\n\n\n定义物理世界的物理属性，比如设置重力加速度。\n\n重力加速度的属性gravity类似body的位置，是一个三维向量vec3。\n\n重力加速度x、y、z分量值，实际开发根据自己项目和坐标系设置即可，咱们假设小球所在的场景，y轴竖直向上，这样重力就速度就是y方向负方向。\n\nconst world = new cannon.world();\n// 设置物理世界重力加速度\nworld.gravity.set(0, -9.8, 0); //单位：m/s²\n\n\n\n# .addbody()把物体添加到物理世界\n\n物理球body添加到物理世界中，这样body就会受到物理世界加速度的影响world。\n\nconst world = new cannon.world();\nworld.addbody(body);\n\n\n\n# world.step()物理世界更新计算\n\n最后不要忘记周期性执行world.step()方法，world.step()方法第一个参数表示固定时间步长，一般可以设置为1/60秒，用于近似计算。\n\nfunction render() {\n    world.step(1/60);//更新物理计算\n    requestanimationframe(render);\n}\nrender()\n\n\n//固定的时间步长1/60秒\nconst fixedtimestep = 1/60;\nfunction render() {\n    world.step(fixedtimestep);\n}\n\n\n\n# 浏览器控制台查看计算结果\n\n你可以查看物体对象body的位置.position、速度.velocity属性。\n\nfunction render() {\n    console.log('球位置', body.position);\n    console.log('球速度', body.velocity);\n    console.log('y方向球位置', body.position.y);\n    world.step(1/60);//更新物理计算\n    requestanimationframe(render);\n}\n\n\n\n# 浏览器控制辅助开发\n\n除了查看文档，你还可以通过浏览器控制台，查看cannonjs某个类的属性或方法。\n\nbody具有位置.position、重量.mass、几何形状.shapes等属性\n\nconst body = new cannon.body();\nconsole.log('body', body);\n\n\nconst body = new cannon.body({\n    mass: 0.3, \n    position: new cannon.vec3(0, 100, 0),\n    shape: new cannon.sphere(1),\n});\n\n\n比如body.position位置属性的属性值是三维向量vec3，vec3具有x、y、z属性和set等多个方法。\n\nconst body = new cannon.body();\nconsole.log('body.position', body.position);\n\n\n\n# 语法总结：访问或设置body属性\n\n通过函数选项设置body对象\n\nconst body = new cannon.body({\n    mass: 0.3, \n    position: new cannon.vec3(0, 100, 0),\n    shape: new cannon.sphere(0.1),\n});\n\n\n部分属性也可以直接访问设置。\n\nconst body = new cannon.body();\nbody.mass = 0.3;\nbody.position = new cannon.vec3(0, 100, 0);\n\n\nbody没有.shape属性，而是.shapes属性，body类提供了方法.addshape()设置几何体，执行.addshape()方法会改变.shapes属性。\n\nconst body = new cannon.body();\nbody.addshape(new cannon.sphere(1));\n",charsets:{cjk:!0}},{title:"1. 物理引擎CannonJS简介和引入",frontmatter:{title:"1. 物理引擎CannonJS简介和引入",date:"2023-09-28T23:23:16.000Z",permalink:"/pages/e48d3c/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/01.%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8ECannonJS%E7%AE%80%E4%BB%8B%E5%92%8C%E5%BC%95%E5%85%A5.html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/01.物理引擎CannonJS简介和引入.md",key:"v-1e2bcf16",path:"/pages/e48d3c/",headers:[{level:3,title:"github资源cannon.js",slug:"github资源cannon-js",normalizedTitle:"github资源cannon.js",charIndex:149},{level:3,title:"github资源cannon-es",slug:"github资源cannon-es",normalizedTitle:"github资源cannon-es",charIndex:370},{level:3,title:"cannon-es安装和引入",slug:"cannon-es安装和引入",normalizedTitle:"cannon-es安装和引入",charIndex:820}],headersStr:"github资源cannon.js github资源cannon-es cannon-es安装和引入",content:'# 物理引擎CannonJS简介和引入\n\nJavaScript物理模拟引擎还是比较多的，比如Ammo.js、Physi.js、Cannon.js，这些引擎虽然语法细节有差异，但是在3D应用中开发思路是相似的。\n\n本课程就以Cannon.js为例给大家讲解three.js和物理引擎的结合。\n\n\n# github资源cannon.js\n\ngithub资源cannon.js：https://github.com/schteppe/cannon.js\n\ncannon.js文档：可以在本地静态服务器打开cannon.js\\docs\\index.html预览Canonjs引擎的文档。\n\ncannon.js案例：cannon.js\\examples\\和\\demos\\目录下可以看到一些cannonjs和three.js结合的一些小例子。\n\n\n# github资源cannon-es\n\ncannon-es对cannon.js进行了重写，补充支持了ES6和Typescript语法。\n\n不过除了es语法版本问题，也要注意一点就是cannon-es也改变了cannon.js部分API写法，这一点提醒大家，你查看别人文档或代码一定注意，别人用的cannon.js还是cannon-es。\n\ngithub资源cannon-es：https://github.com/dreammonkey/cannon-es\n\ncannon-es在线文档：https://pmndrs.github.io/cannon-es/docs/index.html\n\ncannon-es在线案例：https://pmndrs.github.io/cannon-es/\n\ncannon-es案例：cannon-es\\examples\\目录下可以看到一些cannonjs和three.js结合的一些小例子。\n\n本课程使用cannon-es给大家讲解CannonJS的使用。\n\n\n# cannon-es安装和引入\n\n在工程化开发的时候可以通过npm命令行安装cannon.js模块。\n\nnpm install --save cannon-es\n\n\n// 某个API\nimport {World, Vec3} from "cannon-es";\n// 全部API一次性引入\nimport * as CANNON from "cannon-es";\n\n\n咱们课件中是在.html文件中直接引入的cannon-es，实际开发，用上面npm安装方式引入即可。\n\n <script type="importmap">\n    {\n\t\t\t"imports": {\n        \t\t"cannon-es": "../cannon-es/dist/cannon-es.js"\n\t\t\t}\n\t\t}\n\t<\/script>\n  <script type="module">\n    import * as CANNON from \'cannon-es\';\n    // 测试是否引入成功\n    console.log(\'CANNON\', CANNON.World); \n    \n    import { World } from \'cannon-es\';\n    console.log(\'World\', World);\n  <\/script>\n',normalizedContent:'# 物理引擎cannonjs简介和引入\n\njavascript物理模拟引擎还是比较多的，比如ammo.js、physi.js、cannon.js，这些引擎虽然语法细节有差异，但是在3d应用中开发思路是相似的。\n\n本课程就以cannon.js为例给大家讲解three.js和物理引擎的结合。\n\n\n# github资源cannon.js\n\ngithub资源cannon.js：https://github.com/schteppe/cannon.js\n\ncannon.js文档：可以在本地静态服务器打开cannon.js\\docs\\index.html预览canonjs引擎的文档。\n\ncannon.js案例：cannon.js\\examples\\和\\demos\\目录下可以看到一些cannonjs和three.js结合的一些小例子。\n\n\n# github资源cannon-es\n\ncannon-es对cannon.js进行了重写，补充支持了es6和typescript语法。\n\n不过除了es语法版本问题，也要注意一点就是cannon-es也改变了cannon.js部分api写法，这一点提醒大家，你查看别人文档或代码一定注意，别人用的cannon.js还是cannon-es。\n\ngithub资源cannon-es：https://github.com/dreammonkey/cannon-es\n\ncannon-es在线文档：https://pmndrs.github.io/cannon-es/docs/index.html\n\ncannon-es在线案例：https://pmndrs.github.io/cannon-es/\n\ncannon-es案例：cannon-es\\examples\\目录下可以看到一些cannonjs和three.js结合的一些小例子。\n\n本课程使用cannon-es给大家讲解cannonjs的使用。\n\n\n# cannon-es安装和引入\n\n在工程化开发的时候可以通过npm命令行安装cannon.js模块。\n\nnpm install --save cannon-es\n\n\n// 某个api\nimport {world, vec3} from "cannon-es";\n// 全部api一次性引入\nimport * as cannon from "cannon-es";\n\n\n咱们课件中是在.html文件中直接引入的cannon-es，实际开发，用上面npm安装方式引入即可。\n\n <script type="importmap">\n    {\n\t\t\t"imports": {\n        \t\t"cannon-es": "../cannon-es/dist/cannon-es.js"\n\t\t\t}\n\t\t}\n\t<\/script>\n  <script type="module">\n    import * as cannon from \'cannon-es\';\n    // 测试是否引入成功\n    console.log(\'cannon\', cannon.world); \n    \n    import { world } from \'cannon-es\';\n    console.log(\'world\', world);\n  <\/script>\n',charsets:{cjk:!0}},{title:"5. 练习-修改小球参数",frontmatter:{title:"5. 练习-修改小球参数",date:"2023-10-11T20:55:12.000Z",permalink:"/pages/ee7628/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/05.%E7%BB%83%E4%B9%A0-%E4%BF%AE%E6%94%B9%E5%B0%8F%E7%90%83%E5%8F%82%E6%95%B0.html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/05.练习-修改小球参数.md",key:"v-76f03d60",path:"/pages/ee7628/",headers:[{level:3,title:"下落真实感问题",slug:"下落真实感问题",normalizedTitle:"下落真实感问题",charIndex:71},{level:3,title:"修改的参数",slug:"修改的参数",normalizedTitle:"修改的参数",charIndex:393}],headersStr:"下落真实感问题 修改的参数",content:"# 练习-修改小球参数\n\n本节课不讲解新的CannonJS知识点，算是一个练习题，就是修改小球相关参数，更像生活中乒乓球下落的感觉。\n\n\n# 下落真实感问题\n\n生活中大家看到的乒乓球，一般也就是从一两米以内位置下落，咱们上节课直接放到了100m高度，自由下落时间肯定会比较长，你会感觉感觉不太真实，当然你可以把重力加速度增加到特别大，去减少下落时间。\n\n// 设置物理世界重力加速度\n// world.gravity.set(0, -9.8, 0);\nworld.gravity.set(0, -1000, 0);\n\n\n不过一般写CannonJS参数时候，都尽量参考物理世界的规律，重力加速度没必要过于离谱，所以可以使用下面方式，改变小球下落高度和自身尺寸，更加接近生活中的情况。\n\n// 设置物理世界重力加速度\nworld.gravity.set(0, -9.8, 0);\n\n\n\n# 修改的参数\n\n在上节课基础上，重新修改下落高度，对比下落效果差异(原来下来高度比较高，整体观看，会感觉很慢)。\n\n// 物理小球：对应threejs的网格小球\nbody.position.y = 1;\n// 网格小球\nmesh.position.y = 1;\n\n\n小球尺寸修改，和生活乒乓球尺寸相近即可\n\n// 物理小球\nconst body = new CANNON.Body({\n    mass: 0.03,//自由下落，这里重量不影响，是否修改无所谓\n    shape: new CANNON.Sphere(0.02)\n});\n// 网格小球\nconst geometry = new THREE.SphereGeometry(0.02);\n\n\n相机可以距离原点更近一些\n\n//相机\nconst camera = new THREE.PerspectiveCamera(30, width / height, 0.1, 3000);\n// camera.position.set(292, 223, 185);\ncamera.position.set(3,3,3);\n// 网格地面\nconst planeGeometry = new THREE.PlaneGeometry(2, 2);\n",normalizedContent:"# 练习-修改小球参数\n\n本节课不讲解新的cannonjs知识点，算是一个练习题，就是修改小球相关参数，更像生活中乒乓球下落的感觉。\n\n\n# 下落真实感问题\n\n生活中大家看到的乒乓球，一般也就是从一两米以内位置下落，咱们上节课直接放到了100m高度，自由下落时间肯定会比较长，你会感觉感觉不太真实，当然你可以把重力加速度增加到特别大，去减少下落时间。\n\n// 设置物理世界重力加速度\n// world.gravity.set(0, -9.8, 0);\nworld.gravity.set(0, -1000, 0);\n\n\n不过一般写cannonjs参数时候，都尽量参考物理世界的规律，重力加速度没必要过于离谱，所以可以使用下面方式，改变小球下落高度和自身尺寸，更加接近生活中的情况。\n\n// 设置物理世界重力加速度\nworld.gravity.set(0, -9.8, 0);\n\n\n\n# 修改的参数\n\n在上节课基础上，重新修改下落高度，对比下落效果差异(原来下来高度比较高，整体观看，会感觉很慢)。\n\n// 物理小球：对应threejs的网格小球\nbody.position.y = 1;\n// 网格小球\nmesh.position.y = 1;\n\n\n小球尺寸修改，和生活乒乓球尺寸相近即可\n\n// 物理小球\nconst body = new cannon.body({\n    mass: 0.03,//自由下落，这里重量不影响，是否修改无所谓\n    shape: new cannon.sphere(0.02)\n});\n// 网格小球\nconst geometry = new three.spheregeometry(0.02);\n\n\n相机可以距离原点更近一些\n\n//相机\nconst camera = new three.perspectivecamera(30, width / height, 0.1, 3000);\n// camera.position.set(292, 223, 185);\ncamera.position.set(3,3,3);\n// 网格地面\nconst planegeometry = new three.planegeometry(2, 2);\n",charsets:{cjk:!0}},{title:"6. 练习-点按钮重复下落",frontmatter:{title:"6. 练习-点按钮重复下落",date:"2023-10-11T20:55:31.000Z",permalink:"/pages/a5ef46/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/06.%E7%BB%83%E4%B9%A0-%E7%82%B9%E6%8C%89%E9%92%AE%E9%87%8D%E5%A4%8D%E4%B8%8B%E8%90%BD.html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/06.练习-点按钮重复下落.md",key:"v-580c898f",path:"/pages/a5ef46/",headers:[{level:3,title:"回顾原来的知识点",slug:"回顾原来的知识点",normalizedTitle:"回顾原来的知识点",charIndex:64},{level:3,title:"通过按钮控制小球下落",slug:"通过按钮控制小球下落",normalizedTitle:"通过按钮控制小球下落",charIndex:217},{level:3,title:"按钮控制重复下落",slug:"按钮控制重复下落",normalizedTitle:"按钮控制重复下落",charIndex:446}],headersStr:"回顾原来的知识点 通过按钮控制小球下落 按钮控制重复下落",content:"# 练习-点按钮重复下落\n\n大家可以利用前面学习过的知识，做一个简单的练习题，就是通过HTML按钮控制乒乓球重复下落。\n\n\n# 回顾原来的知识点\n\n前面讲解过，物理碰撞体body只有添加到物理世界world中，才会收到物理世界的影响，比如受到重力影响，你可以注释world.addBody(body);代码测试验证。\n\nworld.gravity.set(0, -9.8, 0);\nworld.addBody(body);\n\n\n\n# 通过按钮控制小球下落\n\ndocument.getElementById('test').addEventListener('click', function () {\n    \n})\n\n\n// 点击按钮后，才把物理小球碰撞体body添加到物理世界\ndocument.getElementById('test').addEventListener('click', function () {\n    world.addBody(body);\n})\n\n\n\n# 按钮控制重复下落\n\n点击按钮，body回到下落的初始位置。\n\ndocument.getElementById('test').addEventListener('click', function () {\n    body.position.y = 1;//点击按钮，body回到下落的初始位置\n    world.addBody(body);//添加到物理世界，才开始下落\n})\n\n\n注意body没必要重复添加到物理世界中，声明一个变量标记是否已经添加到物理世界中。\n\nlet addBool = false;//标记body是否已经添加到world中\ndocument.getElementById('test').addEventListener('click', function () {\n    body.position.y = 1;//点击按钮，body回到下落的初始位置\n    if (!addBool){\n        world.addBody(body);//添加到物理世界，才开始下落\n        addBool = true;\n    }\n})\n",normalizedContent:"# 练习-点按钮重复下落\n\n大家可以利用前面学习过的知识，做一个简单的练习题，就是通过html按钮控制乒乓球重复下落。\n\n\n# 回顾原来的知识点\n\n前面讲解过，物理碰撞体body只有添加到物理世界world中，才会收到物理世界的影响，比如受到重力影响，你可以注释world.addbody(body);代码测试验证。\n\nworld.gravity.set(0, -9.8, 0);\nworld.addbody(body);\n\n\n\n# 通过按钮控制小球下落\n\ndocument.getelementbyid('test').addeventlistener('click', function () {\n    \n})\n\n\n// 点击按钮后，才把物理小球碰撞体body添加到物理世界\ndocument.getelementbyid('test').addeventlistener('click', function () {\n    world.addbody(body);\n})\n\n\n\n# 按钮控制重复下落\n\n点击按钮，body回到下落的初始位置。\n\ndocument.getelementbyid('test').addeventlistener('click', function () {\n    body.position.y = 1;//点击按钮，body回到下落的初始位置\n    world.addbody(body);//添加到物理世界，才开始下落\n})\n\n\n注意body没必要重复添加到物理世界中，声明一个变量标记是否已经添加到物理世界中。\n\nlet addbool = false;//标记body是否已经添加到world中\ndocument.getelementbyid('test').addeventlistener('click', function () {\n    body.position.y = 1;//点击按钮，body回到下落的初始位置\n    if (!addbool){\n        world.addbody(body);//添加到物理世界，才开始下落\n        addbool = true;\n    }\n})\n",charsets:{cjk:!0}},{title:"7. CannonJS碰撞事件，碰撞声音",frontmatter:{title:"7. CannonJS碰撞事件，碰撞声音",date:"2023-10-11T20:55:48.000Z",permalink:"/pages/4a6320/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/07.CannonJS%E7%A2%B0%E6%92%9E%E4%BA%8B%E4%BB%B6%EF%BC%8C%E7%A2%B0%E6%92%9E%E5%A3%B0%E9%9F%B3.html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/07.CannonJS碰撞事件，碰撞声音.md",key:"v-0c4a5c5c",path:"/pages/4a6320/",headers:[{level:3,title:"碰撞体Body的碰撞事件collide",slug:"碰撞体body的碰撞事件collide",normalizedTitle:"碰撞体body的碰撞事件collide",charIndex:65},{level:3,title:"碰撞事件的接触属性.contact",slug:"碰撞事件的接触属性-contact",normalizedTitle:"碰撞事件的接触属性.contact",charIndex:334},{level:3,title:"contact.getImpactVelocityAlongNormal()",slug:"contact-getimpactvelocityalongnormal",normalizedTitle:"contact.getimpactvelocityalongnormal()",charIndex:639},{level:3,title:"碰撞声音基本思路",slug:"碰撞声音基本思路",normalizedTitle:"碰撞声音基本思路",charIndex:787},{level:3,title:"加载音频代码",slug:"加载音频代码",normalizedTitle:"加载音频代码",charIndex:1026},{level:3,title:"通过碰撞程度，控制音量大小",slug:"通过碰撞程度-控制音量大小",normalizedTitle:"通过碰撞程度，控制音量大小",charIndex:1381},{level:3,title:"声音资源下载地址",slug:"声音资源下载地址",normalizedTitle:"声音资源下载地址",charIndex:2015}],headersStr:"碰撞体Body的碰撞事件collide 碰撞事件的接触属性.contact contact.getImpactVelocityAlongNormal() 碰撞声音基本思路 加载音频代码 通过碰撞程度，控制音量大小 声音资源下载地址",content:"# CannonJS碰撞事件，碰撞声音\n\n本节课给大家主要讲解CannonJS的碰撞事件，并根据碰撞信息，设置碰撞声音。\n\n\n# 碰撞体Body的碰撞事件collide\n\n浏览器控制台查看碰撞事件的属性\n\nbody.addEventListener('collide', (event) => {\n    console.log('碰撞事件', event);\n})\n\n\n查看碰撞事件的.contact属性,.contact表示当前body与其他碰撞体Body的碰撞信息。\n\nbody.addEventListener('collide', (event) => {\n    console.log('碰撞碰撞信息', event.contact);\n})\n\n\n\n# 碰撞事件的接触属性.contact\n\n当两个碰撞体Body碰撞的时候，会生成碰撞信息，碰撞事件.contact包含内容是body之间的碰撞信息。\n\n属性.contact的值对应CannonJS的一个类ContactEquation，cannon-es对应封装的文件目录\\src\\equations\\ContactEquation.ts。\n\n点击文档地址ContactEquation\n\ncontact.bi和contact.bj两个属性表示发生碰撞的两个碰撞体Body。\n\n * contact.bi: 监控碰撞事件的Body\n * contact.bj: 与contact.bi发生的碰撞的Body\n\n\n# contact.getImpactVelocityAlongNormal()\n\n两个物体在碰撞法线方向上对的相对速度\n\nconst contact = event.contact;\n//获得沿法线的冲击速度\ncontact.getImpactVelocityAlongNormal()\n\n\n\n# 碰撞声音基本思路\n\n提前准备一个乒乓球碰撞地面的录音，然后通过Audio加载音频，当物理小球body与物理地面发生碰撞的时候，播放音频。\n\n// 这里只是简单的思路，后面会详细讲解\nconst audio = new Audio('./碰撞声.wav');\n... \nbody.addEventListener('collide', (event) => {\n    ...\n    // 小球body发生碰撞事件，播放音频\n    audio.play();\n})\n\n\n\n# 加载音频代码\n\n注意浏览器限制，音频首次播放，需要用户交互，不能用audio.play();代码直接播放，所以在碰撞事件播放音频之前，先通过用户点击事件播放音频。\n\nconst audio = new Audio('./碰撞声.wav');\ndocument.getElementById('audio').addEventListener('click', function () {\n    audio.volume = 0;//按钮开启声音时候，设置静音\n    audio.play();\n})\n\n\n碰撞事件触发音频播放\n\nbody.addEventListener('collide', () => {\n    audio.volume = 1;\n    audio.play();\n})\n\n\n\n# 通过碰撞程度，控制音量大小\n\n刚刚讲过contact.getImpactVelocityAlongNormal()可以获取两个物体在碰撞法线方向上对的相对速度。\n\n可以用碰撞相对速度表征碰撞程度，通过碰撞相对速度，控制音量大小。\n\n// 浏览器控制台测试下最大碰撞相对速度\nbody.addEventListener('collide', (event) => {\n    const contact = event.contact;\n    const ImpactV = contact.getImpactVelocityAlongNormal();\n    console.log('ImpactV', ImpactV);\n})\n\n\nbody.addEventListener('collide', (event) => {\n    const contact = event.contact;\n    const ImpactV = contact.getImpactVelocityAlongNormal();\n    // 碰撞越狠，声音越大\n    //4.5比ImpactV最大值吕略微大一点，这样音量范围0~1\n    audio.volume = ImpactV / 4.5;\n    audio.play();\n})\n\n\n当然你也可以用其他函数关系\n\naudio.volume = Math.pow(ImpactV / 4.5,2);\n\n\n\n# 声音资源下载地址\n\nhttps://www.aigei.com/",normalizedContent:"# cannonjs碰撞事件，碰撞声音\n\n本节课给大家主要讲解cannonjs的碰撞事件，并根据碰撞信息，设置碰撞声音。\n\n\n# 碰撞体body的碰撞事件collide\n\n浏览器控制台查看碰撞事件的属性\n\nbody.addeventlistener('collide', (event) => {\n    console.log('碰撞事件', event);\n})\n\n\n查看碰撞事件的.contact属性,.contact表示当前body与其他碰撞体body的碰撞信息。\n\nbody.addeventlistener('collide', (event) => {\n    console.log('碰撞碰撞信息', event.contact);\n})\n\n\n\n# 碰撞事件的接触属性.contact\n\n当两个碰撞体body碰撞的时候，会生成碰撞信息，碰撞事件.contact包含内容是body之间的碰撞信息。\n\n属性.contact的值对应cannonjs的一个类contactequation，cannon-es对应封装的文件目录\\src\\equations\\contactequation.ts。\n\n点击文档地址contactequation\n\ncontact.bi和contact.bj两个属性表示发生碰撞的两个碰撞体body。\n\n * contact.bi: 监控碰撞事件的body\n * contact.bj: 与contact.bi发生的碰撞的body\n\n\n# contact.getimpactvelocityalongnormal()\n\n两个物体在碰撞法线方向上对的相对速度\n\nconst contact = event.contact;\n//获得沿法线的冲击速度\ncontact.getimpactvelocityalongnormal()\n\n\n\n# 碰撞声音基本思路\n\n提前准备一个乒乓球碰撞地面的录音，然后通过audio加载音频，当物理小球body与物理地面发生碰撞的时候，播放音频。\n\n// 这里只是简单的思路，后面会详细讲解\nconst audio = new audio('./碰撞声.wav');\n... \nbody.addeventlistener('collide', (event) => {\n    ...\n    // 小球body发生碰撞事件，播放音频\n    audio.play();\n})\n\n\n\n# 加载音频代码\n\n注意浏览器限制，音频首次播放，需要用户交互，不能用audio.play();代码直接播放，所以在碰撞事件播放音频之前，先通过用户点击事件播放音频。\n\nconst audio = new audio('./碰撞声.wav');\ndocument.getelementbyid('audio').addeventlistener('click', function () {\n    audio.volume = 0;//按钮开启声音时候，设置静音\n    audio.play();\n})\n\n\n碰撞事件触发音频播放\n\nbody.addeventlistener('collide', () => {\n    audio.volume = 1;\n    audio.play();\n})\n\n\n\n# 通过碰撞程度，控制音量大小\n\n刚刚讲过contact.getimpactvelocityalongnormal()可以获取两个物体在碰撞法线方向上对的相对速度。\n\n可以用碰撞相对速度表征碰撞程度，通过碰撞相对速度，控制音量大小。\n\n// 浏览器控制台测试下最大碰撞相对速度\nbody.addeventlistener('collide', (event) => {\n    const contact = event.contact;\n    const impactv = contact.getimpactvelocityalongnormal();\n    console.log('impactv', impactv);\n})\n\n\nbody.addeventlistener('collide', (event) => {\n    const contact = event.contact;\n    const impactv = contact.getimpactvelocityalongnormal();\n    // 碰撞越狠，声音越大\n    //4.5比impactv最大值吕略微大一点，这样音量范围0~1\n    audio.volume = impactv / 4.5;\n    audio.play();\n})\n\n\n当然你也可以用其他函数关系\n\naudio.volume = math.pow(impactv / 4.5,2);\n\n\n\n# 声音资源下载地址\n\nhttps://www.aigei.com/",charsets:{cjk:!0}},{title:"4. CannonJS模拟乒乓球下落反弹",frontmatter:{title:"4. CannonJS模拟乒乓球下落反弹",date:"2023-10-01T16:54:38.000Z",permalink:"/pages/ae695b/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/04.CannonJS%E6%A8%A1%E6%8B%9F%E4%B9%92%E4%B9%93%E7%90%83%E4%B8%8B%E8%90%BD%E5%8F%8D%E5%BC%B9.html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/04.CannonJS模拟乒乓球下落反弹.md",key:"v-25637300",path:"/pages/ae695b/",headers:[{level:3,title:"创建物理地面",slug:"创建物理地面",normalizedTitle:"创建物理地面",charIndex:92},{level:3,title:"设置body材质，并关联",slug:"设置body材质-并关联",normalizedTitle:"设置body材质，并关联",charIndex:478},{level:3,title:"完整代码",slug:"完整代码",normalizedTitle:"完整代码",charIndex:1123}],headersStr:"创建物理地面 设置body材质，并关联 完整代码",content:"# CannonJS模拟乒乓球下落反弹\n\n接着前面小球自由落体的讲解，这节课给物理世界设置一个物理地面，用来阻止小球的下落，同时通过CannonJS模拟乒乓球下落反弹的效果。\n\n\n# 创建物理地面\n\n创建一个物理地面，这样小球碰到地面就不会继续下落。\n\n为了让地面不受重力或其他物体碰撞影响，按照CannonJS的规则，可以把质量设置为0就行。\n\n提醒：创建物理地面Plane姿态角度改变可以参考threej的矩形平面网格模型。\n\n// 物理地面\nconst groundBody = new CANNON.Body({\n    mass: 0, // 质量为0，始终保持静止，不会受到力碰撞或加速度影响\n    shape:new CANNON.Plane()\n});\n// 改变平面默认的方向，法线默认沿着z轴，旋转到平面向上朝着y方向\n//旋转规律类似threejs 平面\ngroundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);\nworld.addBody(groundBody);\n\n\n\n# 设置body材质，并关联\n\n给物理地面、物理小球body分别创建一个材质。\n\nconst sphereMaterial = new CANNON.Material()\n// 物理小球\nconst body = new CANNON.Body({\n    mass: 0.3,//碰撞体质量\n    material:sphereMaterial//碰撞体材质\n});\n// 物理地面\nconst groundMaterial = new CANNON.Material()\nconst groundBody = new CANNON.Body({\n    mass: 0, // 质量为0，始终保持静止，不会受到力碰撞或加速度影响\n    material: groundMaterial,//地面材质\n});\n\n\n通过材质设置物理地面与物理球的碰撞特点，比如碰撞的反弹恢复系数\n\nrestitution的范围一般是0~1之间选择一个值，一般弹性越大restitution的值也大，比如乒乓球相比橡皮泥反弹能力就更强。\n\nconst contactMaterial = new CANNON.ContactMaterial(groundMaterial, sphereMaterial, {\n    restitution: 0.7, //反弹恢复系数\n})\n// 把关联的材质添加到物理世界中\nworld.addContactMaterial(contactMaterial)\n\n\n\n# 完整代码\n\nimport * as THREE from 'three';\nimport {\n    OrbitControls\n} from 'three/addons/controls/OrbitControls.js';\n\n// 引入cannon-es\nimport * as CANNON from 'cannon-es';\n\nconst world = new CANNON.World();\n// 设置物理世界重力加速度\n// world.gravity.set(0, -9.8, 0);\nworld.gravity.set(0, -50, 0);\n\nconst sphereMaterial = new CANNON.Material()\n// 物理小球：对应threejs的网格小球\nconst body = new CANNON.Body({\n    mass: 0.3,//碰撞体质量\n    material: sphereMaterial,//碰撞体材质\n    shape: new CANNON.Sphere(1.5)\n});\n\nbody.position.y = 100;\nworld.addBody(body);\n\n// 物理地面\nconst groundMaterial = new CANNON.Material()\nconst groundBody = new CANNON.Body({\n    mass: 0, // 质量为0，始终保持静止，不会受到力碰撞或加速度影响\n    shape: new CANNON.Plane(),\n    material: groundMaterial,\n});\n// 改变平面默认的方向，法线默认沿着z轴，旋转到平面向上朝着y方向\ngroundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);//旋转规律类似threejs 平面\nworld.addBody(groundBody);\n\n// 设置地面材质和小球材质之间的碰撞反弹恢复系数\nconst contactMaterial = new CANNON.ContactMaterial(groundMaterial, sphereMaterial, {\n    restitution: 0.7, //反弹恢复系数\n})\n// 把关联的材质添加到物理世界中\nworld.addContactMaterial(contactMaterial)\n\n// 网格小球\nconst geometry = new THREE.SphereGeometry(1.5);\nconst material = new THREE.MeshLambertMaterial({\n    color: 0xffff00,\n});\nconst mesh = new THREE.Mesh(geometry, material);\nmesh.position.y = 100;\n\n// 网格地面\nconst planeGeometry = new THREE.PlaneGeometry(200, 200);\nconst texture = new THREE.TextureLoader().load('./瓷砖.jpg');\ntexture.wrapS = THREE.RepeatWrapping;\ntexture.wrapT = THREE.RepeatWrapping;\ntexture.repeat.set(3, 3);\nconst planeMaterial = new THREE.MeshLambertMaterial({\n    color:0x777777,\n    map: texture,\n});\nconst planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);\nplaneMesh.rotateX(-Math.PI / 2);\n\n//场景\nconst scene = new THREE.Scene();\nscene.add(mesh, planeMesh); //模型对象添加到场景中\n\n\n//辅助观察的坐标系\nconst axesHelper = new THREE.AxesHelper(100);\nscene.add(axesHelper);\n\n\n//光源设置\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 1);\ndirectionalLight.position.set(100, 60, 50);\nscene.add(directionalLight);\nconst ambient = new THREE.AmbientLight(0xffffff, 0.4);\nscene.add(ambient);\n\n\n//相机\nconst width = window.innerWidth;\nconst height = window.innerHeight;\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\ncamera.position.set(292, 223, 185);\ncamera.lookAt(0, 0, 0);\n\n// WebGL渲染器设置\nconst renderer = new THREE.WebGLRenderer({\n    antialias: true, //开启优化锯齿\n});\nrenderer.setPixelRatio(window.devicePixelRatio); //防止输出模糊\nrenderer.setSize(width, height);\ndocument.body.appendChild(renderer.domElement);\n\n\nconst clock = new THREE.Clock();\n// 渲染循环\nfunction render() {\n    world.step(1/60);//更新物理计算\n    mesh.position.copy(body.position);// 网格小球与物理小球位置同步\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\nconst controls = new OrbitControls(camera, renderer.domElement);\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n};\n",normalizedContent:"# cannonjs模拟乒乓球下落反弹\n\n接着前面小球自由落体的讲解，这节课给物理世界设置一个物理地面，用来阻止小球的下落，同时通过cannonjs模拟乒乓球下落反弹的效果。\n\n\n# 创建物理地面\n\n创建一个物理地面，这样小球碰到地面就不会继续下落。\n\n为了让地面不受重力或其他物体碰撞影响，按照cannonjs的规则，可以把质量设置为0就行。\n\n提醒：创建物理地面plane姿态角度改变可以参考threej的矩形平面网格模型。\n\n// 物理地面\nconst groundbody = new cannon.body({\n    mass: 0, // 质量为0，始终保持静止，不会受到力碰撞或加速度影响\n    shape:new cannon.plane()\n});\n// 改变平面默认的方向，法线默认沿着z轴，旋转到平面向上朝着y方向\n//旋转规律类似threejs 平面\ngroundbody.quaternion.setfromeuler(-math.pi / 2, 0, 0);\nworld.addbody(groundbody);\n\n\n\n# 设置body材质，并关联\n\n给物理地面、物理小球body分别创建一个材质。\n\nconst spherematerial = new cannon.material()\n// 物理小球\nconst body = new cannon.body({\n    mass: 0.3,//碰撞体质量\n    material:spherematerial//碰撞体材质\n});\n// 物理地面\nconst groundmaterial = new cannon.material()\nconst groundbody = new cannon.body({\n    mass: 0, // 质量为0，始终保持静止，不会受到力碰撞或加速度影响\n    material: groundmaterial,//地面材质\n});\n\n\n通过材质设置物理地面与物理球的碰撞特点，比如碰撞的反弹恢复系数\n\nrestitution的范围一般是0~1之间选择一个值，一般弹性越大restitution的值也大，比如乒乓球相比橡皮泥反弹能力就更强。\n\nconst contactmaterial = new cannon.contactmaterial(groundmaterial, spherematerial, {\n    restitution: 0.7, //反弹恢复系数\n})\n// 把关联的材质添加到物理世界中\nworld.addcontactmaterial(contactmaterial)\n\n\n\n# 完整代码\n\nimport * as three from 'three';\nimport {\n    orbitcontrols\n} from 'three/addons/controls/orbitcontrols.js';\n\n// 引入cannon-es\nimport * as cannon from 'cannon-es';\n\nconst world = new cannon.world();\n// 设置物理世界重力加速度\n// world.gravity.set(0, -9.8, 0);\nworld.gravity.set(0, -50, 0);\n\nconst spherematerial = new cannon.material()\n// 物理小球：对应threejs的网格小球\nconst body = new cannon.body({\n    mass: 0.3,//碰撞体质量\n    material: spherematerial,//碰撞体材质\n    shape: new cannon.sphere(1.5)\n});\n\nbody.position.y = 100;\nworld.addbody(body);\n\n// 物理地面\nconst groundmaterial = new cannon.material()\nconst groundbody = new cannon.body({\n    mass: 0, // 质量为0，始终保持静止，不会受到力碰撞或加速度影响\n    shape: new cannon.plane(),\n    material: groundmaterial,\n});\n// 改变平面默认的方向，法线默认沿着z轴，旋转到平面向上朝着y方向\ngroundbody.quaternion.setfromeuler(-math.pi / 2, 0, 0);//旋转规律类似threejs 平面\nworld.addbody(groundbody);\n\n// 设置地面材质和小球材质之间的碰撞反弹恢复系数\nconst contactmaterial = new cannon.contactmaterial(groundmaterial, spherematerial, {\n    restitution: 0.7, //反弹恢复系数\n})\n// 把关联的材质添加到物理世界中\nworld.addcontactmaterial(contactmaterial)\n\n// 网格小球\nconst geometry = new three.spheregeometry(1.5);\nconst material = new three.meshlambertmaterial({\n    color: 0xffff00,\n});\nconst mesh = new three.mesh(geometry, material);\nmesh.position.y = 100;\n\n// 网格地面\nconst planegeometry = new three.planegeometry(200, 200);\nconst texture = new three.textureloader().load('./瓷砖.jpg');\ntexture.wraps = three.repeatwrapping;\ntexture.wrapt = three.repeatwrapping;\ntexture.repeat.set(3, 3);\nconst planematerial = new three.meshlambertmaterial({\n    color:0x777777,\n    map: texture,\n});\nconst planemesh = new three.mesh(planegeometry, planematerial);\nplanemesh.rotatex(-math.pi / 2);\n\n//场景\nconst scene = new three.scene();\nscene.add(mesh, planemesh); //模型对象添加到场景中\n\n\n//辅助观察的坐标系\nconst axeshelper = new three.axeshelper(100);\nscene.add(axeshelper);\n\n\n//光源设置\nconst directionallight = new three.directionallight(0xffffff, 1);\ndirectionallight.position.set(100, 60, 50);\nscene.add(directionallight);\nconst ambient = new three.ambientlight(0xffffff, 0.4);\nscene.add(ambient);\n\n\n//相机\nconst width = window.innerwidth;\nconst height = window.innerheight;\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\ncamera.position.set(292, 223, 185);\ncamera.lookat(0, 0, 0);\n\n// webgl渲染器设置\nconst renderer = new three.webglrenderer({\n    antialias: true, //开启优化锯齿\n});\nrenderer.setpixelratio(window.devicepixelratio); //防止输出模糊\nrenderer.setsize(width, height);\ndocument.body.appendchild(renderer.domelement);\n\n\nconst clock = new three.clock();\n// 渲染循环\nfunction render() {\n    world.step(1/60);//更新物理计算\n    mesh.position.copy(body.position);// 网格小球与物理小球位置同步\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\nconst controls = new orbitcontrols(camera, renderer.domelement);\n\n// 画布跟随窗口变化\nwindow.onresize = function () {\n    renderer.setsize(window.innerwidth, window.innerheight);\n    camera.aspect = window.innerwidth / window.innerheight;\n    camera.updateprojectionmatrix();\n};\n",charsets:{cjk:!0}},{title:"8. 长方体Box碰撞体(箱子下落)",frontmatter:{title:"8. 长方体Box碰撞体(箱子下落)",date:"2023-10-11T20:56:09.000Z",permalink:"/pages/bcb959/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/08.%E9%95%BF%E6%96%B9%E4%BD%93Box%E7%A2%B0%E6%92%9E%E4%BD%93(%E7%AE%B1%E5%AD%90%E4%B8%8B%E8%90%BD).html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/08.长方体Box碰撞体(箱子下落).md",key:"v-0f889bbc",path:"/pages/bcb959/",headers:[{level:3,title:"长方体CANNON.Box",slug:"长方体cannon-box",normalizedTitle:"长方体cannon.box",charIndex:201},{level:3,title:"长方体Box形状Body表示物理箱子",slug:"长方体box形状body表示物理箱子",normalizedTitle:"长方体box形状body表示物理箱子",charIndex:384},{level:3,title:"箱子与弹性碰撞设置",slug:"箱子与弹性碰撞设置",normalizedTitle:"箱子与弹性碰撞设置",charIndex:1090},{level:3,title:"旋转长方体",slug:"旋转长方体",normalizedTitle:"旋转长方体",charIndex:1353},{level:3,title:"同步箱子Mesh和Body姿态角度.quaternion",slug:"同步箱子mesh和body姿态角度-quaternion",normalizedTitle:"同步箱子mesh和body姿态角度.quaternion",charIndex:1580},{level:3,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:1935}],headersStr:"长方体CANNON.Box 长方体Box形状Body表示物理箱子 箱子与弹性碰撞设置 旋转长方体 同步箱子Mesh和Body姿态角度.quaternion 注意",content:"# 长方体Box碰撞体(箱子下落)\n\n前面给大家介绍过球形Sphere碰撞体,本节课给大家介绍一个长方体Box形状碰撞体，并用Box来模拟一个箱子下落效果。\n\n// 球形碰撞体\nconst body = new CANNON.Body({\n    mass: 0.3,\n    shape: new CANNON.Sphere(1)\n});\n\n\n下面代码是在前面小球下落基础上修改，其他不变。\n\n\n# 长方体CANNON.Box\n\nCANNON.Box表示一个长方体,参数是一个三维向量。三维向量的三个参数分别是表示长方体xyz方向的一半尺寸。\n\nBox坐标原点默认与长方体几何中心重合。\n\n// x、y、z三个方向的尺寸(长宽高)，分别为1.0、0.4、0.6\nnew CANNON.Box(new CANNON.Vec3(0.5, 0.2, 0.3))\n\n\n\n# 长方体Box形状Body表示物理箱子\n\n课件代码已经预先提供了一个长方体网格Mesh，用来表示箱子的外观效果，箱子在x、y、z三个方向尺寸分别是1.0、0.4、0.6。\n\n// 网格长方体\nconst geometry = new THREE.BoxGeometry(1.0,0.4,0.6);\nconst material = new THREE.MeshLambertMaterial({\n    map: new THREE.TextureLoader().load('./箱子.jpg'),\n});\nconst mesh = new THREE.Mesh(geometry, material);\nmesh.position.y = 5;\n\n\nBox形状的碰撞体Body表示物理箱子，高度与箱子Mesh一致设置为5m。\n\nconst world = new CANNON.World();\nworld.gravity.set(0, -9.8, 0);\n\nconst boxMaterial = new CANNON.Material()\n// 物理长方体\nconst body = new CANNON.Body({\n    mass: 0.3,//碰撞体质量\n    material: boxMaterial,//碰撞体材质\n    // x、y、z方向尺寸1.0、0.4、0.6\n    shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.2, 0.3))\n});\nbody.position.y = 5;\nworld.addBody(body);\n\n\n\n# 箱子与弹性碰撞设置\n\n你可以对比下面两个弹性碰撞系数的反弹差异。\n\n 1. 原来乒乓球的弹性碰撞设置\n\nnew CANNON.ContactMaterial(groundMaterial, boxMaterial, {\n    restitution: 0.7,\n})\n\n\n 2. 如果长方体表示一个箱子，反弹恢复系数就低一点，不用像乒乓球那么高\n\nnew CANNON.ContactMaterial(groundMaterial, boxMaterial, {\n    restitution: 0.2,\n})\n\n\n\n# 旋转长方体\n\n箱子换个姿态角度下落，观察下落效果差异。\n\n// 网格箱子旋转\n// 设置箱子下落的初始姿态角度\nmesh.rotation.set(Math.PI / 3, Math.PI / 3, Math.PI / 3);\n\n\n箱子碰撞体body绕xyz方向分别旋转60度，这样就是箱子倾斜角着地。\n\nbody.quaternion.setFromEuler(Math.PI / 3, Math.PI / 3, Math.PI / 3);\n\n\n\n# 同步箱子Mesh和Body姿态角度.quaternion\n\n在渲染循环中不仅仅要同步箱子网格模型Mesh与物理碰撞体Body的位置.position，也同步两者的姿态角度.quaternion。\n\n// 渲染循环\nfunction render() {\n    world.step(1/60);\n    // 网格mesh与boyd位置同步\n    mesh.position.copy(body.position);\n    //同步姿态角度\n    mesh.quaternion.copy(body.quaternion);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 注意\n\n除了箱子网格模型Mesh与物理碰撞体Body的位置.position一样之外，两者的几何中心也一致，这样才能保证两者重合。\n\n如果长方体mesh与body不完全重合，比如位置不一致，比如姿态角度不一致，比如尺寸不一致，你通过下落测试就能观察出来。\n\n// 网格长方体\nconst geometry = new THREE.BoxGeometry(1.0,0.4,0.6);\nconst mesh = new THREE.Mesh(geometry, material);\nmesh.position.y = 5;\n\n\n// 物理长方体\nconst body = new CANNON.Body({\n    mass: 0.3,//碰撞体质量\n    material: boxMaterial,//碰撞体材质\n    // x、y、z方向尺寸1.0、0.4、0.6\n    shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.2, 0.3))\n});\nbody.position.y = 5;\n",normalizedContent:"# 长方体box碰撞体(箱子下落)\n\n前面给大家介绍过球形sphere碰撞体,本节课给大家介绍一个长方体box形状碰撞体，并用box来模拟一个箱子下落效果。\n\n// 球形碰撞体\nconst body = new cannon.body({\n    mass: 0.3,\n    shape: new cannon.sphere(1)\n});\n\n\n下面代码是在前面小球下落基础上修改，其他不变。\n\n\n# 长方体cannon.box\n\ncannon.box表示一个长方体,参数是一个三维向量。三维向量的三个参数分别是表示长方体xyz方向的一半尺寸。\n\nbox坐标原点默认与长方体几何中心重合。\n\n// x、y、z三个方向的尺寸(长宽高)，分别为1.0、0.4、0.6\nnew cannon.box(new cannon.vec3(0.5, 0.2, 0.3))\n\n\n\n# 长方体box形状body表示物理箱子\n\n课件代码已经预先提供了一个长方体网格mesh，用来表示箱子的外观效果，箱子在x、y、z三个方向尺寸分别是1.0、0.4、0.6。\n\n// 网格长方体\nconst geometry = new three.boxgeometry(1.0,0.4,0.6);\nconst material = new three.meshlambertmaterial({\n    map: new three.textureloader().load('./箱子.jpg'),\n});\nconst mesh = new three.mesh(geometry, material);\nmesh.position.y = 5;\n\n\nbox形状的碰撞体body表示物理箱子，高度与箱子mesh一致设置为5m。\n\nconst world = new cannon.world();\nworld.gravity.set(0, -9.8, 0);\n\nconst boxmaterial = new cannon.material()\n// 物理长方体\nconst body = new cannon.body({\n    mass: 0.3,//碰撞体质量\n    material: boxmaterial,//碰撞体材质\n    // x、y、z方向尺寸1.0、0.4、0.6\n    shape: new cannon.box(new cannon.vec3(0.5, 0.2, 0.3))\n});\nbody.position.y = 5;\nworld.addbody(body);\n\n\n\n# 箱子与弹性碰撞设置\n\n你可以对比下面两个弹性碰撞系数的反弹差异。\n\n 1. 原来乒乓球的弹性碰撞设置\n\nnew cannon.contactmaterial(groundmaterial, boxmaterial, {\n    restitution: 0.7,\n})\n\n\n 2. 如果长方体表示一个箱子，反弹恢复系数就低一点，不用像乒乓球那么高\n\nnew cannon.contactmaterial(groundmaterial, boxmaterial, {\n    restitution: 0.2,\n})\n\n\n\n# 旋转长方体\n\n箱子换个姿态角度下落，观察下落效果差异。\n\n// 网格箱子旋转\n// 设置箱子下落的初始姿态角度\nmesh.rotation.set(math.pi / 3, math.pi / 3, math.pi / 3);\n\n\n箱子碰撞体body绕xyz方向分别旋转60度，这样就是箱子倾斜角着地。\n\nbody.quaternion.setfromeuler(math.pi / 3, math.pi / 3, math.pi / 3);\n\n\n\n# 同步箱子mesh和body姿态角度.quaternion\n\n在渲染循环中不仅仅要同步箱子网格模型mesh与物理碰撞体body的位置.position，也同步两者的姿态角度.quaternion。\n\n// 渲染循环\nfunction render() {\n    world.step(1/60);\n    // 网格mesh与boyd位置同步\n    mesh.position.copy(body.position);\n    //同步姿态角度\n    mesh.quaternion.copy(body.quaternion);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 注意\n\n除了箱子网格模型mesh与物理碰撞体body的位置.position一样之外，两者的几何中心也一致，这样才能保证两者重合。\n\n如果长方体mesh与body不完全重合，比如位置不一致，比如姿态角度不一致，比如尺寸不一致，你通过下落测试就能观察出来。\n\n// 网格长方体\nconst geometry = new three.boxgeometry(1.0,0.4,0.6);\nconst mesh = new three.mesh(geometry, material);\nmesh.position.y = 5;\n\n\n// 物理长方体\nconst body = new cannon.body({\n    mass: 0.3,//碰撞体质量\n    material: boxmaterial,//碰撞体材质\n    // x、y、z方向尺寸1.0、0.4、0.6\n    shape: new cannon.box(new cannon.vec3(0.5, 0.2, 0.3))\n});\nbody.position.y = 5;\n",charsets:{cjk:!0}},{title:"9. 练习题-外部gltf箱子模型",frontmatter:{title:"9. 练习题-外部gltf箱子模型",date:"2023-10-11T20:56:29.000Z",permalink:"/pages/b646d4/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/09.%E7%BB%83%E4%B9%A0%E9%A2%98-%E5%A4%96%E9%83%A8gltf%E7%AE%B1%E5%AD%90%E6%A8%A1%E5%9E%8B.html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/09.练习题-外部gltf箱子模型.md",key:"v-949d0b96",path:"/pages/b646d4/",headers:[{level:3,title:"包围盒Box3计算模型尺寸",slug:"包围盒box3计算模型尺寸",normalizedTitle:"包围盒box3计算模型尺寸",charIndex:505},{level:3,title:"外部gltf箱子模型局部坐标原点问题",slug:"外部gltf箱子模型局部坐标原点问题",normalizedTitle:"外部gltf箱子模型局部坐标原点问题",charIndex:944}],headersStr:"包围盒Box3计算模型尺寸 外部gltf箱子模型局部坐标原点问题",content:'# 练习题-外部gltf箱子模型\n\n继续上节课箱子案例的讲解，做一个练习题，你可以尝试把上节课threejs代码创建的箱子模型替换为外部gltf模型。\n\n// 箱子网格模型\nconst geometry = new THREE.BoxGeometry(1.0,0.4,0.6);\nconst material = new THREE.MeshLambertMaterial({\n    map: new THREE.TextureLoader().load(\'./箱子.jpg\'),\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\n\nimport { GLTFLoader } from \'three/addons/loaders/GLTFLoader.js\';\nconst loader = new GLTFLoader();\nconst gltf = await loader.loadAsync("../箱子.glb")\nconst mesh = gltf.scene;//获取箱子网格模型\nmesh.position.y = 5;\n\n\n\n# 包围盒Box3计算模型尺寸\n\n如果你想知道箱子gltf模型尺寸，可以在Blender中测量，当然也可以用包围盒Box3自动计算外部gltf模型长宽高尺寸。\n\n用包围盒计算好处就是，你加载的模型不管长宽高是多少，都可以代码自动计算出来。\n\n如果关于包围盒知识点忘记了，你可以参考前面基础内容对包围盒讲解。\n\nconst box3 = new THREE.Box3();\nbox3.expandByObject(mesh);//计算模型包围盒\nconst size = new THREE.Vector3();\nbox3.getSize(size);//包围盒计算箱子的尺寸\n\n\n根据包围盒计算的结果，设置Box的尺寸。\n\n// 物理箱子\nconst body = new CANNON.Body({\n    ...\n    shape: new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2))\n});\n\n\n\n# 外部gltf箱子模型局部坐标原点问题\n\n你可以打开课件中两个模型文件箱子.glb与箱子-坐标原点不于中心重合.glb，查看自身坐标原点相对自身几何中心的位置，对比下不同。箱子.glb模型的局部坐标原点与自身几何中心重合，另一个模型不重合。\n\n你可以对比下，两个箱子模型文件在代码中的表现。你会发现，模型局部坐标原点相对自身位置，会影响代码结果。\n\n这提醒我们，在以后的开发中，Blender或其他人任何三维建模软件导出模型的时候，要注意模型的坐标原点位置。\n\n// const gltf = await loader.loadAsync("../箱子.glb")\nconst gltf = await loader.loadAsync("../箱子-坐标原点不于中心重合.glb")\n',normalizedContent:'# 练习题-外部gltf箱子模型\n\n继续上节课箱子案例的讲解，做一个练习题，你可以尝试把上节课threejs代码创建的箱子模型替换为外部gltf模型。\n\n// 箱子网格模型\nconst geometry = new three.boxgeometry(1.0,0.4,0.6);\nconst material = new three.meshlambertmaterial({\n    map: new three.textureloader().load(\'./箱子.jpg\'),\n});\nconst mesh = new three.mesh(geometry, material);\n\n\nimport { gltfloader } from \'three/addons/loaders/gltfloader.js\';\nconst loader = new gltfloader();\nconst gltf = await loader.loadasync("../箱子.glb")\nconst mesh = gltf.scene;//获取箱子网格模型\nmesh.position.y = 5;\n\n\n\n# 包围盒box3计算模型尺寸\n\n如果你想知道箱子gltf模型尺寸，可以在blender中测量，当然也可以用包围盒box3自动计算外部gltf模型长宽高尺寸。\n\n用包围盒计算好处就是，你加载的模型不管长宽高是多少，都可以代码自动计算出来。\n\n如果关于包围盒知识点忘记了，你可以参考前面基础内容对包围盒讲解。\n\nconst box3 = new three.box3();\nbox3.expandbyobject(mesh);//计算模型包围盒\nconst size = new three.vector3();\nbox3.getsize(size);//包围盒计算箱子的尺寸\n\n\n根据包围盒计算的结果，设置box的尺寸。\n\n// 物理箱子\nconst body = new cannon.body({\n    ...\n    shape: new cannon.box(new cannon.vec3(size.x/2, size.y/2, size.z/2))\n});\n\n\n\n# 外部gltf箱子模型局部坐标原点问题\n\n你可以打开课件中两个模型文件箱子.glb与箱子-坐标原点不于中心重合.glb，查看自身坐标原点相对自身几何中心的位置，对比下不同。箱子.glb模型的局部坐标原点与自身几何中心重合，另一个模型不重合。\n\n你可以对比下，两个箱子模型文件在代码中的表现。你会发现，模型局部坐标原点相对自身位置，会影响代码结果。\n\n这提醒我们，在以后的开发中，blender或其他人任何三维建模软件导出模型的时候，要注意模型的坐标原点位置。\n\n// const gltf = await loader.loadasync("../箱子.glb")\nconst gltf = await loader.loadasync("../箱子-坐标原点不于中心重合.glb")\n',charsets:{cjk:!0}},{title:"3. 练习-threejs可视化cannon计算结果",frontmatter:{title:"3. 练习-threejs可视化cannon计算结果",date:"2023-10-01T14:08:50.000Z",permalink:"/pages/eb4d49/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/03.%E7%BB%83%E4%B9%A0-threejs%E5%8F%AF%E8%A7%86%E5%8C%96cannon%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C.html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/03.练习-threejs可视化cannon计算结果.md",key:"v-2c6a8a39",path:"/pages/eb4d49/",headers:[{level:3,title:"知识点回顾",slug:"知识点回顾",normalizedTitle:"知识点回顾",charIndex:177},{level:3,title:"渲染循环更新小球位置",slug:"渲染循环更新小球位置",normalizedTitle:"渲染循环更新小球位置",charIndex:671},{level:3,title:"调节物理世界加速度",slug:"调节物理世界加速度",normalizedTitle:"调节物理世界加速度",charIndex:1058}],headersStr:"知识点回顾 渲染循环更新小球位置 调节物理世界加速度",content:"# 练习-threejs可视化cannon计算结果\n\n本节课是一个练习题，就是用threejs把cannonjs计算的小球位置可视化表示出来。\n\n * CannonJS：负责物理计算，比如计算出来一个小球的下落位置\n * three.js：负责可视化渲染，比如用Mesh渲染一个下落的小球视觉效果\n\n一个负责物理模拟计算，一个负责3D场景的渲染\n\n\n# 知识点回顾\n\n参考上节课知识点，创建一个body表示小球，与threejs的网格小球mesh对应。\n\nconst world = new CANNON.World();\n// 设置物理世界重力加速度\nworld.gravity.set(0, -9.8, 0);\n\n// 物理小球：对应threejs的网格小球\nconst body = new CANNON.Body({\n    mass: 0.3,//碰撞体质量\n    shape:new CANNON.Sphere(1),\n});\nbody.position.y = 100;\nworld.addBody(body);\n\n// 网格小球\nconst geometry = new THREE.SphereGeometry(1);\nconst material = new THREE.MeshLambertMaterial({\n    color: 0x00ffff,\n});\nconst mesh = new THREE.Mesh(geometry, material);\nmesh.position.y = 100;\n\n\n\n# 渲染循环更新小球位置\n\n执行world.step()会更新计算物理小球body的下落位置，这时候如果你想看到threejs小球Mesh下落动画，就需要把body位置同步到mesh上面，非常简单，直接复制即可mesh.position.copy(body.position)。\n\nconst fixedTimeStep = 1/60;\n// 渲染循环\nfunction render() {\n    world.step(fixedTimeStep);\n    // 渲染循环中，同步物理球body与网格球mesh的位置\n    mesh.position.copy(body.position);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 调节物理世界加速度\n\n你可以尝试改变物理世界的重力加速度，对比不同加速度，threejs小球Mesh下落动画视觉效果差异。\n\nworld.gravity.set(0, -9.8, 0);\n\n\nworld.gravity.set(0, -50, 0);\n\n\n你实际设置，重力加速度不一定就是设置为9.8，也可以根据需要设置不同的重力加速度大小，开发游戏或元宇宙项目，物理效果追求的是感知正确，不是物理正确，所谓感知正确，就是你的眼睛看着正常就行，并不一定非要与现实100%一致，cannonjs一般就是近似计算位置、速度。当然咱们这节课还没有结合threejs，大家看不到视觉效果，后面咱们都会结合threejs网格Mesh给大家演示。",normalizedContent:"# 练习-threejs可视化cannon计算结果\n\n本节课是一个练习题，就是用threejs把cannonjs计算的小球位置可视化表示出来。\n\n * cannonjs：负责物理计算，比如计算出来一个小球的下落位置\n * three.js：负责可视化渲染，比如用mesh渲染一个下落的小球视觉效果\n\n一个负责物理模拟计算，一个负责3d场景的渲染\n\n\n# 知识点回顾\n\n参考上节课知识点，创建一个body表示小球，与threejs的网格小球mesh对应。\n\nconst world = new cannon.world();\n// 设置物理世界重力加速度\nworld.gravity.set(0, -9.8, 0);\n\n// 物理小球：对应threejs的网格小球\nconst body = new cannon.body({\n    mass: 0.3,//碰撞体质量\n    shape:new cannon.sphere(1),\n});\nbody.position.y = 100;\nworld.addbody(body);\n\n// 网格小球\nconst geometry = new three.spheregeometry(1);\nconst material = new three.meshlambertmaterial({\n    color: 0x00ffff,\n});\nconst mesh = new three.mesh(geometry, material);\nmesh.position.y = 100;\n\n\n\n# 渲染循环更新小球位置\n\n执行world.step()会更新计算物理小球body的下落位置，这时候如果你想看到threejs小球mesh下落动画，就需要把body位置同步到mesh上面，非常简单，直接复制即可mesh.position.copy(body.position)。\n\nconst fixedtimestep = 1/60;\n// 渲染循环\nfunction render() {\n    world.step(fixedtimestep);\n    // 渲染循环中，同步物理球body与网格球mesh的位置\n    mesh.position.copy(body.position);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 调节物理世界加速度\n\n你可以尝试改变物理世界的重力加速度，对比不同加速度，threejs小球mesh下落动画视觉效果差异。\n\nworld.gravity.set(0, -9.8, 0);\n\n\nworld.gravity.set(0, -50, 0);\n\n\n你实际设置，重力加速度不一定就是设置为9.8，也可以根据需要设置不同的重力加速度大小，开发游戏或元宇宙项目，物理效果追求的是感知正确，不是物理正确，所谓感知正确，就是你的眼睛看着正常就行，并不一定非要与现实100%一致，cannonjs一般就是近似计算位置、速度。当然咱们这节课还没有结合threejs，大家看不到视觉效果，后面咱们都会结合threejs网格mesh给大家演示。",charsets:{cjk:!0}},{title:"10. 凸多面体ConvexPolyhedron",frontmatter:{title:"10. 凸多面体ConvexPolyhedron",date:"2023-10-11T20:56:54.000Z",permalink:"/pages/280f40/"},regularPath:"/02.Three.js%E8%BF%9B%E9%98%B6%E6%95%99%E7%A8%8B/10.10.CannonJS%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/10.%E5%87%B8%E5%A4%9A%E9%9D%A2%E4%BD%93ConvexPolyhedron.html",relativePath:"02.Three.js进阶教程/10.10.CannonJS物理引擎/10.凸多面体ConvexPolyhedron.md",key:"v-692d0a85",path:"/pages/280f40/",headers:[{level:3,title:"查看gltf模型几何体结构",slug:"查看gltf模型几何体结构",normalizedTitle:"查看gltf模型几何体结构",charIndex:269},{level:3,title:"凸多面体ConvexPolyhedron",slug:"凸多面体convexpolyhedron-2",normalizedTitle:"凸多面体convexpolyhedron",charIndex:2},{level:3,title:"gltf凸多面体转CannonJS凸多面体",slug:"gltf凸多面体转cannonjs凸多面体",normalizedTitle:"gltf凸多面体转cannonjs凸多面体",charIndex:999}],headersStr:"查看gltf模型几何体结构 凸多面体ConvexPolyhedron gltf凸多面体转CannonJS凸多面体",content:"# 凸多面体ConvexPolyhedron\n\n对于不同形状的碰撞体Body，需要选择CannonJS不同的几何体表示，比如用球体Sphere表示一个乒乓球的形状，用长方体Box表示一个箱子的形状。\n\nconst body = new CANNON.Body({\n    shape: new CANNON.Box(new CANNON.Vec3(1, 2, 1))\n});\n\n\n这节课给大家介绍一个新的CannonJS几何类ConvexPolyhedron,ConvexPolyhedron可以用来表示不同外形的凸多面体。\n\n\n\n\n# 查看gltf模型几何体结构\n\nconst gltf = await loader.loadAsync(\"../凸多面体.glb\")\nconst mesh = gltf.scene.getObjectByName('多面体');//获取凸多面体网格模型\nmesh.position.y = 5;\nconsole.log('mesh.geometry',mesh.geometry);\n\n\n提醒：学下面内容之前，确保你已经掌握前面基础课程介绍的几何体BufferGeometry。\n\n\n# 凸多面体ConvexPolyhedron\n\n凸多面体ConvexPolyhedron三角形索引和顶点位置数据的格式如下\n\n//凸多面体数据格式：三角形顶点位置\nconst vertices = [\n    new CANNON.Vec3(0, 0, 0),\n    new CANNON.Vec3(0, 1, 0),\n    ...\n];\n//凸多面体数据格式：三角形面的索引值\nconst faces = [\n    [0,1,2],//三角形1顶点索引值\n    [3,4,5] //三角形2顶点索引值\n    ...\n];\n\n\nconst shape = new CANNON.ConvexPolyhedron({ \n    vertices: vertices, \n    faces: faces\n});\n// 简化写法\nconst shape = new CANNON.ConvexPolyhedron({ vertices, faces });\nconst body = new CANNON.Body({\n    shape: shape\n});\n\n\n\n# gltf凸多面体转CannonJS凸多面体\n\n获取gltf模型的三角形顶点数据，转化为CannonJS凸多面体ConvexPolyhedron的三角形顶点数据。\n\nconst vertices = [];//所有三角形顶点位置数据\nconst faces = [];//所有三角形面的索引值\nconst pos = mesh.geometry.attributes.position;\nfor (let i = 0; i < pos.count; i++) {\n    const x = pos.getX(i);\n    const y = pos.getY(i);\n    const z = pos.getZ(i);\n    vertices.push(new CANNON.Vec3(x, y, z));\n}\nconst index = mesh.geometry.index.array;\nfor (let i = 0; i < index.length; i += 3) {\n    const a = index[i];\n    const b = index[i + 1];\n    const c = index[i + 2];\n    faces.push([a, b, c]);\n}\n// CannonJS的凸多面体ConvexPolyhedron\nconst shape = new CANNON.ConvexPolyhedron({ vertices, faces });\n// 物理凸多面体\nconst body = new CANNON.Body({\n    shape: shape\n});\n\n\n注意：课程案例gltf模型有顶点索引数据geometry.index，不过有些模型geometry.index可能没有任何数据。如果没有index数据，转化代码和上面稍微有区别。\n\nconst pos = geometry.attributes.position;\nfor (let i = 0; i < pos.count; i++) {\n    const x = pos.getX(i);\n    const y = pos.getY(i);\n    const z = pos.getZ(i);\n    vertices.push(new CANNON.Vec3(x, y, z));\n}\nfor (let i = 0; i < pos.count; i = +3) {\n    faces.push([i, i + 1, i + 2]);\n}\n\n\n注意：另一方面就是网格模型的位置、角度、缩放属性，也会对转化代码也会有影响，后面遇到具体问题具体分析。",normalizedContent:"# 凸多面体convexpolyhedron\n\n对于不同形状的碰撞体body，需要选择cannonjs不同的几何体表示，比如用球体sphere表示一个乒乓球的形状，用长方体box表示一个箱子的形状。\n\nconst body = new cannon.body({\n    shape: new cannon.box(new cannon.vec3(1, 2, 1))\n});\n\n\n这节课给大家介绍一个新的cannonjs几何类convexpolyhedron,convexpolyhedron可以用来表示不同外形的凸多面体。\n\n\n\n\n# 查看gltf模型几何体结构\n\nconst gltf = await loader.loadasync(\"../凸多面体.glb\")\nconst mesh = gltf.scene.getobjectbyname('多面体');//获取凸多面体网格模型\nmesh.position.y = 5;\nconsole.log('mesh.geometry',mesh.geometry);\n\n\n提醒：学下面内容之前，确保你已经掌握前面基础课程介绍的几何体buffergeometry。\n\n\n# 凸多面体convexpolyhedron\n\n凸多面体convexpolyhedron三角形索引和顶点位置数据的格式如下\n\n//凸多面体数据格式：三角形顶点位置\nconst vertices = [\n    new cannon.vec3(0, 0, 0),\n    new cannon.vec3(0, 1, 0),\n    ...\n];\n//凸多面体数据格式：三角形面的索引值\nconst faces = [\n    [0,1,2],//三角形1顶点索引值\n    [3,4,5] //三角形2顶点索引值\n    ...\n];\n\n\nconst shape = new cannon.convexpolyhedron({ \n    vertices: vertices, \n    faces: faces\n});\n// 简化写法\nconst shape = new cannon.convexpolyhedron({ vertices, faces });\nconst body = new cannon.body({\n    shape: shape\n});\n\n\n\n# gltf凸多面体转cannonjs凸多面体\n\n获取gltf模型的三角形顶点数据，转化为cannonjs凸多面体convexpolyhedron的三角形顶点数据。\n\nconst vertices = [];//所有三角形顶点位置数据\nconst faces = [];//所有三角形面的索引值\nconst pos = mesh.geometry.attributes.position;\nfor (let i = 0; i < pos.count; i++) {\n    const x = pos.getx(i);\n    const y = pos.gety(i);\n    const z = pos.getz(i);\n    vertices.push(new cannon.vec3(x, y, z));\n}\nconst index = mesh.geometry.index.array;\nfor (let i = 0; i < index.length; i += 3) {\n    const a = index[i];\n    const b = index[i + 1];\n    const c = index[i + 2];\n    faces.push([a, b, c]);\n}\n// cannonjs的凸多面体convexpolyhedron\nconst shape = new cannon.convexpolyhedron({ vertices, faces });\n// 物理凸多面体\nconst body = new cannon.body({\n    shape: shape\n});\n\n\n注意：课程案例gltf模型有顶点索引数据geometry.index，不过有些模型geometry.index可能没有任何数据。如果没有index数据，转化代码和上面稍微有区别。\n\nconst pos = geometry.attributes.position;\nfor (let i = 0; i < pos.count; i++) {\n    const x = pos.getx(i);\n    const y = pos.gety(i);\n    const z = pos.getz(i);\n    vertices.push(new cannon.vec3(x, y, z));\n}\nfor (let i = 0; i < pos.count; i = +3) {\n    faces.push([i, i + 1, i + 2]);\n}\n\n\n注意：另一方面就是网格模型的位置、角度、缩放属性，也会对转化代码也会有影响，后面遇到具体问题具体分析。",charsets:{cjk:!0}},{title:"1. 学前说明",frontmatter:{title:"1. 学前说明",date:"2023-10-19T15:11:51.000Z",permalink:"/pages/d30795/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/01.%E5%AD%A6%E5%89%8D%E8%AF%B4%E6%98%8E.html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/01.学前说明.md",key:"v-a8d65390",path:"/pages/d30795/",headers:[{level:3,title:"Three.js Shader可以做什么",slug:"three-js-shader可以做什么",normalizedTitle:"three.js shader可以做什么",charIndex:69},{level:3,title:"学习基础",slug:"学习基础",normalizedTitle:"学习基础",charIndex:184},{level:3,title:"WebGL基础问题",slug:"webgl基础问题",normalizedTitle:"webgl基础问题",charIndex:395},{level:3,title:"Threejs底层：WebGL",slug:"threejs底层-webgl",normalizedTitle:"threejs底层：webgl",charIndex:613}],headersStr:"Three.js Shader可以做什么 学习基础 WebGL基础问题 Threejs底层：WebGL",content:"# 学前说明\n\n在正式学习Threejs Shader之前，先说下通过Threejs Shader可以做什么，怎么去学习的问题。\n\n\n# Three.js Shader可以做什么\n\n先简单展示几个Threejs Shader相关的效果。\n\n * 建筑流光效果\n * 智慧城市特效\n * 地球、地图可视化飞线Shader\n * 网页波浪背景\n\n效果查看视频地址\n\n\n# 学习基础\n\n学习Threejs Shader之前，确保《Three.js可视化系统课》，阶段1、阶段2内容你已经学习了，对threejs有一个基本的了解。\n\n * 【阶段1】Threejs基础、中级部分 【必修】\n\n * 【阶段2】Threejs进阶数学几何计算 【必修】\n\n * 【阶段1】阶段1对应案例【选修】\n\n * 【阶段2】阶段2对应案例【选修】\n\n * 【阶段3】原生WebGL 【选修，建议最好学】\n\n\n# WebGL基础问题\n\n如果你时间比较充足，最好先入门WebGL，再学习Threejs Shader，这样更容易理解threejs Shader代码。\n\n不过有一点学习WebGL要求相对高点。\n\n当然如果你不想花时间学习WebGL，项目着急写threejs shader，你跳过《原生webgl课程》也行，只是这样有个小缺陷，学习threejs shader难度会更高点，要有心理准备，不过好处就是不用折腾WebGL的API了。\n\n\n# Threejs底层：WebGL\n\n像你平时写threejs代码的WebGL渲染器WebGLRenderer，本质上就是对WebGL API的封装。\n\nWebGL渲染器执行.render()渲染的过程，本质上就是调用WebGL API，控制你的电脑或手机的GPU渲染3D场景。\n\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera();\n// WebGL渲染器\nconst renderer = new THREE.WebGLRenderer();\nrenderer.render(scene, camera);\n\n\n如果想了解WebGLRenderer是如何封装WebGL API的，你可以查看threejs官方文件包，src/renderers目录下与WebGL渲染器WebGLRenderer有关的代码。",normalizedContent:"# 学前说明\n\n在正式学习threejs shader之前，先说下通过threejs shader可以做什么，怎么去学习的问题。\n\n\n# three.js shader可以做什么\n\n先简单展示几个threejs shader相关的效果。\n\n * 建筑流光效果\n * 智慧城市特效\n * 地球、地图可视化飞线shader\n * 网页波浪背景\n\n效果查看视频地址\n\n\n# 学习基础\n\n学习threejs shader之前，确保《three.js可视化系统课》，阶段1、阶段2内容你已经学习了，对threejs有一个基本的了解。\n\n * 【阶段1】threejs基础、中级部分 【必修】\n\n * 【阶段2】threejs进阶数学几何计算 【必修】\n\n * 【阶段1】阶段1对应案例【选修】\n\n * 【阶段2】阶段2对应案例【选修】\n\n * 【阶段3】原生webgl 【选修，建议最好学】\n\n\n# webgl基础问题\n\n如果你时间比较充足，最好先入门webgl，再学习threejs shader，这样更容易理解threejs shader代码。\n\n不过有一点学习webgl要求相对高点。\n\n当然如果你不想花时间学习webgl，项目着急写threejs shader，你跳过《原生webgl课程》也行，只是这样有个小缺陷，学习threejs shader难度会更高点，要有心理准备，不过好处就是不用折腾webgl的api了。\n\n\n# threejs底层：webgl\n\n像你平时写threejs代码的webgl渲染器webglrenderer，本质上就是对webgl api的封装。\n\nwebgl渲染器执行.render()渲染的过程，本质上就是调用webgl api，控制你的电脑或手机的gpu渲染3d场景。\n\nconst scene = new three.scene();\nconst camera = new three.perspectivecamera();\n// webgl渲染器\nconst renderer = new three.webglrenderer();\nrenderer.render(scene, camera);\n\n\n如果想了解webglrenderer是如何封装webgl api的，你可以查看threejs官方文件包，src/renderers目录下与webgl渲染器webglrenderer有关的代码。",charsets:{cjk:!0}},{title:"2. 着色器GLSL ES语言(复习)",frontmatter:{title:"2. 着色器GLSL ES语言(复习)",date:"2023-10-19T15:14:06.000Z",permalink:"/pages/3b3f35/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/02.%E7%9D%80%E8%89%B2%E5%99%A8GLSL%20ES%E8%AF%AD%E8%A8%80(%E5%A4%8D%E4%B9%A0).html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/02.着色器GLSL ES语言(复习).md",key:"v-c1efc94c",path:"/pages/3b3f35/",headersStr:null,content:"# 2.着色器GLSL ES语言\n\n这部分内容在原生WebGL中讲解过，直接去复习或重新学习下就行。\n\n文档地址：1.2. 着色器GLSL ES语言",normalizedContent:"# 2.着色器glsl es语言\n\n这部分内容在原生webgl中讲解过，直接去复习或重新学习下就行。\n\n文档地址：1.2. 着色器glsl es语言",charsets:{cjk:!0}},{title:"3. ShaderMaterial着色器材质",frontmatter:{title:"3. ShaderMaterial着色器材质",date:"2023-10-23T22:43:53.000Z",permalink:"/pages/eb2fda/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/03.ShaderMaterial%E7%9D%80%E8%89%B2%E5%99%A8%E6%9D%90%E8%B4%A8.html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/03.ShaderMaterial着色器材质.md",key:"v-7cebfb4f",path:"/pages/eb2fda/",headers:[{level:3,title:".vertexShader和fragmentShader属性",slug:"vertexshader和fragmentshader属性",normalizedTitle:".vertexshader和fragmentshader属性",charIndex:378},{level:3,title:"使用Shader材质ShaderMaterial",slug:"使用shader材质shadermaterial",normalizedTitle:"使用shader材质shadermaterial",charIndex:654},{level:3,title:"设置顶点着色器vertexShader",slug:"设置顶点着色器vertexshader",normalizedTitle:"设置顶点着色器vertexshader",charIndex:1275},{level:3,title:"设置顶点着色器主函数",slug:"设置顶点着色器主函数",normalizedTitle:"设置顶点着色器主函数",charIndex:1678},{level:3,title:"内置变量gl_Position",slug:"内置变量gl-position",normalizedTitle:"内置变量gl_position",charIndex:1908},{level:3,title:"着色器GLSL ES语言语法：attribute关键字",slug:"着色器glsl-es语言语法-attribute关键字",normalizedTitle:"着色器glsl es语言语法：attribute关键字",charIndex:2432},{level:3,title:"知识回顾：几何体geometry的顶点位置数据",slug:"知识回顾-几何体geometry的顶点位置数据",normalizedTitle:"知识回顾：几何体geometry的顶点位置数据",charIndex:3105},{level:3,title:"ShaderMaterial的内置变量position",slug:"shadermaterial的内置变量position",normalizedTitle:"shadermaterial的内置变量position",charIndex:3410},{level:3,title:"内置变量position含义",slug:"内置变量position含义",normalizedTitle:"内置变量position含义",charIndex:3766},{level:3,title:"知识回顾：顶点矩阵变换",slug:"知识回顾-顶点矩阵变换",normalizedTitle:"知识回顾：顶点矩阵变换",charIndex:4665},{level:3,title:"着色器GLSL ES语言语法：uniform关键字",slug:"着色器glsl-es语言语法-uniform关键字",normalizedTitle:"着色器glsl es语言语法：uniform关键字",charIndex:4934},{level:3,title:"知识点回顾：世界矩阵.matrixWorld",slug:"知识点回顾-世界矩阵-matrixworld",normalizedTitle:"知识点回顾：世界矩阵.matrixworld",charIndex:5272},{level:3,title:"内置变量模型矩阵modelMatrix",slug:"内置变量模型矩阵modelmatrix",normalizedTitle:"内置变量模型矩阵modelmatrix",charIndex:5619},{level:3,title:"知识回顾：视图矩阵和投影矩阵",slug:"知识回顾-视图矩阵和投影矩阵",normalizedTitle:"知识回顾：视图矩阵和投影矩阵",charIndex:6490},{level:3,title:"内置变量:视图矩阵viewMatrix和投影矩阵projectionMatrix",slug:"内置变量-视图矩阵viewmatrix和投影矩阵projectionmatrix",normalizedTitle:"内置变量:视图矩阵viewmatrix和投影矩阵projectionmatrix",charIndex:6924},{level:3,title:"设置片元着色器代码fragmentShader",slug:"设置片元着色器代码fragmentshader",normalizedTitle:"设置片元着色器代码fragmentshader",charIndex:7780},{level:3,title:"体验测试",slug:"体验测试",normalizedTitle:"体验测试",charIndex:8549},{level:3,title:"内置变量：模型视图矩阵",slug:"内置变量-模型视图矩阵",normalizedTitle:"内置变量：模型视图矩阵",charIndex:8919}],headersStr:".vertexShader和fragmentShader属性 使用Shader材质ShaderMaterial 设置顶点着色器vertexShader 设置顶点着色器主函数 内置变量gl_Position 着色器GLSL ES语言语法：attribute关键字 知识回顾：几何体geometry的顶点位置数据 ShaderMaterial的内置变量position 内置变量position含义 知识回顾：顶点矩阵变换 着色器GLSL ES语言语法：uniform关键字 知识点回顾：世界矩阵.matrixWorld 内置变量模型矩阵modelMatrix 知识回顾：视图矩阵和投影矩阵 内置变量:视图矩阵viewMatrix和投影矩阵projectionMatrix 设置片元着色器代码fragmentShader 体验测试 内置变量：模型视图矩阵",content:"# ShaderMaterial着色器材质\n\n原来给大家介绍过threejs的各种材质，比如MeshBasicMaterial、MeshLambertMaterial...，对于这些材质，你可以通过color、map等属性直接设置物体的外观。\n\nconst material = new THREE.MeshBasicMaterial({\n    color: 0x00ffff,//颜色\n    map:texture,//颜色贴图\n});\n\n\n这节课介绍一个特殊的threejs材质，就是Shader材质类ShaderMaterial，单词Shader就是着色器的意思，ShaderMaterial是通过着色器GLSL ES语言自定义材质效果，比如颜色。\n\n提醒：如果你图形学或数学的相关基础都不太好，建议本节课的视频和文档内容反复多看几遍。\n\n\n# .vertexShader和fragmentShader属性\n\n * .vertexShader：顶点着色器\n * .fragmentShader：片元着色器\n\n本节课主要重点学习ShaderMaterial的顶点着色器属性.vertexShader、片元着色器属性.fragmentShader。\n\nconst material = new THREE.ShaderMaterial({\n    vertexShader: '着色器代码',// 顶点着色器\n    fragmentShader: '着色器代码',// 片元着色器\n});\n\n\n\n# 使用Shader材质ShaderMaterial\n\n打开本节课源码演示文件，你可以看到一个矩形网格模型Mesh，Mesh的材质是基础网格材质MeshBasicMaterial。\n\nconst geometry = new THREE.PlaneGeometry(100, 50);\nconst material = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n使用Shader材质ShaderMaterial代替MeshBasicMaterial，外观效果，可以通过顶点着色器.vertexShader、片元着色器.fragmentShader实现。\n\n具体替换结果，你可以查看课件案例源码文件，打开测试效果，和演示文件对比下。\n\nconst geometry = new THREE.PlaneGeometry(100, 50);\nconst material = new THREE.ShaderMaterial({\n    vertexShader: '...',// 顶点着色器\n    fragmentShader: '...',// 片元着色器\n});\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n\n# 设置顶点着色器vertexShader\n\nShaderMaterial顶点着色器属性vertexShader的值是字符串，字符串的内容是着色器GLSL ES语言写的代码。关于着色器GLSL ES语言的语法可以参考前面课程1.2. 着色器GLSL ES语言的介绍。\n\nconst material = new THREE.ShaderMaterial({\n    vertexShader: '',// 顶点着色器\n});\n\n\n为了方便预览顶点着色器代码，咱们用模板字符串``的形式去写,模板字符串``的按键位于键盘Tab键的上面。\n\nconst vertexShader = `\n    // 写顶点着色器的代码 \n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n});\n\n\n\n# 设置顶点着色器主函数\n\n先按照着色器GLSL ES语言的语法，给顶点着色器代码设置一个主函数main,函数main无返回值，前面加上关键字void即可。\n\nconst vertexShader = `\nvoid main(){\n    // 写顶点着色器的代码  \n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n});\n\n\n\n# 内置变量gl_Position\n\ngl_Position是着色器GLSL ES语言的内置变量，所谓内置变量，就是不用声明，就可以在代码中使用。\n\n着色器内置变量gl_Position数据类型是四维向量vec4，可以用函数vec4()创建,vec4()有四个参数，每个参数都是浮点数float\n\ngl_Position的值,前面三个参数表示xyz坐标，第四个参数一般固定设置为1.0。\n\nconst vertexShader = `\nvoid main(){\n    gl_Position = vec4( x, y ,z ,1.0 );\n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n});\n\n\n不过一般不会通过gl_Position直接写顶点坐标，而是从几何体BufferGeometry获取顶点坐标数据，下面给大家讲解具体实现方式。\n\nconst vertexShader = `\nvoid main(){\n    gl_Position = vec4(从几何体获取顶点xyz坐标,1.0 );\n}\n`\n\n\n\n# 着色器GLSL ES语言语法：attribute关键字\n\nattribute是着色器GLSL ES语言的一个关键字，按照GLSL ES的语法规定，attribute关键字一般用来声明与顶点数据有关变量。\n\nattribute vec3 pos;表示用attribute声明了一个变量pos，attribute的作用就是指明pos是顶点相关变量，pos的数类型是三维向量vec3，三维向量vec3意味着pos表示的顶点数据有x、y、z三个分量。比如你可以用pos表示顶点的位置数据xyz(当然也能表示其它类型顶点数据,遇到再讲解)。\n\nconst vertexShader = `\nattribute vec3 pos;//注意在主函数外面\nvoid main(){\n    gl_Position = vec4(...,1.0 );\n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n});\n\n\n假设attribute声明的变量pos表示顶点位置数据，你就可以赋值给gl_Position。\n\n执行vec4(pos,1.0 ),给三维向量vec3增加一个分量，就可以变成四维向量vec4(这是GLSL ES基本语法)。\n\nconst vertexShader = `\nattribute vec3 pos;\nvoid main(){\n    gl_Position = vec4(pos,1.0 );\n}\n`\n\n\n\n# 知识回顾：几何体geometry的顶点位置数据\n\n知识回顾：基础课程中讲解过几何体BufferGeometry的顶点知识\n\n访问geometry.attributes.position你可以看到几何体所有的顶点位置数据，这些位置数据包含在一个数组中，三个为一组表示一个顶点的x、y、z坐标。这里再强调一遍，threejs默认情况下，几何体的顶点位置数据中的每个顶点都包含x、y、z三个分量。\n\nconst geometry = new THREE.PlaneGeometry(100, 50);\nconsole.log('顶点位置数据',geometry.attributes.position);\n\n\n\n# ShaderMaterial的内置变量position\n\n调用shader材质ShaderMaterial的时候，threejs会在内部给你写的顶点着色器代码中，插入一行代码attribute vec3 position;，相当于帮你声明了一个变量position，position表示顶点的位置数据\n\nconst vertexShader = `\nattribute vec3 position;//默认提供,不用自己写\nvoid main(){\n    gl_Position = vec4(...,1.0 );\n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n});\n\n\n\n# 内置变量position含义\n\n查看案例代码，可以看到几何体geometry与ShaderMaterial材质构成了一个mesh。也就是说材质ShaderMaterial关联了几何体geometry。\n\nconst geometry = new THREE.PlaneGeometry(100, 50);\nconsole.log('顶点位置数据',geometry.attributes.position);\nconst material = new THREE.ShaderMaterial();\nconst mesh = new THREE.Mesh(geometry, material);\n\n\n当你ShaderMaterial的时候，threejs会在内部把内置变量position与几何体的顶点位置数据geometry.attributes.position关联起来。这意味着，你在顶点着色器代码中访问变量position，就相当于获取了几何体顶点位置数据geometry.attributes.position\n\n\nconst vertexShader = `\n// attribute vec3 position;//默认提供,不用自己写\nvoid main(){\n    gl_Position = vec4(...,1.0 );\n}\n`\n\n\n总而言之，你可以通过执行代码gl_Position = vec4(position,1.0);，把几何体的顶点位置数据geometry.attributes.position赋值给内置变量gl_Position\n\nconst vertexShader = `\n// attribute vec3 position;//默认提供,不用自己写\nvoid main(){\n    gl_Position = vec4(position,1.0 );\n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n});\n\n\n\n# 知识回顾：顶点矩阵变换\n\n如果你对矩阵变换的知识点完全不了解，可以去看看前面threejs进阶部分关于矩阵的讲解。\n\nconst vertexShader = `\nvoid main(){\n    // 通过矩阵对顶点坐标进行几何变换(旋转、缩放、平移)\n    gl_Position = 矩阵 * vec4(position,1.0 );\n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n});\n\n\n\n# 着色器GLSL ES语言语法：uniform关键字\n\nuniform是着色器GLSL ES语言语言的一个关键字，用来声明非顶点的变量(顶点变量用atribute声明)，比如模型的矩阵、光源位置等等。\n\n执行uniform mat4 mT;意味着，你通过关键字uniform声明一个变量mT，变量mT的数据类型是mat4(4x4的矩阵)。\n\nconst vertexShader = `\nuniform mat4 mT;\nvoid main(){\n    gl_Position = mT * vec4(position,1.0 );\n}\n`\n\n\n假设mT是一个平移矩阵，mT * vec4(position,1.0 )就可以平移几何体的顶点位置position。\n\n\n\n\n# 知识点回顾：世界矩阵.matrixWorld\n\n当网格模型mesh自身或父对象平移、旋转、缩放时候，会改变自身的世界矩阵属性mesh.matrixWorld，换句话说，就是threejs内部会用世界矩阵.matrixWorld记录mesh的位置、尺寸和姿态角度变化。\n\nconst mesh = new THREE.Mesh(geometry, material);\nmesh.position.set(100,0,0);//平移改变位置\nmesh.scale.set(3,3,3,);//缩放改变尺寸\nmesh.rotateY(Math.PI / 2);//旋转改变姿态角度\n\n\n关于模型世界矩阵mesh.matrixWorld更多内容可以参考前面课程5.5 模型本地矩阵、世界矩阵\n\n\n# 内置变量模型矩阵modelMatrix\n\n调用shader材质ShaderMaterial的时候，threejs会在内部给你写的顶点着色器代码中，插入一行代码uniform mat4 modelMatrix;，这意味着帮你声明了一个变量modelMatrix，modelMatrix在这里表示4x4的模型矩阵mat4。\n\nconst vertexShader = `\nuniform mat4 modelMatrix;//默认提供,不用自己写\nvoid main(){\n    gl_Position = vec4(...,1.0 );\n}\n`\n\n\n使用ShaderMaterial的时候，threejs会自动获取模型世界矩阵mesh.matrixWorld的值，赋值给变量modelMatrix。这意味着，模型矩阵modelMatrix包含了模型自身的位置、缩放、姿态角度信息。\n\n你当平移、旋转、缩放mesh时候，会改变mesh的世界矩阵属性.matrixWorld，自然同步改变顶点着色器的模型矩阵modelMatrix变量。\n\nconst mesh = new THREE.Mesh(geometry, material);\nmesh.position.set(100,0,0);\nmesh.rotateY(Math.PI / 2);\n\n\n在顶点着色器代码中，你可以直接使用modelMatrix对几何体顶点位置坐标进行旋转、缩放、平移。\n\nconst vertexShader = `\n// uniform mat4 modelMatrix;//默认提供,不用自己写\nvoid main(){\n    // 模型矩阵 * 顶点坐标\n    gl_Position = modelMatrix * vec4(position,1.0 );\n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n});\n\n\n\n# 知识回顾：视图矩阵和投影矩阵\n\n通过基础课程的学习大家都知道，当你改变相机的参数的时候，场景中模型Mesh渲染位置、尺寸、角度可能会发生变化。其实原因很简单，threejs内部会把相机的参数生成矩阵，对模型的顶点进行矩阵变换。\n\nconst width = window.innerWidth;\nconst height = window.innerHeight;\nconst camera = new THREE.PerspectiveCamera(30, width / height, 1, 3000);\ncamera.position.set(292, 223, 185);\ncamera.lookAt(0, 0, 0);\n\n\n前面进阶课程5.6. 视图矩阵、投影矩阵，给大家介绍过，threejs会读取相机的参数生成两个矩阵，也就是视图矩阵camera.matrixWorldInverse和投影矩阵camera.projectionMatrix。\n\n\n# 内置变量:视图矩阵viewMatrix和投影矩阵projectionMatrix\n\n刚才给大家介绍过ShaderMaterial的一个内置变量是模型矩阵modelMatrix。\n\nconst vertexShader = `\nuniform mat4 modelMatrix;//默认提供,不用自己写\nvoid main(){\n    gl_Position = modelMatrix * vec4(position,1.0 );\n}\n`\n\n\n使用ShaderMaterial的时候，除了内置变量模型矩阵modelMatrix，threejs内部还提供了两个内置的矩阵变量，这两个内置变量分别是相机的视图矩阵viewMatrix、投影矩阵projectionMatrix。viewMatrix的值来自相机视图矩阵属性camera.matrixWorldInverse，projectionMatrix的值来自相机的投影矩阵属性camera.projectionMatrix。\n\n视图矩阵viewMatrix和投影矩阵projectionMatrix因为是内置变量，同样不用声明你就可以直接使用。\n\nconst vertexShader = `\nuniform mat4 modelMatrix;//默认提供,不用自己写\nuniform mat4 viewMatrix;//默认提供,不用自己写\nuniform mat4 projectionMatrix;//默认提供,不用自己写\nvoid main(){\n    // 投影矩阵 * 视图矩阵 * 模型矩阵 * 顶点坐标\n    // 注意矩阵乘法前后顺序不要写错\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position,1.0 );\n}\n`\n\n\n通过viewMatrix和projectionMatrix来表示相机对场景模型的旋转、缩放、平移变换。\n\n\n# 设置片元着色器代码fragmentShader\n\nfragmentShader表示ShaderMaterial的片元着色器属性。\n\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n    ...\n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n    fragmentShader: fragmentShader,// 片元着色器\n});\n\n\ngl_FragColor和gl_Position一样是着色器GLSL ES语言的内置变量，不用声明，就可以在代码中使用。\n\n你可以通过gl_FragColor设置ShaderMaterial相关模型的颜色值。\n\n着色器内置变量gl_FragColor数据类型是四维向量vec4，可以用函数vec4()创建,vec4()有四个参数，每个参数都是浮点数float\n\ngl_FragColor的值,前面三个参数表示像素的RGB值，第四个参数表示透明度，不透明就是1.0。\n\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n    // RGB 0.0,1.0,1.0对应16进制颜色是0x00ffff\n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n    fragmentShader: fragmentShader,// 片元着色器\n});\n\n\n\n# 体验测试\n\n你可以平移网格模型mesh.position.x = 100;，然后比较下顶点着色器使用modelMatrix和不使用modelMatrix的差异。\n\n你可以发现modelMatrix包含了你的平移变换mesh.position.x = 100;。\n\n// 投影矩阵 * 视图矩阵 * 模型矩阵 * 模型顶点坐标\ngl_Position = projectionMatrix*viewMatrix*modelMatrix*vec4( position, 1.0 );\n\n\nmesh.position.x = 100;\n\n\n改变模型的颜色值\n\n// 青色\ngl_FragColor = vec4(0.0,1.0,1.0,1.0);\n// 红色\ngl_FragColor = vec4(1.0,0.0,0.0,1.0);\n\n\n\n# 内置变量：模型视图矩阵\n\nShaderMaterial还提供了一个内置变量模型视图矩阵modelViewMatrix，就是视图矩阵viewMatrix和模型矩阵modelMatrix的乘积。\n\nconst vertexShader = `\n//模型视图矩阵\nuniform mat4 modelViewMatrix;//默认提供,不用自己写\nvoid main(){\n    // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n    gl_Position = projectionMatrix*modelViewMatrix*vec4( position, 1.0 );\n}\n`\n\n\n你可以把上面代码viewMatrix*modelMatrix简化为modelViewMatrix。\n\n// 投影矩阵 * 视图矩阵 * 模型矩阵 * 模型顶点坐标\ngl_Position = projectionMatrix*viewMatrix*modelMatrix*vec4( position, 1.0 );\n\n\n// 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\ngl_Position = projectionMatrix*modelViewMatrix*vec4( position, 1.0 );\n",normalizedContent:"# shadermaterial着色器材质\n\n原来给大家介绍过threejs的各种材质，比如meshbasicmaterial、meshlambertmaterial...，对于这些材质，你可以通过color、map等属性直接设置物体的外观。\n\nconst material = new three.meshbasicmaterial({\n    color: 0x00ffff,//颜色\n    map:texture,//颜色贴图\n});\n\n\n这节课介绍一个特殊的threejs材质，就是shader材质类shadermaterial，单词shader就是着色器的意思，shadermaterial是通过着色器glsl es语言自定义材质效果，比如颜色。\n\n提醒：如果你图形学或数学的相关基础都不太好，建议本节课的视频和文档内容反复多看几遍。\n\n\n# .vertexshader和fragmentshader属性\n\n * .vertexshader：顶点着色器\n * .fragmentshader：片元着色器\n\n本节课主要重点学习shadermaterial的顶点着色器属性.vertexshader、片元着色器属性.fragmentshader。\n\nconst material = new three.shadermaterial({\n    vertexshader: '着色器代码',// 顶点着色器\n    fragmentshader: '着色器代码',// 片元着色器\n});\n\n\n\n# 使用shader材质shadermaterial\n\n打开本节课源码演示文件，你可以看到一个矩形网格模型mesh，mesh的材质是基础网格材质meshbasicmaterial。\n\nconst geometry = new three.planegeometry(100, 50);\nconst material = new three.meshbasicmaterial({\n    color: 0xff0000,\n});\nconst mesh = new three.mesh(geometry, material);\n\n\n使用shader材质shadermaterial代替meshbasicmaterial，外观效果，可以通过顶点着色器.vertexshader、片元着色器.fragmentshader实现。\n\n具体替换结果，你可以查看课件案例源码文件，打开测试效果，和演示文件对比下。\n\nconst geometry = new three.planegeometry(100, 50);\nconst material = new three.shadermaterial({\n    vertexshader: '...',// 顶点着色器\n    fragmentshader: '...',// 片元着色器\n});\nconst mesh = new three.mesh(geometry, material);\n\n\n\n# 设置顶点着色器vertexshader\n\nshadermaterial顶点着色器属性vertexshader的值是字符串，字符串的内容是着色器glsl es语言写的代码。关于着色器glsl es语言的语法可以参考前面课程1.2. 着色器glsl es语言的介绍。\n\nconst material = new three.shadermaterial({\n    vertexshader: '',// 顶点着色器\n});\n\n\n为了方便预览顶点着色器代码，咱们用模板字符串``的形式去写,模板字符串``的按键位于键盘tab键的上面。\n\nconst vertexshader = `\n    // 写顶点着色器的代码 \n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n});\n\n\n\n# 设置顶点着色器主函数\n\n先按照着色器glsl es语言的语法，给顶点着色器代码设置一个主函数main,函数main无返回值，前面加上关键字void即可。\n\nconst vertexshader = `\nvoid main(){\n    // 写顶点着色器的代码  \n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n});\n\n\n\n# 内置变量gl_position\n\ngl_position是着色器glsl es语言的内置变量，所谓内置变量，就是不用声明，就可以在代码中使用。\n\n着色器内置变量gl_position数据类型是四维向量vec4，可以用函数vec4()创建,vec4()有四个参数，每个参数都是浮点数float\n\ngl_position的值,前面三个参数表示xyz坐标，第四个参数一般固定设置为1.0。\n\nconst vertexshader = `\nvoid main(){\n    gl_position = vec4( x, y ,z ,1.0 );\n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n});\n\n\n不过一般不会通过gl_position直接写顶点坐标，而是从几何体buffergeometry获取顶点坐标数据，下面给大家讲解具体实现方式。\n\nconst vertexshader = `\nvoid main(){\n    gl_position = vec4(从几何体获取顶点xyz坐标,1.0 );\n}\n`\n\n\n\n# 着色器glsl es语言语法：attribute关键字\n\nattribute是着色器glsl es语言的一个关键字，按照glsl es的语法规定，attribute关键字一般用来声明与顶点数据有关变量。\n\nattribute vec3 pos;表示用attribute声明了一个变量pos，attribute的作用就是指明pos是顶点相关变量，pos的数类型是三维向量vec3，三维向量vec3意味着pos表示的顶点数据有x、y、z三个分量。比如你可以用pos表示顶点的位置数据xyz(当然也能表示其它类型顶点数据,遇到再讲解)。\n\nconst vertexshader = `\nattribute vec3 pos;//注意在主函数外面\nvoid main(){\n    gl_position = vec4(...,1.0 );\n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n});\n\n\n假设attribute声明的变量pos表示顶点位置数据，你就可以赋值给gl_position。\n\n执行vec4(pos,1.0 ),给三维向量vec3增加一个分量，就可以变成四维向量vec4(这是glsl es基本语法)。\n\nconst vertexshader = `\nattribute vec3 pos;\nvoid main(){\n    gl_position = vec4(pos,1.0 );\n}\n`\n\n\n\n# 知识回顾：几何体geometry的顶点位置数据\n\n知识回顾：基础课程中讲解过几何体buffergeometry的顶点知识\n\n访问geometry.attributes.position你可以看到几何体所有的顶点位置数据，这些位置数据包含在一个数组中，三个为一组表示一个顶点的x、y、z坐标。这里再强调一遍，threejs默认情况下，几何体的顶点位置数据中的每个顶点都包含x、y、z三个分量。\n\nconst geometry = new three.planegeometry(100, 50);\nconsole.log('顶点位置数据',geometry.attributes.position);\n\n\n\n# shadermaterial的内置变量position\n\n调用shader材质shadermaterial的时候，threejs会在内部给你写的顶点着色器代码中，插入一行代码attribute vec3 position;，相当于帮你声明了一个变量position，position表示顶点的位置数据\n\nconst vertexshader = `\nattribute vec3 position;//默认提供,不用自己写\nvoid main(){\n    gl_position = vec4(...,1.0 );\n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n});\n\n\n\n# 内置变量position含义\n\n查看案例代码，可以看到几何体geometry与shadermaterial材质构成了一个mesh。也就是说材质shadermaterial关联了几何体geometry。\n\nconst geometry = new three.planegeometry(100, 50);\nconsole.log('顶点位置数据',geometry.attributes.position);\nconst material = new three.shadermaterial();\nconst mesh = new three.mesh(geometry, material);\n\n\n当你shadermaterial的时候，threejs会在内部把内置变量position与几何体的顶点位置数据geometry.attributes.position关联起来。这意味着，你在顶点着色器代码中访问变量position，就相当于获取了几何体顶点位置数据geometry.attributes.position\n\n\nconst vertexshader = `\n// attribute vec3 position;//默认提供,不用自己写\nvoid main(){\n    gl_position = vec4(...,1.0 );\n}\n`\n\n\n总而言之，你可以通过执行代码gl_position = vec4(position,1.0);，把几何体的顶点位置数据geometry.attributes.position赋值给内置变量gl_position\n\nconst vertexshader = `\n// attribute vec3 position;//默认提供,不用自己写\nvoid main(){\n    gl_position = vec4(position,1.0 );\n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n});\n\n\n\n# 知识回顾：顶点矩阵变换\n\n如果你对矩阵变换的知识点完全不了解，可以去看看前面threejs进阶部分关于矩阵的讲解。\n\nconst vertexshader = `\nvoid main(){\n    // 通过矩阵对顶点坐标进行几何变换(旋转、缩放、平移)\n    gl_position = 矩阵 * vec4(position,1.0 );\n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n});\n\n\n\n# 着色器glsl es语言语法：uniform关键字\n\nuniform是着色器glsl es语言语言的一个关键字，用来声明非顶点的变量(顶点变量用atribute声明)，比如模型的矩阵、光源位置等等。\n\n执行uniform mat4 mt;意味着，你通过关键字uniform声明一个变量mt，变量mt的数据类型是mat4(4x4的矩阵)。\n\nconst vertexshader = `\nuniform mat4 mt;\nvoid main(){\n    gl_position = mt * vec4(position,1.0 );\n}\n`\n\n\n假设mt是一个平移矩阵，mt * vec4(position,1.0 )就可以平移几何体的顶点位置position。\n\n\n\n\n# 知识点回顾：世界矩阵.matrixworld\n\n当网格模型mesh自身或父对象平移、旋转、缩放时候，会改变自身的世界矩阵属性mesh.matrixworld，换句话说，就是threejs内部会用世界矩阵.matrixworld记录mesh的位置、尺寸和姿态角度变化。\n\nconst mesh = new three.mesh(geometry, material);\nmesh.position.set(100,0,0);//平移改变位置\nmesh.scale.set(3,3,3,);//缩放改变尺寸\nmesh.rotatey(math.pi / 2);//旋转改变姿态角度\n\n\n关于模型世界矩阵mesh.matrixworld更多内容可以参考前面课程5.5 模型本地矩阵、世界矩阵\n\n\n# 内置变量模型矩阵modelmatrix\n\n调用shader材质shadermaterial的时候，threejs会在内部给你写的顶点着色器代码中，插入一行代码uniform mat4 modelmatrix;，这意味着帮你声明了一个变量modelmatrix，modelmatrix在这里表示4x4的模型矩阵mat4。\n\nconst vertexshader = `\nuniform mat4 modelmatrix;//默认提供,不用自己写\nvoid main(){\n    gl_position = vec4(...,1.0 );\n}\n`\n\n\n使用shadermaterial的时候，threejs会自动获取模型世界矩阵mesh.matrixworld的值，赋值给变量modelmatrix。这意味着，模型矩阵modelmatrix包含了模型自身的位置、缩放、姿态角度信息。\n\n你当平移、旋转、缩放mesh时候，会改变mesh的世界矩阵属性.matrixworld，自然同步改变顶点着色器的模型矩阵modelmatrix变量。\n\nconst mesh = new three.mesh(geometry, material);\nmesh.position.set(100,0,0);\nmesh.rotatey(math.pi / 2);\n\n\n在顶点着色器代码中，你可以直接使用modelmatrix对几何体顶点位置坐标进行旋转、缩放、平移。\n\nconst vertexshader = `\n// uniform mat4 modelmatrix;//默认提供,不用自己写\nvoid main(){\n    // 模型矩阵 * 顶点坐标\n    gl_position = modelmatrix * vec4(position,1.0 );\n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n});\n\n\n\n# 知识回顾：视图矩阵和投影矩阵\n\n通过基础课程的学习大家都知道，当你改变相机的参数的时候，场景中模型mesh渲染位置、尺寸、角度可能会发生变化。其实原因很简单，threejs内部会把相机的参数生成矩阵，对模型的顶点进行矩阵变换。\n\nconst width = window.innerwidth;\nconst height = window.innerheight;\nconst camera = new three.perspectivecamera(30, width / height, 1, 3000);\ncamera.position.set(292, 223, 185);\ncamera.lookat(0, 0, 0);\n\n\n前面进阶课程5.6. 视图矩阵、投影矩阵，给大家介绍过，threejs会读取相机的参数生成两个矩阵，也就是视图矩阵camera.matrixworldinverse和投影矩阵camera.projectionmatrix。\n\n\n# 内置变量:视图矩阵viewmatrix和投影矩阵projectionmatrix\n\n刚才给大家介绍过shadermaterial的一个内置变量是模型矩阵modelmatrix。\n\nconst vertexshader = `\nuniform mat4 modelmatrix;//默认提供,不用自己写\nvoid main(){\n    gl_position = modelmatrix * vec4(position,1.0 );\n}\n`\n\n\n使用shadermaterial的时候，除了内置变量模型矩阵modelmatrix，threejs内部还提供了两个内置的矩阵变量，这两个内置变量分别是相机的视图矩阵viewmatrix、投影矩阵projectionmatrix。viewmatrix的值来自相机视图矩阵属性camera.matrixworldinverse，projectionmatrix的值来自相机的投影矩阵属性camera.projectionmatrix。\n\n视图矩阵viewmatrix和投影矩阵projectionmatrix因为是内置变量，同样不用声明你就可以直接使用。\n\nconst vertexshader = `\nuniform mat4 modelmatrix;//默认提供,不用自己写\nuniform mat4 viewmatrix;//默认提供,不用自己写\nuniform mat4 projectionmatrix;//默认提供,不用自己写\nvoid main(){\n    // 投影矩阵 * 视图矩阵 * 模型矩阵 * 顶点坐标\n    // 注意矩阵乘法前后顺序不要写错\n    gl_position = projectionmatrix * viewmatrix * modelmatrix * vec4(position,1.0 );\n}\n`\n\n\n通过viewmatrix和projectionmatrix来表示相机对场景模型的旋转、缩放、平移变换。\n\n\n# 设置片元着色器代码fragmentshader\n\nfragmentshader表示shadermaterial的片元着色器属性。\n\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n    ...\n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n    fragmentshader: fragmentshader,// 片元着色器\n});\n\n\ngl_fragcolor和gl_position一样是着色器glsl es语言的内置变量，不用声明，就可以在代码中使用。\n\n你可以通过gl_fragcolor设置shadermaterial相关模型的颜色值。\n\n着色器内置变量gl_fragcolor数据类型是四维向量vec4，可以用函数vec4()创建,vec4()有四个参数，每个参数都是浮点数float\n\ngl_fragcolor的值,前面三个参数表示像素的rgb值，第四个参数表示透明度，不透明就是1.0。\n\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n    // rgb 0.0,1.0,1.0对应16进制颜色是0x00ffff\n    gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n    fragmentshader: fragmentshader,// 片元着色器\n});\n\n\n\n# 体验测试\n\n你可以平移网格模型mesh.position.x = 100;，然后比较下顶点着色器使用modelmatrix和不使用modelmatrix的差异。\n\n你可以发现modelmatrix包含了你的平移变换mesh.position.x = 100;。\n\n// 投影矩阵 * 视图矩阵 * 模型矩阵 * 模型顶点坐标\ngl_position = projectionmatrix*viewmatrix*modelmatrix*vec4( position, 1.0 );\n\n\nmesh.position.x = 100;\n\n\n改变模型的颜色值\n\n// 青色\ngl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n// 红色\ngl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n\n\n\n# 内置变量：模型视图矩阵\n\nshadermaterial还提供了一个内置变量模型视图矩阵modelviewmatrix，就是视图矩阵viewmatrix和模型矩阵modelmatrix的乘积。\n\nconst vertexshader = `\n//模型视图矩阵\nuniform mat4 modelviewmatrix;//默认提供,不用自己写\nvoid main(){\n    // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n    gl_position = projectionmatrix*modelviewmatrix*vec4( position, 1.0 );\n}\n`\n\n\n你可以把上面代码viewmatrix*modelmatrix简化为modelviewmatrix。\n\n// 投影矩阵 * 视图矩阵 * 模型矩阵 * 模型顶点坐标\ngl_position = projectionmatrix*viewmatrix*modelmatrix*vec4( position, 1.0 );\n\n\n// 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\ngl_position = projectionmatrix*modelviewmatrix*vec4( position, 1.0 );\n",charsets:{cjk:!0}},{title:"5. uniform变量传值",frontmatter:{title:"5. uniform变量传值",date:"2023-10-23T22:44:10.000Z",permalink:"/pages/2c9721/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/05.uniform%E5%8F%98%E9%87%8F%E4%BC%A0%E5%80%BC.html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/05.uniform变量传值.md",key:"v-1e96b2cc",path:"/pages/2c9721/",headers:[{level:3,title:"1. uniform声明变量",slug:"_1-uniform声明变量",normalizedTitle:"1. uniform声明变量",charIndex:119},{level:3,title:"2. 给uniform变量传值",slug:"_2-给uniform变量传值",normalizedTitle:"2. 给uniform变量传值",charIndex:377},{level:3,title:"3. uniform变量赋值给gl_FragColor",slug:"_3-uniform变量赋值给gl-fragcolor",normalizedTitle:"3. uniform变量赋值给gl_fragcolor",charIndex:977},{level:3,title:"练习：uniform传值颜色数据",slug:"练习-uniform传值颜色数据",normalizedTitle:"练习：uniform传值颜色数据",charIndex:1484},{level:3,title:"测试：改变uniforms数据",slug:"测试-改变uniforms数据",normalizedTitle:"测试：改变uniforms数据",charIndex:2424}],headersStr:"1. uniform声明变量 2. 给uniform变量传值 3. uniform变量赋值给gl_FragColor 练习：uniform传值颜色数据 测试：改变uniforms数据",content:"# uniform变量传值\n\n在给shader材质ShaderMaterial自定义着色器GLSL ES代码的时候，有时候会用uniform关键字声明一个变量，这节课给大家讲解，threejs怎么给uniform声明的变量传值。\n\n\n# 1. uniform声明变量\n\n使用着色器GLSL ES语言的关键字uniform声明一个透明度变量opacity，opacity的数据类型设置为浮点数float，透明度变量名字你可以自定义，这里命名为opacity。\n\n// 片元着色器代码\nconst fragmentShader = `\nuniform float opacity;//uniform声明透明度变量opacity\nvoid main() {\n    gl_FragColor = vec4(0.0,1.0,1.0,0.3);\n}\n`\n\n\n\n# 2. 给uniform变量传值\n\n通过ShaderMaterial参数的uniforms属性，可以给顶点或片元着色器中的uniform变量传值。\n\n比如下面片元着色器代码中，有一个uniform变量名称是opacity,ShaderMaterial的uniforms也有一个同名的属性opacity。这样的话，threejs会把uniforms中opacity的值传值片元着色器中同名uniform变量opacity\n\nconst fragmentShader = `\nuniform float opacity;//uniform声明透明度变量opacity\nvoid main() {\n    gl_FragColor = vec4(0.0,1.0,1.0,0.3);\n}\n`\nconst material = new THREE.ShaderMaterial({\n  uniforms: {\n    // 给透明度uniform变量opacity传值\n    opacity:{value:0.3}\n  },\n  vertexShader: vertexShader,// 顶点着色器\n  fragmentShader: fragmentShader,// 片元着色器\n  side: THREE.DoubleSide,\n  transparent: true,//允许透明\n});\n\n\n\n# 3. uniform变量赋值给gl_FragColor\n\n把uniform变量透明度opacity赋值给gl_FragColor，查看渲染效果(注意允许透明transparent: true)。\n\n// 片元着色器代码\nconst fragmentShader = `\nuniform float opacity;//uniform声明透明度变量opacity\nvoid main() {\n    gl_FragColor = vec4(0.0,1.0,1.0,opacity);\n}\n`\nconst material = new THREE.ShaderMaterial({\n  uniforms: {\n    // 给透明度uniform变量opacity传值\n    opacity:{value:0.3}\n  },\n  vertexShader: vertexShader,\n  fragmentShader: fragmentShader,// 片元着色器\n  transparent: true,//允许透明\n});\n\n\n你可以uniforms里面opacity的值改为其他值，查看效果变化。\n\n\n# 练习：uniform传值颜色数据\n\n通过上面学习，你可以做一个练习题，就是用uniform声明一个颜色变量color，然后，用uniforms给uniform变量颜色color传值。\n\n// 片元着色器代码\nconst fragmentShader = `\nuniform float opacity;//uniform声明变量opacity表示透明度\nuniform vec3 color;//声明一个颜色变量color\nvoid main() {\n    gl_FragColor = vec4(color,opacity);\n}\n`\nconst geometry = new THREE.PlaneGeometry(100, 50);\nconst material = new THREE.ShaderMaterial({\n  uniforms: {\n    // 给透明度uniform变量opacity传值\n    opacity: { value: 0.3 },\n    // 给uniform同名color变量传值\n    color:{value:new THREE.Color(0x00ffff)}\n  },\n  vertexShader: vertexShader,// 顶点着色器\n  fragmentShader: fragmentShader,// 片元着色器\n  side: THREE.DoubleSide,\n  transparent: true,//允许透明\n});\n\n\n\n注意着色器语言GLSL ES中uniform变量数据类型，与threejs中uniforms属性value值的对应关系。\n\nUNIFORM变量数据类型   UNIFORMS属性数据\nfloat           Number\nvec2            THREE.Vector2\nvec3            THREE.Vector3\nvec3            THREE.Color\nvec4            THREE.Vector4\n\n更多uniform与GLSL数据类型对应关系，可以查看threejs文档关于的Uniform介绍\n\n\n# 测试：改变uniforms数据\n\n你改变uniforms里面一些属性的值，ShaderMaterial着色器中同名uniform变量会跟着改变，进而影响threejs渲染效果，你可以改变下面属性进行测试。\n\nmaterial.uniforms.opacity.value = 0.2;\nmaterial.uniforms.color.value.set(0xff0000);\n",normalizedContent:"# uniform变量传值\n\n在给shader材质shadermaterial自定义着色器glsl es代码的时候，有时候会用uniform关键字声明一个变量，这节课给大家讲解，threejs怎么给uniform声明的变量传值。\n\n\n# 1. uniform声明变量\n\n使用着色器glsl es语言的关键字uniform声明一个透明度变量opacity，opacity的数据类型设置为浮点数float，透明度变量名字你可以自定义，这里命名为opacity。\n\n// 片元着色器代码\nconst fragmentshader = `\nuniform float opacity;//uniform声明透明度变量opacity\nvoid main() {\n    gl_fragcolor = vec4(0.0,1.0,1.0,0.3);\n}\n`\n\n\n\n# 2. 给uniform变量传值\n\n通过shadermaterial参数的uniforms属性，可以给顶点或片元着色器中的uniform变量传值。\n\n比如下面片元着色器代码中，有一个uniform变量名称是opacity,shadermaterial的uniforms也有一个同名的属性opacity。这样的话，threejs会把uniforms中opacity的值传值片元着色器中同名uniform变量opacity\n\nconst fragmentshader = `\nuniform float opacity;//uniform声明透明度变量opacity\nvoid main() {\n    gl_fragcolor = vec4(0.0,1.0,1.0,0.3);\n}\n`\nconst material = new three.shadermaterial({\n  uniforms: {\n    // 给透明度uniform变量opacity传值\n    opacity:{value:0.3}\n  },\n  vertexshader: vertexshader,// 顶点着色器\n  fragmentshader: fragmentshader,// 片元着色器\n  side: three.doubleside,\n  transparent: true,//允许透明\n});\n\n\n\n# 3. uniform变量赋值给gl_fragcolor\n\n把uniform变量透明度opacity赋值给gl_fragcolor，查看渲染效果(注意允许透明transparent: true)。\n\n// 片元着色器代码\nconst fragmentshader = `\nuniform float opacity;//uniform声明透明度变量opacity\nvoid main() {\n    gl_fragcolor = vec4(0.0,1.0,1.0,opacity);\n}\n`\nconst material = new three.shadermaterial({\n  uniforms: {\n    // 给透明度uniform变量opacity传值\n    opacity:{value:0.3}\n  },\n  vertexshader: vertexshader,\n  fragmentshader: fragmentshader,// 片元着色器\n  transparent: true,//允许透明\n});\n\n\n你可以uniforms里面opacity的值改为其他值，查看效果变化。\n\n\n# 练习：uniform传值颜色数据\n\n通过上面学习，你可以做一个练习题，就是用uniform声明一个颜色变量color，然后，用uniforms给uniform变量颜色color传值。\n\n// 片元着色器代码\nconst fragmentshader = `\nuniform float opacity;//uniform声明变量opacity表示透明度\nuniform vec3 color;//声明一个颜色变量color\nvoid main() {\n    gl_fragcolor = vec4(color,opacity);\n}\n`\nconst geometry = new three.planegeometry(100, 50);\nconst material = new three.shadermaterial({\n  uniforms: {\n    // 给透明度uniform变量opacity传值\n    opacity: { value: 0.3 },\n    // 给uniform同名color变量传值\n    color:{value:new three.color(0x00ffff)}\n  },\n  vertexshader: vertexshader,// 顶点着色器\n  fragmentshader: fragmentshader,// 片元着色器\n  side: three.doubleside,\n  transparent: true,//允许透明\n});\n\n\n\n注意着色器语言glsl es中uniform变量数据类型，与threejs中uniforms属性value值的对应关系。\n\nuniform变量数据类型   uniforms属性数据\nfloat           number\nvec2            three.vector2\nvec3            three.vector3\nvec3            three.color\nvec4            three.vector4\n\n更多uniform与glsl数据类型对应关系，可以查看threejs文档关于的uniform介绍\n\n\n# 测试：改变uniforms数据\n\n你改变uniforms里面一些属性的值，shadermaterial着色器中同名uniform变量会跟着改变，进而影响threejs渲染效果，你可以改变下面属性进行测试。\n\nmaterial.uniforms.opacity.value = 0.2;\nmaterial.uniforms.color.value.set(0xff0000);\n",charsets:{cjk:!0}},{title:"4. ShaderMaterial半透明、双面显示",frontmatter:{title:"4. ShaderMaterial半透明、双面显示",date:"2023-10-23T22:44:03.000Z",permalink:"/pages/8142c3/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/04.ShaderMaterial%E5%8D%8A%E9%80%8F%E6%98%8E%E3%80%81%E5%8F%8C%E9%9D%A2%E6%98%BE%E7%A4%BA.html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/04.ShaderMaterial半透明、双面显示.md",key:"v-3c4463d4",path:"/pages/8142c3/",headers:[{level:3,title:"知识回顾",slug:"知识回顾",normalizedTitle:"知识回顾",charIndex:78},{level:3,title:"知识回顾：.side属性",slug:"知识回顾-side属性",normalizedTitle:"知识回顾：.side属性",charIndex:572},{level:3,title:"ShaderMaterial属性.side",slug:"shadermaterial属性-side",normalizedTitle:"shadermaterial属性.side",charIndex:734},{level:3,title:"知识回顾：MeshBasicMaterial设置半透明效果",slug:"知识回顾-meshbasicmaterial设置半透明效果",normalizedTitle:"知识回顾：meshbasicmaterial设置半透明效果",charIndex:1054},{level:3,title:"ShaderMaterial设置半透明效果",slug:"shadermaterial设置半透明效果",normalizedTitle:"shadermaterial设置半透明效果",charIndex:1207}],headersStr:"知识回顾 知识回顾：.side属性 ShaderMaterial属性.side 知识回顾：MeshBasicMaterial设置半透明效果 ShaderMaterial设置半透明效果",content:"# ShaderMaterial半透明、双面显示\n\n这节课给大家演示下，shader材质ShaderMaterial怎么设置双面显示、半透明效果。\n\n\n# 知识回顾\n\n查看上节代码效果，你可以看出来通过ShaderMaterial自定义着色器GLSL ES代码，实现了类似基础网材质MeshBasicMaterial的效果。\n\nconst material = new THREE.MeshBasicMaterial({\n    color: 0x00ffff,\n});\n\n\nconst vertexShader = `\nvoid main(){\n  gl_Position = projectionMatrix*modelViewMatrix*vec4( position, 1.0 );\n}\n`\nconst fragmentShader = `\nvoid main() {\n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n}\n`\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n    fragmentShader: fragmentShader,// 片元着色器\n});\n\n\n\n# 知识回顾：.side属性\n\n默认单面显示，设置side:THREE.DoubleSide改为双面显示。\n\nconst material = new THREE.MeshBasicMaterial({\n    color: 0x00ffff,\n    side:THREE.DoubleSide//双面显示\n});\n\n\n\n# ShaderMaterial属性.side\n\nShaderMaterial和MeshBasicMaterial一样可以从父类Material继承.side属性，通过.side属性可以设置网格模型Mesh的两面如何显示。\n\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    side: THREE.DoubleSide//双面显示\n});\n\n\n这时候你会发现ShaderMaterial和MeshBasicMaterial可以实现一样的双面显示效果。\n\n\n# 知识回顾：MeshBasicMaterial设置半透明效果\n\nconst material = new THREE.MeshBasicMaterial({\n  color: 0x00ffff,\n  transparent: true,//允许透明\n  opacity:0.3,//透明度\n});\n\n\n\n# ShaderMaterial设置半透明效果\n\n通过片元着色器代码设置ShaderMaterial透明度，更改内置变量gl_FragColor的第四个分量即可。\n\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n    //透明度1.0不透明\n    // gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n    //透明度设置0.3，在0~1之间，半透明\n    gl_FragColor = vec4(0.0,1.0,1.0,0.3);\n}\n`\nconst geometry = new THREE.PlaneGeometry(100, 50);\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,// 顶点着色器\n    fragmentShader: fragmentShader,// 片元着色器\n});\n\n\nshader材质ShaderMaterial设置transparent:true,允许透明度计算，gl_FragColor = vec4(0.0,1.0,1.0,0.3)设置的半透明效果才会生效。\n\nconst material = new THREE.ShaderMaterial({\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    side: THREE.DoubleSide//双面显示\n});\n",normalizedContent:"# shadermaterial半透明、双面显示\n\n这节课给大家演示下，shader材质shadermaterial怎么设置双面显示、半透明效果。\n\n\n# 知识回顾\n\n查看上节代码效果，你可以看出来通过shadermaterial自定义着色器glsl es代码，实现了类似基础网材质meshbasicmaterial的效果。\n\nconst material = new three.meshbasicmaterial({\n    color: 0x00ffff,\n});\n\n\nconst vertexshader = `\nvoid main(){\n  gl_position = projectionmatrix*modelviewmatrix*vec4( position, 1.0 );\n}\n`\nconst fragmentshader = `\nvoid main() {\n    gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n}\n`\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n    fragmentshader: fragmentshader,// 片元着色器\n});\n\n\n\n# 知识回顾：.side属性\n\n默认单面显示，设置side:three.doubleside改为双面显示。\n\nconst material = new three.meshbasicmaterial({\n    color: 0x00ffff,\n    side:three.doubleside//双面显示\n});\n\n\n\n# shadermaterial属性.side\n\nshadermaterial和meshbasicmaterial一样可以从父类material继承.side属性，通过.side属性可以设置网格模型mesh的两面如何显示。\n\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,\n    fragmentshader: fragmentshader,\n    side: three.doubleside//双面显示\n});\n\n\n这时候你会发现shadermaterial和meshbasicmaterial可以实现一样的双面显示效果。\n\n\n# 知识回顾：meshbasicmaterial设置半透明效果\n\nconst material = new three.meshbasicmaterial({\n  color: 0x00ffff,\n  transparent: true,//允许透明\n  opacity:0.3,//透明度\n});\n\n\n\n# shadermaterial设置半透明效果\n\n通过片元着色器代码设置shadermaterial透明度，更改内置变量gl_fragcolor的第四个分量即可。\n\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n    //透明度1.0不透明\n    // gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n    //透明度设置0.3，在0~1之间，半透明\n    gl_fragcolor = vec4(0.0,1.0,1.0,0.3);\n}\n`\nconst geometry = new three.planegeometry(100, 50);\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,// 顶点着色器\n    fragmentshader: fragmentshader,// 片元着色器\n});\n\n\nshader材质shadermaterial设置transparent:true,允许透明度计算，gl_fragcolor = vec4(0.0,1.0,1.0,0.3)设置的半透明效果才会生效。\n\nconst material = new three.shadermaterial({\n    vertexshader: vertexshader,\n    fragmentshader: fragmentshader,\n    side: three.doubleside//双面显示\n});\n",charsets:{cjk:!0}},{title:"6. WebGL渲染管线",frontmatter:{title:"6. WebGL渲染管线",date:"2023-10-23T22:44:18.000Z",permalink:"/pages/21c48e/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/06.WebGL%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/06.WebGL渲染管线.md",key:"v-58412606",path:"/pages/21c48e/",headers:[{level:3,title:"知识回顾：三角形和几何体顶点",slug:"知识回顾-三角形和几何体顶点",normalizedTitle:"知识回顾：三角形和几何体顶点",charIndex:116},{level:3,title:"显卡GPU：执行着色器代码",slug:"显卡gpu-执行着色器代码",normalizedTitle:"显卡gpu：执行着色器代码",charIndex:849},{level:3,title:"显卡内存(显存)",slug:"显卡内存-显存",normalizedTitle:"显卡内存(显存)",charIndex:1051},{level:3,title:"WebGL渲染管线",slug:"webgl渲染管线-2",normalizedTitle:"webgl渲染管线",charIndex:2},{level:3,title:"ShaderMaterial代码执行过程",slug:"shadermaterial代码执行过程",normalizedTitle:"shadermaterial代码执行过程",charIndex:1380},{level:3,title:"WebGL渲染管线执行过程",slug:"webgl渲染管线执行过程",normalizedTitle:"webgl渲染管线执行过程",charIndex:2077},{level:3,title:"顶点着色器：逐顶点概念",slug:"顶点着色器-逐顶点概念",normalizedTitle:"顶点着色器：逐顶点概念",charIndex:2263},{level:3,title:"图元装配、光栅化",slug:"图元装配、光栅化",normalizedTitle:"图元装配、光栅化",charIndex:2582},{level:3,title:"片元着色器：逐片元概念",slug:"片元着色器-逐片元概念",normalizedTitle:"片元着色器：逐片元概念",charIndex:2758}],headersStr:"知识回顾：三角形和几何体顶点 显卡GPU：执行着色器代码 显卡内存(显存) WebGL渲染管线 ShaderMaterial代码执行过程 WebGL渲染管线执行过程 顶点着色器：逐顶点概念 图元装配、光栅化 片元着色器：逐片元概念",content:"# WebGL渲染管线\n\n本节课主要是结合前面写过的ShaderMaterial代码，科普下WebGL渲染管线概念，这样有助于后续的课程学习，你跟着视频过一遍就行，如果你有些名词概念你比较陌生，也不用深究，先大概有个印象。\n\n\n# 知识回顾：三角形和几何体顶点\n\n你可以回顾下，基础课程中章节2关于BufferGeometry的知识点。网格模型是由三角形拼接而成，每个三角形包含三个顶点，这些三角形顶点的数据包含在Mesh对应的几何体中BufferGeometry\n\n\n\n课件演示文件中直接使用的threejs自带矩形平面几何体。\n\nconst geometry = new THREE.PlaneGeometry(100, 50);\n\n\n然后你自己做一个练习，把演示文件中PlaneGeometry替换为你自定义顶点的矩形平面,加深下印象，Mesh一般通过三角形组成，三角形有自己顶点坐标。\n\nconst geometry = new THREE.BufferGeometry(); //创建一个几何体对象\n//类型数组创建顶点数据\nconst vertices = new Float32Array([\n  // 三角形1顶点坐标\n  -50, -25, 0, //顶点1坐标\n  50, -25, 0, //顶点2坐标\n  50, 25, 0, //顶点3坐标\n  // 三角形2顶点坐标\n  -50, -25, 0, //顶点4坐标   和顶点1位置相同\n  50, 25, 0, //顶点5坐标  和顶点3位置相同\n  -50, 25, 0, //顶点6坐标\n]);\nconst attribute = new THREE.BufferAttribute(vertices, 3); //3个为一组，表示一个顶点的xyz坐标\n// 设置几何体顶点位置.attributes.position\ngeometry.attributes.position = attribute;\n\n\n\n\n# 显卡GPU：执行着色器代码\n\n你稍微有点电脑常识，应该都知道电脑除了CPU处理器，还有一个GPU图形处理器。\n\n你平时写的JavaScript代码会在CPU上执行，而你写的着色器GLSL ES代码是在你显卡的GPU上执行。\n\n\n\n也就是3D渲染依赖于你电脑上的显卡GPU，一般来说，你渲染的3D场景越复杂，对显卡要求越高，比如一些大场景的物联网、数字孪生项目，往往需要配置一个比较好的独立显卡。\n\n\n# 显卡内存(显存)\n\n你电脑上显卡除了GPU，还有GPU对应的内存，也就是显存，在显卡GPU渲染3D场景的时候，会把相关的顶点、纹理图像等数据存储在显存上。\n\n\n\n你在购买显卡的时候，一般会看到商品标注的显存容量参数。\n\n\n\n\n# WebGL渲染管线\n\n如果你有WebGL基础，对WebGL渲染管线肯定不陌生，当然你不了解WebGL也没关系，咱们会后续课程会结合threejs代码给你从零介绍WebGL渲染管线。\n\n你可以把WebGL渲染管线想象为你显卡上的一条工厂流水线，工厂流水线有不同的工位，渲染管线也是如此，渲染管线上有多个不同的功能单元。\n\n\n\n提醒：渲染管线内容比较多，本节课跟着下面内容，先了解渲染管线小部分功能单元即可，不用全部记住。\n\n\n# ShaderMaterial代码执行过程\n\n这是前面咱们经常写的ShaderMaterial代码。\n\n// 顶点着色器代码\nconst vertexShader = `\nvoid main(){\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_Position = projectionMatrix*modelViewMatrix*vec4( position, 1.0 );\n}\n`\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n}\n`\nconst material = new THREE.ShaderMaterial({\n  vertexShader: vertexShader,// 顶点着色器\n  fragmentShader: fragmentShader,// 片元着色器\n});\nconst mesh = new THREE.Mesh(geometry, material);\nexport default mesh;\n\n\n当threejs通过WebGL渲染器WebGLRenderer渲染的时候，会做下面几件事：\n\n 1. 从几何体BufferGeometry中获取顶点数据，把这些顶点数据存入显存上创建的顶点缓冲区。\n 2. 顶点着色器功能单元，会执行顶点着色器GLSL ES代码，对这些顶点进行几何体变换(旋转、缩放、平移)\n 3. 片元着色器功能单元，会执行片元着色器GLSL ES代码，设置颜色值。\n\n\n\n\n# WebGL渲染管线执行过程\n\n下面给大家详细说明下，顶点着色器到片元着色器的处理可成。\n\n\n\n 1. 顶点缓冲区：顶点数据\n 2. 顶点着色器：顶点变换\n 3. 图元装配：比如渲染Mesh，Mesh几何体有多个三角形拼接，三个点为一组生成一个三角形\n 4. 光栅化：比如在上一步三角形轮廓中，生成填充一个一个片元(像素)\n 5. 片元着色器：给片元(像素)着色器\n\n\n# 顶点着色器：逐顶点概念\n\n\n\n渲染管线上顶点着色器的功能就是执行顶点着色器代码,根据你写的代码对几何体顶点数据进行处理。比如本节课案例源码，就是通过矩阵对顶点进行几何体变换(平移、旋转、缩放)。\n\n这个过程是逐顶点操作的，你把每个顶点数据想象成流水线上的一个一个零件，每个顶点经过顶点着色器功能单元时候，都会倍顶点着色器处理，比如几何变换。\n\n// 顶点着色器代码\nconst vertexShader = `\nvoid main(){\n  // 对每个顶点坐标进行矩阵变换\n  gl_Position = projectionMatrix*modelViewMatrix*vec4( position, 1.0 );\n}\n`\n\n\n\n# 图元装配、光栅化\n\n经过顶点着色器处理的顶点数据，会进入WebGL渲染管线下一个环节，也就是图元装配，比如渲染Mesh，图元装配时候，就会把三个点为一组生成一个三角形轮廓，接着就是光栅化，在上一步三角形轮廓内生成一个个片元，填充三角形轮廓，你可以暂时把片元理解为像素点。光栅化其实相当于在几何图形轮廓内，生成一个个密集排列的片元(像素)。\n\n\n\n\n# 片元着色器：逐片元概念\n\n经过图元装配、光栅化，会生成一个一个片元，片元着色器的作用就是执行片元着色器代码，按照片元着色器代码，给所有片元上色，也就是设置片元的像素值。每个片元经过渲染管线上的片元着色器都会按照GLSL ES代码规则设置颜色值，下节课会给大家演示更多上色规则。\n\n\n\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n    // 给每个片元设置颜色\n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n}\n`\n",normalizedContent:"# webgl渲染管线\n\n本节课主要是结合前面写过的shadermaterial代码，科普下webgl渲染管线概念，这样有助于后续的课程学习，你跟着视频过一遍就行，如果你有些名词概念你比较陌生，也不用深究，先大概有个印象。\n\n\n# 知识回顾：三角形和几何体顶点\n\n你可以回顾下，基础课程中章节2关于buffergeometry的知识点。网格模型是由三角形拼接而成，每个三角形包含三个顶点，这些三角形顶点的数据包含在mesh对应的几何体中buffergeometry\n\n\n\n课件演示文件中直接使用的threejs自带矩形平面几何体。\n\nconst geometry = new three.planegeometry(100, 50);\n\n\n然后你自己做一个练习，把演示文件中planegeometry替换为你自定义顶点的矩形平面,加深下印象，mesh一般通过三角形组成，三角形有自己顶点坐标。\n\nconst geometry = new three.buffergeometry(); //创建一个几何体对象\n//类型数组创建顶点数据\nconst vertices = new float32array([\n  // 三角形1顶点坐标\n  -50, -25, 0, //顶点1坐标\n  50, -25, 0, //顶点2坐标\n  50, 25, 0, //顶点3坐标\n  // 三角形2顶点坐标\n  -50, -25, 0, //顶点4坐标   和顶点1位置相同\n  50, 25, 0, //顶点5坐标  和顶点3位置相同\n  -50, 25, 0, //顶点6坐标\n]);\nconst attribute = new three.bufferattribute(vertices, 3); //3个为一组，表示一个顶点的xyz坐标\n// 设置几何体顶点位置.attributes.position\ngeometry.attributes.position = attribute;\n\n\n\n\n# 显卡gpu：执行着色器代码\n\n你稍微有点电脑常识，应该都知道电脑除了cpu处理器，还有一个gpu图形处理器。\n\n你平时写的javascript代码会在cpu上执行，而你写的着色器glsl es代码是在你显卡的gpu上执行。\n\n\n\n也就是3d渲染依赖于你电脑上的显卡gpu，一般来说，你渲染的3d场景越复杂，对显卡要求越高，比如一些大场景的物联网、数字孪生项目，往往需要配置一个比较好的独立显卡。\n\n\n# 显卡内存(显存)\n\n你电脑上显卡除了gpu，还有gpu对应的内存，也就是显存，在显卡gpu渲染3d场景的时候，会把相关的顶点、纹理图像等数据存储在显存上。\n\n\n\n你在购买显卡的时候，一般会看到商品标注的显存容量参数。\n\n\n\n\n# webgl渲染管线\n\n如果你有webgl基础，对webgl渲染管线肯定不陌生，当然你不了解webgl也没关系，咱们会后续课程会结合threejs代码给你从零介绍webgl渲染管线。\n\n你可以把webgl渲染管线想象为你显卡上的一条工厂流水线，工厂流水线有不同的工位，渲染管线也是如此，渲染管线上有多个不同的功能单元。\n\n\n\n提醒：渲染管线内容比较多，本节课跟着下面内容，先了解渲染管线小部分功能单元即可，不用全部记住。\n\n\n# shadermaterial代码执行过程\n\n这是前面咱们经常写的shadermaterial代码。\n\n// 顶点着色器代码\nconst vertexshader = `\nvoid main(){\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_position = projectionmatrix*modelviewmatrix*vec4( position, 1.0 );\n}\n`\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n    gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n}\n`\nconst material = new three.shadermaterial({\n  vertexshader: vertexshader,// 顶点着色器\n  fragmentshader: fragmentshader,// 片元着色器\n});\nconst mesh = new three.mesh(geometry, material);\nexport default mesh;\n\n\n当threejs通过webgl渲染器webglrenderer渲染的时候，会做下面几件事：\n\n 1. 从几何体buffergeometry中获取顶点数据，把这些顶点数据存入显存上创建的顶点缓冲区。\n 2. 顶点着色器功能单元，会执行顶点着色器glsl es代码，对这些顶点进行几何体变换(旋转、缩放、平移)\n 3. 片元着色器功能单元，会执行片元着色器glsl es代码，设置颜色值。\n\n\n\n\n# webgl渲染管线执行过程\n\n下面给大家详细说明下，顶点着色器到片元着色器的处理可成。\n\n\n\n 1. 顶点缓冲区：顶点数据\n 2. 顶点着色器：顶点变换\n 3. 图元装配：比如渲染mesh，mesh几何体有多个三角形拼接，三个点为一组生成一个三角形\n 4. 光栅化：比如在上一步三角形轮廓中，生成填充一个一个片元(像素)\n 5. 片元着色器：给片元(像素)着色器\n\n\n# 顶点着色器：逐顶点概念\n\n\n\n渲染管线上顶点着色器的功能就是执行顶点着色器代码,根据你写的代码对几何体顶点数据进行处理。比如本节课案例源码，就是通过矩阵对顶点进行几何体变换(平移、旋转、缩放)。\n\n这个过程是逐顶点操作的，你把每个顶点数据想象成流水线上的一个一个零件，每个顶点经过顶点着色器功能单元时候，都会倍顶点着色器处理，比如几何变换。\n\n// 顶点着色器代码\nconst vertexshader = `\nvoid main(){\n  // 对每个顶点坐标进行矩阵变换\n  gl_position = projectionmatrix*modelviewmatrix*vec4( position, 1.0 );\n}\n`\n\n\n\n# 图元装配、光栅化\n\n经过顶点着色器处理的顶点数据，会进入webgl渲染管线下一个环节，也就是图元装配，比如渲染mesh，图元装配时候，就会把三个点为一组生成一个三角形轮廓，接着就是光栅化，在上一步三角形轮廓内生成一个个片元，填充三角形轮廓，你可以暂时把片元理解为像素点。光栅化其实相当于在几何图形轮廓内，生成一个个密集排列的片元(像素)。\n\n\n\n\n# 片元着色器：逐片元概念\n\n经过图元装配、光栅化，会生成一个一个片元，片元着色器的作用就是执行片元着色器代码，按照片元着色器代码，给所有片元上色，也就是设置片元的像素值。每个片元经过渲染管线上的片元着色器都会按照glsl es代码规则设置颜色值，下节课会给大家演示更多上色规则。\n\n\n\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n    // 给每个片元设置颜色\n    gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n}\n`\n",charsets:{cjk:!0}},{title:"7. 片元屏幕坐标fragCoord.xy",frontmatter:{title:"7. 片元屏幕坐标fragCoord.xy",date:"2023-10-23T22:44:27.000Z",permalink:"/pages/b109f4/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/07.%E7%89%87%E5%85%83%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87fragCoord.xy.html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/07.片元屏幕坐标fragCoord.xy.md",key:"v-31b2dbbf",path:"/pages/b109f4/",headers:[{level:3,title:"知识回顾：片元着色器",slug:"知识回顾-片元着色器",normalizedTitle:"知识回顾：片元着色器",charIndex:62},{level:3,title:"gl_FragCoord.xy片元屏幕坐标",slug:"gl-fragcoord-xy片元屏幕坐标",normalizedTitle:"gl_fragcoord.xy片元屏幕坐标",charIndex:319},{level:3,title:"根据片元屏幕坐标设置颜色",slug:"根据片元屏幕坐标设置颜色",normalizedTitle:"根据片元屏幕坐标设置颜色",charIndex:716},{level:3,title:"discard舍弃部分片元",slug:"discard舍弃部分片元",normalizedTitle:"discard舍弃部分片元",charIndex:1206}],headersStr:"知识回顾：片元着色器 gl_FragCoord.xy片元屏幕坐标 根据片元屏幕坐标设置颜色 discard舍弃部分片元",content:"# 片元屏幕坐标gl_FragCoord.xy\n\n这节课给大家介绍下片元的屏幕坐标gl_FragCoord.xy。\n\n\n# 知识回顾：片元着色器\n\n顶点数据经过WebGL渲染管线图元装配和光栅化处理以后，会得到模型对应的一个个片元。\n\n\n\n比如一个三角形，经过光栅化处理，会获取到一个由片元拼出来一个三角形图案，这些片元，可以通过着色器代码设置像素颜色值gl_FragColor = 片元颜色。\n\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n    //所有片元都是同一种颜色 \n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n}\n`\n\n\n\n# gl_FragCoord.xy片元屏幕坐标\n\ngl_FragCoord和gl_FragColor、gl_Position一样，都是着色器语言GLSL ES的内置变量，不用声明，可以直接使用。\n\ngl_FragCoord是一个四维向量vec4,本节课只介绍前面两个x、y分量gl_FragCoord.xy，gl_FragCoord.x表示片元x坐标，gl_FragCoord.y表示片元的y坐标，这里提醒大家，一定注意gl_FragCoord.xy的坐标系，不是平时你threejs代码里面的xyz世界坐标系。\n\ngl_FragCoord.xy坐标系的坐标原点，位于threejs canvas画布的左下角，x轴水平向右，y轴竖直向上，单位是像素px。\n\n\n\n比如咱们代码中canvas画布的宽高度是500px、500px，右上角的坐标就是(500,500)，中间就是(250,250)\n\n\n# 根据片元屏幕坐标设置颜色\n\ncanvas画布总宽800px的情况下，以中间作为分界点，左半部分片元红色，右半部分片元蓝色。\n\n//根据片元的x坐标，来设置片元的像素值\nif(gl_FragCoord.x < 400.0){\n  gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n}else {\n  gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n}\n\n\ncanvas画布总高600px的情况下，以中间作为分界点，上半部分片元红色，下半部分片元蓝色。\n\n//根据片元的x坐标，来设置片元的像素值\nif(gl_FragCoord.y < 300.0){\n  gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n}else {\n  gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n}\n\n\n根据片元x坐标，设置一个渐变色。\n\n// 片元沿着x方向渐变\n gl_FragColor = vec4(gl_FragCoord.x/800.0*1.0,0.0,0.0,1.0);\n\n\n\n# discard舍弃部分片元\n\ndiscard是着色器语言GLSL ES的一个关键字，用来控制片元着色器功能单元，舍弃某个片元。\n\nif(gl_FragCoord.x < 400.0){\n  // 符合条件片元保留，并设置颜色\n  gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n}else {\n  discard;//不符合条件片元直接舍弃掉\n}\n\n",normalizedContent:"# 片元屏幕坐标gl_fragcoord.xy\n\n这节课给大家介绍下片元的屏幕坐标gl_fragcoord.xy。\n\n\n# 知识回顾：片元着色器\n\n顶点数据经过webgl渲染管线图元装配和光栅化处理以后，会得到模型对应的一个个片元。\n\n\n\n比如一个三角形，经过光栅化处理，会获取到一个由片元拼出来一个三角形图案，这些片元，可以通过着色器代码设置像素颜色值gl_fragcolor = 片元颜色。\n\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n    //所有片元都是同一种颜色 \n    gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n}\n`\n\n\n\n# gl_fragcoord.xy片元屏幕坐标\n\ngl_fragcoord和gl_fragcolor、gl_position一样，都是着色器语言glsl es的内置变量，不用声明，可以直接使用。\n\ngl_fragcoord是一个四维向量vec4,本节课只介绍前面两个x、y分量gl_fragcoord.xy，gl_fragcoord.x表示片元x坐标，gl_fragcoord.y表示片元的y坐标，这里提醒大家，一定注意gl_fragcoord.xy的坐标系，不是平时你threejs代码里面的xyz世界坐标系。\n\ngl_fragcoord.xy坐标系的坐标原点，位于threejs canvas画布的左下角，x轴水平向右，y轴竖直向上，单位是像素px。\n\n\n\n比如咱们代码中canvas画布的宽高度是500px、500px，右上角的坐标就是(500,500)，中间就是(250,250)\n\n\n# 根据片元屏幕坐标设置颜色\n\ncanvas画布总宽800px的情况下，以中间作为分界点，左半部分片元红色，右半部分片元蓝色。\n\n//根据片元的x坐标，来设置片元的像素值\nif(gl_fragcoord.x < 400.0){\n  gl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n}else {\n  gl_fragcolor = vec4(0.0,0.0,1.0,1.0);\n}\n\n\ncanvas画布总高600px的情况下，以中间作为分界点，上半部分片元红色，下半部分片元蓝色。\n\n//根据片元的x坐标，来设置片元的像素值\nif(gl_fragcoord.y < 300.0){\n  gl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n}else {\n  gl_fragcolor = vec4(0.0,0.0,1.0,1.0);\n}\n\n\n根据片元x坐标，设置一个渐变色。\n\n// 片元沿着x方向渐变\n gl_fragcolor = vec4(gl_fragcoord.x/800.0*1.0,0.0,0.0,1.0);\n\n\n\n# discard舍弃部分片元\n\ndiscard是着色器语言glsl es的一个关键字，用来控制片元着色器功能单元，舍弃某个片元。\n\nif(gl_fragcoord.x < 400.0){\n  // 符合条件片元保留，并设置颜色\n  gl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n}else {\n  discard;//不符合条件片元直接舍弃掉\n}\n\n",charsets:{cjk:!0}},{title:"9. 顶点位置插值(实现渐变色)",frontmatter:{title:"9. 顶点位置插值(实现渐变色)",date:"2023-10-23T22:44:49.000Z",permalink:"/pages/64fa98/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/09.%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%80%BC(%E5%AE%9E%E7%8E%B0%E6%B8%90%E5%8F%98%E8%89%B2).html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/09.顶点位置插值(实现渐变色).md",key:"v-555d9eed",path:"/pages/64fa98/",headers:[{level:3,title:"知识回顾：顶点颜色数据插值计算",slug:"知识回顾-顶点颜色数据插值计算",normalizedTitle:"知识回顾：顶点颜色数据插值计算",charIndex:92},{level:3,title:"顶点位置数据position插值计算",slug:"顶点位置数据position插值计算",normalizedTitle:"顶点位置数据position插值计算",charIndex:733},{level:3,title:"使用positon插值后数据vPosition控制片元颜色",slug:"使用positon插值后数据vposition控制片元颜色",normalizedTitle:"使用positon插值后数据vposition控制片元颜色",charIndex:1083},{level:3,title:"根据插值位置数据vPosition设置渐变色",slug:"根据插值位置数据vposition设置渐变色",normalizedTitle:"根据插值位置数据vposition设置渐变色",charIndex:1408},{level:3,title:"positon模型矩阵变换后插值",slug:"positon模型矩阵变换后插值",normalizedTitle:"positon模型矩阵变换后插值",charIndex:1823}],headersStr:"知识回顾：顶点颜色数据插值计算 顶点位置数据position插值计算 使用positon插值后数据vPosition控制片元颜色 根据插值位置数据vPosition设置渐变色 positon模型矩阵变换后插值",content:"# 顶点位置插值(实现渐变色)\n\n这节课给大家讲解顶点位置插值position，然后利用插值的顶点位置数据，逐片元操作，实现一个网格模型Mesh沿着y轴方向进行颜色渐变。\n\n\n\n\n# 知识回顾：顶点颜色数据插值计算\n\n\n\n上节课给大家讲解过，你通过着色器语言GLSL ES关键字varying声明一个变量vColor，然后main函数中执行vColor = color;，就可以对顶点颜色数据color进行插值计算，插值后vColor的颜色数据量与片元数量一致，也就是说每一个片元都能对应一个顶点颜色插值数据vColor\n\n// 顶点着色器代码\nconst vertexShader = `\n// attribute vec3 color;//默认提供不用手写\nvarying vec3 vColor;// varying关键字声明一个变量表示顶点颜色插值后的结果\nvoid main(){\n  vColor = color;// 顶点颜色数据进行插值计算\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n// 片元着色器代码\nconst fragmentShader = `\nvarying vec3 vColor;// 顶点片元化后有多少个片元,顶点颜色插值后就有多少个颜色数据\nvoid main() {\n    // gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n    gl_FragColor = vec4(vColor,1.0);\n}\n`\n\n\n\n# 顶点位置数据position插值计算\n\n不仅仅顶点颜色color数据可以通过顶点着色器插值计算，其实所有类型的顶点数据都可以，比如顶点位置数据position。\n\n你只需要记住一个规律，任何类型的顶点数据，插值计算后，都会生成和所有片元一一对应的新数据。\n\n\n\n// 顶点着色器代码\nconst vertexShader = `\nvarying vec3 vPosition;//表示顶点插值后位置数据，与片元数量相同，一一对应\nvoid main(){\n  vPosition = position;// 顶点位置坐标插值计算\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n# 使用positon插值后数据vPosition控制片元颜色\n\n根据几何体顶点坐标控制Mesh的颜色，y坐标小于0部分，红色，其他部分绿色。\n\n\n\n// 片元着色器代码\nconst fragmentShader = `\nvarying vec3 vPosition;//获取顶点着色器插值数据vPosition\nvoid main() {\n  // 根据vPosition位置控制片元颜色\n  if(vPosition.y < 0.0){\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n  }else{\n    gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n  }\n}\n`\n\n\n\n# 根据插值位置数据vPosition设置渐变色\n\n控制Mesh沿着y方向，从底部到顶部进行颜色渐变,底部是绿色，顶部是红色。\n\n下面以Mesh的几何体为准，几何体是一个矩形平面PlaneGeometry，底部顶点y坐标-25，顶部顶点y坐标25\n\nconst geometry = new THREE.PlaneGeometry(100, 50);\n// 片元着色器代码\nconst fragmentShader = `\nvarying vec3 vPosition;\nvoid main() {\n    float per = (vPosition.y + 25.0)/50.0;\n    // 几何体顶点y坐标25，颜色值：1  0  0(红色)\n    // 几何体顶点y坐标-25，颜色值：0  1  0(绿色)\n    gl_FragColor = vec4(per,1.0-per,0.0,1.0);\n}\n`\n\n\n\n# positon模型矩阵变换后插值\n\n刚才说话所有类型顶点数据都可以插值，你也可以测试，把顶点数据先用模型矩阵modelMatrix进行变换，再插值计算。\n\n这个时候vPosition反应就不仅仅是几何体geometry顶点的位置了，也包含mesh自身的旋转、缩放、平移。\n\n// 顶点着色器代码\nconst vertexShader = `\nvarying vec3 vPosition;\nvoid main(){\n  // vPosition = position;\n  // 考虑mesh及其父对象旋转、缩放、平移的影响\n  vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n你可以把mesh向上平移mesh.position.y += 25;。这时候你想想怎么写片元着色器代码，保证矩形平面底部绿色，顶部红色，然后进行渐变。\n\n// 片元着色器代码\nconst fragmentShader = `\nvarying vec3 vPosition;\nvoid main() {\n    float per = vPosition.y /50.0;\n    // Mesh y坐标50，颜色值：1  0  0(红色)\n    // Mesh y坐标0，颜色值：0  1  0(绿色)\n    gl_FragColor = vec4(per,1.0-per,0.0,1.0);\n}\n`\n\n\n",normalizedContent:"# 顶点位置插值(实现渐变色)\n\n这节课给大家讲解顶点位置插值position，然后利用插值的顶点位置数据，逐片元操作，实现一个网格模型mesh沿着y轴方向进行颜色渐变。\n\n\n\n\n# 知识回顾：顶点颜色数据插值计算\n\n\n\n上节课给大家讲解过，你通过着色器语言glsl es关键字varying声明一个变量vcolor，然后main函数中执行vcolor = color;，就可以对顶点颜色数据color进行插值计算，插值后vcolor的颜色数据量与片元数量一致，也就是说每一个片元都能对应一个顶点颜色插值数据vcolor\n\n// 顶点着色器代码\nconst vertexshader = `\n// attribute vec3 color;//默认提供不用手写\nvarying vec3 vcolor;// varying关键字声明一个变量表示顶点颜色插值后的结果\nvoid main(){\n  vcolor = color;// 顶点颜色数据进行插值计算\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n// 片元着色器代码\nconst fragmentshader = `\nvarying vec3 vcolor;// 顶点片元化后有多少个片元,顶点颜色插值后就有多少个颜色数据\nvoid main() {\n    // gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n    gl_fragcolor = vec4(vcolor,1.0);\n}\n`\n\n\n\n# 顶点位置数据position插值计算\n\n不仅仅顶点颜色color数据可以通过顶点着色器插值计算，其实所有类型的顶点数据都可以，比如顶点位置数据position。\n\n你只需要记住一个规律，任何类型的顶点数据，插值计算后，都会生成和所有片元一一对应的新数据。\n\n\n\n// 顶点着色器代码\nconst vertexshader = `\nvarying vec3 vposition;//表示顶点插值后位置数据，与片元数量相同，一一对应\nvoid main(){\n  vposition = position;// 顶点位置坐标插值计算\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n# 使用positon插值后数据vposition控制片元颜色\n\n根据几何体顶点坐标控制mesh的颜色，y坐标小于0部分，红色，其他部分绿色。\n\n\n\n// 片元着色器代码\nconst fragmentshader = `\nvarying vec3 vposition;//获取顶点着色器插值数据vposition\nvoid main() {\n  // 根据vposition位置控制片元颜色\n  if(vposition.y < 0.0){\n    gl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n  }else{\n    gl_fragcolor = vec4(0.0,0.0,1.0,1.0);\n  }\n}\n`\n\n\n\n# 根据插值位置数据vposition设置渐变色\n\n控制mesh沿着y方向，从底部到顶部进行颜色渐变,底部是绿色，顶部是红色。\n\n下面以mesh的几何体为准，几何体是一个矩形平面planegeometry，底部顶点y坐标-25，顶部顶点y坐标25\n\nconst geometry = new three.planegeometry(100, 50);\n// 片元着色器代码\nconst fragmentshader = `\nvarying vec3 vposition;\nvoid main() {\n    float per = (vposition.y + 25.0)/50.0;\n    // 几何体顶点y坐标25，颜色值：1  0  0(红色)\n    // 几何体顶点y坐标-25，颜色值：0  1  0(绿色)\n    gl_fragcolor = vec4(per,1.0-per,0.0,1.0);\n}\n`\n\n\n\n# positon模型矩阵变换后插值\n\n刚才说话所有类型顶点数据都可以插值，你也可以测试，把顶点数据先用模型矩阵modelmatrix进行变换，再插值计算。\n\n这个时候vposition反应就不仅仅是几何体geometry顶点的位置了，也包含mesh自身的旋转、缩放、平移。\n\n// 顶点着色器代码\nconst vertexshader = `\nvarying vec3 vposition;\nvoid main(){\n  // vposition = position;\n  // 考虑mesh及其父对象旋转、缩放、平移的影响\n  vposition = vec3(modelmatrix * vec4( position, 1.0 ));\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n你可以把mesh向上平移mesh.position.y += 25;。这时候你想想怎么写片元着色器代码，保证矩形平面底部绿色，顶部红色，然后进行渐变。\n\n// 片元着色器代码\nconst fragmentshader = `\nvarying vec3 vposition;\nvoid main() {\n    float per = vposition.y /50.0;\n    // mesh y坐标50，颜色值：1  0  0(红色)\n    // mesh y坐标0，颜色值：0  1  0(绿色)\n    gl_fragcolor = vec4(per,1.0-per,0.0,1.0);\n}\n`\n\n\n",charsets:{cjk:!0}},{title:"8. 顶点颜色varying插值计算",frontmatter:{title:"8. 顶点颜色varying插值计算",date:"2023-10-23T22:44:37.000Z",permalink:"/pages/118412/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/08.%E9%A1%B6%E7%82%B9%E9%A2%9C%E8%89%B2varying%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97.html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/08.顶点颜色varying插值计算.md",key:"v-047aa23a",path:"/pages/118412/",headers:[{level:3,title:"知识回顾：几何体顶点颜色geometry.attributes.color",slug:"知识回顾-几何体顶点颜色geometry-attributes-color",normalizedTitle:"知识回顾：几何体顶点颜色geometry.attributes.color",charIndex:60},{level:3,title:"设置顶点颜色",slug:"设置顶点颜色",normalizedTitle:"设置顶点颜色",charIndex:273},{level:3,title:"允许用顶点颜色渲染vertexColors:true,",slug:"允许用顶点颜色渲染vertexcolors-true",normalizedTitle:"允许用顶点颜色渲染vertexcolors:true,",charIndex:775},{level:3,title:"内置变量",slug:"内置变量",normalizedTitle:"内置变量",charIndex:1016},{level:3,title:"顶点颜色插值计算",slug:"顶点颜色插值计算",normalizedTitle:"顶点颜色插值计算",charIndex:1413}],headersStr:"知识回顾：几何体顶点颜色geometry.attributes.color 设置顶点颜色 允许用顶点颜色渲染vertexColors:true, 内置变量 顶点颜色插值计算",content:"# 顶点颜色varying插值计算\n\n本节课结合顶点着色器、片元着色器代码，给家讲解下顶点颜色的插值计算。\n\n\n\n\n# 知识回顾：几何体顶点颜色geometry.attributes.color\n\n知识回顾：9.18 顶点颜色插值\n\n比如一条直线，你把直线几何体两个端点，分别设置一个颜色，threejs会根据两端的颜色，在两点之间，按照距离远近插入不同颜色，就是所谓的颜色插值计算，距离某个点越近受某个点颜色影响越大。\n\n\n\n对于网格的三角形也是类似，三角形内部一个点的颜色，同时收到三个点的颜色影响，距离某个点越近，受影响越大。\n\n\n\n\n# 设置顶点颜色\n\n课件演示文件，ShaderMaterial对应的几何体已经提前给大家设置了一个三角形对应的三个顶点数据。\n\nconst geometry = new THREE.BufferGeometry(); //创建一个几何体对象\nconst vertices = new Float32Array([//类型数组创建顶点数据\n  0, 0, 0, //顶点1坐标\n  50, 0, 0, //顶点2坐标\n  0, 25, 0, //顶点3坐标\n]);\ngeometry.attributes.position = new THREE.BufferAttribute(vertices, 3);\n\n\nShaderMaterial对应的几何体设置顶点颜色数据。\n\nconst colors = new Float32Array([\n  1, 0, 0, //顶点1颜色 \n  0, 0, 1, //顶点2颜色\n  0, 1, 0, //顶点3颜色\n]);\ngeometry.attributes.color = new THREE.BufferAttribute(colors, 3); \n\n\n\n# 允许用顶点颜色渲染vertexColors:true,\n\nShaderMaterial和原来的网格材质一样，设置vertexColors:true,，允许设置使用顶点颜色渲染\n\nconst material = new THREE.ShaderMaterial({\n  vertexShader: vertexShader,\n  fragmentShader: fragmentShader,\n  vertexColors:true,//允许设置使用顶点颜色渲染\n});\n\n\n\n# 内置变量\n\n前面给大家讲过，ShaderMaterial默认提供了一个内置变量position,表示顶点的位置坐标，数据来自几何体顶点位置数据geometry.attributes.position。\n\n除此外，ShaderMaterial还有一个内置变量color,表示顶点的颜色数据，数据来自你定义的几何体顶点颜色属性geometry.attributes.color\n\n// 顶点着色器代码\nconst vertexShader = `\n// attribute vec3 color;//ShaderMaterial默认提供不用手写\nvoid main(){\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n# 顶点颜色插值计算\n\ncolor变量表示插值之前的顶点颜色数据，varying关键字声明一个插值计算后的顶点颜色变量vColor。\n\n// 顶点着色器代码\nconst vertexShader = `\n// attribute vec3 color;//默认提供不用手写\nvarying vec3 vColor;// varying关键字声明一个变量表示顶点颜色插值后的结果\nvoid main(){\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n顶点数据插值计算语法：在顶点着色器主函数main里面，把顶点数据赋值给另一个varying声明的变量即可。\n\n// 顶点着色器代码\nconst vertexShader = `\n// attribute vec3 color;//默认提供不用手写\nvarying vec3 vColor;// varying关键字声明一个变量表示顶点颜色插值后的结果\nvoid main(){\n  vColor = color;// 顶点颜色数据进行插值计算\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n如果你想在片元着色器中获取顶点着色器中顶点颜色数据插值计算的结果vColor,非常简单，用关键字varying声明一个与同名变量vColor就行。\n\n这里注意，你可能会好奇，通过color的顶点会插值得到多少个新的颜色vColor,很简单，与片元的数量一样。\n\n换句话说就是每个片元都有一个对应的vColor颜色数据，你可以把vColor赋值给gl_FragColor。\n\n\n\n// 片元着色器代码\nconst fragmentShader = `\nvarying vec3 vColor;// 顶点片元化后有多少个片元,顶点颜色插值后就有多少个颜色数据\nvoid main() {\n    gl_FragColor = vec4(vColor,1.0);\n}\n`\n",normalizedContent:"# 顶点颜色varying插值计算\n\n本节课结合顶点着色器、片元着色器代码，给家讲解下顶点颜色的插值计算。\n\n\n\n\n# 知识回顾：几何体顶点颜色geometry.attributes.color\n\n知识回顾：9.18 顶点颜色插值\n\n比如一条直线，你把直线几何体两个端点，分别设置一个颜色，threejs会根据两端的颜色，在两点之间，按照距离远近插入不同颜色，就是所谓的颜色插值计算，距离某个点越近受某个点颜色影响越大。\n\n\n\n对于网格的三角形也是类似，三角形内部一个点的颜色，同时收到三个点的颜色影响，距离某个点越近，受影响越大。\n\n\n\n\n# 设置顶点颜色\n\n课件演示文件，shadermaterial对应的几何体已经提前给大家设置了一个三角形对应的三个顶点数据。\n\nconst geometry = new three.buffergeometry(); //创建一个几何体对象\nconst vertices = new float32array([//类型数组创建顶点数据\n  0, 0, 0, //顶点1坐标\n  50, 0, 0, //顶点2坐标\n  0, 25, 0, //顶点3坐标\n]);\ngeometry.attributes.position = new three.bufferattribute(vertices, 3);\n\n\nshadermaterial对应的几何体设置顶点颜色数据。\n\nconst colors = new float32array([\n  1, 0, 0, //顶点1颜色 \n  0, 0, 1, //顶点2颜色\n  0, 1, 0, //顶点3颜色\n]);\ngeometry.attributes.color = new three.bufferattribute(colors, 3); \n\n\n\n# 允许用顶点颜色渲染vertexcolors:true,\n\nshadermaterial和原来的网格材质一样，设置vertexcolors:true,，允许设置使用顶点颜色渲染\n\nconst material = new three.shadermaterial({\n  vertexshader: vertexshader,\n  fragmentshader: fragmentshader,\n  vertexcolors:true,//允许设置使用顶点颜色渲染\n});\n\n\n\n# 内置变量\n\n前面给大家讲过，shadermaterial默认提供了一个内置变量position,表示顶点的位置坐标，数据来自几何体顶点位置数据geometry.attributes.position。\n\n除此外，shadermaterial还有一个内置变量color,表示顶点的颜色数据，数据来自你定义的几何体顶点颜色属性geometry.attributes.color\n\n// 顶点着色器代码\nconst vertexshader = `\n// attribute vec3 color;//shadermaterial默认提供不用手写\nvoid main(){\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n# 顶点颜色插值计算\n\ncolor变量表示插值之前的顶点颜色数据，varying关键字声明一个插值计算后的顶点颜色变量vcolor。\n\n// 顶点着色器代码\nconst vertexshader = `\n// attribute vec3 color;//默认提供不用手写\nvarying vec3 vcolor;// varying关键字声明一个变量表示顶点颜色插值后的结果\nvoid main(){\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n顶点数据插值计算语法：在顶点着色器主函数main里面，把顶点数据赋值给另一个varying声明的变量即可。\n\n// 顶点着色器代码\nconst vertexshader = `\n// attribute vec3 color;//默认提供不用手写\nvarying vec3 vcolor;// varying关键字声明一个变量表示顶点颜色插值后的结果\nvoid main(){\n  vcolor = color;// 顶点颜色数据进行插值计算\n  // 投影矩阵 * 模型视图矩阵 * 模型顶点坐标\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n如果你想在片元着色器中获取顶点着色器中顶点颜色数据插值计算的结果vcolor,非常简单，用关键字varying声明一个与同名变量vcolor就行。\n\n这里注意，你可能会好奇，通过color的顶点会插值得到多少个新的颜色vcolor,很简单，与片元的数量一样。\n\n换句话说就是每个片元都有一个对应的vcolor颜色数据，你可以把vcolor赋值给gl_fragcolor。\n\n\n\n// 片元着色器代码\nconst fragmentshader = `\nvarying vec3 vcolor;// 顶点片元化后有多少个片元,顶点颜色插值后就有多少个颜色数据\nvoid main() {\n    gl_fragcolor = vec4(vcolor,1.0);\n}\n`\n",charsets:{cjk:!0}},{title:"10. 颜色贴图map(顶点UV坐标)",frontmatter:{title:"10. 颜色贴图map(顶点UV坐标)",date:"2023-10-25T10:35:58.000Z",permalink:"/pages/8db59b/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/10.%E9%A2%9C%E8%89%B2%E8%B4%B4%E5%9B%BEmap(%E9%A1%B6%E7%82%B9UV%E5%9D%90%E6%A0%87).html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/10.颜色贴图map(顶点UV坐标).md",key:"v-5c0d32fb",path:"/pages/8db59b/",headers:[{level:3,title:"知识回顾：顶点UV坐标",slug:"知识回顾-顶点uv坐标",normalizedTitle:"知识回顾：顶点uv坐标",charIndex:614},{level:3,title:"顶点UV坐标内置变量uv",slug:"顶点uv坐标内置变量uv",normalizedTitle:"顶点uv坐标内置变量uv",charIndex:1582},{level:3,title:"1. 顶点UV坐标插值计算",slug:"_1-顶点uv坐标插值计算",normalizedTitle:"1. 顶点uv坐标插值计算",charIndex:1979},{level:3,title:"2. 声明颜色贴图变量uniform sampler2D map",slug:"_2-声明颜色贴图变量uniform-sampler2d-map",normalizedTitle:"2. 声明颜色贴图变量uniform sampler2d map",charIndex:2242},{level:3,title:"3. 给uniform变量map传值",slug:"_3-给uniform变量map传值",normalizedTitle:"3. 给uniform变量map传值",charIndex:2465},{level:3,title:"4. 采样纹理赋值给gl_FragColor",slug:"_4-采样纹理赋值给gl-fragcolor",normalizedTitle:"4. 采样纹理赋值给gl_fragcolor",charIndex:2821}],headersStr:"知识回顾：顶点UV坐标 顶点UV坐标内置变量uv 1. 顶点UV坐标插值计算 2. 声明颜色贴图变量uniform sampler2D map 3. 给uniform变量map传值 4. 采样纹理赋值给gl_FragColor",content:"# 颜色贴图map(顶点UV坐标)\n\n通过基础课程的学习，大家对网格材质的颜色贴图属性.map，肯定不陌生。\n\nconst texture = new THREE.TextureLoader().load('./Earth.png');\nconst material = new THREE.MeshBasicMaterial({\n    map: texture,\n});\n\n\n本节课任务就是用shader材质ShaderMaterial替换网格材质MeshBasicMaterial材质,用着色器GLSL ES代码实现一个颜色贴图.map的功能。\n\n本节课演示的代码如下：\n\nconst vertexShader = `\nvarying vec2 vUv;\nvoid main(){\n  vUv = uv;// UV坐标插值计算\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\nconst fragmentShader = `\nuniform sampler2D map;//颜色贴图变量\nvarying vec2 vUv;\nvoid main() {\n    // 通过几何体的UV坐标从颜色贴图获取像素值\n    gl_FragColor = texture2D( map, vUv );\n}\n`\n\n\n\n# 知识回顾：顶点UV坐标\n\n学习本节课课程之前，先确保你对顶点UV坐标有一定的概念，具体知识可以参考前面课程参考前面课程5.2.自定义UV坐标。\n\n\n\nconst geometry = new THREE.BufferGeometry();\nconst vertices = new Float32Array([\n    0, 0, 0, //顶点1坐标\n    160, 0, 0, //顶点2坐标\n    160, 80, 0, //顶点3坐标\n    0, 80, 0, //顶点4坐标\n]);\ngeometry.attributes.position = new THREE.BufferAttribute(vertices, 3);;\nconst indexes = new Uint16Array([\n    0, 1, 2, 0, 2, 3,// 矩形两个三角形对应顶点位置索引值\n])\ngeometry.index = new THREE.BufferAttribute(indexes, 1); // 索引数据赋值给几何体的index属性\n/**纹理坐标0~1之间随意定义*/\nconst uvs = new Float32Array([\n    0, 0, //图片左下角\n    1, 0, //图片右下角\n    1, 1, //图片右上角\n    0, 1, //图片左上角\n]);\ngeometry.attributes.uv = new THREE.BufferAttribute(uvs, 2); //2个为一组,表示一个顶点的纹理坐标\n\n\n纹理与网格模型面不同区域之间的映射关系是由几何体自身的UV坐标决定的。\n\nconst geometry = new THREE.PlaneGeometry(100, 50);\nconst geometry = new THREE.BoxGeometry(100, 100, 100); //立方体\nconst geometry = new THREE.SphereGeometry(60, 25, 25); //球体\n// threejs自带几何体也有自己默认UV坐标\nconsole.log('uv',geometry.attributes.uv);\n\n\n\n# 顶点UV坐标内置变量uv\n\n前面几节课给大家介绍过shader材质ShaderMaterial的两个内置变量顶点位置position、顶点颜色color。这节课给大家介绍一个新的顶点变量，顶点UV坐标uv，uv的数据来自几何体uv属性geometry.attributes.uv\n\nattribute vec3 position;//默认提供,不用自己写\nattribute vec3 color;//默认提供,不用自己写\nattribute vec2 uv;//默认提供,不用自己写\n\n\nconst vertexShader = `\nattribute vec2 uv;//默认提供,不用自己写\nvoid main(){\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n# 1. 顶点UV坐标插值计算\n\n仿照前面两节课顶点位置position、顶点颜色color插值计算语法，对顶点uv坐标进行插值计算。\n\nconst vertexShader = `\n// attribute vec2 uv;//默认提供,不用自己写\nvarying vec2 vUv;\nvoid main(){\n  vUv = uv;// UV坐标插值计算\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n# 2. 声明颜色贴图变量uniform sampler2D map\n\nuniform关键字声明一个颜色贴图相关的变量map，纹理贴图对应数据类型需要用关键字sampler2D表示。\n\n// 片元着色器代码\nconst fragmentShader = `\nuniform sampler2D map;//颜色贴图变量\nvoid main() {\n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n}\n`\n\n\n\n# 3. 给uniform变量map传值\n\n查看Uniform的文档,能看到着色器语言数据类型sampler2D对应threejs的数据类型THREE.Texture。\n\nconst texture = new THREE.TextureLoader().load('./Earth.png');\nconst material = new THREE.ShaderMaterial({\n  uniforms: {\n    // 给着色器中同名uniform变量map传值\n    map: {value: texture},\n  },\n  vertexShader: vertexShader,// 顶点着色器\n  fragmentShader: fragmentShader,// 片元着色器\n});\n\n\n\n\n# 4. 采样纹理赋值给gl_FragColor\n\n执行varying vec2 vUv;从顶点着色器获取插值后UV坐标vUv，然后执行texture2D( map, vUv );从颜色贴图上提取像素值，赋值给模型的片元gl_FragColor。\n\n// 片元着色器代码\nconst fragmentShader = `\nuniform sampler2D map;//颜色贴图变量\nvarying vec2 vUv;\nvoid main() {\n    // 通过几何体的UV坐标从颜色贴图获取像素值\n    gl_FragColor = texture2D( map, vUv );\n}\n`\n",normalizedContent:"# 颜色贴图map(顶点uv坐标)\n\n通过基础课程的学习，大家对网格材质的颜色贴图属性.map，肯定不陌生。\n\nconst texture = new three.textureloader().load('./earth.png');\nconst material = new three.meshbasicmaterial({\n    map: texture,\n});\n\n\n本节课任务就是用shader材质shadermaterial替换网格材质meshbasicmaterial材质,用着色器glsl es代码实现一个颜色贴图.map的功能。\n\n本节课演示的代码如下：\n\nconst vertexshader = `\nvarying vec2 vuv;\nvoid main(){\n  vuv = uv;// uv坐标插值计算\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\nconst fragmentshader = `\nuniform sampler2d map;//颜色贴图变量\nvarying vec2 vuv;\nvoid main() {\n    // 通过几何体的uv坐标从颜色贴图获取像素值\n    gl_fragcolor = texture2d( map, vuv );\n}\n`\n\n\n\n# 知识回顾：顶点uv坐标\n\n学习本节课课程之前，先确保你对顶点uv坐标有一定的概念，具体知识可以参考前面课程参考前面课程5.2.自定义uv坐标。\n\n\n\nconst geometry = new three.buffergeometry();\nconst vertices = new float32array([\n    0, 0, 0, //顶点1坐标\n    160, 0, 0, //顶点2坐标\n    160, 80, 0, //顶点3坐标\n    0, 80, 0, //顶点4坐标\n]);\ngeometry.attributes.position = new three.bufferattribute(vertices, 3);;\nconst indexes = new uint16array([\n    0, 1, 2, 0, 2, 3,// 矩形两个三角形对应顶点位置索引值\n])\ngeometry.index = new three.bufferattribute(indexes, 1); // 索引数据赋值给几何体的index属性\n/**纹理坐标0~1之间随意定义*/\nconst uvs = new float32array([\n    0, 0, //图片左下角\n    1, 0, //图片右下角\n    1, 1, //图片右上角\n    0, 1, //图片左上角\n]);\ngeometry.attributes.uv = new three.bufferattribute(uvs, 2); //2个为一组,表示一个顶点的纹理坐标\n\n\n纹理与网格模型面不同区域之间的映射关系是由几何体自身的uv坐标决定的。\n\nconst geometry = new three.planegeometry(100, 50);\nconst geometry = new three.boxgeometry(100, 100, 100); //立方体\nconst geometry = new three.spheregeometry(60, 25, 25); //球体\n// threejs自带几何体也有自己默认uv坐标\nconsole.log('uv',geometry.attributes.uv);\n\n\n\n# 顶点uv坐标内置变量uv\n\n前面几节课给大家介绍过shader材质shadermaterial的两个内置变量顶点位置position、顶点颜色color。这节课给大家介绍一个新的顶点变量，顶点uv坐标uv，uv的数据来自几何体uv属性geometry.attributes.uv\n\nattribute vec3 position;//默认提供,不用自己写\nattribute vec3 color;//默认提供,不用自己写\nattribute vec2 uv;//默认提供,不用自己写\n\n\nconst vertexshader = `\nattribute vec2 uv;//默认提供,不用自己写\nvoid main(){\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n# 1. 顶点uv坐标插值计算\n\n仿照前面两节课顶点位置position、顶点颜色color插值计算语法，对顶点uv坐标进行插值计算。\n\nconst vertexshader = `\n// attribute vec2 uv;//默认提供,不用自己写\nvarying vec2 vuv;\nvoid main(){\n  vuv = uv;// uv坐标插值计算\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n# 2. 声明颜色贴图变量uniform sampler2d map\n\nuniform关键字声明一个颜色贴图相关的变量map，纹理贴图对应数据类型需要用关键字sampler2d表示。\n\n// 片元着色器代码\nconst fragmentshader = `\nuniform sampler2d map;//颜色贴图变量\nvoid main() {\n    gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n}\n`\n\n\n\n# 3. 给uniform变量map传值\n\n查看uniform的文档,能看到着色器语言数据类型sampler2d对应threejs的数据类型three.texture。\n\nconst texture = new three.textureloader().load('./earth.png');\nconst material = new three.shadermaterial({\n  uniforms: {\n    // 给着色器中同名uniform变量map传值\n    map: {value: texture},\n  },\n  vertexshader: vertexshader,// 顶点着色器\n  fragmentshader: fragmentshader,// 片元着色器\n});\n\n\n\n\n# 4. 采样纹理赋值给gl_fragcolor\n\n执行varying vec2 vuv;从顶点着色器获取插值后uv坐标vuv，然后执行texture2d( map, vuv );从颜色贴图上提取像素值，赋值给模型的片元gl_fragcolor。\n\n// 片元着色器代码\nconst fragmentshader = `\nuniform sampler2d map;//颜色贴图变量\nvarying vec2 vuv;\nvoid main() {\n    // 通过几何体的uv坐标从颜色贴图获取像素值\n    gl_fragcolor = texture2d( map, vuv );\n}\n`\n",charsets:{cjk:!0}},{title:"11. shader模仿点材质效果",frontmatter:{title:"11. shader模仿点材质效果",date:"2023-10-25T10:36:09.000Z",permalink:"/pages/964545/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/11.shader%E6%A8%A1%E4%BB%BF%E7%82%B9%E6%9D%90%E8%B4%A8%E6%95%88%E6%9E%9C.html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/11.shader模仿点材质效果.md",key:"v-301a465c",path:"/pages/964545/",headers:[{level:3,title:"内置变量gl_PointSize",slug:"内置变量gl-pointsize",normalizedTitle:"内置变量gl_pointsize",charIndex:557},{level:3,title:"内置变量gl_PointCoord(Point坐标)",slug:"内置变量gl-pointcoord-point坐标",normalizedTitle:"内置变量gl_pointcoord(point坐标)",charIndex:1017},{level:3,title:"修剪方形点变成圆形点",slug:"修剪方形点变成圆形点",normalizedTitle:"修剪方形点变成圆形点",charIndex:1866}],headersStr:"内置变量gl_PointSize 内置变量gl_PointCoord(Point坐标) 修剪方形点变成圆形点",content:"# shader模仿点材质效果\n\n先复习下前面基础课程，关于点材质PointsMaterial和点模型Points的知识点。\n\nconst geometry = new THREE.BufferGeometry();\nconst vertices = new Float32Array([\n    0, 0, 0, //顶点1坐标\n    25, 0, 0, //顶点2坐标\n    50, 0, 0, //顶点3坐标\n    75, 0, 0, //顶点4坐标\n    100, 0, 0, //顶点5坐标\n]);\ngeometry.attributes.position = new THREE.BufferAttribute(vertices, 3);\nconst material = new THREE.PointsMaterial({\n    color: 0x00ffff,\n    size: 10.0 //点渲染大小调节\n}); \nconst points = new THREE.Points(geometry, material); //点模型对象\n\n\n本节课任务就是借助ShaderMaterial，自定义着色器GLSL ES代码，实现PointsMaterial的部分渲染效果。\n\n\n# 内置变量gl_PointSize\n\ngl_PointSize和gl_Position一样，都是顶点着色器GLSL ES的一个内置变量，gl_PointSize作用是设置点渲染的像素大小。\n\n// 顶点着色器代码\nconst vertexShader = `\nvoid main(){\n  gl_PointSize = 20.0;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n测试上面代码效果的时候，模型对象要使用点模型Points，而不是Mesh，Mesh表示把几何体geometry顶点数据渲染为三角形，Line表示把顶点数据渲染为直线，Points表示把顶点数据渲染为方形点。\n\n// const mesh = new THREE.Mesh(geometry, material);\nconst mesh = new THREE.Points(geometry, material);\n\n\n\n# 内置变量gl_PointCoord(Point坐标)\n\ngl_PointCoord是片元着色器着色器GLSL ES的一个内置变量，与Points渲染的方形点坐标相关，具体含义如下图：\n\nPoints可以渲染多个方形点，每个方形点的gl_PointCoord坐标原点都位于自身的左上角，x轴水平向右，y轴水平向下，不管gl_PointSize多大，Points方形点右下角gl_PointCoord坐标都是(1.0,1.0)。\n\n\n\n你可以通过下面代码，进行测试验证。\n\n方形点左边红色，右边蓝色\n\nconst fragmentShader = `\nvoid main() {\n    if(gl_PointCoord.x<0.5){\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }else{\n      gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}\n`\n\n\n方形点上边红色，下边蓝色\n\nconst fragmentShader = `\nvoid main() { \n    if(gl_PointCoord.y<0.5){\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }else{\n      gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}\n`\n\n\n左上角四分之一红色\n\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n    if(gl_PointCoord.x<0.5 && gl_PointCoord.y<0.5){\n      gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }else{\n      gl_FragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}\n`\n\n\n\n# 修剪方形点变成圆形点\n\ndistance()是着色器语言GLSL ES内置函数，用来计算两个向量之间的距离。\n\ndistance(gl_PointCoord, vec2(0.5, 0.5));表示方形点里面每个片元的gl_PointCoord坐标与坐标(0.5,0.5)的距离r。\n\n以这个距离距离r作为临界值，每个方形点的所有片元凡是距离中心vec2(0.5, 0.5)的距离大于r，都舍弃，就会生成一个圆形的点。\n\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n  // vec2(0.5, 0.5)是方形点的圆心\n  float r = distance(gl_PointCoord, vec2(0.5, 0.5));\n  if(r < 0.5){\n    // 方形区域片元距离几何中心半径小于0.5，像素颜色设置红色\n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n  }else {\n    // 方形区域距离几何中心半径不小于0.5的片元剪裁舍弃掉：\n    discard;\n  }\n}\n`\n",normalizedContent:"# shader模仿点材质效果\n\n先复习下前面基础课程，关于点材质pointsmaterial和点模型points的知识点。\n\nconst geometry = new three.buffergeometry();\nconst vertices = new float32array([\n    0, 0, 0, //顶点1坐标\n    25, 0, 0, //顶点2坐标\n    50, 0, 0, //顶点3坐标\n    75, 0, 0, //顶点4坐标\n    100, 0, 0, //顶点5坐标\n]);\ngeometry.attributes.position = new three.bufferattribute(vertices, 3);\nconst material = new three.pointsmaterial({\n    color: 0x00ffff,\n    size: 10.0 //点渲染大小调节\n}); \nconst points = new three.points(geometry, material); //点模型对象\n\n\n本节课任务就是借助shadermaterial，自定义着色器glsl es代码，实现pointsmaterial的部分渲染效果。\n\n\n# 内置变量gl_pointsize\n\ngl_pointsize和gl_position一样，都是顶点着色器glsl es的一个内置变量，gl_pointsize作用是设置点渲染的像素大小。\n\n// 顶点着色器代码\nconst vertexshader = `\nvoid main(){\n  gl_pointsize = 20.0;\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n测试上面代码效果的时候，模型对象要使用点模型points，而不是mesh，mesh表示把几何体geometry顶点数据渲染为三角形，line表示把顶点数据渲染为直线，points表示把顶点数据渲染为方形点。\n\n// const mesh = new three.mesh(geometry, material);\nconst mesh = new three.points(geometry, material);\n\n\n\n# 内置变量gl_pointcoord(point坐标)\n\ngl_pointcoord是片元着色器着色器glsl es的一个内置变量，与points渲染的方形点坐标相关，具体含义如下图：\n\npoints可以渲染多个方形点，每个方形点的gl_pointcoord坐标原点都位于自身的左上角，x轴水平向右，y轴水平向下，不管gl_pointsize多大，points方形点右下角gl_pointcoord坐标都是(1.0,1.0)。\n\n\n\n你可以通过下面代码，进行测试验证。\n\n方形点左边红色，右边蓝色\n\nconst fragmentshader = `\nvoid main() {\n    if(gl_pointcoord.x<0.5){\n      gl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n    }else{\n      gl_fragcolor = vec4(0.0,0.0,1.0,1.0);\n    }\n}\n`\n\n\n方形点上边红色，下边蓝色\n\nconst fragmentshader = `\nvoid main() { \n    if(gl_pointcoord.y<0.5){\n      gl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n    }else{\n      gl_fragcolor = vec4(0.0,0.0,1.0,1.0);\n    }\n}\n`\n\n\n左上角四分之一红色\n\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n    if(gl_pointcoord.x<0.5 && gl_pointcoord.y<0.5){\n      gl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n    }else{\n      gl_fragcolor = vec4(0.0,0.0,1.0,1.0);\n    }\n}\n`\n\n\n\n# 修剪方形点变成圆形点\n\ndistance()是着色器语言glsl es内置函数，用来计算两个向量之间的距离。\n\ndistance(gl_pointcoord, vec2(0.5, 0.5));表示方形点里面每个片元的gl_pointcoord坐标与坐标(0.5,0.5)的距离r。\n\n以这个距离距离r作为临界值，每个方形点的所有片元凡是距离中心vec2(0.5, 0.5)的距离大于r，都舍弃，就会生成一个圆形的点。\n\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n  // vec2(0.5, 0.5)是方形点的圆心\n  float r = distance(gl_pointcoord, vec2(0.5, 0.5));\n  if(r < 0.5){\n    // 方形区域片元距离几何中心半径小于0.5，像素颜色设置红色\n    gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n  }else {\n    // 方形区域距离几何中心半径不小于0.5的片元剪裁舍弃掉：\n    discard;\n  }\n}\n`\n",charsets:{cjk:!0}},{title:"12. attribute自定义顶点变量",frontmatter:{title:"12. attribute自定义顶点变量",date:"2023-10-25T10:36:17.000Z",permalink:"/pages/f74c6d/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/01.1.threejs%20Shader%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/12.attribute%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B6%E7%82%B9%E5%8F%98%E9%87%8F.html",relativePath:"03.Threejs Shader教程/01.1.threejs Shader基础语法/12.attribute自定义顶点变量.md",key:"v-6da97d6b",path:"/pages/f74c6d/",headers:[{level:3,title:"知识回顾：顶点数据",slug:"知识回顾-顶点数据",normalizedTitle:"知识回顾：顶点数据",charIndex:403},{level:3,title:"问题思考",slug:"问题思考",normalizedTitle:"问题思考",charIndex:944},{level:3,title:"1. 自定义顶点数据geometry.attributes.size",slug:"_1-自定义顶点数据geometry-attributes-size",normalizedTitle:"1. 自定义顶点数据geometry.attributes.size",charIndex:1048},{level:3,title:"声明顶点尺寸size变量",slug:"声明顶点尺寸size变量",normalizedTitle:"声明顶点尺寸size变量",charIndex:1744},{level:3,title:"每个方形点尺寸单独控制",slug:"每个方形点尺寸单独控制",normalizedTitle:"每个方形点尺寸单独控制",charIndex:2127}],headersStr:"知识回顾：顶点数据 问题思考 1. 自定义顶点数据geometry.attributes.size 声明顶点尺寸size变量 每个方形点尺寸单独控制",content:"# attribute自定义顶点变量\n\n下面给大家讲解，怎么给threejs几何体BufferGeometry自定义任意类型的顶点数据,同时顶点着色器代码里面声明一个同名的attribute顶点变量。\n\n顶点.size属性\n\nconst geometry = new THREE.BufferGeometry();\ngeometry.attributes.size = new THREE.BufferAttribute(sizes, 1);\n\n\n着色器顶点size变量\n\n// 顶点着色器代码\nconst vertexShader = `\nattribute float size;//着色器size变量\nvoid main(){\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n\n# 知识回顾：顶点数据\n\n前面基础课程关于BufferGeometry，介绍过顶点位置、颜色、UV、法向量等数据。\n\ngeometry.attributes.position\ngeometry.attributes.color\ngeometry.attributes.uv\ngeometry.attributes.normal\n\n\n通过本章节前面学习，大家知道，ShaderMaterial默认会提供几个顶点数据的内置变量，比如顶点位置position、顶点颜色color、顶点UV坐标uv。\n\nattribute vec3 position;// 默认提供,不用自己写\nattribute vec3 color;// 默认提供,不用自己写\nattribute vec2 uv;// 默认提供,不用自己写\n\n\n// 顶点着色器代码\nconst vertexShader = `\nvoid main(){\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n\n\n上面两个知识点，确保你都非常熟悉以后，你可以跟着视频学习进行下面内容，也就是自定义几何体任意类型的顶点数据。\n\n\n# 问题思考\n\n大家思考一个问题，使用Points渲染几何体顶点数据的时候，怎么能让每一个顶点对应的方形点尺寸不同，你可以打开课件案例源码，预览下效果，然后自己尝试修改上节课的代码，实现下图的效果。\n\n\n\n\n# 1. 自定义顶点数据geometry.attributes.size\n\n模仿顶点位置坐标geometry.attributes.position的自定义，给几何体BufferGeometry自定义一个顶点size数据geometry.attributes.size。\n\nsize里面的每个顶点数据表示对应Points方形点尺寸gl_PointSize的缩放倍数。\n\nconst geometry = new THREE.BufferGeometry();\nconst vertices = new Float32Array([\n    0, 0, 0, //顶点1坐标\n    25, 0, 0, //顶点2坐标\n    50, 0, 0, //顶点3坐标\n    75, 0, 0, //顶点4坐标\n    100, 0, 0, //顶点5坐标\n]);\n//3个为一组，表示一个顶点的xyz坐标\ngeometry.attributes.position = new THREE.BufferAttribute(vertices, 3); \nconst sizes = new Float32Array([\n    1.0, //顶点1对应方形点尺寸缩放倍数\n    0.8, //顶点2\n    0.6, //顶点3\n    0.4, //顶点4\n    0.2, //顶点5\n]);\n// 1个数为一组表示对应顶点gl_PointSize的缩放倍数\ngeometry.attributes.size = new THREE.BufferAttribute(sizes, 1);\n\n\n\n# 声明顶点尺寸size变量\n\nattribute float size;声明顶点尺寸变量size，因为只有一个分量，数据类型不需要用向量，用浮点数float即可。\n\n注意这里的着色器里面size变量和几何体的顶点尺寸属性geometry.attributes.sizesize名字保持一致，这样threejs才能从geometry获取geometry.attributes.size数据，传递给着色器变量size。\n\n// 几何体自定的size属性\ngeometry.attributes.size = new THREE.BufferAttribute(sizes, 1);\n// 顶点着色器代码\nconst vertexShader = `\nattribute float size;//着色器size变量\nvoid main(){\n  ...\n}\n`\n\n\n\n# 每个方形点尺寸单独控制\n\ngl_PointSize = 20.0 * size;分别控制每个方形点的尺寸大小。\n\n// 顶点着色器代码\nconst vertexShader = `\nattribute float size;\nvoid main(){\n  gl_PointSize = 20.0 * size;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`\n",normalizedContent:"# attribute自定义顶点变量\n\n下面给大家讲解，怎么给threejs几何体buffergeometry自定义任意类型的顶点数据,同时顶点着色器代码里面声明一个同名的attribute顶点变量。\n\n顶点.size属性\n\nconst geometry = new three.buffergeometry();\ngeometry.attributes.size = new three.bufferattribute(sizes, 1);\n\n\n着色器顶点size变量\n\n// 顶点着色器代码\nconst vertexshader = `\nattribute float size;//着色器size变量\nvoid main(){\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n\n\n# 知识回顾：顶点数据\n\n前面基础课程关于buffergeometry，介绍过顶点位置、颜色、uv、法向量等数据。\n\ngeometry.attributes.position\ngeometry.attributes.color\ngeometry.attributes.uv\ngeometry.attributes.normal\n\n\n通过本章节前面学习，大家知道，shadermaterial默认会提供几个顶点数据的内置变量，比如顶点位置position、顶点颜色color、顶点uv坐标uv。\n\nattribute vec3 position;// 默认提供,不用自己写\nattribute vec3 color;// 默认提供,不用自己写\nattribute vec2 uv;// 默认提供,不用自己写\n\n\n// 顶点着色器代码\nconst vertexshader = `\nvoid main(){\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n\n\n上面两个知识点，确保你都非常熟悉以后，你可以跟着视频学习进行下面内容，也就是自定义几何体任意类型的顶点数据。\n\n\n# 问题思考\n\n大家思考一个问题，使用points渲染几何体顶点数据的时候，怎么能让每一个顶点对应的方形点尺寸不同，你可以打开课件案例源码，预览下效果，然后自己尝试修改上节课的代码，实现下图的效果。\n\n\n\n\n# 1. 自定义顶点数据geometry.attributes.size\n\n模仿顶点位置坐标geometry.attributes.position的自定义，给几何体buffergeometry自定义一个顶点size数据geometry.attributes.size。\n\nsize里面的每个顶点数据表示对应points方形点尺寸gl_pointsize的缩放倍数。\n\nconst geometry = new three.buffergeometry();\nconst vertices = new float32array([\n    0, 0, 0, //顶点1坐标\n    25, 0, 0, //顶点2坐标\n    50, 0, 0, //顶点3坐标\n    75, 0, 0, //顶点4坐标\n    100, 0, 0, //顶点5坐标\n]);\n//3个为一组，表示一个顶点的xyz坐标\ngeometry.attributes.position = new three.bufferattribute(vertices, 3); \nconst sizes = new float32array([\n    1.0, //顶点1对应方形点尺寸缩放倍数\n    0.8, //顶点2\n    0.6, //顶点3\n    0.4, //顶点4\n    0.2, //顶点5\n]);\n// 1个数为一组表示对应顶点gl_pointsize的缩放倍数\ngeometry.attributes.size = new three.bufferattribute(sizes, 1);\n\n\n\n# 声明顶点尺寸size变量\n\nattribute float size;声明顶点尺寸变量size，因为只有一个分量，数据类型不需要用向量，用浮点数float即可。\n\n注意这里的着色器里面size变量和几何体的顶点尺寸属性geometry.attributes.sizesize名字保持一致，这样threejs才能从geometry获取geometry.attributes.size数据，传递给着色器变量size。\n\n// 几何体自定的size属性\ngeometry.attributes.size = new three.bufferattribute(sizes, 1);\n// 顶点着色器代码\nconst vertexshader = `\nattribute float size;//着色器size变量\nvoid main(){\n  ...\n}\n`\n\n\n\n# 每个方形点尺寸单独控制\n\ngl_pointsize = 20.0 * size;分别控制每个方形点的尺寸大小。\n\n// 顶点着色器代码\nconst vertexshader = `\nattribute float size;\nvoid main(){\n  gl_pointsize = 20.0 * size;\n  gl_position = projectionmatrix * modelviewmatrix * vec4( position, 1.0 );\n}\n`\n",charsets:{cjk:!0}},{title:"1. threejs材质的shader代码",frontmatter:{title:"1. threejs材质的shader代码",date:"2023-10-25T23:27:11.000Z",permalink:"/pages/b7b8ff/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/02.2.onBeforeCompile%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8/01.threejs%E6%9D%90%E8%B4%A8%E7%9A%84shader%E4%BB%A3%E7%A0%81.html",relativePath:"03.Threejs Shader教程/02.2.onBeforeCompile修改材质/01.threejs材质的shader代码.md",key:"v-75e4b124",path:"/pages/b7b8ff/",headers:[{level:3,title:"知识回顾：ShaderMaterial自定义shader代码",slug:"知识回顾-shadermaterial自定义shader代码",normalizedTitle:"知识回顾：shadermaterial自定义shader代码",charIndex:77},{level:3,title:"不同材质对应的shader文件",slug:"不同材质对应的shader文件",normalizedTitle:"不同材质对应的shader文件",charIndex:349},{level:3,title:"#include语法简介",slug:"include语法简介",normalizedTitle:"#include语法简介",charIndex:511},{level:3,title:"renderers\\shaders\\ShaderChunk目录",slug:"renderers-shaders-shaderchunk目录",normalizedTitle:"renderers\\shaders\\shaderchunk目录",charIndex:610},{level:3,title:".onBeforeCompile查看shader代码",slug:"onbeforecompile查看shader代码",normalizedTitle:".onbeforecompile查看shader代码",charIndex:1173}],headersStr:"知识回顾：ShaderMaterial自定义shader代码 不同材质对应的shader文件 #include语法简介 renderers\\shaders\\ShaderChunk目录 .onBeforeCompile查看shader代码",content:"# threejs各个材质的shader代码\n\n本节课给大家说说threejs各种网格材质、点材质、精灵材质，对应的着色器(shader)代码。\n\n\n# 知识回顾：ShaderMaterial自定义shader代码\n\n回顾下前面ShaderMaterial讲解，你会发现咱们用ShaderMaterial自定义着色器GLSL ES代码，模拟过基础网格材质MeshBasicMaterial、点材质PointsMaterial的渲染效果。\n\n * 1.3. ShaderMaterial着色器材质\n * 1.11.shader模仿点材质效果\n\n其实threejs中，接触的常用的网格材质、点材质本质上都是shader(着色器)代码，都有threejs提前定义好的着色器 GLSL ES代码。\n\n\n# 不同材质对应的shader文件\n\n你可以下载threejs官方文件包，或者直接查看课件源码中我下载的threejs文件包。\n\n目录\\src\\renderers\\shaders\\ShaderLib里面有不同threejs材质对应的着色器shader文件。\n\n你通过名字，就可以判断，那个材质，对应那个shader文件\n\n\n# #include语法简介\n\n着色器语言GLSL ES，可以通过#include引入其它的着色器代码文件，你可以类比js的 import语法去对比理解(虽然不同，但是都是为了引入别的文件)。\n\n\n# renderers\\shaders\\ShaderChunk目录\n\n查看threejs官方文件包src\\renderers\\shaders\\ShaderChunk目录，你可以发现ShaderChunk文件夹里面有很多着色器GLSL ES的功能代码模块。\n\n比如文件default_vertex.glsl.js、default_fragment.glsl.js、color_pars_vertex.glsl.js\n\nShaderChunk里面的shader代码文件，会被其它的文件引用，比如shaders\\ShaderLib目录下面的shader文件，就会引用ShaderChunk里面的文件代码。\n\n比如ShaderChunk里面的color_pars_vertex.glsl.js文件，会被ShaderLib里面多个文件引用，你可以检索关键词color_pars_vertex去验证，你会发现多个文件含有代码#include <color_pars_vertex>。\n\n比如网格基础材质MeshBasicMaterial对应shader文件meshbasic.glsl.js，就引入了文件color_pars_vertex.glsl.js\n\n...\n#include <color_pars_vertex>\n...\n\n\n\n# .onBeforeCompile查看shader代码\n\nthreejs各个材质材质会从父类Material继承.onBeforeCompile方法。\n\n你可以通过.onBeforeCompile函数的参数shader获取材质的着色器代码，其实你对照下，就会发现这些代码的来自\\src\\renderers\\shaders\\ShaderLib目录下shader文件。\n\nconst material = new THREE.MeshLambertMaterial();\nmaterial.onBeforeCompile = function (shader) {\n  console.log('shader', shader);\n  console.log('顶点着色器', shader.vertexShader);\n  console.log('片元着色器', shader.fragmentShader);\n}\n",normalizedContent:"# threejs各个材质的shader代码\n\n本节课给大家说说threejs各种网格材质、点材质、精灵材质，对应的着色器(shader)代码。\n\n\n# 知识回顾：shadermaterial自定义shader代码\n\n回顾下前面shadermaterial讲解，你会发现咱们用shadermaterial自定义着色器glsl es代码，模拟过基础网格材质meshbasicmaterial、点材质pointsmaterial的渲染效果。\n\n * 1.3. shadermaterial着色器材质\n * 1.11.shader模仿点材质效果\n\n其实threejs中，接触的常用的网格材质、点材质本质上都是shader(着色器)代码，都有threejs提前定义好的着色器 glsl es代码。\n\n\n# 不同材质对应的shader文件\n\n你可以下载threejs官方文件包，或者直接查看课件源码中我下载的threejs文件包。\n\n目录\\src\\renderers\\shaders\\shaderlib里面有不同threejs材质对应的着色器shader文件。\n\n你通过名字，就可以判断，那个材质，对应那个shader文件\n\n\n# #include语法简介\n\n着色器语言glsl es，可以通过#include引入其它的着色器代码文件，你可以类比js的 import语法去对比理解(虽然不同，但是都是为了引入别的文件)。\n\n\n# renderers\\shaders\\shaderchunk目录\n\n查看threejs官方文件包src\\renderers\\shaders\\shaderchunk目录，你可以发现shaderchunk文件夹里面有很多着色器glsl es的功能代码模块。\n\n比如文件default_vertex.glsl.js、default_fragment.glsl.js、color_pars_vertex.glsl.js\n\nshaderchunk里面的shader代码文件，会被其它的文件引用，比如shaders\\shaderlib目录下面的shader文件，就会引用shaderchunk里面的文件代码。\n\n比如shaderchunk里面的color_pars_vertex.glsl.js文件，会被shaderlib里面多个文件引用，你可以检索关键词color_pars_vertex去验证，你会发现多个文件含有代码#include <color_pars_vertex>。\n\n比如网格基础材质meshbasicmaterial对应shader文件meshbasic.glsl.js，就引入了文件color_pars_vertex.glsl.js\n\n...\n#include <color_pars_vertex>\n...\n\n\n\n# .onbeforecompile查看shader代码\n\nthreejs各个材质材质会从父类material继承.onbeforecompile方法。\n\n你可以通过.onbeforecompile函数的参数shader获取材质的着色器代码，其实你对照下，就会发现这些代码的来自\\src\\renderers\\shaders\\shaderlib目录下shader文件。\n\nconst material = new three.meshlambertmaterial();\nmaterial.onbeforecompile = function (shader) {\n  console.log('shader', shader);\n  console.log('顶点着色器', shader.vertexshader);\n  console.log('片元着色器', shader.fragmentshader);\n}\n",charsets:{cjk:!0}},{title:"2. onBeforeCompile修改材质shader",frontmatter:{title:"2. onBeforeCompile修改材质shader",date:"2023-10-25T23:27:23.000Z",permalink:"/pages/4dd4b2/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/02.2.onBeforeCompile%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8/02.onBeforeCompile%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8shader.html",relativePath:"03.Threejs Shader教程/02.2.onBeforeCompile修改材质/02.onBeforeCompile修改材质shader.md",key:"v-c11250be",path:"/pages/4dd4b2/",headers:[{level:3,title:"gl_FragColor多次执行",slug:"gl-fragcolor多次执行",normalizedTitle:"gl_fragcolor多次执行",charIndex:900},{level:3,title:"查看材质MeshLambertMaterial片元着色器代码",slug:"查看材质meshlambertmaterial片元着色器代码",normalizedTitle:"查看材质meshlambertmaterial片元着色器代码",charIndex:1266},{level:3,title:".replace()方法介绍",slug:"replace-方法介绍",normalizedTitle:".replace()方法介绍",charIndex:1909},{level:3,title:"修改MeshLambertMaterial片元着色器代码",slug:"修改meshlambertmaterial片元着色器代码",normalizedTitle:"修改meshlambertmaterial片元着色器代码",charIndex:2152}],headersStr:"gl_FragColor多次执行 查看材质MeshLambertMaterial片元着色器代码 .replace()方法介绍 修改MeshLambertMaterial片元着色器代码",content:"# .onBeforeCompile修改材质shader\n\n上节课给大家说过，你可以通过材质.onBeforeCompile方法查看材质的着色器代码，其实也可以通过函数参数shader获取顶点或片元着色器GLSL ES的字符串进行二次修改。\n\nconst material = new THREE.MeshLambertMaterial();\nmaterial.onBeforeCompile = function (shader) {\n  console.log('顶点着色器', shader.vertexShader);\n  console.log('片元着色器', shader.fragmentShader);\n  //你可以增删shader.vertexShader字符串\n  //你可以增删shader.fragmentShader字符串\n}\n\n\n本节课修改结果：\n\nconst material = new THREE.MeshLambertMaterial({\n    map: texture,\n});\n// 修改材质material默认的着色器shader代码\nmaterial.onBeforeCompile = function (shader) {\n    // console.log('片元着色器', shader.fragmentShader);\n    // 在片元着色器main函数里面最后一行插入代码\n    shader.fragmentShader = shader.fragmentShader.replace(\n        '#include <dithering_fragment>',//一行代码字符串，你可以用单双引号\n        //多行代码字符串，用模板字符串``更方便\n        `\n        #include <dithering_fragment>\n        gl_FragColor.r = 0.0;\n        gl_FragColor.g = 0.0;\n        `\n    )\n}\n\n\n\n# gl_FragColor多次执行\n\n在片元着色器主函数main中，内置变量gl_FragColor可以多次调用设置RGBA分量的值。\n\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n    //重新访问rgb属性赋值\n    gl_FragColor.g = 0.0;\n}\n`\n\n\n// 片元着色器代码\nconst fragmentShader = `\nvoid main() {\n    gl_FragColor = vec4(0.0,1.0,1.0,1.0);\n    //可以多次赋值\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n}\n`\n\n\n\n# 查看材质MeshLambertMaterial片元着色器代码\n\n你可以直接去threejs官方文件包目录\\src\\renderers\\shaders\\ShaderLib，查看MeshLambertMaterial对应的shader文件meshlambert.glsl.js。\n\nmeshlambert.glsl.js里面有两个字符串，一个是顶点着色器代码，一个片元着色器代码。\n\nconst material = new THREE.MeshLambertMaterial();\n\n\n也可以直接浏览器控制台log打印\n\nmaterial.onBeforeCompile = function (shader) {\n    console.log('片元着色器', shader.fragmentShader);\n}\n\n\n因为threejs经常改变，不太稳定，所以这里强烈提醒，不同版本threejs，同一个材质的shader代码可能一样，也可能不一样，代码打印结果，以你使用的threejs版本为准，并不一定要和我视频完全一致。\n\n你可以确定下你当前threejs版本，MeshLambertMaterial片元着色器主函数main里面最后一行代码是什么，我这里是#include <dithering_fragment>。\n\nvoid main() {\n    ...\n    ...\n    ...\n    #include <dithering_fragment>\n}\n\n\n\n# .replace()方法介绍\n\n.replace()JavaScript语言处理字符串的一个方法，算是普通前端基础。如果你了解，可以跳过去，如果不熟悉，就跟着视频熟悉下。\n\n.replace()功能就是修改一串字符串，具体方式就是检索字符串是否包含参数1表示的字符串，去替换新的字符串。\n\nconst str = '我爱加班';\nconst newStr = str.replace('爱加班','不爱加班');\nconsole.log('改变后字符串', newStr);\n\n\n\n# 修改MeshLambertMaterial片元着色器代码\n\n目标：在MeshLambertMaterial片元着色器主函数main里面最后一行后面增加代码。\n\nvoid main() {\n    ...\n    ...\n    ...\n    #include <dithering_fragment>\n    // 在这里增加代码\n}\n\n\n材质的片元着色器代码shader.fragmentShader本身就是一个字符串，所以我们可以用.replace()去修改替换shader.fragmentShader里面的部分代码。\n\nconst material = new THREE.MeshLambertMaterial({\n    map: texture,\n});\n// 修改材质material默认的着色器shader代码\nmaterial.onBeforeCompile = function (shader) {\n    // console.log('片元着色器', shader.fragmentShader);\n    // 在片元着色器main函数里面最后一行插入代码\n    shader.fragmentShader = shader.fragmentShader.replace(\n        '#include <dithering_fragment>',//一行代码字符串，你可以用单双引号\n        //多行代码字符串，用模板字符串``更方便\n        `\n        #include <dithering_fragment>\n        gl_FragColor.r = 0.0;\n        gl_FragColor.g = 0.0;\n        `\n    )\n}\n",normalizedContent:"# .onbeforecompile修改材质shader\n\n上节课给大家说过，你可以通过材质.onbeforecompile方法查看材质的着色器代码，其实也可以通过函数参数shader获取顶点或片元着色器glsl es的字符串进行二次修改。\n\nconst material = new three.meshlambertmaterial();\nmaterial.onbeforecompile = function (shader) {\n  console.log('顶点着色器', shader.vertexshader);\n  console.log('片元着色器', shader.fragmentshader);\n  //你可以增删shader.vertexshader字符串\n  //你可以增删shader.fragmentshader字符串\n}\n\n\n本节课修改结果：\n\nconst material = new three.meshlambertmaterial({\n    map: texture,\n});\n// 修改材质material默认的着色器shader代码\nmaterial.onbeforecompile = function (shader) {\n    // console.log('片元着色器', shader.fragmentshader);\n    // 在片元着色器main函数里面最后一行插入代码\n    shader.fragmentshader = shader.fragmentshader.replace(\n        '#include <dithering_fragment>',//一行代码字符串，你可以用单双引号\n        //多行代码字符串，用模板字符串``更方便\n        `\n        #include <dithering_fragment>\n        gl_fragcolor.r = 0.0;\n        gl_fragcolor.g = 0.0;\n        `\n    )\n}\n\n\n\n# gl_fragcolor多次执行\n\n在片元着色器主函数main中，内置变量gl_fragcolor可以多次调用设置rgba分量的值。\n\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n    gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n    //重新访问rgb属性赋值\n    gl_fragcolor.g = 0.0;\n}\n`\n\n\n// 片元着色器代码\nconst fragmentshader = `\nvoid main() {\n    gl_fragcolor = vec4(0.0,1.0,1.0,1.0);\n    //可以多次赋值\n    gl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n}\n`\n\n\n\n# 查看材质meshlambertmaterial片元着色器代码\n\n你可以直接去threejs官方文件包目录\\src\\renderers\\shaders\\shaderlib，查看meshlambertmaterial对应的shader文件meshlambert.glsl.js。\n\nmeshlambert.glsl.js里面有两个字符串，一个是顶点着色器代码，一个片元着色器代码。\n\nconst material = new three.meshlambertmaterial();\n\n\n也可以直接浏览器控制台log打印\n\nmaterial.onbeforecompile = function (shader) {\n    console.log('片元着色器', shader.fragmentshader);\n}\n\n\n因为threejs经常改变，不太稳定，所以这里强烈提醒，不同版本threejs，同一个材质的shader代码可能一样，也可能不一样，代码打印结果，以你使用的threejs版本为准，并不一定要和我视频完全一致。\n\n你可以确定下你当前threejs版本，meshlambertmaterial片元着色器主函数main里面最后一行代码是什么，我这里是#include <dithering_fragment>。\n\nvoid main() {\n    ...\n    ...\n    ...\n    #include <dithering_fragment>\n}\n\n\n\n# .replace()方法介绍\n\n.replace()javascript语言处理字符串的一个方法，算是普通前端基础。如果你了解，可以跳过去，如果不熟悉，就跟着视频熟悉下。\n\n.replace()功能就是修改一串字符串，具体方式就是检索字符串是否包含参数1表示的字符串，去替换新的字符串。\n\nconst str = '我爱加班';\nconst newstr = str.replace('爱加班','不爱加班');\nconsole.log('改变后字符串', newstr);\n\n\n\n# 修改meshlambertmaterial片元着色器代码\n\n目标：在meshlambertmaterial片元着色器主函数main里面最后一行后面增加代码。\n\nvoid main() {\n    ...\n    ...\n    ...\n    #include <dithering_fragment>\n    // 在这里增加代码\n}\n\n\n材质的片元着色器代码shader.fragmentshader本身就是一个字符串，所以我们可以用.replace()去修改替换shader.fragmentshader里面的部分代码。\n\nconst material = new three.meshlambertmaterial({\n    map: texture,\n});\n// 修改材质material默认的着色器shader代码\nmaterial.onbeforecompile = function (shader) {\n    // console.log('片元着色器', shader.fragmentshader);\n    // 在片元着色器main函数里面最后一行插入代码\n    shader.fragmentshader = shader.fragmentshader.replace(\n        '#include <dithering_fragment>',//一行代码字符串，你可以用单双引号\n        //多行代码字符串，用模板字符串``更方便\n        `\n        #include <dithering_fragment>\n        gl_fragcolor.r = 0.0;\n        gl_fragcolor.g = 0.0;\n        `\n    )\n}\n",charsets:{cjk:!0}},{title:"3. 修改材质shader(彩色图变灰度图)",frontmatter:{title:"3. 修改材质shader(彩色图变灰度图)",date:"2023-10-25T23:27:34.000Z",permalink:"/pages/d163ed/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/02.2.onBeforeCompile%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8/03.%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8shader(%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%8F%98%E7%81%B0%E5%BA%A6%E5%9B%BE).html",relativePath:"03.Threejs Shader教程/02.2.onBeforeCompile修改材质/03.修改材质shader(彩色图变灰度图).md",key:"v-26882685",path:"/pages/d163ed/",headers:[{level:3,title:"灰度图公式",slug:"灰度图公式",normalizedTitle:"灰度图公式",charIndex:327},{level:3,title:"思考思路",slug:"思考思路",normalizedTitle:"思考思路",charIndex:549},{level:3,title:".onBeforeCompile+.replace修改着色代码",slug:"onbeforecompile-replace修改着色代码",normalizedTitle:".onbeforecompile+.replace修改着色代码",charIndex:688}],headersStr:"灰度图公式 思考思路 .onBeforeCompile+.replace修改着色代码",content:"# 修改材质shader(彩色图变灰度图)\n\n通过上节课学习，大家已经知道，怎么用onBeforeCompile修改材质shader,这节课算是一个练习题。\n\n打开演示文件代码，你可以看到MeshLambertMaterial材质渲染的彩色效果图。\n\nconst texture = new THREE.TextureLoader().load('./Earth.png');\nconst material = new THREE.MeshLambertMaterial({\n    map: texture,\n});\n\n\n任务：修改Lambert网格材质MeshLambertMaterial默认的shader代码，把彩色图转化为灰度图。\n\n\n\n\n# 灰度图公式\n\n获取彩色图R、G、B三个分量，执行灰度图公式0.299*R+0.587*G+0.114*B，把计算结果gray作为新的R、G、B值。\n\n// 灰度图公式\ngray = 0.299 * R + 0.587 * G + 0.114 * B;\n// gray作为新的R、G、B值\ngl_FragColor = vec4(gray,gray,gray,1);\n\n\n\n\n提醒：灰度图公式不用记忆，用到了直接复制文档公式或百度下就行\n\n\n# 思考思路\n\n你可以尝试思考下，怎么才能修改shader代码，才能把彩色图转灰度图。\n\n首先这肯定像素RGB值相关，这样的话，应该是修改片元着色器，而不是修改顶点着色器。再具体点说就是通过片元着色器内置变量gl_FragColor修改片元的R、G、B分量，变成灰白效果。\n\n\n# .onBeforeCompile+.replace修改着色代码\n\n查看你当前threejs版本，材质片元着色器代码main里面的最后一行，复制出来即可。\n\nmaterial.onBeforeCompile = function (shader) {\n    console.log('片元着色器', shader.fragmentShader);\n}\n\n\n.replace处理片元着色器代码，把最后一行替换为最后一行加别的代码。\n\nconst material = new THREE.MeshLambertMaterial({\n    map: texture,\n});\n// 修改材质material默认的着色器shader代码\nmaterial.onBeforeCompile = function (shader) {\n    console.log('片元着色器', shader.fragmentShader);\n    // 在片元着色器main函数里面最后一行插入灰度图代码\n    shader.fragmentShader = shader.fragmentShader.replace(\n        '#include <dithering_fragment>',\n        `\n        #include <dithering_fragment>\n        // 灰度图公式\n        float gray = 0.299*gl_FragColor.r+0.587*gl_FragColor.g+0.114*gl_FragColor.b;\n        gl_FragColor = vec4(gray,gray,gray,gl_FragColor.a);\n        `\n    )\n}\n",normalizedContent:"# 修改材质shader(彩色图变灰度图)\n\n通过上节课学习，大家已经知道，怎么用onbeforecompile修改材质shader,这节课算是一个练习题。\n\n打开演示文件代码，你可以看到meshlambertmaterial材质渲染的彩色效果图。\n\nconst texture = new three.textureloader().load('./earth.png');\nconst material = new three.meshlambertmaterial({\n    map: texture,\n});\n\n\n任务：修改lambert网格材质meshlambertmaterial默认的shader代码，把彩色图转化为灰度图。\n\n\n\n\n# 灰度图公式\n\n获取彩色图r、g、b三个分量，执行灰度图公式0.299*r+0.587*g+0.114*b，把计算结果gray作为新的r、g、b值。\n\n// 灰度图公式\ngray = 0.299 * r + 0.587 * g + 0.114 * b;\n// gray作为新的r、g、b值\ngl_fragcolor = vec4(gray,gray,gray,1);\n\n\n\n\n提醒：灰度图公式不用记忆，用到了直接复制文档公式或百度下就行\n\n\n# 思考思路\n\n你可以尝试思考下，怎么才能修改shader代码，才能把彩色图转灰度图。\n\n首先这肯定像素rgb值相关，这样的话，应该是修改片元着色器，而不是修改顶点着色器。再具体点说就是通过片元着色器内置变量gl_fragcolor修改片元的r、g、b分量，变成灰白效果。\n\n\n# .onbeforecompile+.replace修改着色代码\n\n查看你当前threejs版本，材质片元着色器代码main里面的最后一行，复制出来即可。\n\nmaterial.onbeforecompile = function (shader) {\n    console.log('片元着色器', shader.fragmentshader);\n}\n\n\n.replace处理片元着色器代码，把最后一行替换为最后一行加别的代码。\n\nconst material = new three.meshlambertmaterial({\n    map: texture,\n});\n// 修改材质material默认的着色器shader代码\nmaterial.onbeforecompile = function (shader) {\n    console.log('片元着色器', shader.fragmentshader);\n    // 在片元着色器main函数里面最后一行插入灰度图代码\n    shader.fragmentshader = shader.fragmentshader.replace(\n        '#include <dithering_fragment>',\n        `\n        #include <dithering_fragment>\n        // 灰度图公式\n        float gray = 0.299*gl_fragcolor.r+0.587*gl_fragcolor.g+0.114*gl_fragcolor.b;\n        gl_fragcolor = vec4(gray,gray,gray,gl_fragcolor.a);\n        `\n    )\n}\n",charsets:{cjk:!0}},{title:"4. 顶点位置插值(设置片元颜色)",frontmatter:{title:"4. 顶点位置插值(设置片元颜色)",date:"2023-10-28T21:44:16.000Z",permalink:"/pages/a93f3a/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/02.2.onBeforeCompile%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8/04.%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%80%BC(%E8%AE%BE%E7%BD%AE%E7%89%87%E5%85%83%E9%A2%9C%E8%89%B2).html",relativePath:"03.Threejs Shader教程/02.2.onBeforeCompile修改材质/04.顶点位置插值(设置片元颜色).md",key:"v-4871c65a",path:"/pages/a93f3a/",headers:[{level:3,title:"任务：在网格y方向增加一条光带",slug:"任务-在网格y方向增加一条光带",normalizedTitle:"任务：在网格y方向增加一条光带",charIndex:149},{level:3,title:"修改顶点着色器：增加顶点位置插值计算代码",slug:"修改顶点着色器-增加顶点位置插值计算代码",normalizedTitle:"修改顶点着色器：增加顶点位置插值计算代码",charIndex:171},{level:3,title:"片元着色器增加varying vec3 vPosition;",slug:"片元着色器增加varying-vec3-vposition",normalizedTitle:"片元着色器增加varying vec3 vposition;",charIndex:1209},{level:3,title:"根据片元对应顶点位置设置片元颜色",slug:"根据片元对应顶点位置设置片元颜色",normalizedTitle:"根据片元对应顶点位置设置片元颜色",charIndex:1602},{level:3,title:"修改片元着色器字符串",slug:"修改片元着色器字符串",normalizedTitle:"修改片元着色器字符串",charIndex:2079},{level:3,title:"多条光带",slug:"多条光带",normalizedTitle:"多条光带",charIndex:2587},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2922}],headersStr:"任务：在网格y方向增加一条光带 修改顶点着色器：增加顶点位置插值计算代码 片元着色器增加varying vec3 vPosition; 根据片元对应顶点位置设置片元颜色 修改片元着色器字符串 多条光带 总结",content:"# 顶点位置插值(设置片元颜色)\n\n这节课讲解一个onBeforeCompile修改材质shader的案例，具体就是对顶点的位置坐标xyz进行插值计算，然后根据片元对应的顶点插值坐标，设置片元颜色。\n\n顶点插值这个知识点其实在前面1.9. 顶点位置插值(实现渐变色)讲解过，可以去回顾下。\n\n\n# 任务：在网格y方向增加一条光带\n\n\n\n\n# 修改顶点着色器：增加顶点位置插值计算代码\n\n你可以通过浏览器控制台log打印，查看顶点着色器代码。\n\nmaterial.onBeforeCompile = function (shader) {\n  console.log('vertexShader', shader.vertexShader);\n};\n\n\n// 浏览器控制台打印顶点着色器代码(提醒不同版本不一定相同)\n#include <common>\n...\nvoid main(){\n  ...\n  #include <fog_vertex>\n} \n\n\n这时候你可以思考一个问题，怎么给顶点着色器代码main函数之前插入一行插值计算的相关代码varying vec3 vPosition;\n\n#include <common>\n...\nvarying vec3 vPosition;//表示顶点位置插值后的坐标\nvoid main(){\n  ...\n  #include <fog_vertex>\n} \n\n\n.replace()查询关键词void main() {进行如下替换。\n\nmaterial.onBeforeCompile = function (shader) {\n  shader.vertexShader = shader.vertexShader.replace(\n    'void main() {',\n    `\n    varying vec3 vPosition;//顶点位置插值后的坐标\n    void main(){\n    `\n  );\n};\n\n\n在main函数里面，增加顶点位置插值计算的代码。 position表示几何体的顶点位置坐标，modelMatrix表示网格模型的旋转缩放平移。\n\nmaterial.onBeforeCompile = function (shader) {\n  shader.vertexShader = shader.vertexShader.replace(\n    'void main() {',\n    `\n    varying vec3 vPosition;//顶点位置插值后的坐标\n    void main(){\n      // 顶点位置坐标模型矩阵变换后，进行插值计算\n      vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n    `\n  );\n};\n\n\n\n# 片元着色器增加varying vec3 vPosition;\n\n查看片元着色器代码，在main函数前面增加代码varying vec3 vPosition;，与上面顶点着色器代码思路相似。\n\nmaterial.onBeforeCompile = function (shader) {\n  console.log('fragmentShader', shader.fragmentShader);\n};\n\n\n片元着色器增加varying vec3 vPosition;,获取顶点位置插值之后的坐标值vPosition。\n\nshader.fragmentShader = shader.fragmentShader.replace(\n  'void main() {',\n  `\n  varying vec3 vPosition;\n  void main() {\n  `\n);\n\n\n\n# 根据片元对应顶点位置设置片元颜色\n\n回顾下前面shader知识点，大家都知道，网格模型Mesh经过图元装配和光栅化以后，会生成一个一个的片元，这些片元会构成Mesh的3D轮廓。\n\n\n\n同时顶点位置数据插值计算之后，会生成每个片元对应的xyz坐标。这时候我们就可以跟片元的坐标vPosition控制自身的颜色值。\n\n// 顶点着色器\nvarying vec3 vPosition;//顶点位置插值后的坐标\nvoid main(){\n  // 顶点位置坐标模型矩阵变换后，进行插值计算\n  vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n}\n// 片元着色器\nvarying vec3 vPosition;//顶点位置插值后的坐标\nvoid main(){\n  // 根据y坐标控制片元颜色\n  if(vPosition.y > 20.0 && vPosition.y < 21.0 ){\n    gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n  }\n}\n\n\n\n# 修改片元着色器字符串\n\n浏览器控制打印的片元着色器代码，复制main函数里面最后一行代码(提醒：不同版本可能不同，以你自己版本为准)\n\nmaterial.onBeforeCompile = function (shader) {\n  console.log('fragmentShader', shader.fragmentShader);\n};\n\n\n网格材质shader代码中gl_FragColor已经有默认设置的颜色，我们可以在片元着色器主函数main里面最后一行增加下面代码，在网格模型上生成一条光带。\n\nshader.fragmentShader = shader.fragmentShader.replace(\n    '#include <dithering_fragment>',\n    `\n    #include <dithering_fragment>\n    if(vPosition.y > 20.0 && vPosition.y < 21.0 ){\n        gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n    }\n    `\n  );\n\n\n\n# 多条光带\n\n网格模型上面等间距设置多条光带。\n\nshader.fragmentShader = shader.fragmentShader.replace(\n  '#include <dithering_fragment>',\n  `\n  #include <dithering_fragment>\n  float y0 = 0.0;\n  for (int i = 0; i < 4; i++) {\n    y0 += 20.0;\n    if(vPosition.y > y0 && vPosition.y < y0+1.0 ){\n      gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n    }\n  }\n  `\n);\n\n\n\n\n\n# 总结\n\n静态不动的模型，使用最方便\n\n运动的",normalizedContent:"# 顶点位置插值(设置片元颜色)\n\n这节课讲解一个onbeforecompile修改材质shader的案例，具体就是对顶点的位置坐标xyz进行插值计算，然后根据片元对应的顶点插值坐标，设置片元颜色。\n\n顶点插值这个知识点其实在前面1.9. 顶点位置插值(实现渐变色)讲解过，可以去回顾下。\n\n\n# 任务：在网格y方向增加一条光带\n\n\n\n\n# 修改顶点着色器：增加顶点位置插值计算代码\n\n你可以通过浏览器控制台log打印，查看顶点着色器代码。\n\nmaterial.onbeforecompile = function (shader) {\n  console.log('vertexshader', shader.vertexshader);\n};\n\n\n// 浏览器控制台打印顶点着色器代码(提醒不同版本不一定相同)\n#include <common>\n...\nvoid main(){\n  ...\n  #include <fog_vertex>\n} \n\n\n这时候你可以思考一个问题，怎么给顶点着色器代码main函数之前插入一行插值计算的相关代码varying vec3 vposition;\n\n#include <common>\n...\nvarying vec3 vposition;//表示顶点位置插值后的坐标\nvoid main(){\n  ...\n  #include <fog_vertex>\n} \n\n\n.replace()查询关键词void main() {进行如下替换。\n\nmaterial.onbeforecompile = function (shader) {\n  shader.vertexshader = shader.vertexshader.replace(\n    'void main() {',\n    `\n    varying vec3 vposition;//顶点位置插值后的坐标\n    void main(){\n    `\n  );\n};\n\n\n在main函数里面，增加顶点位置插值计算的代码。 position表示几何体的顶点位置坐标，modelmatrix表示网格模型的旋转缩放平移。\n\nmaterial.onbeforecompile = function (shader) {\n  shader.vertexshader = shader.vertexshader.replace(\n    'void main() {',\n    `\n    varying vec3 vposition;//顶点位置插值后的坐标\n    void main(){\n      // 顶点位置坐标模型矩阵变换后，进行插值计算\n      vposition = vec3(modelmatrix * vec4( position, 1.0 ));\n    `\n  );\n};\n\n\n\n# 片元着色器增加varying vec3 vposition;\n\n查看片元着色器代码，在main函数前面增加代码varying vec3 vposition;，与上面顶点着色器代码思路相似。\n\nmaterial.onbeforecompile = function (shader) {\n  console.log('fragmentshader', shader.fragmentshader);\n};\n\n\n片元着色器增加varying vec3 vposition;,获取顶点位置插值之后的坐标值vposition。\n\nshader.fragmentshader = shader.fragmentshader.replace(\n  'void main() {',\n  `\n  varying vec3 vposition;\n  void main() {\n  `\n);\n\n\n\n# 根据片元对应顶点位置设置片元颜色\n\n回顾下前面shader知识点，大家都知道，网格模型mesh经过图元装配和光栅化以后，会生成一个一个的片元，这些片元会构成mesh的3d轮廓。\n\n\n\n同时顶点位置数据插值计算之后，会生成每个片元对应的xyz坐标。这时候我们就可以跟片元的坐标vposition控制自身的颜色值。\n\n// 顶点着色器\nvarying vec3 vposition;//顶点位置插值后的坐标\nvoid main(){\n  // 顶点位置坐标模型矩阵变换后，进行插值计算\n  vposition = vec3(modelmatrix * vec4( position, 1.0 ));\n}\n// 片元着色器\nvarying vec3 vposition;//顶点位置插值后的坐标\nvoid main(){\n  // 根据y坐标控制片元颜色\n  if(vposition.y > 20.0 && vposition.y < 21.0 ){\n    gl_fragcolor = vec4(1.0,1.0,0.0,1.0);\n  }\n}\n\n\n\n# 修改片元着色器字符串\n\n浏览器控制打印的片元着色器代码，复制main函数里面最后一行代码(提醒：不同版本可能不同，以你自己版本为准)\n\nmaterial.onbeforecompile = function (shader) {\n  console.log('fragmentshader', shader.fragmentshader);\n};\n\n\n网格材质shader代码中gl_fragcolor已经有默认设置的颜色，我们可以在片元着色器主函数main里面最后一行增加下面代码，在网格模型上生成一条光带。\n\nshader.fragmentshader = shader.fragmentshader.replace(\n    '#include <dithering_fragment>',\n    `\n    #include <dithering_fragment>\n    if(vposition.y > 20.0 && vposition.y < 21.0 ){\n        gl_fragcolor = vec4(1.0,1.0,0.0,1.0);\n    }\n    `\n  );\n\n\n\n# 多条光带\n\n网格模型上面等间距设置多条光带。\n\nshader.fragmentshader = shader.fragmentshader.replace(\n  '#include <dithering_fragment>',\n  `\n  #include <dithering_fragment>\n  float y0 = 0.0;\n  for (int i = 0; i < 4; i++) {\n    y0 += 20.0;\n    if(vposition.y > y0 && vposition.y < y0+1.0 ){\n      gl_fragcolor = vec4(1.0,1.0,0.0,1.0);\n    }\n  }\n  `\n);\n\n\n\n\n\n# 总结\n\n静态不动的模型，使用最方便\n\n运动的",charsets:{cjk:!0}},{title:"6. 模型扫光效果(顶点位置插值)",frontmatter:{title:"6. 模型扫光效果(顶点位置插值)",date:"2023-10-28T21:44:37.000Z",permalink:"/pages/e9f8fd/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/02.2.onBeforeCompile%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8/06.%E6%A8%A1%E5%9E%8B%E6%89%AB%E5%85%89%E6%95%88%E6%9E%9C(%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%80%BC).html",relativePath:"03.Threejs Shader教程/02.2.onBeforeCompile修改材质/06.模型扫光效果(顶点位置插值).md",key:"v-a7e2a9c6",path:"/pages/e9f8fd/",headers:[{level:3,title:"扫光思路",slug:"扫光思路",normalizedTitle:"扫光思路",charIndex:73},{level:3,title:"测试shader.uniforms给着色器变量y传值",slug:"测试shader-uniforms给着色器变量y传值",normalizedTitle:"测试shader.uniforms给着色器变量y传值",charIndex:452},{level:3,title:"在onBeforeCompile函数外访问shader.uniforms属性",slug:"在onbeforecompile函数外访问shader-uniforms属性",normalizedTitle:"在onbeforecompile函数外访问shader.uniforms属性",charIndex:829},{level:3,title:"时间改变来控制模型光带的位置",slug:"时间改变来控制模型光带的位置",normalizedTitle:"时间改变来控制模型光带的位置",charIndex:1442}],headersStr:"扫光思路 测试shader.uniforms给着色器变量y传值 在onBeforeCompile函数外访问shader.uniforms属性 时间改变来控制模型光带的位置",content:"# 模型扫光效果(顶点位置插值)\n\n接着2.4节顶点位置插值计算的讲解，设置一个扫光动画效果，你可以打开2.6、2.7小节源码查看效果。\n\n\n# 扫光思路\n\n回顾前两节内容，模型上的光带效果是通过片元对应y坐标控制的。\n\nif(vPosition.y > 20.0 && vPosition.y < 21.0 ){\n    gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n}\n\n\n那么如果想让光带动起来，生成一个扫光效果，那么你就可以让vPosition.y判断条件片元高度是随着时间改变的即可。\n\nuniform float y; //变化的y控制光带高度\nviod main(){\n    // 如果让y随着时间的变化，就可以实现一个动态的扫光效果。\n    if(vPosition.y > y && vPosition.y < y + 1.0 ){\n        gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n    }\n}\n\n\n\n# 测试shader.uniforms给着色器变量y传值\n\n执行shader.uniforms.y = { value: 30 };给片元着色器uniform变量y传递一个值30，查看视觉效果。\n\nmaterial.onBeforeCompile = function (shader) {\n  ...\n  shader.fragmentShader = shader.fragmentShader.replace(\n    'void main() {',\n    `\n    uniform float y; //变化的y控制光带高度\n    varying vec3 vPosition;\n    void main() {\n    `\n  );\n  ...\n  shader.uniforms.y = { value: 30 };\n};\n\n\n\n\n# 在onBeforeCompile函数外访问shader.uniforms属性\n\nmaterial.onBeforeCompile = function (shader) {\n  ...\n  mesh.shader = shader;\n};\n\n\n在渲染循环中访问shader，你会发现首次打印值是未定义undefined,这说明renderer.render(scene, camera)执行一次后，才能获取到material.onBeforeCompile函数的参数shader，完成赋值mesh.shader = shader;\n\nfunction render() {\n    console.log('mesh.shader', mesh.shader);\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\nfunction render() {\n    renderer.render(scene, camera);\n    // enderer.render执行一次，才能获取到mesh.shader\n    console.log('mesh.shader', mesh.shader);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n# 时间改变来控制模型光带的位置\n\n可以通过时间，改变mesh.shader.uniforms.y的值,这样模型光带就会随着时间改变。\n\n// 渲染循环\nconst clock = new THREE.Clock();\nfunction render() {\n    // console.log('mesh.shader', mesh.shader);\n    const deltaTime = clock.getDelta();\n    renderer.render(scene, camera);\n    // enderer.render执行一次，才能获取到mesh.shader\n    mesh.shader.uniforms.y.value += 30 * deltaTime;\n    // 一旦y接近模型mesh顶部，重新设置为0，这样扫光反复循环\n    if (mesh.shader.uniforms.y.value > 99) mesh.shader.uniforms.y.value = 0;\n    requestAnimationFrame(render);\n}\nrender();\n",normalizedContent:"# 模型扫光效果(顶点位置插值)\n\n接着2.4节顶点位置插值计算的讲解，设置一个扫光动画效果，你可以打开2.6、2.7小节源码查看效果。\n\n\n# 扫光思路\n\n回顾前两节内容，模型上的光带效果是通过片元对应y坐标控制的。\n\nif(vposition.y > 20.0 && vposition.y < 21.0 ){\n    gl_fragcolor = vec4(1.0,1.0,0.0,1.0);\n}\n\n\n那么如果想让光带动起来，生成一个扫光效果，那么你就可以让vposition.y判断条件片元高度是随着时间改变的即可。\n\nuniform float y; //变化的y控制光带高度\nviod main(){\n    // 如果让y随着时间的变化，就可以实现一个动态的扫光效果。\n    if(vposition.y > y && vposition.y < y + 1.0 ){\n        gl_fragcolor = vec4(1.0,1.0,0.0,1.0);\n    }\n}\n\n\n\n# 测试shader.uniforms给着色器变量y传值\n\n执行shader.uniforms.y = { value: 30 };给片元着色器uniform变量y传递一个值30，查看视觉效果。\n\nmaterial.onbeforecompile = function (shader) {\n  ...\n  shader.fragmentshader = shader.fragmentshader.replace(\n    'void main() {',\n    `\n    uniform float y; //变化的y控制光带高度\n    varying vec3 vposition;\n    void main() {\n    `\n  );\n  ...\n  shader.uniforms.y = { value: 30 };\n};\n\n\n\n\n# 在onbeforecompile函数外访问shader.uniforms属性\n\nmaterial.onbeforecompile = function (shader) {\n  ...\n  mesh.shader = shader;\n};\n\n\n在渲染循环中访问shader，你会发现首次打印值是未定义undefined,这说明renderer.render(scene, camera)执行一次后，才能获取到material.onbeforecompile函数的参数shader，完成赋值mesh.shader = shader;\n\nfunction render() {\n    console.log('mesh.shader', mesh.shader);\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\nfunction render() {\n    renderer.render(scene, camera);\n    // enderer.render执行一次，才能获取到mesh.shader\n    console.log('mesh.shader', mesh.shader);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n# 时间改变来控制模型光带的位置\n\n可以通过时间，改变mesh.shader.uniforms.y的值,这样模型光带就会随着时间改变。\n\n// 渲染循环\nconst clock = new three.clock();\nfunction render() {\n    // console.log('mesh.shader', mesh.shader);\n    const deltatime = clock.getdelta();\n    renderer.render(scene, camera);\n    // enderer.render执行一次，才能获取到mesh.shader\n    mesh.shader.uniforms.y.value += 30 * deltatime;\n    // 一旦y接近模型mesh顶部，重新设置为0，这样扫光反复循环\n    if (mesh.shader.uniforms.y.value > 99) mesh.shader.uniforms.y.value = 0;\n    requestanimationframe(render);\n}\nrender();\n",charsets:{cjk:!0}},{title:"5. 顶点位置插值(设置片元颜色)2",frontmatter:{title:"5. 顶点位置插值(设置片元颜色)2",date:"2023-10-28T21:44:27.000Z",permalink:"/pages/069520/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/02.2.onBeforeCompile%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8/05.%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%80%BC(%E8%AE%BE%E7%BD%AE%E7%89%87%E5%85%83%E9%A2%9C%E8%89%B2)2.html",relativePath:"03.Threejs Shader教程/02.2.onBeforeCompile修改材质/05.顶点位置插值(设置片元颜色)2.md",key:"v-0b4ab0f6",path:"/pages/069520/",headers:[{level:3,title:"不使用模型矩阵进行变换",slug:"不使用模型矩阵进行变换",normalizedTitle:"不使用模型矩阵进行变换",charIndex:583},{level:3,title:"知识回顾：局部坐标系查看顶点位置",slug:"知识回顾-局部坐标系查看顶点位置",normalizedTitle:"知识回顾：局部坐标系查看顶点位置",charIndex:899},{level:3,title:"知识回顾：改变局部坐标系",slug:"知识回顾-改变局部坐标系",normalizedTitle:"知识回顾：改变局部坐标系",charIndex:1246},{level:3,title:"根据顶点坐标设置片元颜色",slug:"根据顶点坐标设置片元颜色",normalizedTitle:"根据顶点坐标设置片元颜色",charIndex:1540},{level:3,title:"顶点位置插值计算总结",slug:"顶点位置插值计算总结",normalizedTitle:"顶点位置插值计算总结",charIndex:2228},{level:3,title:"外部三维模型",slug:"外部三维模型",normalizedTitle:"外部三维模型",charIndex:2444}],headersStr:"不使用模型矩阵进行变换 知识回顾：局部坐标系查看顶点位置 知识回顾：改变局部坐标系 根据顶点坐标设置片元颜色 顶点位置插值计算总结 外部三维模型",content:"# 顶点位置插值(设置片元颜色)2\n\n接着2.4小节讲解，你可以尝试改变上节课模型mesh的y坐标或者进行旋转，看看光带的变化。\n\n// 分别测试下面的不同值\nmesh.position.y = 0;\nmesh.position.y = 25;\nmesh.position.y = 50;\nmesh.rotateZ(Math.PI / 6);\n\n\n模型位置改变的时候，光带对应的片元相对世界坐标系高度始终是20左右，不过如果以自身底部为参照点，光带高度位置是变化的。\n\nif(vPosition.y > 20.0 && vPosition.y < 21.0 ){\n  gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n}\n\n\n因为顶点插值计算时候，使用模型矩阵modelMatrix进行了变换，模型矩阵包含了模型的旋转缩放平移信息。\n\n  shader.vertexShader = shader.vertexShader.replace(\n    'void main() {',\n    `\n    varying vec3 vPosition;\n    void main(){\n      vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n    `\n  );\n\n\n\n# 不使用模型矩阵进行变换\n\n去掉模型矩阵对顶点坐标的影响，只根据几何体的顶点坐标来设置模型Mesh的片元的颜色。\n\n不考虑mesh的旋转缩放平移，仅仅根据mesh.geometry顶点位置插值坐标设置片元颜色。\n\nvoid main(){\n  // vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n  // 顶点位置坐标插值计算\n  vPosition = position;//不考虑模型旋转缩放平移变换(modelMatrix)\n}\n\n\n这时候如果你想实现和上节课相似效果,精确控制光带相对模型自身的位置,就需要根据Geometry顶点分布特点设置代码。\n\n\n\n\n# 知识回顾：局部坐标系查看顶点位置\n\n你可以把辅助坐标轴AxesHelper作为mesh的子对象，就可以查看mesh的局部坐标系。\n\n通过mesh的局部坐标系，方便你查看mesh对应几何体mesh.geometry顶点位置分布状态。\n\n// 查看模型局部坐标系：判断几何体顶点坐标分布情况\nconst axesHelper = new THREE.AxesHelper(100);\nmesh.add(axesHelper);\n\n\n你可以浏览器控制台查看几何体顶点位置坐标\n\nconst geometry = new THREE.BoxGeometry(40, 100, 40);\nconsole.log('顶点位置', geometry.attributes.position);\n\n\n\n\n\n# 知识回顾：改变局部坐标系\n\n你可以再次改变mesh位置，局部坐标系相对世界坐标原点偏移，但是相对自身几何体mesh.geometry位置不变，也就是几何体的顶点坐标不受影响。\n\nmesh.position.x = 100;\n\n\n几何体平移,改变几何体顶点坐标，这时候局部坐标系原点相对geometry位置发生变化。\n\ngeometry.translate(0,50,0);\nconsole.log('顶点位置', geometry.attributes.position);\n\n\n扩展：blender等建模软件中，建模的时候，也可以根据需要调整局部坐标系相对自身顶点坐标的位置。\n\n\n# 根据顶点坐标设置片元颜色\n\nposition直接插值，不用modelMatrix变换，通过下面代码，在几何体高度y = 30.0位置设置光带。\n\n// 片元着色器代码\nvoid main(){\n  if(vPosition.y > 30.0 && vPosition.y < 31.0 ){\n    gl_FragColor = vec4(1.0,1.0,0.0,1.0);\n  }\n}\n\n\n// 顶点着色器代码\nvoid main(){\n  // vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n  // 顶点位置坐标插值计算\n  vPosition = position;//不考虑模型旋转缩放平移变换(modelMatrix)\n}\n\n\n在这种情况下，你再平移旋转缩放mesh，你会发现光带位置始终在mesh局部坐标系的高度y=30位置。\n\nmesh.position.y = 50;\nmesh.rotateZ(Math.PI / 6);\n\n\n你可以在渲染循环中，设置一个旋转动画，查看vPosition = position与vPosition = vec3(modelMatrix * vec4( position, 1.0 ));区别\n\nfunction render() {\n    model.rotateZ(0.01)\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n}\nrender();\n\n\n\n\n# 顶点位置插值计算总结\n\n插值后获取，可以或获取每个片元对应的局部坐标\n\nvoid main(){\n  // 布局坐标\n  vPosition = position;//只考虑几何体的顶点位置xyz \n}\n\n\n插值后获取，可以或获取每个片元对应的世界坐标\n\nvoid main(){\n  // 世界坐标 \n  vPosition = vec3(modelMatrix * vec4( position, 1.0 ));\n}\n\n\n\n# 外部三维模型\n\n提醒：三维建模软件，比如blender与threejs交互的时候，要注意blender中模型局部坐标系的设置对代码的影响。\n\n如果美术给你一个三维模型，你可以用辅助坐标系AxesHelper可视化查看顶点位置坐标分布。\n\n如果你用vPosition = position进行插值计算，来控制片元颜色，要注意局部坐标系坐标原点的设置。一般选择一个特殊的位置，没有固定要求，只要方便你写代码就行了。比如课程案例，是一个光带环绕长方体四周，这时候最好让局部坐标系的随便某个轴，沿着立方体高度方向，坐标原点与底部或中心重合。\n\nloader.load(\"../外部模型.glb\", function (gltf) {\n  model.add(gltf.scene);\n  const mesh = model.getObjectByName('长方体');\n  // 查看模型局部坐标系：判断几何体顶点坐标分布情况\n  const axesHelper = new THREE.AxesHelper(200);\n  mesh.add(axesHelper);\n})\n\n\n",normalizedContent:"# 顶点位置插值(设置片元颜色)2\n\n接着2.4小节讲解，你可以尝试改变上节课模型mesh的y坐标或者进行旋转，看看光带的变化。\n\n// 分别测试下面的不同值\nmesh.position.y = 0;\nmesh.position.y = 25;\nmesh.position.y = 50;\nmesh.rotatez(math.pi / 6);\n\n\n模型位置改变的时候，光带对应的片元相对世界坐标系高度始终是20左右，不过如果以自身底部为参照点，光带高度位置是变化的。\n\nif(vposition.y > 20.0 && vposition.y < 21.0 ){\n  gl_fragcolor = vec4(1.0,1.0,0.0,1.0);\n}\n\n\n因为顶点插值计算时候，使用模型矩阵modelmatrix进行了变换，模型矩阵包含了模型的旋转缩放平移信息。\n\n  shader.vertexshader = shader.vertexshader.replace(\n    'void main() {',\n    `\n    varying vec3 vposition;\n    void main(){\n      vposition = vec3(modelmatrix * vec4( position, 1.0 ));\n    `\n  );\n\n\n\n# 不使用模型矩阵进行变换\n\n去掉模型矩阵对顶点坐标的影响，只根据几何体的顶点坐标来设置模型mesh的片元的颜色。\n\n不考虑mesh的旋转缩放平移，仅仅根据mesh.geometry顶点位置插值坐标设置片元颜色。\n\nvoid main(){\n  // vposition = vec3(modelmatrix * vec4( position, 1.0 ));\n  // 顶点位置坐标插值计算\n  vposition = position;//不考虑模型旋转缩放平移变换(modelmatrix)\n}\n\n\n这时候如果你想实现和上节课相似效果,精确控制光带相对模型自身的位置,就需要根据geometry顶点分布特点设置代码。\n\n\n\n\n# 知识回顾：局部坐标系查看顶点位置\n\n你可以把辅助坐标轴axeshelper作为mesh的子对象，就可以查看mesh的局部坐标系。\n\n通过mesh的局部坐标系，方便你查看mesh对应几何体mesh.geometry顶点位置分布状态。\n\n// 查看模型局部坐标系：判断几何体顶点坐标分布情况\nconst axeshelper = new three.axeshelper(100);\nmesh.add(axeshelper);\n\n\n你可以浏览器控制台查看几何体顶点位置坐标\n\nconst geometry = new three.boxgeometry(40, 100, 40);\nconsole.log('顶点位置', geometry.attributes.position);\n\n\n\n\n\n# 知识回顾：改变局部坐标系\n\n你可以再次改变mesh位置，局部坐标系相对世界坐标原点偏移，但是相对自身几何体mesh.geometry位置不变，也就是几何体的顶点坐标不受影响。\n\nmesh.position.x = 100;\n\n\n几何体平移,改变几何体顶点坐标，这时候局部坐标系原点相对geometry位置发生变化。\n\ngeometry.translate(0,50,0);\nconsole.log('顶点位置', geometry.attributes.position);\n\n\n扩展：blender等建模软件中，建模的时候，也可以根据需要调整局部坐标系相对自身顶点坐标的位置。\n\n\n# 根据顶点坐标设置片元颜色\n\nposition直接插值，不用modelmatrix变换，通过下面代码，在几何体高度y = 30.0位置设置光带。\n\n// 片元着色器代码\nvoid main(){\n  if(vposition.y > 30.0 && vposition.y < 31.0 ){\n    gl_fragcolor = vec4(1.0,1.0,0.0,1.0);\n  }\n}\n\n\n// 顶点着色器代码\nvoid main(){\n  // vposition = vec3(modelmatrix * vec4( position, 1.0 ));\n  // 顶点位置坐标插值计算\n  vposition = position;//不考虑模型旋转缩放平移变换(modelmatrix)\n}\n\n\n在这种情况下，你再平移旋转缩放mesh，你会发现光带位置始终在mesh局部坐标系的高度y=30位置。\n\nmesh.position.y = 50;\nmesh.rotatez(math.pi / 6);\n\n\n你可以在渲染循环中，设置一个旋转动画，查看vposition = position与vposition = vec3(modelmatrix * vec4( position, 1.0 ));区别\n\nfunction render() {\n    model.rotatez(0.01)\n    renderer.render(scene, camera);\n    requestanimationframe(render);\n}\nrender();\n\n\n\n\n# 顶点位置插值计算总结\n\n插值后获取，可以或获取每个片元对应的局部坐标\n\nvoid main(){\n  // 布局坐标\n  vposition = position;//只考虑几何体的顶点位置xyz \n}\n\n\n插值后获取，可以或获取每个片元对应的世界坐标\n\nvoid main(){\n  // 世界坐标 \n  vposition = vec3(modelmatrix * vec4( position, 1.0 ));\n}\n\n\n\n# 外部三维模型\n\n提醒：三维建模软件，比如blender与threejs交互的时候，要注意blender中模型局部坐标系的设置对代码的影响。\n\n如果美术给你一个三维模型，你可以用辅助坐标系axeshelper可视化查看顶点位置坐标分布。\n\n如果你用vposition = position进行插值计算，来控制片元颜色，要注意局部坐标系坐标原点的设置。一般选择一个特殊的位置，没有固定要求，只要方便你写代码就行了。比如课程案例，是一个光带环绕长方体四周，这时候最好让局部坐标系的随便某个轴，沿着立方体高度方向，坐标原点与底部或中心重合。\n\nloader.load(\"../外部模型.glb\", function (gltf) {\n  model.add(gltf.scene);\n  const mesh = model.getobjectbyname('长方体');\n  // 查看模型局部坐标系：判断几何体顶点坐标分布情况\n  const axeshelper = new three.axeshelper(200);\n  mesh.add(axeshelper);\n})\n\n\n",charsets:{cjk:!0}},{title:"博客文章",frontmatter:{archivesPage:!0,title:"博客文章",permalink:"/blog/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-6908b822",path:"/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"7. 模型扫光效果(颜色渐变)",frontmatter:{title:"7. 模型扫光效果(颜色渐变)",date:"2023-10-28T21:44:48.000Z",permalink:"/pages/437645/"},regularPath:"/03.Threejs%20Shader%E6%95%99%E7%A8%8B/02.2.onBeforeCompile%E4%BF%AE%E6%94%B9%E6%9D%90%E8%B4%A8/07.%E6%A8%A1%E5%9E%8B%E6%89%AB%E5%85%89%E6%95%88%E6%9E%9C(%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98).html",relativePath:"03.Threejs Shader教程/02.2.onBeforeCompile修改材质/07.模型扫光效果(颜色渐变).md",key:"v-21a84a04",path:"/pages/437645/",headers:[{level:3,title:"内置函数mix",slug:"内置函数mix",normalizedTitle:"内置函数mix",charIndex:50},{level:3,title:"设置光带上半部分颜色渐变",slug:"设置光带上半部分颜色渐变",normalizedTitle:"设置光带上半部分颜色渐变",charIndex:231},{level:3,title:"设置光带下半部分颜色渐变",slug:"设置光带下半部分颜色渐变",normalizedTitle:"设置光带下半部分颜色渐变",charIndex:639},{level:3,title:"改变渐变规则",slug:"改变渐变规则",normalizedTitle:"改变渐变规则",charIndex:930},{level:3,title:"改变光带颜色",slug:"改变光带颜色",normalizedTitle:"改变光带颜色",charIndex:1339}],headersStr:"内置函数mix 设置光带上半部分颜色渐变 设置光带下半部分颜色渐变 改变渐变规则 改变光带颜色",content:"# 模型扫光效果(颜色渐变)\n\n继续2.6节讲解，给2.6节扫光设置一个渐变色的效果。\n\n\n\n\n# 内置函数mix\n\nmix是着色器语言GLSL ES的内置函数，可以直接使用，比如参数1和2分表示一个颜色值，通过参数3百分比per，就可以控制两个颜色color1、color2的混合比例,参数3范围控制在0~1就行。\n\nmix( color1,color2, per);\n\n\n提醒：mix的参数1和2顺序，不用刻意记住，用代码测试下就行，不对就反过来。\n\n\n# 设置光带上半部分颜色渐变\n\n让片元在高度y ~ y+w范围内渐变。\n\n * 高度y对应颜色是扫光的颜色vec3(1.0,1.0,0.0)\n * 高度y + w对应是模型自身的颜色gl_FragColor.rgb\n * y ~ y+w之间是两种颜色的混合。\n\n//片元着色器代码\nuniform float y; //变化的y控制光带高度\nfloat w = 10.0;//光带宽度一半\nvoid main(\n    // y随着时间改变光带位置也会改变\n    if(vPosition.y >= y && vPosition.y < y + w ){\n      float per = (vPosition.y-y)/w;//范围0~1\n      gl_FragColor.rgb = mix( vec3(1.0,1.0,0.0),gl_FragColor.rgb, per);\n    }\n)\n\n\n\n\n\n# 设置光带下半部分颜色渐变\n\n//片元着色器代码\nuniform float y; //变化的y控制光带高度\nfloat w = 10.0;//光带宽度一半\nvoid main(\n    // y随着时间改变光带位置也会改变\n    if(vPosition.y <= y && vPosition.y > y - w ){\n      float per = (y-vPosition.y)/w;//范围0~1\n      gl_FragColor.rgb = mix( vec3(1.0,1.0,0.0),gl_FragColor.rgb, per);\n    }\n)\n\n\n\n# 改变渐变规则\n\n参数3随着y的变化是线性的插值效果\n\nfloat per = (y-vPosition.y)/w;//范围0~1\nmix(color1,color2, per);\n\n\n你可以尝试改变per的公式，比如平方根，平方去计算，这样per随着y变化曲线就不同。\n\npow是着色器语言GLSL ES内置函数。\n\nper = pow(per,2.0);//平方\ngl_FragColor.rgb = mix( vec3(1.0,1.0,0.0),gl_FragColor.rgb, per);\n\n\nper = pow(per,0.5);//平方根\ngl_FragColor.rgb = mix( vec3(1.0,1.0,0.0),gl_FragColor.rgb, per);\n\n\n至于pow参数选择大于1的2，还是小于1的0.5，或者其他值，不用可以记住，只要有个印象，可以改变per的变化曲线即可。\n\n\n# 改变光带颜色\n\n你可以根据需要调整光带为任何颜色。\n\n// 光带黄色\nmix( vec3(1.0,1.0,0.0),gl_FragColor.rgb, per);\n\n\n// 光带白色\nmix( vec3(1.0,1.0,1.0),gl_FragColor.rgb, per);\n\n\n// 光带偏向青色\nmix( vec3(0.3,1.0,1.0),gl_FragColor.rgb, per);\n",normalizedContent:"# 模型扫光效果(颜色渐变)\n\n继续2.6节讲解，给2.6节扫光设置一个渐变色的效果。\n\n\n\n\n# 内置函数mix\n\nmix是着色器语言glsl es的内置函数，可以直接使用，比如参数1和2分表示一个颜色值，通过参数3百分比per，就可以控制两个颜色color1、color2的混合比例,参数3范围控制在0~1就行。\n\nmix( color1,color2, per);\n\n\n提醒：mix的参数1和2顺序，不用刻意记住，用代码测试下就行，不对就反过来。\n\n\n# 设置光带上半部分颜色渐变\n\n让片元在高度y ~ y+w范围内渐变。\n\n * 高度y对应颜色是扫光的颜色vec3(1.0,1.0,0.0)\n * 高度y + w对应是模型自身的颜色gl_fragcolor.rgb\n * y ~ y+w之间是两种颜色的混合。\n\n//片元着色器代码\nuniform float y; //变化的y控制光带高度\nfloat w = 10.0;//光带宽度一半\nvoid main(\n    // y随着时间改变光带位置也会改变\n    if(vposition.y >= y && vposition.y < y + w ){\n      float per = (vposition.y-y)/w;//范围0~1\n      gl_fragcolor.rgb = mix( vec3(1.0,1.0,0.0),gl_fragcolor.rgb, per);\n    }\n)\n\n\n\n\n\n# 设置光带下半部分颜色渐变\n\n//片元着色器代码\nuniform float y; //变化的y控制光带高度\nfloat w = 10.0;//光带宽度一半\nvoid main(\n    // y随着时间改变光带位置也会改变\n    if(vposition.y <= y && vposition.y > y - w ){\n      float per = (y-vposition.y)/w;//范围0~1\n      gl_fragcolor.rgb = mix( vec3(1.0,1.0,0.0),gl_fragcolor.rgb, per);\n    }\n)\n\n\n\n# 改变渐变规则\n\n参数3随着y的变化是线性的插值效果\n\nfloat per = (y-vposition.y)/w;//范围0~1\nmix(color1,color2, per);\n\n\n你可以尝试改变per的公式，比如平方根，平方去计算，这样per随着y变化曲线就不同。\n\npow是着色器语言glsl es内置函数。\n\nper = pow(per,2.0);//平方\ngl_fragcolor.rgb = mix( vec3(1.0,1.0,0.0),gl_fragcolor.rgb, per);\n\n\nper = pow(per,0.5);//平方根\ngl_fragcolor.rgb = mix( vec3(1.0,1.0,0.0),gl_fragcolor.rgb, per);\n\n\n至于pow参数选择大于1的2，还是小于1的0.5，或者其他值，不用可以记住，只要有个印象，可以改变per的变化曲线即可。\n\n\n# 改变光带颜色\n\n你可以根据需要调整光带为任何颜色。\n\n// 光带黄色\nmix( vec3(1.0,1.0,0.0),gl_fragcolor.rgb, per);\n\n\n// 光带白色\nmix( vec3(1.0,1.0,1.0),gl_fragcolor.rgb, per);\n\n\n// 光带偏向青色\nmix( vec3(0.3,1.0,1.0),gl_fragcolor.rgb, per);\n",charsets:{cjk:!0}},{title:"1. Blender入门基础",frontmatter:{title:"1. Blender入门基础",date:"2023-11-27T21:16:36.000Z",permalink:"/pages/00cfc0/"},regularPath:"/Blender%E6%95%99%E7%A8%8B/01.1.Blender%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/01.Blender%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80.html",relativePath:"Blender教程/01.1.Blender入门基础/01.Blender入门基础.md",key:"v-0dd532f8",path:"/pages/00cfc0/",headers:[{level:3,title:"3D建模相关美术软件",slug:"_3d建模相关美术软件",normalizedTitle:"3d建模相关美术软件",charIndex:159},{level:3,title:"Blender课程面向对象",slug:"blender课程面向对象",normalizedTitle:"blender课程面向对象",charIndex:357},{level:3,title:"Blender学前基础",slug:"blender学前基础",normalizedTitle:"blender学前基础",charIndex:480}],headersStr:"3D建模相关美术软件 Blender课程面向对象 Blender学前基础",content:"# Web3D可视化3D建模\n\n这节课给大家谈谈，Web3D可视化项目三维建模(3D建模)的问题。\n\n对于大部分Web3D可视化项目，比如产品展示、物联网、数字孪生、元宇宙游戏,除了程序员写代码之外，还需要美术制作3D模型。\n\n智慧小区(园区)案例代码效果\n\n\n\nBlender软件绘制的小区(园区)模型\n\n\n\n\n# 3D建模相关美术软件\n\nWeb3D可视化这块，我推荐大家使用Blender，尤其程序员，非常方便，轻量开源。\n\n美术常用3D建模软件：Blender、C4D、3damx、maya\n\n工程领域3D建模：SolidWorks(机械)、UG(机械)、Revit(BIM)\n\n平面美术软件：PS、AI(UI设计、制作模型贴图)\n\n角色模型雕刻软件：zbrush\n\nPBR相关:substance\n\n\n# Blender课程面向对象\n\nBledner三维建模的方向有很多，比如UI设计、影视动漫、游戏、3D可视化等等，本课程主要是Web3D可视化方向。\n\n无论你是Web3D可视化方向的程序员，还是美术，都能学习。\n\n * 美术\n * 程序员\n\n\n# Blender学前基础\n\n学习Blender一般不要什么特别基础，互联网时代的智人都能学习。",normalizedContent:"# web3d可视化3d建模\n\n这节课给大家谈谈，web3d可视化项目三维建模(3d建模)的问题。\n\n对于大部分web3d可视化项目，比如产品展示、物联网、数字孪生、元宇宙游戏,除了程序员写代码之外，还需要美术制作3d模型。\n\n智慧小区(园区)案例代码效果\n\n\n\nblender软件绘制的小区(园区)模型\n\n\n\n\n# 3d建模相关美术软件\n\nweb3d可视化这块，我推荐大家使用blender，尤其程序员，非常方便，轻量开源。\n\n美术常用3d建模软件：blender、c4d、3damx、maya\n\n工程领域3d建模：solidworks(机械)、ug(机械)、revit(bim)\n\n平面美术软件：ps、ai(ui设计、制作模型贴图)\n\n角色模型雕刻软件：zbrush\n\npbr相关:substance\n\n\n# blender课程面向对象\n\nbledner三维建模的方向有很多，比如ui设计、影视动漫、游戏、3d可视化等等，本课程主要是web3d可视化方向。\n\n无论你是web3d可视化方向的程序员，还是美术，都能学习。\n\n * 美术\n * 程序员\n\n\n# blender学前基础\n\n学习blender一般不要什么特别基础，互联网时代的智人都能学习。",charsets:{cjk:!0}},{title:"2. Blender下载、安装、中文界面",frontmatter:{title:"2. Blender下载、安装、中文界面",date:"2023-11-27T21:16:56.000Z",permalink:"/pages/1c4bb8/"},regularPath:"/Blender%E6%95%99%E7%A8%8B/01.1.Blender%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/02.Blender%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E4%B8%AD%E6%96%87%E7%95%8C%E9%9D%A2.html",relativePath:"Blender教程/01.1.Blender入门基础/02.Blender下载、安装、中文界面.md",key:"v-a994a3e0",path:"/pages/1c4bb8/",headers:[{level:3,title:"Blender安装",slug:"blender安装",normalizedTitle:"blender安装",charIndex:60},{level:3,title:"设置中文界面",slug:"设置中文界面",normalizedTitle:"设置中文界面",charIndex:190},{level:3,title:"软件界面介绍",slug:"软件界面介绍",normalizedTitle:"软件界面介绍",charIndex:304}],headersStr:"Blender安装 设置中文界面 软件界面介绍",content:"# Blender下载、安装、中文界面\n\nBlender是一款开源免费的3D软件，下面给大家说下怎么安装配置。\n\n\n# Blender安装\n\n课件里面提供一个window系统的Blender安装包，window系统，你可以直接用来安装。\n\n当然你也可以去Blender官网下载其它安装包。\n\nBlender安装操作和日常软件差不多，根据提示直接安装就行,我这里不再演示。\n\n\n# 设置中文界面\n\nBlender安装好以后，默认是英文界面，你可以改为汉字界面。\n\n1.偏好设置(左上角主菜单——编辑Edit)\n\n\n\n2.界面选项(interface)\n\n\n\n3.语言language，选择汉字模式\n\n\n\n\n# 软件界面介绍\n\n主界面不同功能区\n\n\n\n主界面的3D模型编辑窗口\n\n",normalizedContent:"# blender下载、安装、中文界面\n\nblender是一款开源免费的3d软件，下面给大家说下怎么安装配置。\n\n\n# blender安装\n\n课件里面提供一个window系统的blender安装包，window系统，你可以直接用来安装。\n\n当然你也可以去blender官网下载其它安装包。\n\nblender安装操作和日常软件差不多，根据提示直接安装就行,我这里不再演示。\n\n\n# 设置中文界面\n\nblender安装好以后，默认是英文界面，你可以改为汉字界面。\n\n1.偏好设置(左上角主菜单——编辑edit)\n\n\n\n2.界面选项(interface)\n\n\n\n3.语言language，选择汉字模式\n\n\n\n\n# 软件界面介绍\n\n主界面不同功能区\n\n\n\n主界面的3d模型编辑窗口\n\n",charsets:{cjk:!0}},{title:"3. 基本操作：旋转、缩放、平移",frontmatter:{title:"3. 基本操作：旋转、缩放、平移",date:"2023-11-27T21:17:08.000Z",permalink:"/pages/b66c23/"},regularPath:"/Blender%E6%95%99%E7%A8%8B/01.1.Blender%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/03.%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%9A%E6%97%8B%E8%BD%AC%E3%80%81%E7%BC%A9%E6%94%BE%E3%80%81%E5%B9%B3%E7%A7%BB.html",relativePath:"Blender教程/01.1.Blender入门基础/03.基本操作：旋转、缩放、平移.md",key:"v-6fda0888",path:"/pages/b66c23/",headers:[{level:3,title:"旋转、缩放、平移",slug:"旋转、缩放、平移",normalizedTitle:"旋转、缩放、平移",charIndex:7},{level:3,title:"xyz坐标轴",slug:"xyz坐标轴",normalizedTitle:"xyz坐标轴",charIndex:216},{level:3,title:"切换观察视角(视图)",slug:"切换观察视角-视图",normalizedTitle:"切换观察视角(视图)",charIndex:352}],headersStr:"旋转、缩放、平移 xyz坐标轴 切换观察视角(视图)",content:"# 基本操作：旋转、缩放、平移\n\n打开Blender软件，你可以看到一个默认的立方体网格模型(Mesh)。\n\n这节课在此基础上给大家演示下，Blender 3D模型绘图区域的旋转、缩放、平移操作。\n\n\n# 旋转、缩放、平移\n\n * 缩放：上下滚动鼠标中键，可以缩放场景显示的范围\n * 旋转：按住鼠标中键不松开，左右拖动、上下拖动，可以转换场景观察角度\n * 平移：按住鼠标中键+键盘Shift(不松开),可以上下左右拖动\n\n\n# xyz坐标轴\n\n3D绘图区域你可以看到立方体模型底部有两条垂直交叉的线，红色是x轴，绿色是y轴，z轴默认竖直向上。\n\n3D绘图区右上角你能看到一个xyz坐标轴。\n\n鼠标中键旋转三维场景的时候，你可以看到模型底部的x、y轴跟着旋转，右上角xyz坐标也跟着同步。\n\n\n\n\n# 切换观察视角(视图)\n\n建模时候，最常用是鼠标中键旋转切换观察视角，非常灵活方便。\n\n除此外，你还可以直接设置前、后、左、右、顶(上)、底(下)6个视图，也就是沿着xyz正半轴、xyz负半轴6个方向，观察三维模型。\n\n\n\n前后左右上下6个视图的操作方法：\n\n 1. 快捷键反引号按键(ESC下面)，注意在英文输入法按快捷键\n 2. 3D绘图窗口右上角xyz坐标，点击xyz的正半轴或负半轴",normalizedContent:"# 基本操作：旋转、缩放、平移\n\n打开blender软件，你可以看到一个默认的立方体网格模型(mesh)。\n\n这节课在此基础上给大家演示下，blender 3d模型绘图区域的旋转、缩放、平移操作。\n\n\n# 旋转、缩放、平移\n\n * 缩放：上下滚动鼠标中键，可以缩放场景显示的范围\n * 旋转：按住鼠标中键不松开，左右拖动、上下拖动，可以转换场景观察角度\n * 平移：按住鼠标中键+键盘shift(不松开),可以上下左右拖动\n\n\n# xyz坐标轴\n\n3d绘图区域你可以看到立方体模型底部有两条垂直交叉的线，红色是x轴，绿色是y轴，z轴默认竖直向上。\n\n3d绘图区右上角你能看到一个xyz坐标轴。\n\n鼠标中键旋转三维场景的时候，你可以看到模型底部的x、y轴跟着旋转，右上角xyz坐标也跟着同步。\n\n\n\n\n# 切换观察视角(视图)\n\n建模时候，最常用是鼠标中键旋转切换观察视角，非常灵活方便。\n\n除此外，你还可以直接设置前、后、左、右、顶(上)、底(下)6个视图，也就是沿着xyz正半轴、xyz负半轴6个方向，观察三维模型。\n\n\n\n前后左右上下6个视图的操作方法：\n\n 1. 快捷键反引号按键(esc下面)，注意在英文输入法按快捷键\n 2. 3d绘图窗口右上角xyz坐标，点击xyz的正半轴或负半轴",charsets:{cjk:!0}},{title:"4. 编辑、保存网格模型",frontmatter:{title:"4. 编辑、保存网格模型",date:"2023-11-27T21:17:17.000Z",permalink:"/pages/73804e/"},regularPath:"/Blender%E6%95%99%E7%A8%8B/01.1.Blender%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/04.%E7%BC%96%E8%BE%91%E3%80%81%E4%BF%9D%E5%AD%98%E7%BD%91%E6%A0%BC%E6%A8%A1%E5%9E%8B.html",relativePath:"Blender教程/01.1.Blender入门基础/04.编辑、保存网格模型.md",key:"v-947d9400",path:"/pages/73804e/",headers:[{level:3,title:"选择网格模型、删除网格模型",slug:"选择网格模型、删除网格模型",normalizedTitle:"选择网格模型、删除网格模型",charIndex:60},{level:3,title:"添加网格模型(Mesh)",slug:"添加网格模型-mesh",normalizedTitle:"添加网格模型(mesh)",charIndex:221},{level:3,title:"添加快捷键：Shift + A",slug:"添加快捷键-shift-a",normalizedTitle:"添加快捷键：shift + a",charIndex:376},{level:3,title:"旋转、平移、缩放网格(Mesh)",slug:"旋转、平移、缩放网格-mesh",normalizedTitle:"旋转、平移、缩放网格(mesh)",charIndex:466},{level:3,title:"保存文件(Ctrl+S)",slug:"保存文件-ctrl-s",normalizedTitle:"保存文件(ctrl+s)",charIndex:618}],headersStr:"选择网格模型、删除网格模型 添加网格模型(Mesh) 添加快捷键：Shift + A 旋转、平移、缩放网格(Mesh) 保存文件(Ctrl+S)",content:"# 编辑、保存网格模型\n\n在Blender中，一般会用网格模型表示生活中的物体，网格对应英文单词就是Mesh。\n\n\n# 选择网格模型、删除网格模型\n\n选择模型：鼠标单击可以选择某个模型，选中的模型会有一个发光描边效果。\n\n取消选中：点击选中模型之外区域，选中模型就会被取消选中。\n\n一个模型处于选中状态下，右键弹出菜单，可以删除选中的网格模型，或者快捷键Delete删除。\n\n快捷键Ctrl+Z可以撤销上一步的操作，比如撤销模型删除\n\n\n# 添加网格模型(Mesh)\n\nBlender默认提供了多种形状的网格模型，比如矩形平面、立方体、球、圆柱、圆锥...\n\n\n\n创建某个网格模型的时候，左下角会有一个小弹窗，可以展开或关闭，展开后，可以看到网格模型相关的参数设置，比如位置、尺寸...。如果你不输入参数，鼠标操作其它功能，弹窗就会消失。\n\n\n\n\n# 添加快捷键：Shift + A\n\n通过快捷键Shift + A,可以快速弹出菜单的添加选项，在弹出界面可以找到网格选项。\n\n提醒：在英文输入法下，使用Blender快捷键\n\n\n# 旋转、平移、缩放网格(Mesh)\n\n绘图窗口左侧有多个工具，比如用于网格模型的平移、旋转、缩放，鼠标点击这些按钮，可以切换到对应的功能。\n\n\n\n比如点击工具栏里面的平移按钮，在选中一个网格(Mesh)，就会看到一个坐标轴，你可以通过坐标轴，平移网格模型，改变网格模型的位置(position)。\n\n\n# 保存文件(Ctrl+S)\n\n你编辑好的模型，可以通过快捷键Ctrl+S保存到你的电脑上，或者通过菜单栏文件-保存操作。\n\n可以下次打开文件，继续编辑，就能你的word文档一样。编辑好模型，快捷键Ctrl+S，在你保存的原模型文件中，更新模型数据。",normalizedContent:"# 编辑、保存网格模型\n\n在blender中，一般会用网格模型表示生活中的物体，网格对应英文单词就是mesh。\n\n\n# 选择网格模型、删除网格模型\n\n选择模型：鼠标单击可以选择某个模型，选中的模型会有一个发光描边效果。\n\n取消选中：点击选中模型之外区域，选中模型就会被取消选中。\n\n一个模型处于选中状态下，右键弹出菜单，可以删除选中的网格模型，或者快捷键delete删除。\n\n快捷键ctrl+z可以撤销上一步的操作，比如撤销模型删除\n\n\n# 添加网格模型(mesh)\n\nblender默认提供了多种形状的网格模型，比如矩形平面、立方体、球、圆柱、圆锥...\n\n\n\n创建某个网格模型的时候，左下角会有一个小弹窗，可以展开或关闭，展开后，可以看到网格模型相关的参数设置，比如位置、尺寸...。如果你不输入参数，鼠标操作其它功能，弹窗就会消失。\n\n\n\n\n# 添加快捷键：shift + a\n\n通过快捷键shift + a,可以快速弹出菜单的添加选项，在弹出界面可以找到网格选项。\n\n提醒：在英文输入法下，使用blender快捷键\n\n\n# 旋转、平移、缩放网格(mesh)\n\n绘图窗口左侧有多个工具，比如用于网格模型的平移、旋转、缩放，鼠标点击这些按钮，可以切换到对应的功能。\n\n\n\n比如点击工具栏里面的平移按钮，在选中一个网格(mesh)，就会看到一个坐标轴，你可以通过坐标轴，平移网格模型，改变网格模型的位置(position)。\n\n\n# 保存文件(ctrl+s)\n\n你编辑好的模型，可以通过快捷键ctrl+s保存到你的电脑上，或者通过菜单栏文件-保存操作。\n\n可以下次打开文件，继续编辑，就能你的word文档一样。编辑好模型，快捷键ctrl+s，在你保存的原模型文件中，更新模型数据。",charsets:{cjk:!0}},{title:"谈谈Three.js版本问题",frontmatter:{title:"谈谈Three.js版本问题",date:"2023-09-11T14:19:27.000Z",permalink:"/pages/0fdf7b/"},regularPath:"/Threejs%E6%96%87%E7%AB%A0/01.%E8%B0%88%E8%B0%88Three.js%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98.html",relativePath:"Threejs文章/01.谈谈Three.js版本问题.md",key:"v-139fa962",path:"/pages/0fdf7b/",headers:[{level:3,title:"所有版本链接",slug:"所有版本链接",normalizedTitle:"所有版本链接",charIndex:148},{level:3,title:"初学者学习提醒",slug:"初学者学习提醒",normalizedTitle:"初学者学习提醒",charIndex:205},{level:3,title:"系统课程",slug:"系统课程",normalizedTitle:"系统课程",charIndex:434},{level:3,title:"有无必要用threejs最新版本",slug:"有无必要用threejs最新版本",normalizedTitle:"有无必要用threejs最新版本",charIndex:663},{level:3,title:"查询特定版本的文档",slug:"查询特定版本的文档",normalizedTitle:"查询特定版本的文档",charIndex:854},{level:3,title:"Geometry类",slug:"geometry类",normalizedTitle:"geometry类",charIndex:1039},{level:3,title:"Texture颜色空间",slug:"texture颜色空间",normalizedTitle:"texture颜色空间",charIndex:1214}],headersStr:"所有版本链接 初学者学习提醒 系统课程 有无必要用threejs最新版本 查询特定版本的文档 Geometry类 Texture颜色空间",content:"# 谈谈Three.js版本问题\n\nThree.js有一个最大特点，就是过去的10来年，每个月都会更新发布一个版本，非常不稳定，截止到2023年今天9月11号已经发布了156个版本。\n\n所以我强烈提醒大家，学习任何threejs相关课程或参考threejs相关文章，一定要注意版本问题。\n\n\n# 所有版本链接\n\n查看所有版本链接：http://www.webgl3d.cn/pages/aac9ab/\n\n\n# 初学者学习提醒\n\n如果你是初学者，有一点我是非常不建议的，就是你直接npm安装本月份最新版本的threejs学习，因为你无法保证，新版本课程，哪怕是几周前录制的，也可能某个api改变了，导致代码无法执行。\n\n// 默认本月最新版本\nnpm install three --save\n\n\n你可以在github下载特定版本文件包，也可以npm安装特定版本。\n\n// 比如安装156版本\nnpm install three@0.156.0 --save\n\n\n\n# 系统课程\n\n新手学习threejs，除了版本问题，往往也会有其他小问题，如果你想少走弯路，节约学习时间，有老师答疑，可以报名咱们的Three.js可视化系统课程WebGL。\n\n报名后，某节课学习遇到问题，你可以咨询我，我同时也会根据你个人基础，给你最合适的学习指导与建议。\n\n 1. 第一阶段：基本内容和中级内容\n 2. 第二阶段：进阶数学几何计算、漫游、八叉树碰撞检测等等\n 3. 第三阶段：WebGL、Threejs Shader、WebGPU\n\n\n# 有无必要用threejs最新版本\n\nThreejs每个月相比上个月都会变化，不过大部分是时候，两个月之间，相比较，变化不会太大。\n\n最近一年threejs虽然升级变化，但是整体的结构，变化不大。这就是说最近一年视频课程你都可以学习。\n\n有同学可能一定要用最新版本，这时候你要注意，几遍这个课程录制了刚刚几周，都有可能改变。主要是threejs每个月发布一个版本，频率太快。\n\n\n# 查询特定版本的文档\n\n等你入门完成，开始上手以后，随便那个版本都无所谓，哪里有问题直接查询对应theeejs版本的文档即可。\n\nthreejs官网文档是最新版本，不一定和你们公司用的版本一致，所以一定要注意，查询公司用的threejs，对应版本文档。\n\n查看特定版本文档方法：github上下载对应版本文件包，找到doc目录中html文件本地静态服务打开即可。\n\n\n# Geometry类\n\n旧版本几何体相关的类，有Geometry和BufferGeometry两个，新版本已经删除Geometry及其子类。\n\nBufferGeometry所有旧版本子类名称也发生改变，比如BoxBufferGeometry、PlaneBufferGeometry已经改变为BoxGeometry、PlaneGeometry。\n\n\n# Texture颜色空间\n\n新版本，纹理对象Texture,颜色空间相关的属性名.encoding已经变更为.colorSpace。\n\ntexture.encoding = THREE.sRGBEncoding;\n\n\ntexture.colorSpace  = THREE.SRGBColorSpace;\n",normalizedContent:"# 谈谈three.js版本问题\n\nthree.js有一个最大特点，就是过去的10来年，每个月都会更新发布一个版本，非常不稳定，截止到2023年今天9月11号已经发布了156个版本。\n\n所以我强烈提醒大家，学习任何threejs相关课程或参考threejs相关文章，一定要注意版本问题。\n\n\n# 所有版本链接\n\n查看所有版本链接：http://www.webgl3d.cn/pages/aac9ab/\n\n\n# 初学者学习提醒\n\n如果你是初学者，有一点我是非常不建议的，就是你直接npm安装本月份最新版本的threejs学习，因为你无法保证，新版本课程，哪怕是几周前录制的，也可能某个api改变了，导致代码无法执行。\n\n// 默认本月最新版本\nnpm install three --save\n\n\n你可以在github下载特定版本文件包，也可以npm安装特定版本。\n\n// 比如安装156版本\nnpm install three@0.156.0 --save\n\n\n\n# 系统课程\n\n新手学习threejs，除了版本问题，往往也会有其他小问题，如果你想少走弯路，节约学习时间，有老师答疑，可以报名咱们的three.js可视化系统课程webgl。\n\n报名后，某节课学习遇到问题，你可以咨询我，我同时也会根据你个人基础，给你最合适的学习指导与建议。\n\n 1. 第一阶段：基本内容和中级内容\n 2. 第二阶段：进阶数学几何计算、漫游、八叉树碰撞检测等等\n 3. 第三阶段：webgl、threejs shader、webgpu\n\n\n# 有无必要用threejs最新版本\n\nthreejs每个月相比上个月都会变化，不过大部分是时候，两个月之间，相比较，变化不会太大。\n\n最近一年threejs虽然升级变化，但是整体的结构，变化不大。这就是说最近一年视频课程你都可以学习。\n\n有同学可能一定要用最新版本，这时候你要注意，几遍这个课程录制了刚刚几周，都有可能改变。主要是threejs每个月发布一个版本，频率太快。\n\n\n# 查询特定版本的文档\n\n等你入门完成，开始上手以后，随便那个版本都无所谓，哪里有问题直接查询对应theeejs版本的文档即可。\n\nthreejs官网文档是最新版本，不一定和你们公司用的版本一致，所以一定要注意，查询公司用的threejs，对应版本文档。\n\n查看特定版本文档方法：github上下载对应版本文件包，找到doc目录中html文件本地静态服务打开即可。\n\n\n# geometry类\n\n旧版本几何体相关的类，有geometry和buffergeometry两个，新版本已经删除geometry及其子类。\n\nbuffergeometry所有旧版本子类名称也发生改变，比如boxbuffergeometry、planebuffergeometry已经改变为boxgeometry、planegeometry。\n\n\n# texture颜色空间\n\n新版本，纹理对象texture,颜色空间相关的属性名.encoding已经变更为.colorspace。\n\ntexture.encoding = three.srgbencoding;\n\n\ntexture.colorspace  = three.srgbcolorspace;\n",charsets:{cjk:!0}},{title:"5. Blender导出gltf(与threejs协作)",frontmatter:{title:"5. Blender导出gltf(与threejs协作)",date:"2023-11-27T21:17:26.000Z",permalink:"/pages/a4ad16/"},regularPath:"/Blender%E6%95%99%E7%A8%8B/01.1.Blender%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/05.Blender%E5%AF%BC%E5%87%BAgltf(%E4%B8%8Ethreejs%E5%8D%8F%E4%BD%9C).html",relativePath:"Blender教程/01.1.Blender入门基础/05.Blender导出gltf(与threejs协作).md",key:"v-71cb85e4",path:"/pages/a4ad16/",headers:[{level:3,title:"Blender导出不同格式模型文件",slug:"blender导出不同格式模型文件",normalizedTitle:"blender导出不同格式模型文件",charIndex:73},{level:3,title:"Blender导入不同格式模型文件",slug:"blender导入不同格式模型文件",normalizedTitle:"blender导入不同格式模型文件",charIndex:202},{level:3,title:".gltf格式文件(美术——程序协作)",slug:"gltf格式文件-美术-程序协作",normalizedTitle:".gltf格式文件(美术——程序协作)",charIndex:362},{level:3,title:"gltf二进制格式.glb",slug:"gltf二进制格式-glb",normalizedTitle:"gltf二进制格式.glb",charIndex:593},{level:3,title:"【扩展】three.js加载解析gltf模型文件",slug:"【扩展】three-js加载解析gltf模型文件",normalizedTitle:"【扩展】three.js加载解析gltf模型文件",charIndex:659}],headersStr:"Blender导出不同格式模型文件 Blender导入不同格式模型文件 .gltf格式文件(美术——程序协作) gltf二进制格式.glb 【扩展】three.js加载解析gltf模型文件",content:"# Blender导出gltf(美术与程序员协作)\n\n通过Blender制作好3D模型，一般需要导出模型文件，然后通过代码渲染这个模型。\n\n\n# Blender导出不同格式模型文件\n\n图片有.jpg、.png等各种格式。\n\n3D模型文件和图片文件一样，也有多种格式，不同格式能包含的模型数据也不完全相同。\n\n你可以用Blender导出你需要的格式，比如.stl、.fbx、.gltf格式文件\n\n\n\n\n# Blender导入不同格式模型文件\n\n实际开发的时候，美术也不一定就使用Blender软件，不同软件之间，就需要共同支持的格式来协作。\n\n比如用3dmax、c4d导出gltf、fbx等常见格式文件，然后再用blender打开这些文件。\n\n通过菜单-文件-导入功能，你可以查看blender能打开的模型文件。\n\n\n\n\n# .gltf格式文件(美术——程序协作)\n\nBlender能够导出很多种格式，不过除了特殊需求外，大家一般导出gltf格式模型文件即可。对于threejs、cesium、BabylonJS任何一款3D引擎，加载gltf格式模型都是非常方便的。\n\n你可以把gltf格式模型，当做图片领域的jpg格式，非常常用。\n\nweb3d可视化项目，最常见的方式是Blender导出gltf格式的模型文件\n\n * 美术：制作3D模型\n * 程序员：渲染外部模型、设置交互\n\n\n# gltf二进制格式.glb\n\n导出gltf格式模型的时候，除了后缀名.gltf，也可以选择导出gltf的二进制格式.glb\n\n\n# 【扩展】three.js加载解析gltf模型文件\n\n你可以尝试用three.js引擎加载上面你导出的gltf格式模型文件。\n\n具体代码去学习threejs基础课程的讲解6.3. 加载.gltf文件\n\nBlender课件中我也放了一个threejs加载gltf的代码，你可以用来测试你导出的gltf模型。\n\n提醒：不管你是美术还是程序员，以后开发，都可以用这个代码去验证你的gltf模型文件是否正常导出。",normalizedContent:"# blender导出gltf(美术与程序员协作)\n\n通过blender制作好3d模型，一般需要导出模型文件，然后通过代码渲染这个模型。\n\n\n# blender导出不同格式模型文件\n\n图片有.jpg、.png等各种格式。\n\n3d模型文件和图片文件一样，也有多种格式，不同格式能包含的模型数据也不完全相同。\n\n你可以用blender导出你需要的格式，比如.stl、.fbx、.gltf格式文件\n\n\n\n\n# blender导入不同格式模型文件\n\n实际开发的时候，美术也不一定就使用blender软件，不同软件之间，就需要共同支持的格式来协作。\n\n比如用3dmax、c4d导出gltf、fbx等常见格式文件，然后再用blender打开这些文件。\n\n通过菜单-文件-导入功能，你可以查看blender能打开的模型文件。\n\n\n\n\n# .gltf格式文件(美术——程序协作)\n\nblender能够导出很多种格式，不过除了特殊需求外，大家一般导出gltf格式模型文件即可。对于threejs、cesium、babylonjs任何一款3d引擎，加载gltf格式模型都是非常方便的。\n\n你可以把gltf格式模型，当做图片领域的jpg格式，非常常用。\n\nweb3d可视化项目，最常见的方式是blender导出gltf格式的模型文件\n\n * 美术：制作3d模型\n * 程序员：渲染外部模型、设置交互\n\n\n# gltf二进制格式.glb\n\n导出gltf格式模型的时候，除了后缀名.gltf，也可以选择导出gltf的二进制格式.glb\n\n\n# 【扩展】three.js加载解析gltf模型文件\n\n你可以尝试用three.js引擎加载上面你导出的gltf格式模型文件。\n\n具体代码去学习threejs基础课程的讲解6.3. 加载.gltf文件\n\nblender课件中我也放了一个threejs加载gltf的代码，你可以用来测试你导出的gltf模型。\n\n提醒：不管你是美术还是程序员，以后开发，都可以用这个代码去验证你的gltf模型文件是否正常导出。",charsets:{cjk:!0}},{title:"阅读Three.js源码",frontmatter:{title:"阅读Three.js源码",date:"2023-09-20T08:55:34.000Z",permalink:"/pages/33b01c/"},regularPath:"/Threejs%E6%96%87%E7%AB%A0/02.%E9%98%85%E8%AF%BBThree.js%E6%BA%90%E7%A0%81.html",relativePath:"Threejs文章/02.阅读Three.js源码.md",key:"v-b72d140e",path:"/pages/33b01c/",headers:[{level:3,title:"查看Threejs文件包的src目录",slug:"查看threejs文件包的src目录",normalizedTitle:"查看threejs文件包的src目录",charIndex:93},{level:3,title:"查询特定类的源码",slug:"查询特定类的源码",normalizedTitle:"查询特定类的源码",charIndex:233},{level:3,title:"查看类某个方法的源码",slug:"查看类某个方法的源码",normalizedTitle:"查看类某个方法的源码",charIndex:344},{level:3,title:"renderers目录",slug:"renderers目录",normalizedTitle:"renderers目录",charIndex:606},{level:3,title:"renderers/shaders目录",slug:"renderers-shaders目录",normalizedTitle:"renderers/shaders目录",charIndex:751}],headersStr:"查看Threejs文件包的src目录 查询特定类的源码 查看类某个方法的源码 renderers目录 renderers/shaders目录",content:"# 阅读Three.js源码\n\n如果你接触threejs有一定时间了，也能写一些简单的项目，这时候可以尝试预览下Threejs的源码，通过Threejs的源码可以了解很多知识。\n\n\n# 查看Threejs文件包的src目录\n\n查看所有版本链接：http://www.webgl3d.cn/pages/aac9ab/\n\n你可以在github上下载随便一个版本的threejs文件包，解压后，可以看到一个src目录文件，里面就是threejs所有类对应的代码。\n\n\n# 查询特定类的源码\n\n比如所有模型对象的父类Object3D,对应的文件地址./src/core/Object3D.js。\n\n比如三维向量类Vector3,对应的文件地址./src/math/Vector3.js。\n\n\n# 查看类某个方法的源码\n\n查看三维向量类Vector3,方法copy和clone对应的源码，有些时候，你查看threejs某个类的源码，相比文档，会更加清晰。\n\n// 复制参数的值，返回的还是执行该方法的对象\ncopy( v ) {\n\tthis.x = v.x;\n\tthis.y = v.y;\n\tthis.z = v.z;\n\treturn this;\n}\n// 返回一个新的对象\nclone() {\n\treturn new this.constructor( this.x, this.y, this.z );\n}\n\n\n\n# renderers目录\n\nrenderers目录里面主要WebGl渲染器相关的代码，是src目录下最复杂的。如果想你查看里面的代码，请确保你已经入门原生WebGL，否则你很难理解。\n\nWebGLRenderer.js文件对应的其实就是WebGL渲染器类WebGLRenderer。\n\n\n# renderers/shaders目录\n\nThree.js所有的材质Material本质上就是shader，也就是GLSL代码。\n\n所有材质对应的shader代码，你可以查看目录renderers/shaders。\n\n如果你想通过材质.onBeforeCompile方法修改threejs默认的shader，就需要去大概熟悉renderers/shaders目录中的文件。\n\n今天视频时间有限，如果你想了解更多具体进阶内容，可以选择报名咱们的Three.js可视化系统课程WebGL。\n\n相应应用，比如智慧城市shader特效、地球飞线特效。",normalizedContent:"# 阅读three.js源码\n\n如果你接触threejs有一定时间了，也能写一些简单的项目，这时候可以尝试预览下threejs的源码，通过threejs的源码可以了解很多知识。\n\n\n# 查看threejs文件包的src目录\n\n查看所有版本链接：http://www.webgl3d.cn/pages/aac9ab/\n\n你可以在github上下载随便一个版本的threejs文件包，解压后，可以看到一个src目录文件，里面就是threejs所有类对应的代码。\n\n\n# 查询特定类的源码\n\n比如所有模型对象的父类object3d,对应的文件地址./src/core/object3d.js。\n\n比如三维向量类vector3,对应的文件地址./src/math/vector3.js。\n\n\n# 查看类某个方法的源码\n\n查看三维向量类vector3,方法copy和clone对应的源码，有些时候，你查看threejs某个类的源码，相比文档，会更加清晰。\n\n// 复制参数的值，返回的还是执行该方法的对象\ncopy( v ) {\n\tthis.x = v.x;\n\tthis.y = v.y;\n\tthis.z = v.z;\n\treturn this;\n}\n// 返回一个新的对象\nclone() {\n\treturn new this.constructor( this.x, this.y, this.z );\n}\n\n\n\n# renderers目录\n\nrenderers目录里面主要webgl渲染器相关的代码，是src目录下最复杂的。如果想你查看里面的代码，请确保你已经入门原生webgl，否则你很难理解。\n\nwebglrenderer.js文件对应的其实就是webgl渲染器类webglrenderer。\n\n\n# renderers/shaders目录\n\nthree.js所有的材质material本质上就是shader，也就是glsl代码。\n\n所有材质对应的shader代码，你可以查看目录renderers/shaders。\n\n如果你想通过材质.onbeforecompile方法修改threejs默认的shader，就需要去大概熟悉renderers/shaders目录中的文件。\n\n今天视频时间有限，如果你想了解更多具体进阶内容，可以选择报名咱们的three.js可视化系统课程webgl。\n\n相应应用，比如智慧城市shader特效、地球飞线特效。",charsets:{cjk:!0}},{title:"3D模型gltf下载网站(threejs开发)",frontmatter:{title:"3D模型gltf下载网站(threejs开发)",date:"2023-12-27T11:49:11.000Z",permalink:"/pages/c3ecc9/"},regularPath:"/Threejs%E6%96%87%E7%AB%A0/03.3D%E6%A8%A1%E5%9E%8Bgltf%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99(threejs%E5%BC%80%E5%8F%91).html",relativePath:"Threejs文章/03.3D模型gltf下载网站(threejs开发).md",key:"v-4ebeb0e4",path:"/pages/c3ecc9/",headers:[{level:3,title:"CG模型网",slug:"cg模型网",normalizedTitle:"cg模型网",charIndex:99},{level:3,title:"sketchfab",slug:"sketchfab",normalizedTitle:"sketchfab",charIndex:278},{level:3,title:"free3d.com",slug:"free3d-com",normalizedTitle:"free3d.com",charIndex:408},{level:3,title:"glTF-Sample-Models",slug:"gltf-sample-models",normalizedTitle:"gltf-sample-models",charIndex:482},{level:3,title:"机械领域模型",slug:"机械领域模型",normalizedTitle:"机械领域模型",charIndex:649},{level:3,title:"万能淘宝、拼多多",slug:"万能淘宝、拼多多",normalizedTitle:"万能淘宝、拼多多",charIndex:781},{level:3,title:"正式开发：3D建模",slug:"正式开发-3d建模",normalizedTitle:"正式开发：3d建模",charIndex:820}],headersStr:"CG模型网 sketchfab free3d.com glTF-Sample-Models 机械领域模型 万能淘宝、拼多多 正式开发：3D建模",content:"# 3D模型下载网站(threejs开发)\n\n用threejs做web3d可视化项目的时候，有时候需要下载三维模型，尤其是直接下载gltf格式模型。\n\n下面给大家简单介绍一个模型网站资源。\n\n\n# CG模型网\n\nCG模型网：https://www.cgmodel.com/\n\n国内网站资源，模型非常多，有很多建模师，上传3D模型，有免费简单模型，也有付费的精细模型。\n\n不过很多不是blender格式，或者gltf格式，你很多时候，需要自己处理下。\n\n还有这些里面的模型，很多相对web3d可视化项目来说，往往需要减面，有很多多余顶点或说着三角形\n\n\n# sketchfab\n\nsketchfab：https://sketchfab.com\n\nsketchfab是国外网站资源，主要已付费为主，国外网站资源，直接打开速度可能会慢点。\n\nsketchfab提供了很多gltf格式模型，还可以在线预览3d效果。\n\n\n# free3d.com\n\nfree3d是国外网站资源，有免费模型，有付费模型\n\nfree3d.com：https://free3d.com/\n\n\n# glTF-Sample-Models\n\ngithub上一个开源项目，提供的各种gltf格式3d模型，threejs examples里面很多模型都是用的这里面的。\n\nglTF-Sample-Models:https://github.com/KhronosGroup/glTF-Sample-Models/tree/main\n\n\n# 机械领域模型\n\n微小网：https://www.vx.com/\n\n微小网主要是机械行业工程师常用网站，如果你们公司的物联网或数字孪生项目，有与机械相关的，可以让美术下载参考。\n\n不过注意，一般需要专业的机械软件才能打开，比如SolidWorks、UG等等\n\n\n# 万能淘宝、拼多多\n\n淘宝、拼多多也有很多资源可供选择，这里就不演示。\n\n\n# 正式开发：3D建模\n\n一般来说正式开发的话，模型还是需要公司自己的3D美术绘制模型，或者说外包给别的建模工作室。\n\n主要是因为下载的模型不一定就能刚好满足需求，另一方面，及时外观符合需要，但是模型面数很有可能太大，也需要美术后期减面处理，否则会导致，一方面网页加载时间太长，另一方面渲染性能可能也不好。",normalizedContent:"# 3d模型下载网站(threejs开发)\n\n用threejs做web3d可视化项目的时候，有时候需要下载三维模型，尤其是直接下载gltf格式模型。\n\n下面给大家简单介绍一个模型网站资源。\n\n\n# cg模型网\n\ncg模型网：https://www.cgmodel.com/\n\n国内网站资源，模型非常多，有很多建模师，上传3d模型，有免费简单模型，也有付费的精细模型。\n\n不过很多不是blender格式，或者gltf格式，你很多时候，需要自己处理下。\n\n还有这些里面的模型，很多相对web3d可视化项目来说，往往需要减面，有很多多余顶点或说着三角形\n\n\n# sketchfab\n\nsketchfab：https://sketchfab.com\n\nsketchfab是国外网站资源，主要已付费为主，国外网站资源，直接打开速度可能会慢点。\n\nsketchfab提供了很多gltf格式模型，还可以在线预览3d效果。\n\n\n# free3d.com\n\nfree3d是国外网站资源，有免费模型，有付费模型\n\nfree3d.com：https://free3d.com/\n\n\n# gltf-sample-models\n\ngithub上一个开源项目，提供的各种gltf格式3d模型，threejs examples里面很多模型都是用的这里面的。\n\ngltf-sample-models:https://github.com/khronosgroup/gltf-sample-models/tree/main\n\n\n# 机械领域模型\n\n微小网：https://www.vx.com/\n\n微小网主要是机械行业工程师常用网站，如果你们公司的物联网或数字孪生项目，有与机械相关的，可以让美术下载参考。\n\n不过注意，一般需要专业的机械软件才能打开，比如solidworks、ug等等\n\n\n# 万能淘宝、拼多多\n\n淘宝、拼多多也有很多资源可供选择，这里就不演示。\n\n\n# 正式开发：3d建模\n\n一般来说正式开发的话，模型还是需要公司自己的3d美术绘制模型，或者说外包给别的建模工作室。\n\n主要是因为下载的模型不一定就能刚好满足需求，另一方面，及时外观符合需要，但是模型面数很有可能太大，也需要美术后期减面处理，否则会导致，一方面网页加载时间太长，另一方面渲染性能可能也不好。",charsets:{cjk:!0}},{title:"three.js模拟显示屏模型播放视频",frontmatter:{title:"three.js模拟显示屏模型播放视频",date:"2024-01-01T11:48:55.000Z",permalink:"/pages/6188ce/"},regularPath:"/Threejs%E6%96%87%E7%AB%A0/04.three.js%E6%A8%A1%E6%8B%9F%E6%98%BE%E7%A4%BA%E5%B1%8F%E6%A8%A1%E5%9E%8B%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91.html",relativePath:"Threejs文章/04.three.js模拟显示屏模型播放视频.md",key:"v-27b0f8bf",path:"/pages/6188ce/",headers:[{level:3,title:"1. 建模软件设置好UV",slug:"_1-建模软件设置好uv",normalizedTitle:"1. 建模软件设置好uv",charIndex:149},{level:3,title:"2. video元素加载纹理",slug:"_2-video元素加载纹理",normalizedTitle:"2. video元素加载纹理",charIndex:316},{level:3,title:"3. 视频创建纹理VideoTexture",slug:"_3-视频创建纹理videotexture",normalizedTitle:"3. 视频创建纹理videotexture",charIndex:480},{level:3,title:"4. 播放视频video.play()",slug:"_4-播放视频video-play",normalizedTitle:"4. 播放视频video.play()",charIndex:814},{level:3,title:"注意：gltf加载的模型，纹理.flipY 、颜色空间问题",slug:"注意-gltf加载的模型-纹理-flipy、颜色空间问题",normalizedTitle:"注意：gltf加载的模型，纹理.flipy 、颜色空间问题",charIndex:null}],headersStr:"1. 建模软件设置好UV 2. video元素加载纹理 3. 视频创建纹理VideoTexture 4. 播放视频video.play() 注意：gltf加载的模型，纹理.flipY 、颜色空间问题",content:"# three.js模拟显示屏模型播放视频\n\n需求：在有些Web3D项目中，有一个虚拟屏幕网格模型，你希望屏幕网格模型能模拟播放视频。\n\n\n\n思路非常简单，你可以获取图片创建纹理对象Texture，作为材质.map的纹理贴图。同样方式，你也可以获取视频创建纹理对象，作为.map属性的值。\n\n\n# 1. 建模软件设置好UV\n\n使用三维软件建模的过程中，比如使用Blender时候，要把表示虚拟屏幕的Mesh，UV设置好，这样方便代码中添加纹理贴图。可以让美术在建模软件中，先随机设置一张图片作为纹理，验证UV是否设置好。\n\n比如咱们这节课中模型，创建显示屏模型的时候，单独一个矩形平面Mesh表示显示屏，用来添加视频纹理。\n\n\n# 2. video元素加载纹理\n\nvideo是html5的一个元素，可以用来加载播放视频，如果不熟悉，可以去补充下相关的前端知识点。\n\nconst video = document.createElement('video');\nvideo.src = \"./医院宣传.mp4\";\nvideo.loop = true;\n\n\n\n# 3. 视频创建纹理VideoTexture\n\n通过VideoTexture可以把video生成一个纹理，给材质map属性赋值。\n\nconst video = document.createElement('video');\nvideo.src = \"./医院宣传.mp4\";\nvideo.loop = true;\n// 视频生成纹理对象\nconst texture = new THREE.VideoTexture(video);\n// 获取矩形平面Mesh(显示屏)设置map\nmodel.getObjectByName('电视').material = new THREE.MeshBasicMaterial({\n    map: texture\n})\n\n\n\n# 4. 播放视频video.play()\n\n视频纹理起作用，非常简单，直接播放视频video即可，视频的每一帧图像数据会在材质.map上更新。整个原理非常简单，就是视频在播放的过程中，threejs会获取视频当前时间对应的一帧图像作为纹理。\n\nvideo.play();\n\n\n现在很多浏览器不允许视频加载的时候，默认播放，这一点要注意。比如你可以在某个鼠标或键盘事件触发视频的播放。\n\naddEventListener('mousedown', () => {\n    video.play();\n});\n\n\n\n\n# 注意：gltf加载的模型，纹理.flipY、颜色空间问题\n\n如果你是给gltf模型里面屏幕Mesh设置纹理贴图，纹理贴图方向错误(注意UV坐标正确的情况下)，注意.flipY属性的设置。\n\ntexture.flipY = false;\n\n\n还有颜色空间的问题，如果颜色空间设置不对，可能会出现纹理颜色与正常颜色不一致的问题。\n\ntexture.colorSpace  = THREE.SRGBColorSpace;//新版本\n\n\ntexture.encoding = THREE.sRGBEncoding;//旧版本\n",normalizedContent:"# three.js模拟显示屏模型播放视频\n\n需求：在有些web3d项目中，有一个虚拟屏幕网格模型，你希望屏幕网格模型能模拟播放视频。\n\n\n\n思路非常简单，你可以获取图片创建纹理对象texture，作为材质.map的纹理贴图。同样方式，你也可以获取视频创建纹理对象，作为.map属性的值。\n\n\n# 1. 建模软件设置好uv\n\n使用三维软件建模的过程中，比如使用blender时候，要把表示虚拟屏幕的mesh，uv设置好，这样方便代码中添加纹理贴图。可以让美术在建模软件中，先随机设置一张图片作为纹理，验证uv是否设置好。\n\n比如咱们这节课中模型，创建显示屏模型的时候，单独一个矩形平面mesh表示显示屏，用来添加视频纹理。\n\n\n# 2. video元素加载纹理\n\nvideo是html5的一个元素，可以用来加载播放视频，如果不熟悉，可以去补充下相关的前端知识点。\n\nconst video = document.createelement('video');\nvideo.src = \"./医院宣传.mp4\";\nvideo.loop = true;\n\n\n\n# 3. 视频创建纹理videotexture\n\n通过videotexture可以把video生成一个纹理，给材质map属性赋值。\n\nconst video = document.createelement('video');\nvideo.src = \"./医院宣传.mp4\";\nvideo.loop = true;\n// 视频生成纹理对象\nconst texture = new three.videotexture(video);\n// 获取矩形平面mesh(显示屏)设置map\nmodel.getobjectbyname('电视').material = new three.meshbasicmaterial({\n    map: texture\n})\n\n\n\n# 4. 播放视频video.play()\n\n视频纹理起作用，非常简单，直接播放视频video即可，视频的每一帧图像数据会在材质.map上更新。整个原理非常简单，就是视频在播放的过程中，threejs会获取视频当前时间对应的一帧图像作为纹理。\n\nvideo.play();\n\n\n现在很多浏览器不允许视频加载的时候，默认播放，这一点要注意。比如你可以在某个鼠标或键盘事件触发视频的播放。\n\naddeventlistener('mousedown', () => {\n    video.play();\n});\n\n\n\n\n# 注意：gltf加载的模型，纹理.flipy、颜色空间问题\n\n如果你是给gltf模型里面屏幕mesh设置纹理贴图，纹理贴图方向错误(注意uv坐标正确的情况下)，注意.flipy属性的设置。\n\ntexture.flipy = false;\n\n\n还有颜色空间的问题，如果颜色空间设置不对，可能会出现纹理颜色与正常颜色不一致的问题。\n\ntexture.colorspace  = three.srgbcolorspace;//新版本\n\n\ntexture.encoding = three.srgbencoding;//旧版本\n",charsets:{cjk:!0}},{title:"1. Vue+Three.js课程简介",frontmatter:{title:"1. Vue+Three.js课程简介",date:"2023-03-26T11:44:43.000Z",permalink:"/pages/46aa7c/"},regularPath:"/Vue+Three.js%203D%E5%8F%AF%E8%A7%86%E5%8C%96/01.1.%E5%AD%A6%E5%89%8D%E8%AF%B4%E6%98%8E/01.Vue+Three.js%E8%AF%BE%E7%A8%8B%E7%AE%80%E4%BB%8B.html",relativePath:"Vue+Three.js 3D可视化/01.1.学前说明/01.Vue+Three.js课程简介.md",key:"v-177bce0e",path:"/pages/46aa7c/",headers:[{level:3,title:"前端经验问题",slug:"前端经验问题",normalizedTitle:"前端经验问题",charIndex:50},{level:3,title:"Vue + Three.js方案",slug:"vue-three-js方案",normalizedTitle:"vue + three.js方案",charIndex:262},{level:3,title:"物联网、数字孪生3D可视化开发流程",slug:"物联网、数字孪生3d可视化开发流程",normalizedTitle:"物联网、数字孪生3d可视化开发流程",charIndex:402},{level:3,title:"学员基础-web前端",slug:"学员基础-web前端",normalizedTitle:"学员基础-web前端",charIndex:571},{level:3,title:"学员基础-Threejs",slug:"学员基础-threejs",normalizedTitle:"学员基础-threejs",charIndex:732},{level:3,title:"学员基础-Blender",slug:"学员基础-blender",normalizedTitle:"学员基础-blender",charIndex:993},{level:3,title:"Vue+Three.js课程风格",slug:"vue-three-js课程风格",normalizedTitle:"vue+three.js课程风格",charIndex:1117},{level:3,title:"具体技术栈",slug:"具体技术栈",normalizedTitle:"具体技术栈",charIndex:1265},{level:3,title:"Vue+Threejs项目模板",slug:"vue-threejs项目模板",normalizedTitle:"vue+threejs项目模板",charIndex:1393},{level:3,title:"课程形式",slug:"课程形式",normalizedTitle:"课程形式",charIndex:1688}],headersStr:"前端经验问题 Vue + Three.js方案 物联网、数字孪生3D可视化开发流程 学员基础-web前端 学员基础-Threejs 学员基础-Blender Vue+Three.js课程风格 具体技术栈 Vue+Threejs项目模板 课程形式",content:"# 课程介绍\n\n在正式学习之前，先对Vue+Three.js 3D可视化课程进行简单介绍。\n\n\n# 前端经验问题\n\n仅仅学习Three.js等3D知识对普通web前端要求不高，稍微了解就行，如果是实战开发的话，对前端基础要求比较高。\n\n如果你本身有几年开发前端经验，再好不过，只需要学习3D部分知识即可，如果没有前端经验，除了3D知识，你还需要加紧补充web前端知识点。\n\nWeb3D开发也是建立普通web前端基础上的，一句话就是，你做Web3D项目开发，需要掌握的web前端知识和普通web前端程序员没什么区别。\n\n\n# Vue + Three.js方案\n\n如果你们的项目计划使用Vue + Three.js方案开发，你不知道两者如何结合，或者不知道怎么把threejs引入到Vue项目，可以参考本课程的讲解。\n\n本课程会从零演示Vue与Three.js结合，用于Web3D可视化项目的开发。\n\n\n# 物联网、数字孪生3D可视化开发流程\n\n课程会以一个工厂为例演示一个Web3D可视化的开发流程。\n\n如果你是小白，刚开始接触智慧城市、工厂、园区、收费站等等物联网、数字孪生相关的Web3D可视化项目，那么，本课程对于你来说是非常有用。\n\n通过本课程，可以让一个初次接触Web3D可视化项目的小白，快速找到方向，节约学习和开发时间。\n\n\n# 学员基础-web前端\n\n学习本课程，要求有一定的Web前端基础，比如最基本的HTML、CSS、JavaScript、ES6、Nodejs、ajax等前端基础知识，比如项目实战开发需要的Vue、Vite技术栈。\n\n如果你没有前端相关基础，最好找相关课程学习下，比如说你没有Vue基础，那么本课程你也没办法正常学习。\n\n\n# 学员基础-Threejs\n\n课程会从零全流程演示Threejs引入Vue项目中的过程。如果你是刚开始接触Three.js，虽然也可以直接学习，但是如果你有一定Threejs基础，学习本课程会更加轻松。\n\n建议：如果你是刚接接触Three.js，可以先不考虑结合Vuejs，先看看咱们的Three.js基础课程，再来学习本课程，如果时间比较紧，最低要求，掌握Threejs入门课程第一章节，再来学习本课程。\n\n注意：本课程某个知识点，在Threejs基础教程1~16章节已经jd会讲解比较快，未涉及的，会详细讲解。\n\n\n# 学员基础-Blender\n\n三维场景的搭建，除了需要写代码之外，还需要三维建模，不过一般实际开发，都是公司美术负责三维建模。\n\n对于程序员而言，如果掌握三维建模更好，当然不掌握也可以，你会用Blender查看预览、导入、导出三维模型即可。\n\n\n# Vue+Three.js课程风格\n\n关于Three.js很多知识点，在基础部分都有详细介绍，为了节约大家学习时间，Vue+Three.js课程的风格，倾向思路和流程讲解，不会一个一个字母去敲。\n\n课程不会只提供一个最终案例源码，每当完成一部分，会提供对应的源码，以便大家分阶段参考学习。\n\n\n# 具体技术栈\n\n课程案例会涉及到的技术栈：\n\n 1. Vue3：前端框架\n 2. Vite：工程化开发\n 3. UI组件库element-ui\n 4. Three.js：Web3D可视化\n 5. 三维建模软件Blender：创建、查看、导出工厂模型\n\n\n# Vue+Threejs项目模板\n\n通过学习本课程，你可以获得一些Web3D可视化开发的基础模板。\n\n比如你想开发一个智慧园区的案例，那就你可以用本课程提供的Vue+Threejs项目模板，用园区模型替换掉代码里面的工厂模型，在配置园区相关的数据，这样就可以大大节约你的初次开发时间。\n\n以后发布的一些进阶案例，都会使用本课程提供的Vue+Threejs项目模板。\n\n 1. 场景、相机、渲染器基础配置\n 2. Canvas全屏布局、局部布局\n 3. 加载gltf压缩模型、进度条\n 4. 光源设置、阴影计算\n 5. 后期处理、抗锯齿\n 6. 射线拾取模型\n 7. HTML元素标签\n\n\n# 课程形式\n\n视频 + 注释源码 + 图文电子书",normalizedContent:"# 课程介绍\n\n在正式学习之前，先对vue+three.js 3d可视化课程进行简单介绍。\n\n\n# 前端经验问题\n\n仅仅学习three.js等3d知识对普通web前端要求不高，稍微了解就行，如果是实战开发的话，对前端基础要求比较高。\n\n如果你本身有几年开发前端经验，再好不过，只需要学习3d部分知识即可，如果没有前端经验，除了3d知识，你还需要加紧补充web前端知识点。\n\nweb3d开发也是建立普通web前端基础上的，一句话就是，你做web3d项目开发，需要掌握的web前端知识和普通web前端程序员没什么区别。\n\n\n# vue + three.js方案\n\n如果你们的项目计划使用vue + three.js方案开发，你不知道两者如何结合，或者不知道怎么把threejs引入到vue项目，可以参考本课程的讲解。\n\n本课程会从零演示vue与three.js结合，用于web3d可视化项目的开发。\n\n\n# 物联网、数字孪生3d可视化开发流程\n\n课程会以一个工厂为例演示一个web3d可视化的开发流程。\n\n如果你是小白，刚开始接触智慧城市、工厂、园区、收费站等等物联网、数字孪生相关的web3d可视化项目，那么，本课程对于你来说是非常有用。\n\n通过本课程，可以让一个初次接触web3d可视化项目的小白，快速找到方向，节约学习和开发时间。\n\n\n# 学员基础-web前端\n\n学习本课程，要求有一定的web前端基础，比如最基本的html、css、javascript、es6、nodejs、ajax等前端基础知识，比如项目实战开发需要的vue、vite技术栈。\n\n如果你没有前端相关基础，最好找相关课程学习下，比如说你没有vue基础，那么本课程你也没办法正常学习。\n\n\n# 学员基础-threejs\n\n课程会从零全流程演示threejs引入vue项目中的过程。如果你是刚开始接触three.js，虽然也可以直接学习，但是如果你有一定threejs基础，学习本课程会更加轻松。\n\n建议：如果你是刚接接触three.js，可以先不考虑结合vuejs，先看看咱们的three.js基础课程，再来学习本课程，如果时间比较紧，最低要求，掌握threejs入门课程第一章节，再来学习本课程。\n\n注意：本课程某个知识点，在threejs基础教程1~16章节已经jd会讲解比较快，未涉及的，会详细讲解。\n\n\n# 学员基础-blender\n\n三维场景的搭建，除了需要写代码之外，还需要三维建模，不过一般实际开发，都是公司美术负责三维建模。\n\n对于程序员而言，如果掌握三维建模更好，当然不掌握也可以，你会用blender查看预览、导入、导出三维模型即可。\n\n\n# vue+three.js课程风格\n\n关于three.js很多知识点，在基础部分都有详细介绍，为了节约大家学习时间，vue+three.js课程的风格，倾向思路和流程讲解，不会一个一个字母去敲。\n\n课程不会只提供一个最终案例源码，每当完成一部分，会提供对应的源码，以便大家分阶段参考学习。\n\n\n# 具体技术栈\n\n课程案例会涉及到的技术栈：\n\n 1. vue3：前端框架\n 2. vite：工程化开发\n 3. ui组件库element-ui\n 4. three.js：web3d可视化\n 5. 三维建模软件blender：创建、查看、导出工厂模型\n\n\n# vue+threejs项目模板\n\n通过学习本课程，你可以获得一些web3d可视化开发的基础模板。\n\n比如你想开发一个智慧园区的案例，那就你可以用本课程提供的vue+threejs项目模板，用园区模型替换掉代码里面的工厂模型，在配置园区相关的数据，这样就可以大大节约你的初次开发时间。\n\n以后发布的一些进阶案例，都会使用本课程提供的vue+threejs项目模板。\n\n 1. 场景、相机、渲染器基础配置\n 2. canvas全屏布局、局部布局\n 3. 加载gltf压缩模型、进度条\n 4. 光源设置、阴影计算\n 5. 后期处理、抗锯齿\n 6. 射线拾取模型\n 7. html元素标签\n\n\n# 课程形式\n\n视频 + 注释源码 + 图文电子书",charsets:{cjk:!0}},{title:"1. Vite搭建Vue 3D开发环境",frontmatter:{title:"1. Vite搭建Vue 3D开发环境",date:"2023-03-26T11:45:06.000Z",permalink:"/pages/a837c2/"},regularPath:"/Vue+Three.js%203D%E5%8F%AF%E8%A7%86%E5%8C%96/02.2.Vue+Three.js%E5%9F%BA%E7%A1%80/01.Vite%E6%90%AD%E5%BB%BAVue%203D%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html",relativePath:"Vue+Three.js 3D可视化/02.2.Vue+Three.js基础/01.Vite搭建Vue 3D开发环境.md",key:"v-6c478b4f",path:"/pages/a837c2/",headersStr:null,content:"# Vite搭建Vue 3D开发环境",normalizedContent:"# vite搭建vue 3d开发环境",charsets:{cjk:!0}},{title:"1. WebGL学前说明",frontmatter:{title:"1. WebGL学前说明",date:"2023-10-17T17:39:33.000Z",permalink:"/pages/9bc0db/"},regularPath:"/WebGL%E6%95%99%E7%A8%8B/01.1.WebGL%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01.WebGL%E5%AD%A6%E5%89%8D%E8%AF%B4%E6%98%8E.html",relativePath:"WebGL教程/01.1.WebGL快速入门/01.WebGL学前说明.md",key:"v-1c8eca98",path:"/pages/9bc0db/",headers:[{level:3,title:"为什么要学习WebGL",slug:"为什么要学习webgl",normalizedTitle:"为什么要学习webgl",charIndex:35},{level:3,title:"一些threejs shader案例展示",slug:"一些threejs-shader案例展示",normalizedTitle:"一些threejs shader案例展示",charIndex:414},{level:3,title:"为什么要学习WebGL:工作要求",slug:"为什么要学习webgl-工作要求",normalizedTitle:"为什么要学习webgl:工作要求",charIndex:530},{level:3,title:"学习基础",slug:"学习基础",normalizedTitle:"学习基础",charIndex:599},{level:3,title:"前端编程基础",slug:"前端编程基础",normalizedTitle:"前端编程基础",charIndex:847}],headersStr:"为什么要学习WebGL 一些threejs shader案例展示 为什么要学习WebGL:工作要求 学习基础 前端编程基础",content:"# WebGL学前说明\n\n正式讲解之前，对WebGL做一个简单的说明，为什么要学习WebGL，学习WebGL能做什么、怎么学习WebGL。\n\n\n# 为什么要学习WebGL\n\n少部分同学是需要直接使用原生WebGL API写项目或封装3D引擎，自然需要学习。\n\n不过对于大部分同学，做项目并不需要直接用到原生WebGL的API，一般都是选择一个3D引擎，比如three.js、cesium、babylon。\n\n虽然不直接用，但是我还是建议大家学习下原生WebGL，原因很简单，你学习了原生WebGL，一方面，你可以更容易理解three.js等3D引擎的底层原理，另一方面你通过WebGL熟悉了着色器语言GLSL ES的语法后，再去学习threejs、cesium等引擎的shader就会更加容易。\n\n总的来说，不管你现在使用任何一款3D引擎开发项目，如果你想更进一步，都可以提前学习下原生WebGL，这将会使你非常受益。\n\n\n# 一些threejs shader案例展示\n\nthreejs系统课程中 Shader相关案例展示,这些案例都需要用到WebGL的着色器语言GLSL ES。\n\n * 智慧城市特效\n * 地球的飞线效果\n * 建筑的光墙流动效果\n\n\n# 为什么要学习WebGL:工作要求\n\n另一方面，Web3D工资高点的岗位，一般面试，可能问一些渲染管线、Shader的相关知识点。\n\n\n# 学习基础\n\n 1. 数学相关(线性代数、向量点乘叉乘等等)\n 2. 图形学\n\n如果你有数学和图形学相关基础，学习原生WebGL，将会非常容易。如果你没有图形学相关基础，也这没有关系。\n\n考虑大到部分前端或转行的同学，并没有图形学相关基础，咱们的课程会尽量弱化这方面的要求，只要你有基本的高中数学基础，都可以直接学习本课程。\n\n如果你数学基础不太好，也已经入门threejs，可以直接通过咱们的threejs进阶数学几何计算课程，补充相关数学知识，这样比你直接看书更直观，不那么枯燥无聊。\n\n\n# 前端编程基础\n\n学习本课程需要你有基本的前端基础，最起码掌握JavaScript编程语言，稍微熟悉下HTML、CSS。JavaScript(ES6)、HTML、CSS不需要你精通，但是最起码了解基本语法。\n\n 1. HTML入门教程\n\n 2. CSS入门教程\n\n 3. JavaScript入门教程\n\n 4. ES6入门教程",normalizedContent:"# webgl学前说明\n\n正式讲解之前，对webgl做一个简单的说明，为什么要学习webgl，学习webgl能做什么、怎么学习webgl。\n\n\n# 为什么要学习webgl\n\n少部分同学是需要直接使用原生webgl api写项目或封装3d引擎，自然需要学习。\n\n不过对于大部分同学，做项目并不需要直接用到原生webgl的api，一般都是选择一个3d引擎，比如three.js、cesium、babylon。\n\n虽然不直接用，但是我还是建议大家学习下原生webgl，原因很简单，你学习了原生webgl，一方面，你可以更容易理解three.js等3d引擎的底层原理，另一方面你通过webgl熟悉了着色器语言glsl es的语法后，再去学习threejs、cesium等引擎的shader就会更加容易。\n\n总的来说，不管你现在使用任何一款3d引擎开发项目，如果你想更进一步，都可以提前学习下原生webgl，这将会使你非常受益。\n\n\n# 一些threejs shader案例展示\n\nthreejs系统课程中 shader相关案例展示,这些案例都需要用到webgl的着色器语言glsl es。\n\n * 智慧城市特效\n * 地球的飞线效果\n * 建筑的光墙流动效果\n\n\n# 为什么要学习webgl:工作要求\n\n另一方面，web3d工资高点的岗位，一般面试，可能问一些渲染管线、shader的相关知识点。\n\n\n# 学习基础\n\n 1. 数学相关(线性代数、向量点乘叉乘等等)\n 2. 图形学\n\n如果你有数学和图形学相关基础，学习原生webgl，将会非常容易。如果你没有图形学相关基础，也这没有关系。\n\n考虑大到部分前端或转行的同学，并没有图形学相关基础，咱们的课程会尽量弱化这方面的要求，只要你有基本的高中数学基础，都可以直接学习本课程。\n\n如果你数学基础不太好，也已经入门threejs，可以直接通过咱们的threejs进阶数学几何计算课程，补充相关数学知识，这样比你直接看书更直观，不那么枯燥无聊。\n\n\n# 前端编程基础\n\n学习本课程需要你有基本的前端基础，最起码掌握javascript编程语言，稍微熟悉下html、css。javascript(es6)、html、css不需要你精通，但是最起码了解基本语法。\n\n 1. html入门教程\n\n 2. css入门教程\n\n 3. javascript入门教程\n\n 4. es6入门教程",charsets:{cjk:!0}},{title:"2. 着色器GLSL ES语言",frontmatter:{title:"2. 着色器GLSL ES语言",date:"2023-10-17T17:39:43.000Z",permalink:"/pages/409d6c/"},regularPath:"/WebGL%E6%95%99%E7%A8%8B/01.1.WebGL%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02.%E7%9D%80%E8%89%B2%E5%99%A8GLSL%20ES%E8%AF%AD%E8%A8%80.html",relativePath:"WebGL教程/01.1.WebGL快速入门/02.着色器GLSL ES语言.md",key:"v-4b050e8e",path:"/pages/409d6c/",headers:[{level:3,title:"如何学习",slug:"如何学习",normalizedTitle:"如何学习",charIndex:141},{level:3,title:"GLSL ES基础数据类型",slug:"glsl-es基础数据类型",normalizedTitle:"glsl es基础数据类型",charIndex:317},{level:3,title:"声明变量",slug:"声明变量",normalizedTitle:"声明变量",charIndex:543},{level:3,title:"变量简单运算",slug:"变量简单运算",normalizedTitle:"变量简单运算",charIndex:933},{level:3,title:"声明一个常量const",slug:"声明一个常量const",normalizedTitle:"声明一个常量const",charIndex:1074},{level:3,title:"着色器语言GLSL ES声明函数",slug:"着色器语言glsl-es声明函数",normalizedTitle:"着色器语言glsl es声明函数",charIndex:1330},{level:3,title:"if语句",slug:"if语句",normalizedTitle:"if语句",charIndex:1553},{level:3,title:"for循环语句",slug:"for循环语句",normalizedTitle:"for循环语句",charIndex:1936},{level:3,title:"continue和break关键字",slug:"continue和break关键字",normalizedTitle:"continue和break关键字",charIndex:2036},{level:3,title:"向量表示颜色",slug:"向量表示颜色",normalizedTitle:"向量表示颜色",charIndex:2349},{level:3,title:"向量表示顶点位置坐标",slug:"向量表示顶点位置坐标",normalizedTitle:"向量表示顶点位置坐标",charIndex:2817},{level:3,title:"内置变量",slug:"内置变量",normalizedTitle:"内置变量",charIndex:3161},{level:3,title:"GLSL ES代码注释",slug:"glsl-es代码注释",normalizedTitle:"glsl es代码注释",charIndex:3669},{level:3,title:"GLSL ES语句结尾分号",slug:"glsl-es语句结尾分号",normalizedTitle:"glsl es语句结尾分号",charIndex:3746}],headersStr:"如何学习 GLSL ES基础数据类型 声明变量 变量简单运算 声明一个常量const 着色器语言GLSL ES声明函数 if语句 for循环语句 continue和break关键字 向量表示颜色 向量表示顶点位置坐标 内置变量 GLSL ES代码注释 GLSL ES语句结尾分号",content:"# 着色器GLSL ES语言\n\n学习原生WebGL，除了前面说的JavaScript语言之外，你还需要学习一门新的语言就是着色器语言GLSL ES。\n\n平时你接触的JavaScript、C、java等语言是在CPU上执行，对于着色器语言GLSL ES是在显卡GPU上执行。\n\n\n# 如何学习\n\n着色器语言GLSL ES语法虽然类似Typescript、C等语言，但是GLSL主要在GPU上执行，有自身的特殊性，只有结合WebGL案例学习GLSL ES语法，才能更好的理解，所以这节课只介绍GLSL ES部分语法。\n\n所以你本节课不用写任何代码，只要跟着视频过一遍即可，后面还会结合WebGL案例具体介绍GLSL ES的语法。\n\n\n# GLSL ES基础数据类型\n\n着色器语言GLSL的基本数据类型和C语言一样具有常见的整型数int、浮点数float和布尔值bool类型数据。\n\n关键字     数据类型     值\nbool    布尔值      布尔变量值为true或false\nint     整型数      值为整数，比如0,1,2,3...\nfloat   单精度浮点数   浮点数用小数点表示，比如0.6,3.14,2.8\n\n这三个关键字的用法，下面就会给大家展示怎么用于声明变量。\n\n\n# 声明变量\n\n声明变量，并赋值\n\n// 整型变量\nint count = 10;\n// 浮点数变量\nfloat num = 10.0;\n// 声明一个布尔值变量\nbool lightBool = true;\n\n\n通过上面变量声明，你也可以看出，着色器语言声明变量和TypeScript一样需要注明数据类型，但是JavaScript不用注明变量数据类型。\n\n// JavaScript语言声明变量，不用设置数据类型\nlet count = 10;\n\n\n先声明变量，后赋值或改变。\n\nfloat c;\nc = 100.0;\n\n\n改变变量的值\n\nfloat count = 10.0;\ncount = 20.0;\n\n\n注意: 注意变量的数据类型和值要对应\n\n错误赋值方式\n\nfloat num = 1;\n\n\n正确赋值方式\n\nfloat num = 1.0;\n\n\n\n# 变量简单运算\n\n// 32位浮点数相加\nfloat a = 2.0;\nfloat b = 4.0;\nfloat c = a+b;\n\n\n//整数相加\nint a = 2;\nint b = 4;\nint c = a+b;\n\n\n两个变量进行运算，需要保持一样数据类型，否则报错。\n\n\n# 声明一个常量const\n\n着色器语言和C语言、javascript语言一样可以通过关键字const声明一个常量。\n\n// 着色器语言定义一个整形常量\nconst int count = 10;\n// 定义一个浮点数常量10.0\nconst float count = 10.0;\n\n\n着色器语言和其它语言一样，声明一个变量，可以重新赋值，如果通过关键字const声明一个常量，顾名思义是常量，在代码中是不可以更改的。\n\nconst int count = 10;\n// 错误写法\ncount= 20;\n\n\n\n# 着色器语言GLSL ES声明函数\n\n函数计算后,如果需要返回的值，通过关键字return返回，不过注意声明函数时候，函数名称前需要声明return返回值的数据类型。\n\n// 两个参数是浮点数，相加后返回值自然也是浮点数\nfloat add(float x,float y){\n  return x + y\n}\n\n\n声明一个无返回值函数,函数前面用void关键字即可。\n\nvoid main(){\n  float x = 10.0;\n}\n\n\n\n# if语句\n\n着色器语言GLSL中关于if语句、for语句的使用，和javascript语言、C语言中的if语句、for语句执行逻辑规则基本一致，这里默认你已经有一定的编程基础，也就不做过多讲解，只是简单说明一下。\n\n单独使用if\n\nfloat x = 10.0\nif(x > 100.0){\n  x = 100.0;\n}\n\n\nif-else形式\n\nfloat x = 10.0\nif(x > 100.0){\n  x = 100.0;\n} else {\n  x = x + 1.0;\n}\n\n\nif-else if-else if-...else形式\n\nfloat x = 10.0\nif(x<10.0){\n\n}else if (x>=10.0 && x<20.0) {\n\n}else if (x>=20.0 && x<30.0) {\n\n}else {\n\n}\n\n\n\n# for循环语句\n\n和你平时写JavaScript的for循环语句基本相似，只是注意注明变量i的数据类型即可。\n\nfor (int i = 0; i < 20; i++) {\n  ...\n}\n\n\n\n# continue和break关键字\n\n着色器语言continue和break关键字和JavaScript语言习惯也是相似的。\n\nbreak表示终止for循环执行\n\nfor (int i = 0; i < 20; i++) {\n  ...\n  if(i==15){\n    break;//直接终止循环执行，i=16、17等后面的循环不再执行\n  }\n  ...\n}\n\n\ncontinue表示直接跳到for循环的下一个循环\n\nfor (int i = 0; i < 20; i++) {\n  ...\n  if(i==15){\n    continue;//进行下次循环，执行i=16对应的循环\n  }\n  ...\n}\n\n\n\n# 向量表示颜色\n\n在GLSL ES中，向量可以表示多种数据，也能进行多种数学运算，咱们这里先不讲解那么多，说些简单的。\n\nvec3、vec4关键字和int、float一样也是用来表示数据的类型，vec3表示三维向量、vec4表示四维向量，vec3和vec4的每个分量都是浮点数float。\n\n// 四维向量有四个分量，可以用来表示颜色的R、G、B、A\nvec4 color = vec4(1.0, 0.0, 0.0, 1.0);//红色不透明\n\n\n关键字     数据类型\nvec2    二维向量，具有xy两个分量，分量是浮点数\nvec3    三维向量 ，具有xyz三个分量，分量是浮点数\nvec4    四维向量 ，具有xyzw四个分量，分量是浮点数\nivec2   二维向量，分量是整型数\nivec3   三维向量 ，分量是整型数\nivec4   四维向量 ，分量是整型数\nbvec2   二维向量，分量是布尔值bool\nbvec3   三维向量 ，分量是布尔值bool\nbvec4   四维向量 ，分量是布尔值bool\n\n\n# 向量表示顶点位置坐标\n\n三维向量vec3表示变量pos具有三个分量，可以用来表示顶点的xyz坐标。\n\nvec3 pos = vec3(1.0, 2.0, 3.0);\n\n\n用四维向量vec4表示齐次坐标，所谓齐次坐标，就是在GLSL ES中表示一个顶点坐标的的时候，增加一个分量，1.0表示。\n\nvec4 pos = vec4(1.0, 2.0, 3.0,1.0);\n\n\n一个三维向量转化为四维向量\n\nvec3 pos = vec3(1.0, 2.0, 3.0);\nvec4 newPos = vec4(pos,1.0);\n\n\n一个二维向量转化为四维向量\n\nvec2 pos = vec2(1.0, 2.0);\nvec4 newPos = vec4(pos, 3.0,1.0);\n\n\n\n# 内置变量\n\n不管是JavaScript语言，还是着色器语言GLSL ES，你想使用一个变量，都需要先声明。\n\nfloat a = 2.0;\nfloat b = 4.0;\nfloat c = a+b;\n\n\n所谓内置变量就是着色器语言GLSL ES默认提供的变量，不需要声明，就可以使用。GLSL ES内置变量很多，下面介绍几个下节课会用到的。\n\n * gl_PointSize：点渲染像素大小，数据类型浮点数float\n\n * gl_Position：顶点坐标，数据类型四维向量vec4\n\n * gl_FragColor：像素颜色，数据类型四维向量vec4\n\n// 赋值浮点数\ngl_PointSize = 20.0;\n\n\nvec4前面三个参数表示xyz坐标，第四个参数按照GLSL ES语法习惯需要设置为1.0\n\n// 赋值四维向量，表示xyz坐标是原点\ngl_Position = vec4(0.0,0.0,0.0,1.0);\n\n\nvec4前面三个参数是颜色RGB值，第四个参数是透明度值\n\n// 赋值四维向量，表示红色不透明\ngl_FragColor = vec4(1.0,0.0,0.0,1.0);\n\n\n\n# GLSL ES代码注释\n\nGLSL ES代码注释和JavaScript语言的习惯一样。\n\n * 单行注释符号//\n\n * 快级注释符号/* */\n\n\n# GLSL ES语句结尾分号\n\n在JavaScript中，代码语句结尾的分号可以省略，但是 GLSL ES中分号不能省略。\n\nfloat a = 2.0;//正常\n\n\n分号省略，会报错\n\nfloat a = 2.0//分号省略，会报错\n",normalizedContent:"# 着色器glsl es语言\n\n学习原生webgl，除了前面说的javascript语言之外，你还需要学习一门新的语言就是着色器语言glsl es。\n\n平时你接触的javascript、c、java等语言是在cpu上执行，对于着色器语言glsl es是在显卡gpu上执行。\n\n\n# 如何学习\n\n着色器语言glsl es语法虽然类似typescript、c等语言，但是glsl主要在gpu上执行，有自身的特殊性，只有结合webgl案例学习glsl es语法，才能更好的理解，所以这节课只介绍glsl es部分语法。\n\n所以你本节课不用写任何代码，只要跟着视频过一遍即可，后面还会结合webgl案例具体介绍glsl es的语法。\n\n\n# glsl es基础数据类型\n\n着色器语言glsl的基本数据类型和c语言一样具有常见的整型数int、浮点数float和布尔值bool类型数据。\n\n关键字     数据类型     值\nbool    布尔值      布尔变量值为true或false\nint     整型数      值为整数，比如0,1,2,3...\nfloat   单精度浮点数   浮点数用小数点表示，比如0.6,3.14,2.8\n\n这三个关键字的用法，下面就会给大家展示怎么用于声明变量。\n\n\n# 声明变量\n\n声明变量，并赋值\n\n// 整型变量\nint count = 10;\n// 浮点数变量\nfloat num = 10.0;\n// 声明一个布尔值变量\nbool lightbool = true;\n\n\n通过上面变量声明，你也可以看出，着色器语言声明变量和typescript一样需要注明数据类型，但是javascript不用注明变量数据类型。\n\n// javascript语言声明变量，不用设置数据类型\nlet count = 10;\n\n\n先声明变量，后赋值或改变。\n\nfloat c;\nc = 100.0;\n\n\n改变变量的值\n\nfloat count = 10.0;\ncount = 20.0;\n\n\n注意: 注意变量的数据类型和值要对应\n\n错误赋值方式\n\nfloat num = 1;\n\n\n正确赋值方式\n\nfloat num = 1.0;\n\n\n\n# 变量简单运算\n\n// 32位浮点数相加\nfloat a = 2.0;\nfloat b = 4.0;\nfloat c = a+b;\n\n\n//整数相加\nint a = 2;\nint b = 4;\nint c = a+b;\n\n\n两个变量进行运算，需要保持一样数据类型，否则报错。\n\n\n# 声明一个常量const\n\n着色器语言和c语言、javascript语言一样可以通过关键字const声明一个常量。\n\n// 着色器语言定义一个整形常量\nconst int count = 10;\n// 定义一个浮点数常量10.0\nconst float count = 10.0;\n\n\n着色器语言和其它语言一样，声明一个变量，可以重新赋值，如果通过关键字const声明一个常量，顾名思义是常量，在代码中是不可以更改的。\n\nconst int count = 10;\n// 错误写法\ncount= 20;\n\n\n\n# 着色器语言glsl es声明函数\n\n函数计算后,如果需要返回的值，通过关键字return返回，不过注意声明函数时候，函数名称前需要声明return返回值的数据类型。\n\n// 两个参数是浮点数，相加后返回值自然也是浮点数\nfloat add(float x,float y){\n  return x + y\n}\n\n\n声明一个无返回值函数,函数前面用void关键字即可。\n\nvoid main(){\n  float x = 10.0;\n}\n\n\n\n# if语句\n\n着色器语言glsl中关于if语句、for语句的使用，和javascript语言、c语言中的if语句、for语句执行逻辑规则基本一致，这里默认你已经有一定的编程基础，也就不做过多讲解，只是简单说明一下。\n\n单独使用if\n\nfloat x = 10.0\nif(x > 100.0){\n  x = 100.0;\n}\n\n\nif-else形式\n\nfloat x = 10.0\nif(x > 100.0){\n  x = 100.0;\n} else {\n  x = x + 1.0;\n}\n\n\nif-else if-else if-...else形式\n\nfloat x = 10.0\nif(x<10.0){\n\n}else if (x>=10.0 && x<20.0) {\n\n}else if (x>=20.0 && x<30.0) {\n\n}else {\n\n}\n\n\n\n# for循环语句\n\n和你平时写javascript的for循环语句基本相似，只是注意注明变量i的数据类型即可。\n\nfor (int i = 0; i < 20; i++) {\n  ...\n}\n\n\n\n# continue和break关键字\n\n着色器语言continue和break关键字和javascript语言习惯也是相似的。\n\nbreak表示终止for循环执行\n\nfor (int i = 0; i < 20; i++) {\n  ...\n  if(i==15){\n    break;//直接终止循环执行，i=16、17等后面的循环不再执行\n  }\n  ...\n}\n\n\ncontinue表示直接跳到for循环的下一个循环\n\nfor (int i = 0; i < 20; i++) {\n  ...\n  if(i==15){\n    continue;//进行下次循环，执行i=16对应的循环\n  }\n  ...\n}\n\n\n\n# 向量表示颜色\n\n在glsl es中，向量可以表示多种数据，也能进行多种数学运算，咱们这里先不讲解那么多，说些简单的。\n\nvec3、vec4关键字和int、float一样也是用来表示数据的类型，vec3表示三维向量、vec4表示四维向量，vec3和vec4的每个分量都是浮点数float。\n\n// 四维向量有四个分量，可以用来表示颜色的r、g、b、a\nvec4 color = vec4(1.0, 0.0, 0.0, 1.0);//红色不透明\n\n\n关键字     数据类型\nvec2    二维向量，具有xy两个分量，分量是浮点数\nvec3    三维向量 ，具有xyz三个分量，分量是浮点数\nvec4    四维向量 ，具有xyzw四个分量，分量是浮点数\nivec2   二维向量，分量是整型数\nivec3   三维向量 ，分量是整型数\nivec4   四维向量 ，分量是整型数\nbvec2   二维向量，分量是布尔值bool\nbvec3   三维向量 ，分量是布尔值bool\nbvec4   四维向量 ，分量是布尔值bool\n\n\n# 向量表示顶点位置坐标\n\n三维向量vec3表示变量pos具有三个分量，可以用来表示顶点的xyz坐标。\n\nvec3 pos = vec3(1.0, 2.0, 3.0);\n\n\n用四维向量vec4表示齐次坐标，所谓齐次坐标，就是在glsl es中表示一个顶点坐标的的时候，增加一个分量，1.0表示。\n\nvec4 pos = vec4(1.0, 2.0, 3.0,1.0);\n\n\n一个三维向量转化为四维向量\n\nvec3 pos = vec3(1.0, 2.0, 3.0);\nvec4 newpos = vec4(pos,1.0);\n\n\n一个二维向量转化为四维向量\n\nvec2 pos = vec2(1.0, 2.0);\nvec4 newpos = vec4(pos, 3.0,1.0);\n\n\n\n# 内置变量\n\n不管是javascript语言，还是着色器语言glsl es，你想使用一个变量，都需要先声明。\n\nfloat a = 2.0;\nfloat b = 4.0;\nfloat c = a+b;\n\n\n所谓内置变量就是着色器语言glsl es默认提供的变量，不需要声明，就可以使用。glsl es内置变量很多，下面介绍几个下节课会用到的。\n\n * gl_pointsize：点渲染像素大小，数据类型浮点数float\n\n * gl_position：顶点坐标，数据类型四维向量vec4\n\n * gl_fragcolor：像素颜色，数据类型四维向量vec4\n\n// 赋值浮点数\ngl_pointsize = 20.0;\n\n\nvec4前面三个参数表示xyz坐标，第四个参数按照glsl es语法习惯需要设置为1.0\n\n// 赋值四维向量，表示xyz坐标是原点\ngl_position = vec4(0.0,0.0,0.0,1.0);\n\n\nvec4前面三个参数是颜色rgb值，第四个参数是透明度值\n\n// 赋值四维向量，表示红色不透明\ngl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n\n\n\n# glsl es代码注释\n\nglsl es代码注释和javascript语言的习惯一样。\n\n * 单行注释符号//\n\n * 快级注释符号/* */\n\n\n# glsl es语句结尾分号\n\n在javascript中，代码语句结尾的分号可以省略，但是 glsl es中分号不能省略。\n\nfloat a = 2.0;//正常\n\n\n分号省略，会报错\n\nfloat a = 2.0//分号省略，会报错\n",charsets:{cjk:!0}},{title:"3. 第一个WebGL案例",frontmatter:{title:"3. 第一个WebGL案例",date:"2023-10-17T17:39:57.000Z",permalink:"/pages/f66004/"},regularPath:"/WebGL%E6%95%99%E7%A8%8B/01.1.WebGL%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03.%E7%AC%AC%E4%B8%80%E4%B8%AAWebGL%E6%A1%88%E4%BE%8B.html",relativePath:"WebGL教程/01.1.WebGL快速入门/03.第一个WebGL案例.md",key:"v-d98b1d80",path:"/pages/f66004/",headers:[{level:3,title:"创建一个Canvas画布",slug:"创建一个canvas画布",normalizedTitle:"创建一个canvas画布",charIndex:88},{level:3,title:"获取webgl上下文",slug:"获取webgl上下文",normalizedTitle:"获取webgl上下文",charIndex:529},{level:3,title:"渲染管线概念",slug:"渲染管线概念",normalizedTitle:"渲染管线概念",charIndex:1030},{level:3,title:"顶点着色器",slug:"顶点着色器",normalizedTitle:"顶点着色器",charIndex:1215},{level:3,title:"片元着色器",slug:"片元着色器",normalizedTitle:"片元着色器",charIndex:1847},{level:3,title:"编译着色器，并创建程序对象",slug:"编译着色器-并创建程序对象",normalizedTitle:"编译着色器，并创建程序对象",charIndex:2117},{level:3,title:"绘制gl.drawArrays()",slug:"绘制gl-drawarrays",normalizedTitle:"绘制gl.drawarrays()",charIndex:2906},{level:3,title:"封装一个着色器初始化函数",slug:"封装一个着色器初始化函数",normalizedTitle:"封装一个着色器初始化函数",charIndex:3308},{level:3,title:"练习测试",slug:"练习测试",normalizedTitle:"练习测试",charIndex:4280}],headersStr:"创建一个Canvas画布 获取webgl上下文 渲染管线概念 顶点着色器 片元着色器 编译着色器，并创建程序对象 绘制gl.drawArrays() 封装一个着色器初始化函数 练习测试",content:'# 第一个WebGL案例\n\n本节课给大家演示一个WebGL案例，就是在web页面上绘制一个方形点，虽然超级简单，但是可以把WebGL整个的代码结构，给你完美展示出来。\n\n\n# 创建一个Canvas画布\n\n创建一个Canvas画布，用于显示WebGL的渲染结果，canvas元素和div等元素一样是HTML的一个元素，区别地方在于，Canvas画布具有2D和3D绘图功能。\n\n// 宽高度\n<canvas id="webgl" width="500" height="500" style="background: #000;"></canvas>\n\n\n创建一个html文件，在里面body中插入一个canvas元素。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>使用WebGL绘制一个点</title>\n</head>\n<body>\n    <canvas id="webgl" width="500" height="500" style="background: #000;"></canvas>\n</body>\n</html>\n\n\n\n# 获取webgl上下文\n\n<canvas id="webgl"></canvas>\n\n\n通过getElementById()方法获取canvas画布对象\n\n<script>\n    const canvas= document.getElementById(\'webgl\')\n<\/script>\n\n\n通过方法.getContext()获取WebGL上下文,然后你就可以通过返回的对象gl调用WebGL API，实现3D绘图。\n\nconst gl = canvas.getContext(\'webgl\');\n\n\n通过gl对象，可以调用各种WebGL API,通过这些WebGL API可以控制显卡GPU绘制3D图案。\n\nconst gl = canvas.getContext(\'webgl\');\ngl.drawArrays();\ngl.createShader();\ngl.shaderSource();\ngl.compileShader();\ngl.createProgram();\ngl.attachShader();\ngl.linkProgram();\ngl.useProgram();\n\n\n\n# 渲染管线概念\n\n入门WebGL，比较重要的一点就是建立渲染管线的概念。\n\n你可以把渲染管线想象为显卡GPU上的一条流水线，渲染管线上有不同的功能单元。WebGL渲染管线上的各个功能单元，可以通过刚刚介绍的通过WebGL API进行控制。\n\n\n\n整个渲染管线，是比较复杂的，本节课只要求知道渲染管线这个概念就行，更多具体细节，在下来WebGL课程中，会一一介绍。\n\n\n# 顶点着色器\n\n编写顶点着色器需要用到一门语言，就是前面提到的着色器语言GLSL ES。\n\n在js代码中，着色器GLSL代码，要使用字符串的形式表达。为了方便预览顶点着色器代码，咱们用模板字符串``的形式去写,模板字符串``的按键位于键盘Tab键的上面。\n\nconst vertexShaderSource = `\n这里面写着色器GLSL ES代码\n`\n\n\n按照着色器语言习惯，创建一个名为main的主函数，前面使用关键字void类似C语言的语法，表示没有返回值。\n\nconst vertexShaderSource = `\nvoid main(){\n    \n}\n`\n\n\ngl_PointSize和gl_Position是内置变量，所谓内置变量，就是不用声明就可以使用。\n\ngl_PointSize表示渲染点的像素大小，注意用小数(浮点数)表示。\n\ngl_Position表示顶点的位置，值是四维向量vec4,比如表示(x,y,z)坐标，书写形式是vec4(x,y,z,1.0),按照语法规定，前面三个参数表示xyz坐标，最后一个参数是1.0。\n\n//顶点着色器源码\nconst vertexShaderSource = `\nvoid main(){\n    gl_PointSize = 20.0;\n    gl_Position = vec4(0.0,0.0,0.0,1.0);\n}\n`\n\n\n顶点着色器代码就是在GPU上的顶点着色器功能单元执行。\n\n\n\n\n# 片元着色器\n\n片元着色器代码在GPU上的片元着色器功能单元执行。\n\n\n\n内置变量gl_FragColor用来设置片元(像素)颜色，以为本节课为例就是方形点的像素值。\n\ngl_FragColor的值是四维向量vec4，前面三个参数是颜色RGB值，第四个参数是透明度值，第一次学习先给一个1.0表示不透明就行。\n\n//片元着色器源码\nconst fragShaderSource = `\nvoid main(){\n    // 红色\n    gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n}    \n`\n\n\n\n# 编译着色器，并创建程序对象\n\n顶点着色器、片元着色器代码如果想在GPU上执行，需要先通过WebGL API进行编译处理，并创建一个程序对象program。\n\n学习建议：对于大部分同学学习的重点是着色器语言GLSL和渲染管线。如果你不是直接使用原生WebGL API做项目，或者封装3D引擎，你完全不需要记住这些API，只需要有个印象就行。\n\n对于下面代码，你只需要跟着课程过一遍就行，不要求记住，甚至复制粘贴一遍也无所谓。\n\n//创建顶点着色器对象\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER);\n//创建片元着色器对象\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n//引入顶点、片元着色器源代码\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.shaderSource(fragmentShader, fragmentShaderSource);\n//编译顶点、片元着色器\ngl.compileShader(vertexShader);\ngl.compileShader(fragmentShader)\n//创建程序对象program\nconst program = gl.createProgram();\n//附着顶点着色器和片元着色器到program\ngl.attachShader(program, vertexShader);\ngl.attachShader(program, fragmentShader);\n//链接program\ngl.linkProgram(program);\n//使用program\ngl.useProgram(program);\n\n\n\n# 绘制gl.drawArrays()\n\n通过程序对象program处理好上面着色器代码，你在网页上还不能看到渲染效果，还需要通过一个绘制的APIgl.drawArrays()来执行绘制。\n\ngl.drawArrays()在后面会经常用到，因为本节课例子太过简单，只能简单解释下gl.drawArrays()的参数。\n\n文档gl.drawArrays()\n\ngl.drawArrays(mode, first, count);\n\n\n参数1mode表示绘制模式，有多种模式，gl.POINTS表示绘制形式是点，后面还会介绍线和三角形。\n\n参数2first表示从第几个点开始绘制，本节课案例比较简单，只有一个点，设置0即可\n\n参数3count表示总共有多少点，本节课案例只提了一个点的坐标，所以设置为1。\n\n//开始绘制，显示器显示结果\ngl.drawArrays(gl.POINTS, 0, 1);\n\n\n\n# 封装一个着色器初始化函数\n\n初始化着色器的代码，可以封装在一个函数initShader中，因为后面每节课的案例，都会用到这段固定的代码。\n\n//初始化着色器\nconst program = initShader(gl, vertexShaderSource, fragShaderSource);\n//开始绘制，显示器显示结果\ngl.drawArrays(gl.POINTS, 0, 1);\n//声明初始化着色器函数\nfunction initShader(gl, vertexShaderSource, fragmentShaderSource) {\n    //创建顶点着色器对象\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    //创建片元着色器对象\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    //引入顶点、片元着色器源代码\n    gl.shaderSource(vertexShader, vertexShaderSource);\n    gl.shaderSource(fragmentShader, fragmentShaderSource);\n    //编译顶点、片元着色器\n    gl.compileShader(vertexShader);\n    gl.compileShader(fragmentShader);\n    //创建程序对象program\n    const program = gl.createProgram();\n    //附着顶点着色器和片元着色器到program\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    //链接program\n    gl.linkProgram(program);\n    //使用program\n    gl.useProgram(program);\n    //返回程序program对象\n    return program;\n}\n\n\n\n# 练习测试\n\n你可以通过改变WebGL着色器代码内置变量gl_PointSize、gl_Position、gl_FragColor测试WebGL渲染效果的变化。\n\ngl_PointSize=20.0改为gl_PointSize=10.0，观察canvas画布上点的大小变化\n\ngl_Position =vec4(0.0,0.0,0.0,1.0)改为gl_Position =vec4(0.5,0.0,0.0,1.0)，观察canvas画布上点的位置变化\n\ngl_FragColor=vec4(1.0,0.0,0.0,1.0)更改为gl_FragColor = vec4(0.0,0.0,1.0,1.0)，观察屏幕canvas画布上点的颜色变化',normalizedContent:'# 第一个webgl案例\n\n本节课给大家演示一个webgl案例，就是在web页面上绘制一个方形点，虽然超级简单，但是可以把webgl整个的代码结构，给你完美展示出来。\n\n\n# 创建一个canvas画布\n\n创建一个canvas画布，用于显示webgl的渲染结果，canvas元素和div等元素一样是html的一个元素，区别地方在于，canvas画布具有2d和3d绘图功能。\n\n// 宽高度\n<canvas id="webgl" width="500" height="500" style="background: #000;"></canvas>\n\n\n创建一个html文件，在里面body中插入一个canvas元素。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>使用webgl绘制一个点</title>\n</head>\n<body>\n    <canvas id="webgl" width="500" height="500" style="background: #000;"></canvas>\n</body>\n</html>\n\n\n\n# 获取webgl上下文\n\n<canvas id="webgl"></canvas>\n\n\n通过getelementbyid()方法获取canvas画布对象\n\n<script>\n    const canvas= document.getelementbyid(\'webgl\')\n<\/script>\n\n\n通过方法.getcontext()获取webgl上下文,然后你就可以通过返回的对象gl调用webgl api，实现3d绘图。\n\nconst gl = canvas.getcontext(\'webgl\');\n\n\n通过gl对象，可以调用各种webgl api,通过这些webgl api可以控制显卡gpu绘制3d图案。\n\nconst gl = canvas.getcontext(\'webgl\');\ngl.drawarrays();\ngl.createshader();\ngl.shadersource();\ngl.compileshader();\ngl.createprogram();\ngl.attachshader();\ngl.linkprogram();\ngl.useprogram();\n\n\n\n# 渲染管线概念\n\n入门webgl，比较重要的一点就是建立渲染管线的概念。\n\n你可以把渲染管线想象为显卡gpu上的一条流水线，渲染管线上有不同的功能单元。webgl渲染管线上的各个功能单元，可以通过刚刚介绍的通过webgl api进行控制。\n\n\n\n整个渲染管线，是比较复杂的，本节课只要求知道渲染管线这个概念就行，更多具体细节，在下来webgl课程中，会一一介绍。\n\n\n# 顶点着色器\n\n编写顶点着色器需要用到一门语言，就是前面提到的着色器语言glsl es。\n\n在js代码中，着色器glsl代码，要使用字符串的形式表达。为了方便预览顶点着色器代码，咱们用模板字符串``的形式去写,模板字符串``的按键位于键盘tab键的上面。\n\nconst vertexshadersource = `\n这里面写着色器glsl es代码\n`\n\n\n按照着色器语言习惯，创建一个名为main的主函数，前面使用关键字void类似c语言的语法，表示没有返回值。\n\nconst vertexshadersource = `\nvoid main(){\n    \n}\n`\n\n\ngl_pointsize和gl_position是内置变量，所谓内置变量，就是不用声明就可以使用。\n\ngl_pointsize表示渲染点的像素大小，注意用小数(浮点数)表示。\n\ngl_position表示顶点的位置，值是四维向量vec4,比如表示(x,y,z)坐标，书写形式是vec4(x,y,z,1.0),按照语法规定，前面三个参数表示xyz坐标，最后一个参数是1.0。\n\n//顶点着色器源码\nconst vertexshadersource = `\nvoid main(){\n    gl_pointsize = 20.0;\n    gl_position = vec4(0.0,0.0,0.0,1.0);\n}\n`\n\n\n顶点着色器代码就是在gpu上的顶点着色器功能单元执行。\n\n\n\n\n# 片元着色器\n\n片元着色器代码在gpu上的片元着色器功能单元执行。\n\n\n\n内置变量gl_fragcolor用来设置片元(像素)颜色，以为本节课为例就是方形点的像素值。\n\ngl_fragcolor的值是四维向量vec4，前面三个参数是颜色rgb值，第四个参数是透明度值，第一次学习先给一个1.0表示不透明就行。\n\n//片元着色器源码\nconst fragshadersource = `\nvoid main(){\n    // 红色\n    gl_fragcolor = vec4(1.0,0.0,0.0,1.0);\n}    \n`\n\n\n\n# 编译着色器，并创建程序对象\n\n顶点着色器、片元着色器代码如果想在gpu上执行，需要先通过webgl api进行编译处理，并创建一个程序对象program。\n\n学习建议：对于大部分同学学习的重点是着色器语言glsl和渲染管线。如果你不是直接使用原生webgl api做项目，或者封装3d引擎，你完全不需要记住这些api，只需要有个印象就行。\n\n对于下面代码，你只需要跟着课程过一遍就行，不要求记住，甚至复制粘贴一遍也无所谓。\n\n//创建顶点着色器对象\nconst vertexshader = gl.createshader(gl.vertex_shader);\n//创建片元着色器对象\nconst fragmentshader = gl.createshader(gl.fragment_shader);\n//引入顶点、片元着色器源代码\ngl.shadersource(vertexshader, vertexshadersource);\ngl.shadersource(fragmentshader, fragmentshadersource);\n//编译顶点、片元着色器\ngl.compileshader(vertexshader);\ngl.compileshader(fragmentshader)\n//创建程序对象program\nconst program = gl.createprogram();\n//附着顶点着色器和片元着色器到program\ngl.attachshader(program, vertexshader);\ngl.attachshader(program, fragmentshader);\n//链接program\ngl.linkprogram(program);\n//使用program\ngl.useprogram(program);\n\n\n\n# 绘制gl.drawarrays()\n\n通过程序对象program处理好上面着色器代码，你在网页上还不能看到渲染效果，还需要通过一个绘制的apigl.drawarrays()来执行绘制。\n\ngl.drawarrays()在后面会经常用到，因为本节课例子太过简单，只能简单解释下gl.drawarrays()的参数。\n\n文档gl.drawarrays()\n\ngl.drawarrays(mode, first, count);\n\n\n参数1mode表示绘制模式，有多种模式，gl.points表示绘制形式是点，后面还会介绍线和三角形。\n\n参数2first表示从第几个点开始绘制，本节课案例比较简单，只有一个点，设置0即可\n\n参数3count表示总共有多少点，本节课案例只提了一个点的坐标，所以设置为1。\n\n//开始绘制，显示器显示结果\ngl.drawarrays(gl.points, 0, 1);\n\n\n\n# 封装一个着色器初始化函数\n\n初始化着色器的代码，可以封装在一个函数initshader中，因为后面每节课的案例，都会用到这段固定的代码。\n\n//初始化着色器\nconst program = initshader(gl, vertexshadersource, fragshadersource);\n//开始绘制，显示器显示结果\ngl.drawarrays(gl.points, 0, 1);\n//声明初始化着色器函数\nfunction initshader(gl, vertexshadersource, fragmentshadersource) {\n    //创建顶点着色器对象\n    const vertexshader = gl.createshader(gl.vertex_shader);\n    //创建片元着色器对象\n    const fragmentshader = gl.createshader(gl.fragment_shader);\n    //引入顶点、片元着色器源代码\n    gl.shadersource(vertexshader, vertexshadersource);\n    gl.shadersource(fragmentshader, fragmentshadersource);\n    //编译顶点、片元着色器\n    gl.compileshader(vertexshader);\n    gl.compileshader(fragmentshader);\n    //创建程序对象program\n    const program = gl.createprogram();\n    //附着顶点着色器和片元着色器到program\n    gl.attachshader(program, vertexshader);\n    gl.attachshader(program, fragmentshader);\n    //链接program\n    gl.linkprogram(program);\n    //使用program\n    gl.useprogram(program);\n    //返回程序program对象\n    return program;\n}\n\n\n\n# 练习测试\n\n你可以通过改变webgl着色器代码内置变量gl_pointsize、gl_position、gl_fragcolor测试webgl渲染效果的变化。\n\ngl_pointsize=20.0改为gl_pointsize=10.0，观察canvas画布上点的大小变化\n\ngl_position =vec4(0.0,0.0,0.0,1.0)改为gl_position =vec4(0.5,0.0,0.0,1.0)，观察canvas画布上点的位置变化\n\ngl_fragcolor=vec4(1.0,0.0,0.0,1.0)更改为gl_fragcolor = vec4(0.0,0.0,1.0,1.0)，观察屏幕canvas画布上点的颜色变化',charsets:{cjk:!0}},{title:"1. 数学基础(平移、旋转、缩放矩阵)",frontmatter:{title:"1. 数学基础(平移、旋转、缩放矩阵)",date:"2023-10-17T18:12:14.000Z",permalink:"/pages/1dd7e1/"},regularPath:"/WebGL%E6%95%99%E7%A8%8B/02.2.3D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80(%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5).html",relativePath:"WebGL教程/02.2.3D几何变换数学基础/01.数学基础(平移、旋转、缩放矩阵).md",key:"v-483f6004",path:"/pages/1dd7e1/",headersStr:null,content:"# 数学基础(平移、旋转、缩放矩阵)\n\n矩阵介绍，参考WebGPU中讲解，矩阵内容是一样的。\n\n数学基础(平移、旋转、缩放矩阵)：http://www.webgl3d.cn/pages/38777d/",normalizedContent:"# 数学基础(平移、旋转、缩放矩阵)\n\n矩阵介绍，参考webgpu中讲解，矩阵内容是一样的。\n\n数学基础(平移、旋转、缩放矩阵)：http://www.webgl3d.cn/pages/38777d/",charsets:{cjk:!0}},{title:"2. 模型矩阵",frontmatter:{title:"2. 模型矩阵",date:"2023-10-17T18:12:14.000Z",permalink:"/pages/d6fb6c/"},regularPath:"/WebGL%E6%95%99%E7%A8%8B/02.2.3D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/02.%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5.html",relativePath:"WebGL教程/02.2.3D几何变换数学基础/02.模型矩阵.md",key:"v-735dd117",path:"/pages/d6fb6c/",headersStr:null,content:"# 模型矩阵\n\n关于模型矩阵介绍，参考WebGPU中讲解，内容是一样的。\n\n2. 模型矩阵：http://www.webgl3d.cn/pages/47d092/",normalizedContent:"# 模型矩阵\n\n关于模型矩阵介绍，参考webgpu中讲解，内容是一样的。\n\n2. 模型矩阵：http://www.webgl3d.cn/pages/47d092/",charsets:{cjk:!0}},{title:"3. gl-matrix数学计算库",frontmatter:{title:"3. gl-matrix数学计算库",date:"2023-10-17T18:13:28.000Z",permalink:"/pages/7d74bf/"},regularPath:"/WebGL%E6%95%99%E7%A8%8B/02.2.3D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/03.gl-matrix%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%BA%93.html",relativePath:"WebGL教程/02.2.3D几何变换数学基础/03.gl-matrix数学计算库.md",key:"v-d0089e5a",path:"/pages/7d74bf/",headersStr:null,content:"# gl-matrix数学计算库\n\n关于gl-matrix数学计算库介绍，参考WebGPU中视频讲解，内容是一样的。\n\ngl-matrix数学计算库)：http://www.webgl3d.cn/pages/473326/",normalizedContent:"# gl-matrix数学计算库\n\n关于gl-matrix数学计算库介绍，参考webgpu中视频讲解，内容是一样的。\n\ngl-matrix数学计算库)：http://www.webgl3d.cn/pages/473326/",charsets:{cjk:!0}},{title:"1. WebGPU学习开发环境配置",frontmatter:{title:"1. WebGPU学习开发环境配置",date:"2023-04-22T11:48:08.000Z",permalink:"/pages/9bbfa9/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/01.1.WebGPU%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/01.WebGPU%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html",relativePath:"WebGPU教程/01.1.WebGPU快速入门/01.WebGPU学习开发环境配置.md",key:"v-57c2ccdc",path:"/pages/9bbfa9/",headers:[{level:3,title:"1. 一个支持WebGPU的浏览器",slug:"_1-一个支持webgpu的浏览器",normalizedTitle:"1. 一个支持webgpu的浏览器",charIndex:140},{level:3,title:"2. index.html文件",slug:"_2-index-html文件",normalizedTitle:"2. index.html文件",charIndex:379},{level:3,title:"3. vscode编辑器",slug:"_3-vscode编辑器",normalizedTitle:"3. vscode编辑器",charIndex:674},{level:3,title:"4. 测试你的浏览器是否支持WebGPU",slug:"_4-测试你的浏览器是否支持webgpu",normalizedTitle:"4. 测试你的浏览器是否支持webgpu",charIndex:763}],headersStr:"1. 一个支持WebGPU的浏览器 2. index.html文件 3. vscode编辑器 4. 测试你的浏览器是否支持WebGPU",content:'# WebGPU学习(开发)环境配置\n\nWebGPU免费的部分视频\n\n咱们的WebGPU学习(开发)环境配置比较简单，不用vite或webpack配置一个复杂的开发环境，直接使用原生.html文件即可。入门学习WebGPU，平时测试代码，都会非常方便，大大节约学习时间。\n\n\n# 1. 一个支持WebGPU的浏览器\n\n谷歌浏览器从Chrome 113 Beta测试版开始默认支持WebGPU。如果你的谷歌浏览器低于113版本，请下载新版本浏览器才能正常学习WebGPU。下载安装后，就可以直接预览webGPU的3D案例了。\n\n随着时间的推移，将会越来越多的浏览器支持WebGPU。\n\n谷歌浏览器正式版下载\n\n谷歌浏览器Beta测试版下载\n\n你可以用上面链接下载最新版谷歌浏览器，也可以直接用课件中我下载好的ChromeSetup.exe，运行安装。\n\n\n# 2. index.html文件\n\n<script>标签设置type="module"，你就可以直接浏览器中实现ES6语法了，不用webpack或vite进行编译处理。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>http://www.webgl3d.cn/</title>\n</head>\n\n<body>\n    <script type="module">\n        // 编写WebGPU代码\n    <\/script>\n</body>\n\n</html>\n\n\n\n# 3. vscode编辑器\n\n课程选择的是vscode编辑器，平时开发调试WebGPU案例源码,是借助live-srever插件调用浏览器执行WebGPU代码，非常方便。\n\n\n# 4. 测试你的浏览器是否支持WebGPU\n\n<script type="module">\n    if(navigator.gpu){\n        console.log(\'你的浏览器支持WebGPU。\');\n    }else{\n        console.log(\'你的浏览器不支持WebGPU，请更换新版本浏览器。\');\n    }\n<\/script>\n',normalizedContent:'# webgpu学习(开发)环境配置\n\nwebgpu免费的部分视频\n\n咱们的webgpu学习(开发)环境配置比较简单，不用vite或webpack配置一个复杂的开发环境，直接使用原生.html文件即可。入门学习webgpu，平时测试代码，都会非常方便，大大节约学习时间。\n\n\n# 1. 一个支持webgpu的浏览器\n\n谷歌浏览器从chrome 113 beta测试版开始默认支持webgpu。如果你的谷歌浏览器低于113版本，请下载新版本浏览器才能正常学习webgpu。下载安装后，就可以直接预览webgpu的3d案例了。\n\n随着时间的推移，将会越来越多的浏览器支持webgpu。\n\n谷歌浏览器正式版下载\n\n谷歌浏览器beta测试版下载\n\n你可以用上面链接下载最新版谷歌浏览器，也可以直接用课件中我下载好的chromesetup.exe，运行安装。\n\n\n# 2. index.html文件\n\n<script>标签设置type="module"，你就可以直接浏览器中实现es6语法了，不用webpack或vite进行编译处理。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>http://www.webgl3d.cn/</title>\n</head>\n\n<body>\n    <script type="module">\n        // 编写webgpu代码\n    <\/script>\n</body>\n\n</html>\n\n\n\n# 3. vscode编辑器\n\n课程选择的是vscode编辑器，平时开发调试webgpu案例源码,是借助live-srever插件调用浏览器执行webgpu代码，非常方便。\n\n\n# 4. 测试你的浏览器是否支持webgpu\n\n<script type="module">\n    if(navigator.gpu){\n        console.log(\'你的浏览器支持webgpu。\');\n    }else{\n        console.log(\'你的浏览器不支持webgpu，请更换新版本浏览器。\');\n    }\n<\/script>\n',charsets:{cjk:!0}},{title:"2. WebGPU API和Canvas画布",frontmatter:{title:"2. WebGPU API和Canvas画布",date:"2023-04-22T11:49:06.000Z",permalink:"/pages/a4735b/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/01.1.WebGPU%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/02.WebGPU%20API%E5%92%8CCanvas%E7%94%BB%E5%B8%83.html",relativePath:"WebGPU教程/01.1.WebGPU快速入门/02.WebGPU API和Canvas画布.md",key:"v-3f8b08d1",path:"/pages/a4735b/",headers:[{level:3,title:"GPU概念解释",slug:"gpu概念解释",normalizedTitle:"gpu概念解释",charIndex:126},{level:3,title:"GPU设备对象",slug:"gpu设备对象",normalizedTitle:"gpu设备对象",charIndex:195},{level:3,title:"GPU设备对象device的属性和方法",slug:"gpu设备对象device的属性和方法",normalizedTitle:"gpu设备对象device的属性和方法",charIndex:650},{level:3,title:"Canvas画布",slug:"canvas画布",normalizedTitle:"canvas画布",charIndex:13},{level:3,title:"配置WebGPU上下文(Canvas元素作为WebGPU的画布)",slug:"配置webgpu上下文-canvas元素作为webgpu的画布",normalizedTitle:"配置webgpu上下文(canvas元素作为webgpu的画布)",charIndex:1453}],headersStr:"GPU概念解释 GPU设备对象 GPU设备对象device的属性和方法 Canvas画布 配置WebGPU上下文(Canvas元素作为WebGPU的画布)",content:'# WebGPU API和Canvas画布\n\nWebGPU提供很多相关的API，通过这些WebGPU API可以控制你的显卡GPU渲染3D场景或计算数据。\n\nWebGPU API文档：https://www.w3.org/TR/webgpu/\n\n\n# GPU概念解释\n\n所谓GPU就是图形处理器，再具体点说，就是你电脑上的显卡，如果为了追求更好的性能，一般会在电脑上安装独立显卡。\n\n\n# GPU设备对象\n\n创建GPU设备对象device非常简单，执行navigator.gpu.requestAdapter()和adapter.requestDevice()两步操作即可完成。\n\n.requestAdapter()和.requestDevice()都是异步函数，函数前需要加上es6语法的关键字await。\n\n// 浏览器请求GPU适配器\nconst adapter = await navigator.gpu.requestAdapter();\n// 获取GPU设备对象，通过GPU设备对象device的WebGPU API可以控制GPU渲染过程\nconst device = await adapter.requestDevice();\n\n\n浏览器控制台测试查看，适配器对象adapter和GPU设备对象device对象的一些属性和方法\n\nconsole.log(\'适配器adapter\',adapter);\nconsole.log(\'GPU设备对象device\',device);\n\n\n\n# GPU设备对象device的属性和方法\n\n\n\n借助GPU设备对象device提供的很多属性和方法，这些属性和方法都是WebGPU API的一部分。后面课程会给大家逐步讲解，如何通过GPU设备对象device提供的这些WebGPU API渲染3D场景。\n\ndevice.createRenderPipeline()//创建渲染管线\ndevice.createComputePipeline()//创建计算管线\ndevice.createShaderModule()//创建着色器模块\ndevice.createCommandEncoder()//创建命令对象(绘制和计算命令)\ndevice.createBuffer()//创建缓冲区对象\n...\n\n\n初次接触，可能你还不理解这些WebGPU API，那也没关系，后面会详细讲解，现在你可以随意调用两个API写代码，提前熟悉下。\n\n// 创建渲染管线\nconst pipeline = device.createRenderPipeline();\n// 创建GPU命令对象\nconst commandEncoder = device.createCommandEncoder();\n\n\n这也是为什么我们要执行device = await adapter.requestDevice()创建GPU设备对象device，只有通过创建GPU设备对象，我们才可以获得这些API。\n\n\n# Canvas画布\n\nCanvas画布是一个比较特殊的HTML元素，主要用来实现图形绘制的功能，可以进行2D绘图，可以用来实现WebGL，也可以把WebGPU渲染的图像输出到Canvas画布。\n\n\x3c!-- canvas：用来展示WebGPU渲染的结果 --\x3e\n<canvas id="webgpu" width="500" height="500"></canvas>\n\n\n\n# 配置WebGPU上下文(Canvas元素作为WebGPU的画布)\n\n获取id名为webgpu的Canvas画布元素。\n\nconst canvas = document.getElementById(\'webgpu\');\n\n\nCanvas画布对象有一个获取上下文的方法.getContext(),参数可以是2d、webgl、webgpu，不同参数用于不同的功能，咱们这里是用于WebGPU渲染，所以参数设置为webgpu。\n\nconst context = canvas.getContext(\'webgpu\');\n\n\n通过方法context.configure()配置从Canvas画布获取的WebGPU上下文对象context。\n\n用人话说就是关联Canvas画布和GPU设备对象device,这样就能把Canvas元素作为WebGPU的画布,用来呈现3D渲染效果。\n\ncontext.configure({\n    device: device,//WebGPU渲染器使用的GPU设备对象\n});\n\n\nformat属性和颜色格式有关，如果没有特别需要，可以设置为navigator.gpu.getPreferredCanvasFormat()即可，初学可以不用深究。\n\nconst format = navigator.gpu.getPreferredCanvasFormat();//获取浏览器默认的颜色格式\ncontext.configure({\n    device: device,\n    format: format,//颜色格式\n});\n\n\n配置WebGPU上下文代码。\n\n<body>\n    \x3c!-- canvas：用来展示WebGPU渲染的结果 --\x3e\n    <canvas id="webgpu" width="500" height="500"></canvas>\n    <script type="module">\n        // 1. 初始化WebGPU\n        const adapter = await navigator.gpu.requestAdapter();\n        // 获取GPU设备对象，通过GPU设备对象device的WebGPU API可以控制GPU渲染过程\n        const device = await adapter.requestDevice();\n\n        //配置WebGPU上下文，把id名为webgpu的Canvas元素作为WebGPU的画布\n        const canvas = document.getElementById(\'webgpu\');\n        const context = canvas.getContext(\'webgpu\');\n        const format = navigator.gpu.getPreferredCanvasFormat();//获取浏览器默认的\n        context.configure({\n            device: device,//WebGPU渲染器使用的GPU设备对象\n            format: format,//WebGPU渲染器使用的颜色格式\n        });\n    <\/script>\n</body>\n',normalizedContent:'# webgpu api和canvas画布\n\nwebgpu提供很多相关的api，通过这些webgpu api可以控制你的显卡gpu渲染3d场景或计算数据。\n\nwebgpu api文档：https://www.w3.org/tr/webgpu/\n\n\n# gpu概念解释\n\n所谓gpu就是图形处理器，再具体点说，就是你电脑上的显卡，如果为了追求更好的性能，一般会在电脑上安装独立显卡。\n\n\n# gpu设备对象\n\n创建gpu设备对象device非常简单，执行navigator.gpu.requestadapter()和adapter.requestdevice()两步操作即可完成。\n\n.requestadapter()和.requestdevice()都是异步函数，函数前需要加上es6语法的关键字await。\n\n// 浏览器请求gpu适配器\nconst adapter = await navigator.gpu.requestadapter();\n// 获取gpu设备对象，通过gpu设备对象device的webgpu api可以控制gpu渲染过程\nconst device = await adapter.requestdevice();\n\n\n浏览器控制台测试查看，适配器对象adapter和gpu设备对象device对象的一些属性和方法\n\nconsole.log(\'适配器adapter\',adapter);\nconsole.log(\'gpu设备对象device\',device);\n\n\n\n# gpu设备对象device的属性和方法\n\n\n\n借助gpu设备对象device提供的很多属性和方法，这些属性和方法都是webgpu api的一部分。后面课程会给大家逐步讲解，如何通过gpu设备对象device提供的这些webgpu api渲染3d场景。\n\ndevice.createrenderpipeline()//创建渲染管线\ndevice.createcomputepipeline()//创建计算管线\ndevice.createshadermodule()//创建着色器模块\ndevice.createcommandencoder()//创建命令对象(绘制和计算命令)\ndevice.createbuffer()//创建缓冲区对象\n...\n\n\n初次接触，可能你还不理解这些webgpu api，那也没关系，后面会详细讲解，现在你可以随意调用两个api写代码，提前熟悉下。\n\n// 创建渲染管线\nconst pipeline = device.createrenderpipeline();\n// 创建gpu命令对象\nconst commandencoder = device.createcommandencoder();\n\n\n这也是为什么我们要执行device = await adapter.requestdevice()创建gpu设备对象device，只有通过创建gpu设备对象，我们才可以获得这些api。\n\n\n# canvas画布\n\ncanvas画布是一个比较特殊的html元素，主要用来实现图形绘制的功能，可以进行2d绘图，可以用来实现webgl，也可以把webgpu渲染的图像输出到canvas画布。\n\n\x3c!-- canvas：用来展示webgpu渲染的结果 --\x3e\n<canvas id="webgpu" width="500" height="500"></canvas>\n\n\n\n# 配置webgpu上下文(canvas元素作为webgpu的画布)\n\n获取id名为webgpu的canvas画布元素。\n\nconst canvas = document.getelementbyid(\'webgpu\');\n\n\ncanvas画布对象有一个获取上下文的方法.getcontext(),参数可以是2d、webgl、webgpu，不同参数用于不同的功能，咱们这里是用于webgpu渲染，所以参数设置为webgpu。\n\nconst context = canvas.getcontext(\'webgpu\');\n\n\n通过方法context.configure()配置从canvas画布获取的webgpu上下文对象context。\n\n用人话说就是关联canvas画布和gpu设备对象device,这样就能把canvas元素作为webgpu的画布,用来呈现3d渲染效果。\n\ncontext.configure({\n    device: device,//webgpu渲染器使用的gpu设备对象\n});\n\n\nformat属性和颜色格式有关，如果没有特别需要，可以设置为navigator.gpu.getpreferredcanvasformat()即可，初学可以不用深究。\n\nconst format = navigator.gpu.getpreferredcanvasformat();//获取浏览器默认的颜色格式\ncontext.configure({\n    device: device,\n    format: format,//颜色格式\n});\n\n\n配置webgpu上下文代码。\n\n<body>\n    \x3c!-- canvas：用来展示webgpu渲染的结果 --\x3e\n    <canvas id="webgpu" width="500" height="500"></canvas>\n    <script type="module">\n        // 1. 初始化webgpu\n        const adapter = await navigator.gpu.requestadapter();\n        // 获取gpu设备对象，通过gpu设备对象device的webgpu api可以控制gpu渲染过程\n        const device = await adapter.requestdevice();\n\n        //配置webgpu上下文，把id名为webgpu的canvas元素作为webgpu的画布\n        const canvas = document.getelementbyid(\'webgpu\');\n        const context = canvas.getcontext(\'webgpu\');\n        const format = navigator.gpu.getpreferredcanvasformat();//获取浏览器默认的\n        context.configure({\n            device: device,//webgpu渲染器使用的gpu设备对象\n            format: format,//webgpu渲染器使用的颜色格式\n        });\n    <\/script>\n</body>\n',charsets:{cjk:!0}},{title:"4. 着色器语言WGSL快速了解",frontmatter:{title:"4. 着色器语言WGSL快速了解",date:"2023-04-22T11:50:11.000Z",permalink:"/pages/d5968c/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/01.1.WebGPU%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/04.%E7%9D%80%E8%89%B2%E5%99%A8%E8%AF%AD%E8%A8%80WGSL%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3.html",relativePath:"WebGPU教程/01.1.WebGPU快速入门/04.着色器语言WGSL快速了解.md",key:"v-e9796ed4",path:"/pages/d5968c/",headers:[{level:3,title:"文档资料",slug:"文档资料",normalizedTitle:"文档资料",charIndex:196},{level:3,title:"学习基础与难度",slug:"学习基础与难度",normalizedTitle:"学习基础与难度",charIndex:307},{level:3,title:"WGSL学习方法",slug:"wgsl学习方法",normalizedTitle:"wgsl学习方法",charIndex:456},{level:3,title:"WGSL基础类型",slug:"wgsl基础类型",normalizedTitle:"wgsl基础类型",charIndex:610},{level:3,title:"var关键字声明变量",slug:"var关键字声明变量",normalizedTitle:"var关键字声明变量",charIndex:720},{level:3,title:"变量简单运算",slug:"变量简单运算",normalizedTitle:"变量简单运算",charIndex:1038},{level:3,title:"声明函数的关键字fn",slug:"声明函数的关键字fn",normalizedTitle:"声明函数的关键字fn",charIndex:1201},{level:3,title:"if、for等语句",slug:"if、for等语句",normalizedTitle:"if、for等语句",charIndex:1621},{level:3,title:"向量表示颜色",slug:"向量表示颜色",normalizedTitle:"向量表示颜色",charIndex:1879},{level:3,title:"向量表示位置",slug:"向量表示位置",normalizedTitle:"向量表示位置",charIndex:2177},{level:3,title:"结构体",slug:"结构体",normalizedTitle:"结构体",charIndex:2667},{level:3,title:"WGSL代码注释",slug:"wgsl代码注释",normalizedTitle:"wgsl代码注释",charIndex:2927},{level:3,title:"WGSL语句结尾分号",slug:"wgsl语句结尾分号",normalizedTitle:"wgsl语句结尾分号",charIndex:2998}],headersStr:"文档资料 学习基础与难度 WGSL学习方法 WGSL基础类型 var关键字声明变量 变量简单运算 声明函数的关键字fn if、for等语句 向量表示颜色 向量表示位置 结构体 WGSL代码注释 WGSL语句结尾分号",content:"# 着色器语言WGSL快速了解\n\nWGSL语言是专门给WebGPU定制的着色器语言，就像WebGL OpenGL中使用的GLSL着色器语言。\n\n如果你有GLSL着色器语言基础，那么学习WGSL还是比较容易的。\n\n如果你从未学过其他着色器语言，第一次接触WGSL着色器语言，要想真正理解WGSL，还需要和后面WebGPU具体案例结合讲解，如果只是把语法给你念一遍，过于抽象，很难理解。\n\n\n# 文档资料\n\nWGSL英文文档：https://www.w3.org/TR/WGSL/\n\nWebGPU引擎Orillusion团队翻译：https://www.orillusion.com/zh/wgsl.html\n\n\n# 学习基础与难度\n\n如果你有其他着色器语言基础，比如GLSL，那么你学习WGSL将会非常简单。\n\n如果没有学过着色器代码，但是有其它静态类型语言的基础，比如Typescript、C等，理解WGSL基础语言也会相对容易。\n\n如果上面两个基础都没有，只是熟悉JavaScript，相对难度高些。\n\n\n# WGSL学习方法\n\nWGSL虽然类似Typescript、C等语言，但是WGSL主要在GPU上执行，有自身的特殊性，结合WebGPU案例学习WGSL语法，才能更好的理解。\n\n所以本节课不做过多的WGSL语法讲解，随意举几个案例，初步了解一些WGSL最基础的语法，你也不用写代码，跟着视频过一遍即可。\n\n\n# WGSL基础类型\n\n下面简单列举了部分WGSL的数据类型\n\n符号     数据类型\nbool   布尔\nu32    无符号整数\ni32    有符号整数\nf32    32位浮点数\nf16    16位浮点数\n\n\n# var关键字声明变量\n\nWGSL中可以用var关键字声明变量。\n\n// var关键字声明一个变量a，数据类型是无符号整数\nvar a:u32;\na = 2;\n\n\n// var关键字声明一个变量a，数据类型是32位浮点数\nvar a:f32;\na = 2.0;\n\n\n声明的时候直接赋值\n\n// var关键字声明一个32位浮点数\nvar a:f32 = 2.0;\n\n\n有时候你看别人的WGSL代码，声明变量如果赋值了，可能会省略数据类型标注，这时候WGSL会根据变量的值自动推荐变量的数据类型\n\nvar a = 2.0;//推断为f32\n\n\nvar a = 2;//推断为i32\n\n\nvar a = false;//推断为布尔值\n\n\n\n# 变量简单运算\n\n两个变量进行运算，需要保持一样数据类型，否则报错。\n\n// 32位浮点数相加\nvar a:f32 = 2.0;\nvar b:f32 = 4.0;\nvar c:f32 = a+b;\n\n\n// 无符号整数相加\nvar a:u32 = 2;\nvar b:u32 = 4;\nvar c:u32 = a+b;\n\n\n\n# 声明函数的关键字fn\n\n// 这还能混合写，牛逼了\nfn 函数名( 参数1:数据类型, 参数2:数据类型...){\n    // 代码\n}\n\n\nfn add( x: f32, y:f32){\n    var z: f32 =  x + y;\n}\n\n\n如果函数有返回值设置符号->,后面注明返回值的数据类型\n\n// 这还能混合写，牛逼了\nfn 函数名( 参数1, 参数2...) -> 返回值数据类型 {\n    return 返回值;\n}\n\n\nfn add( x: f32, y:f32) -> f32 {\n    return x + y;\n}\n// 类比JavaScript语言函数\nfunction add(x , y){\n    return x + y;\n}\n// 类比TypeScript语言函数\nfunction add(x: number, y: number): number {\n  return x+y\n}\n\n\n\n# if、for等语句\n\n在WGSL中，if、for等语句，和JavaScript逻辑上基本差不多，区别就是注意数据类型即可。\n\nWGSLfor循环语句，基本逻辑\n\nvar n:u32 = 10;\nvar s:f32 = 0.0;\nfor (var i:u32= 0; i < n; i++) {\n    s += 0.05;         \n}\n\n\nvar s:bool;\nvar a:f32 = 2.0;\nif(a>1.0){\n    s = true;\n}else{\n    s = false;\n}\n\n\n\n# 向量表示颜色\n\n在WGSL中，向量可以表示多种数据，也能进行多种数学运算，咱们这里先不讲解那么多，说些简单的。\n\n// 四维向量有四个分量，可以用来表示颜色的R、G、B、A\nvar color:vec4<f32> = vec4<f32>(1.0, 0.0, 0.0, 1.0);//红色不透明\n\n\n// 省略:vec4<f32>数据类型\nvar color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n\n\n// 先声明一个四维向量变量，再赋值\nvar color:vec4<f32>;\ncolor = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n\n\n\n# 向量表示位置\n\n三维向量vec3<f32>表示具有三个分量，可以用来表示顶点的xyz坐标。\n\nvar pos:vec3<f32>;\npos= vec3<f32>(1.0, 2.0, 3.0);\n\n\n四维向量表示齐次坐标，在WGSL中，表示一个坐标的的时候，如果用四维向量表示，最后一个分量是1.0。改坐标表示xyz的齐次坐标。\n\nvar pos:vec4<f32>;\npos= vec4<f32>(1.0, 2.0, 3.0,1.0);\n\n\n一个三维向量转化为四维向量\n\nvar pos:vec3<f32>;\npos = vec3<f32>(1.0, 2.0, 3.0);\n//等价于vec4<f32>(1.0, 2.0, 3.0,1.0)\nvar pos2 = vec4<f32>(pos,1.0);\n\n\n一个二维向量转化为四维向量\n\nvar pos:vec2<f32>;\npos = vec2<f32>(1.0, 2.0);\n//等价于vec4<f32>(1.0, 2.0, 3.0,1.0)\nvar pos2 = vec4<f32>(pos, 3.0,1.0);\n\n\n\n# 结构体\n\nWGSL结构体有点类似JavaScript里面的类\n\n// 定义一个结构体表示点光源\nstruct pointLight {\n    color: vec3<f32>,//光源颜色\n    intensity: f32//光源强度\n};\n\n\n通过结构体生成一个光源，类似JavaScript中类执行new实例化一个对象。\n\nvar light1:pointLight;\nlight1.color = vec3<f32>(1.0, 0.0, 0.0);\nlight1.intensity = 0.6;\n\n\n\n# WGSL代码注释\n\nWGSL代码注释和JavaScript语言的习惯一样。\n\n * 单行注释符号//\n\n * 快级注释符号/* */\n\n\n# WGSL语句结尾分号\n\n在JavaScript中，代码语句结尾的分号可以省略，但是WGSL中分号不能省略。\n\nvar a:f32 = 2.0;\nvar a:f32 = 4.0//分号省略，会报错\n",normalizedContent:"# 着色器语言wgsl快速了解\n\nwgsl语言是专门给webgpu定制的着色器语言，就像webgl opengl中使用的glsl着色器语言。\n\n如果你有glsl着色器语言基础，那么学习wgsl还是比较容易的。\n\n如果你从未学过其他着色器语言，第一次接触wgsl着色器语言，要想真正理解wgsl，还需要和后面webgpu具体案例结合讲解，如果只是把语法给你念一遍，过于抽象，很难理解。\n\n\n# 文档资料\n\nwgsl英文文档：https://www.w3.org/tr/wgsl/\n\nwebgpu引擎orillusion团队翻译：https://www.orillusion.com/zh/wgsl.html\n\n\n# 学习基础与难度\n\n如果你有其他着色器语言基础，比如glsl，那么你学习wgsl将会非常简单。\n\n如果没有学过着色器代码，但是有其它静态类型语言的基础，比如typescript、c等，理解wgsl基础语言也会相对容易。\n\n如果上面两个基础都没有，只是熟悉javascript，相对难度高些。\n\n\n# wgsl学习方法\n\nwgsl虽然类似typescript、c等语言，但是wgsl主要在gpu上执行，有自身的特殊性，结合webgpu案例学习wgsl语法，才能更好的理解。\n\n所以本节课不做过多的wgsl语法讲解，随意举几个案例，初步了解一些wgsl最基础的语法，你也不用写代码，跟着视频过一遍即可。\n\n\n# wgsl基础类型\n\n下面简单列举了部分wgsl的数据类型\n\n符号     数据类型\nbool   布尔\nu32    无符号整数\ni32    有符号整数\nf32    32位浮点数\nf16    16位浮点数\n\n\n# var关键字声明变量\n\nwgsl中可以用var关键字声明变量。\n\n// var关键字声明一个变量a，数据类型是无符号整数\nvar a:u32;\na = 2;\n\n\n// var关键字声明一个变量a，数据类型是32位浮点数\nvar a:f32;\na = 2.0;\n\n\n声明的时候直接赋值\n\n// var关键字声明一个32位浮点数\nvar a:f32 = 2.0;\n\n\n有时候你看别人的wgsl代码，声明变量如果赋值了，可能会省略数据类型标注，这时候wgsl会根据变量的值自动推荐变量的数据类型\n\nvar a = 2.0;//推断为f32\n\n\nvar a = 2;//推断为i32\n\n\nvar a = false;//推断为布尔值\n\n\n\n# 变量简单运算\n\n两个变量进行运算，需要保持一样数据类型，否则报错。\n\n// 32位浮点数相加\nvar a:f32 = 2.0;\nvar b:f32 = 4.0;\nvar c:f32 = a+b;\n\n\n// 无符号整数相加\nvar a:u32 = 2;\nvar b:u32 = 4;\nvar c:u32 = a+b;\n\n\n\n# 声明函数的关键字fn\n\n// 这还能混合写，牛逼了\nfn 函数名( 参数1:数据类型, 参数2:数据类型...){\n    // 代码\n}\n\n\nfn add( x: f32, y:f32){\n    var z: f32 =  x + y;\n}\n\n\n如果函数有返回值设置符号->,后面注明返回值的数据类型\n\n// 这还能混合写，牛逼了\nfn 函数名( 参数1, 参数2...) -> 返回值数据类型 {\n    return 返回值;\n}\n\n\nfn add( x: f32, y:f32) -> f32 {\n    return x + y;\n}\n// 类比javascript语言函数\nfunction add(x , y){\n    return x + y;\n}\n// 类比typescript语言函数\nfunction add(x: number, y: number): number {\n  return x+y\n}\n\n\n\n# if、for等语句\n\n在wgsl中，if、for等语句，和javascript逻辑上基本差不多，区别就是注意数据类型即可。\n\nwgslfor循环语句，基本逻辑\n\nvar n:u32 = 10;\nvar s:f32 = 0.0;\nfor (var i:u32= 0; i < n; i++) {\n    s += 0.05;         \n}\n\n\nvar s:bool;\nvar a:f32 = 2.0;\nif(a>1.0){\n    s = true;\n}else{\n    s = false;\n}\n\n\n\n# 向量表示颜色\n\n在wgsl中，向量可以表示多种数据，也能进行多种数学运算，咱们这里先不讲解那么多，说些简单的。\n\n// 四维向量有四个分量，可以用来表示颜色的r、g、b、a\nvar color:vec4<f32> = vec4<f32>(1.0, 0.0, 0.0, 1.0);//红色不透明\n\n\n// 省略:vec4<f32>数据类型\nvar color = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n\n\n// 先声明一个四维向量变量，再赋值\nvar color:vec4<f32>;\ncolor = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n\n\n\n# 向量表示位置\n\n三维向量vec3<f32>表示具有三个分量，可以用来表示顶点的xyz坐标。\n\nvar pos:vec3<f32>;\npos= vec3<f32>(1.0, 2.0, 3.0);\n\n\n四维向量表示齐次坐标，在wgsl中，表示一个坐标的的时候，如果用四维向量表示，最后一个分量是1.0。改坐标表示xyz的齐次坐标。\n\nvar pos:vec4<f32>;\npos= vec4<f32>(1.0, 2.0, 3.0,1.0);\n\n\n一个三维向量转化为四维向量\n\nvar pos:vec3<f32>;\npos = vec3<f32>(1.0, 2.0, 3.0);\n//等价于vec4<f32>(1.0, 2.0, 3.0,1.0)\nvar pos2 = vec4<f32>(pos,1.0);\n\n\n一个二维向量转化为四维向量\n\nvar pos:vec2<f32>;\npos = vec2<f32>(1.0, 2.0);\n//等价于vec4<f32>(1.0, 2.0, 3.0,1.0)\nvar pos2 = vec4<f32>(pos, 3.0,1.0);\n\n\n\n# 结构体\n\nwgsl结构体有点类似javascript里面的类\n\n// 定义一个结构体表示点光源\nstruct pointlight {\n    color: vec3<f32>,//光源颜色\n    intensity: f32//光源强度\n};\n\n\n通过结构体生成一个光源，类似javascript中类执行new实例化一个对象。\n\nvar light1:pointlight;\nlight1.color = vec3<f32>(1.0, 0.0, 0.0);\nlight1.intensity = 0.6;\n\n\n\n# wgsl代码注释\n\nwgsl代码注释和javascript语言的习惯一样。\n\n * 单行注释符号//\n\n * 快级注释符号/* */\n\n\n# wgsl语句结尾分号\n\n在javascript中，代码语句结尾的分号可以省略，但是wgsl中分号不能省略。\n\nvar a:f32 = 2.0;\nvar a:f32 = 4.0//分号省略，会报错\n",charsets:{cjk:!0}},{title:"3. 创建顶点缓冲区、渲染管线",frontmatter:{title:"3. 创建顶点缓冲区、渲染管线",date:"2023-04-22T11:49:48.000Z",permalink:"/pages/359922/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/01.1.WebGPU%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/03.%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%81%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF.html",relativePath:"WebGPU教程/01.1.WebGPU快速入门/03.创建顶点缓冲区、渲染管线.md",key:"v-5febe29d",path:"/pages/359922/",headers:[{level:3,title:"WebGPU坐标系",slug:"webgpu坐标系",normalizedTitle:"webgpu坐标系",charIndex:87},{level:3,title:"JavaScript类型化数组",slug:"javascript类型化数组",normalizedTitle:"javascript类型化数组",charIndex:376},{level:3,title:"类型化数组Float32Array表示顶点坐标",slug:"类型化数组float32array表示顶点坐标",normalizedTitle:"类型化数组float32array表示顶点坐标",charIndex:601},{level:3,title:"创建顶点缓冲区.createBuffer()",slug:"创建顶点缓冲区-createbuffer",normalizedTitle:"创建顶点缓冲区.createbuffer()",charIndex:968},{level:3,title:"缓冲区存储字节长度设置size",slug:"缓冲区存储字节长度设置size",normalizedTitle:"缓冲区存储字节长度设置size",charIndex:1236},{level:3,title:"缓冲区用途定义usage",slug:"缓冲区用途定义usage",normalizedTitle:"缓冲区用途定义usage",charIndex:1482},{level:3,title:"顶点数据写入顶点缓冲区",slug:"顶点数据写入顶点缓冲区",normalizedTitle:"顶点数据写入顶点缓冲区",charIndex:2040},{level:3,title:".createRenderPipeline()创建渲染管线",slug:"createrenderpipeline-创建渲染管线",normalizedTitle:".createrenderpipeline()创建渲染管线",charIndex:2432},{level:3,title:".createRenderPipeline()参数",slug:"createrenderpipeline-参数",normalizedTitle:".createrenderpipeline()参数",charIndex:2844},{level:3,title:"vertex.buffers配置顶点缓冲区",slug:"vertex-buffers配置顶点缓冲区",normalizedTitle:"vertex.buffers配置顶点缓冲区",charIndex:3401}],headersStr:"WebGPU坐标系 JavaScript类型化数组 类型化数组Float32Array表示顶点坐标 创建顶点缓冲区.createBuffer() 缓冲区存储字节长度设置size 缓冲区用途定义usage 顶点数据写入顶点缓冲区 .createRenderPipeline()创建渲染管线 .createRenderPipeline()参数 vertex.buffers配置顶点缓冲区",content:'# 创建顶点缓冲区、渲染管线\n\n如果你想渲染一个物体，需要先通过顶点坐标来定义该物体的几何形状，本节课就给大家讲解，怎么通过WebGPU的顶点缓冲区来创建顶点数据。\n\n\n# WebGPU坐标系\n\nWebGPU坐标系在Canvas画布上的坐标原点是Canvas画布的中间位置，x轴水平向右，y轴竖直向上，z轴垂直与Canvas画布，朝向屏幕内。\n\n\n\n前端开发时候，HTML元素的宽高很多时候是选择以像素为基准定义，比如宽度500px。WebGPU中顶点坐标的表示值采用的是相对值,比如x和y的坐标范围都是[-1,1]，z坐标的范围是[0,1]。\n\n在咱们入门的第一个案例中，先不深入谈WebGPU坐标系，你能先用x、y两个分量绘制一个2D平面图就行，后面涉及到3D效果的时候，再详细展开讲解z坐标、投影矩阵、视图矩阵、模型矩阵等深入概念。\n\n\n\n\n# JavaScript类型化数组\n\n类型化数组文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays\n\nJavaScript类型化数组不同于普通的数组，类型化数组，就是数组的元素可以设置数字的类型，比如浮点数、无符号整数....\n\n实际开发顶点数据往往都比多，在WebGL、WebGPU、threejs等代码中，会用类型化数组类型化数组表示定义顶点数据。\n\n\n# 类型化数组Float32Array表示顶点坐标\n\n一般来说通过WebGPU绘制一个几何图形的时候，比如一个三角形、一个矩形、一个立方体...需要使用顶点先表示几何体的形状。\n\n刚入门，先定义一个简单的几何图形，比如我使用三个顶点的xyz坐标表示一个三角形。实际开发的时候，你可以根据需要，创建任意个顶点坐标数据，来表达一个复杂的几何图案。\n\n类型化数组Float32Array参数数组里面的元素三个为一组表示顶点的xyz坐标。\n\nconst vertexArray = new Float32Array([\n    // 三角形三个顶点坐标的x、y、z值\n    0.0, 0.0, 0.0,//顶点1坐标\n    1.0, 0.0, 0.0,//顶点2坐标\n    0.0, 1.0, 0.0,//顶点3坐标\n]);\n\n\n\n\n\n# 创建顶点缓冲区.createBuffer()\n\n通过GPU设备对象的.createBuffer()方法可以创建一个顶点缓冲区。\n\n关于顶点缓冲区，给大家简单解释下。大家都知道数据，会占用电脑的内存，对于顶点数据而言，同样需要占用电脑内存空间，你可以这么理解，当device.createBuffer()执行的时候，会在你的电脑显卡GPU的内存(显存)中开辟一片存储空间，用来存存储顶点数据，你可以把这个开辟的存储空间，称为顶点缓冲区。\n\nconst vertexBuffer = device.createBuffer();\n\n\n\n# 缓冲区存储字节长度设置size\n\n设置存储空间的size属性，表示存储空间的大小size。\n\nconst vertexBuffer = device.createBuffer({\n    size: vertexArray.byteLength,//数据字节长度\n});\n\n\n//类型化数组Float32Array一个数字元素，占用存储空间4字节，9个浮点数，数据字节长度9*4\nconsole.log(\'类型化数组数据字节长度\',vertexArray.byteLength);\n\n\n\n# 缓冲区用途定义usage\n\nusage的属性值其他属性值参考文档:https://www.w3.org/TR/webgpu/#typedefdef-gpubufferusageflags\n\n入门案例顶点缓冲区可以像下面一样设置，usage以后还会遇到其他的写法，遇到在专门讲解。\n\n设置usage属性的值为GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,|是JavaScript位运算符。\n\nGPUBufferUsage.VERTEX表示用于该缓冲区是顶点缓冲区，就是存储顶点数据的缓冲区。\n\nGPUBufferUsage.COPY_DST的COPY是复制英文单词，DST是目的地单词destination的缩写，简单说该缓冲区可以写入顶点数据，作为复制顶点数据的目的地。\n\nconst vertexBuffer = device.createBuffer({\n    size: vertexArray.byteLength,//顶点数据的字节长度\n    //usage设置该缓冲区的用途(作为顶点缓冲区|可以写入顶点数据)\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n});\n\n\n\n# 顶点数据写入顶点缓冲区\n\nGPU设备对象device队列属性.queue的有一个方法.writeBuffer()，功能是吧类型化数组中的数据写入.createBuffer()创建的顶点缓冲区中。\n\n.writeBuffer(vertexBuffer, 0, vertexArray)表示把vertexArray里面的顶点数据写入到vertexBuffer对应的GPU显存缓冲区中，参数2表示从vertexArray获取顶点数据的偏移量(单位字节)，0表示从vertexArray的数据开头读取数据。\n\n//把vertexArray里面的顶点数据写入到vertexBuffer对应的GPU显存缓冲区中\n//参数2的0表示从vertexArray的数据开头读取数据。\ndevice.queue.writeBuffer(vertexBuffer, 0, vertexArray)\n\n\n\n# .createRenderPipeline()创建渲染管线\n\n通过GPU设备对象的方法.createRenderPipeline()可以创建一个WebGPU渲染管线。\n\n// 创建一个WebGPU渲染管线对象pipeline\nconst pipeline = device.createRenderPipeline();\n\n\n渲染管线你可以类比生活中的工厂流水线来理解，流水线上不同的功能单元，完成不同的零部件生产，对WebGPU渲染管线类似，WebGPU渲染管线上也提供用于3D渲染的不同功能单元，后面会一一讲解。\n\n你可以把显卡比作一个工厂，工厂里面，你可以开设流水线，同样的道理，你也可以在显卡GPU上开设创建渲染管线，借助GPU设备对象的方法.createRenderPipeline()即可创建WebGPU的渲染管线，你可以根据需要创建多个渲染管线，当然咱们课程入门部分，只需要创建一个用来学习即可。\n\n\n\n\n# .createRenderPipeline()参数\n\n渲染管线方法.createRenderPipeline()的参数是一个对象，对象具有layout、vertex、fragment、primitive等属性，这些属性对应了渲染管线上的不同功能单元。这些属性你现在还不理解，也没有关系，后面会给打逐步讲解。\n\nconst pipeline = device.createRenderPipeline({\n    layout: \'auto\',\n    vertex: {\n        // 顶点着色器\n        module: device.createShaderModule({ code: vertex }),\n        entryPoint: "main"\n    },\n    fragment: {\n        // 片元着色器\n        module: device.createShaderModule({ code: fragment }),\n        entryPoint: "main",\n    },\n    primitive: {\n        topology: "triangle-list",//三角形绘制顶点数据\n    }\n});\n\n\n\n# vertex.buffers配置顶点缓冲区\n\n顶点缓冲区负责渲染管线提供顶点数据，所以所以需要通过渲染管线参数的vertex.buffers属性配置，渲染管线如何获取顶点缓冲区中的顶点数据。\n\nconst pipeline = device.createRenderPipeline({\n    vertex: {//顶点相关配置\n        buffers: [// 顶点所有的缓冲区模块设置\n            {//其中一个顶点缓冲区设置\n                arrayStride: 3*4,//一个顶点数据占用的字节长度，该缓冲区一个顶点包含xyz三个分量，每个数字是4字节浮点数，3*4字节长度\n                attributes: [{// 顶点缓冲区属性\n                    shaderLocation: 0,//GPU显存上顶点缓冲区标记存储位置\n                    format: "float32x3",//格式：loat32x3表示一个顶点数据包含3个32位浮点数\n                    offset: 0//arrayStride表示每组顶点数据间隔字节数，offset表示读取改组的偏差字节数，没特殊需要一般设置0\n                }]\n            }\n        ]\n    },\n});\n',normalizedContent:'# 创建顶点缓冲区、渲染管线\n\n如果你想渲染一个物体，需要先通过顶点坐标来定义该物体的几何形状，本节课就给大家讲解，怎么通过webgpu的顶点缓冲区来创建顶点数据。\n\n\n# webgpu坐标系\n\nwebgpu坐标系在canvas画布上的坐标原点是canvas画布的中间位置，x轴水平向右，y轴竖直向上，z轴垂直与canvas画布，朝向屏幕内。\n\n\n\n前端开发时候，html元素的宽高很多时候是选择以像素为基准定义，比如宽度500px。webgpu中顶点坐标的表示值采用的是相对值,比如x和y的坐标范围都是[-1,1]，z坐标的范围是[0,1]。\n\n在咱们入门的第一个案例中，先不深入谈webgpu坐标系，你能先用x、y两个分量绘制一个2d平面图就行，后面涉及到3d效果的时候，再详细展开讲解z坐标、投影矩阵、视图矩阵、模型矩阵等深入概念。\n\n\n\n\n# javascript类型化数组\n\n类型化数组文档：https://developer.mozilla.org/zh-cn/docs/web/javascript/typed_arrays\n\njavascript类型化数组不同于普通的数组，类型化数组，就是数组的元素可以设置数字的类型，比如浮点数、无符号整数....\n\n实际开发顶点数据往往都比多，在webgl、webgpu、threejs等代码中，会用类型化数组类型化数组表示定义顶点数据。\n\n\n# 类型化数组float32array表示顶点坐标\n\n一般来说通过webgpu绘制一个几何图形的时候，比如一个三角形、一个矩形、一个立方体...需要使用顶点先表示几何体的形状。\n\n刚入门，先定义一个简单的几何图形，比如我使用三个顶点的xyz坐标表示一个三角形。实际开发的时候，你可以根据需要，创建任意个顶点坐标数据，来表达一个复杂的几何图案。\n\n类型化数组float32array参数数组里面的元素三个为一组表示顶点的xyz坐标。\n\nconst vertexarray = new float32array([\n    // 三角形三个顶点坐标的x、y、z值\n    0.0, 0.0, 0.0,//顶点1坐标\n    1.0, 0.0, 0.0,//顶点2坐标\n    0.0, 1.0, 0.0,//顶点3坐标\n]);\n\n\n\n\n\n# 创建顶点缓冲区.createbuffer()\n\n通过gpu设备对象的.createbuffer()方法可以创建一个顶点缓冲区。\n\n关于顶点缓冲区，给大家简单解释下。大家都知道数据，会占用电脑的内存，对于顶点数据而言，同样需要占用电脑内存空间，你可以这么理解，当device.createbuffer()执行的时候，会在你的电脑显卡gpu的内存(显存)中开辟一片存储空间，用来存存储顶点数据，你可以把这个开辟的存储空间，称为顶点缓冲区。\n\nconst vertexbuffer = device.createbuffer();\n\n\n\n# 缓冲区存储字节长度设置size\n\n设置存储空间的size属性，表示存储空间的大小size。\n\nconst vertexbuffer = device.createbuffer({\n    size: vertexarray.bytelength,//数据字节长度\n});\n\n\n//类型化数组float32array一个数字元素，占用存储空间4字节，9个浮点数，数据字节长度9*4\nconsole.log(\'类型化数组数据字节长度\',vertexarray.bytelength);\n\n\n\n# 缓冲区用途定义usage\n\nusage的属性值其他属性值参考文档:https://www.w3.org/tr/webgpu/#typedefdef-gpubufferusageflags\n\n入门案例顶点缓冲区可以像下面一样设置，usage以后还会遇到其他的写法，遇到在专门讲解。\n\n设置usage属性的值为gpubufferusage.vertex | gpubufferusage.copy_dst,|是javascript位运算符。\n\ngpubufferusage.vertex表示用于该缓冲区是顶点缓冲区，就是存储顶点数据的缓冲区。\n\ngpubufferusage.copy_dst的copy是复制英文单词，dst是目的地单词destination的缩写，简单说该缓冲区可以写入顶点数据，作为复制顶点数据的目的地。\n\nconst vertexbuffer = device.createbuffer({\n    size: vertexarray.bytelength,//顶点数据的字节长度\n    //usage设置该缓冲区的用途(作为顶点缓冲区|可以写入顶点数据)\n    usage: gpubufferusage.vertex | gpubufferusage.copy_dst,\n});\n\n\n\n# 顶点数据写入顶点缓冲区\n\ngpu设备对象device队列属性.queue的有一个方法.writebuffer()，功能是吧类型化数组中的数据写入.createbuffer()创建的顶点缓冲区中。\n\n.writebuffer(vertexbuffer, 0, vertexarray)表示把vertexarray里面的顶点数据写入到vertexbuffer对应的gpu显存缓冲区中，参数2表示从vertexarray获取顶点数据的偏移量(单位字节)，0表示从vertexarray的数据开头读取数据。\n\n//把vertexarray里面的顶点数据写入到vertexbuffer对应的gpu显存缓冲区中\n//参数2的0表示从vertexarray的数据开头读取数据。\ndevice.queue.writebuffer(vertexbuffer, 0, vertexarray)\n\n\n\n# .createrenderpipeline()创建渲染管线\n\n通过gpu设备对象的方法.createrenderpipeline()可以创建一个webgpu渲染管线。\n\n// 创建一个webgpu渲染管线对象pipeline\nconst pipeline = device.createrenderpipeline();\n\n\n渲染管线你可以类比生活中的工厂流水线来理解，流水线上不同的功能单元，完成不同的零部件生产，对webgpu渲染管线类似，webgpu渲染管线上也提供用于3d渲染的不同功能单元，后面会一一讲解。\n\n你可以把显卡比作一个工厂，工厂里面，你可以开设流水线，同样的道理，你也可以在显卡gpu上开设创建渲染管线，借助gpu设备对象的方法.createrenderpipeline()即可创建webgpu的渲染管线，你可以根据需要创建多个渲染管线，当然咱们课程入门部分，只需要创建一个用来学习即可。\n\n\n\n\n# .createrenderpipeline()参数\n\n渲染管线方法.createrenderpipeline()的参数是一个对象，对象具有layout、vertex、fragment、primitive等属性，这些属性对应了渲染管线上的不同功能单元。这些属性你现在还不理解，也没有关系，后面会给打逐步讲解。\n\nconst pipeline = device.createrenderpipeline({\n    layout: \'auto\',\n    vertex: {\n        // 顶点着色器\n        module: device.createshadermodule({ code: vertex }),\n        entrypoint: "main"\n    },\n    fragment: {\n        // 片元着色器\n        module: device.createshadermodule({ code: fragment }),\n        entrypoint: "main",\n    },\n    primitive: {\n        topology: "triangle-list",//三角形绘制顶点数据\n    }\n});\n\n\n\n# vertex.buffers配置顶点缓冲区\n\n顶点缓冲区负责渲染管线提供顶点数据，所以所以需要通过渲染管线参数的vertex.buffers属性配置，渲染管线如何获取顶点缓冲区中的顶点数据。\n\nconst pipeline = device.createrenderpipeline({\n    vertex: {//顶点相关配置\n        buffers: [// 顶点所有的缓冲区模块设置\n            {//其中一个顶点缓冲区设置\n                arraystride: 3*4,//一个顶点数据占用的字节长度，该缓冲区一个顶点包含xyz三个分量，每个数字是4字节浮点数，3*4字节长度\n                attributes: [{// 顶点缓冲区属性\n                    shaderlocation: 0,//gpu显存上顶点缓冲区标记存储位置\n                    format: "float32x3",//格式：loat32x3表示一个顶点数据包含3个32位浮点数\n                    offset: 0//arraystride表示每组顶点数据间隔字节数，offset表示读取改组的偏差字节数，没特殊需要一般设置0\n                }]\n            }\n        ]\n    },\n});\n',charsets:{cjk:!0}},{title:"5. 顶点着色器",frontmatter:{title:"5. 顶点着色器",date:"2023-04-22T11:50:29.000Z",permalink:"/pages/55f573/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/01.1.WebGPU%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/05.%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8.html",relativePath:"WebGPU教程/01.1.WebGPU快速入门/05.顶点着色器.md",key:"v-5c2b4d06",path:"/pages/55f573/",headers:[{level:3,title:"顶点着色器代码",slug:"顶点着色器代码",normalizedTitle:"顶点着色器代码",charIndex:127},{level:3,title:"WGSL着色器代码形式",slug:"wgsl着色器代码形式",normalizedTitle:"wgsl着色器代码形式",charIndex:440},{level:3,title:"反引号里面写顶点着色器代码",slug:"反引号里面写顶点着色器代码",normalizedTitle:"反引号里面写顶点着色器代码",charIndex:912},{level:3,title:"@vertex",slug:"vertex",normalizedTitle:"@vertex",charIndex:261},{level:3,title:"fn关键字声明一个函数",slug:"fn关键字声明一个函数",normalizedTitle:"fn关键字声明一个函数",charIndex:1194},{level:3,title:"vscode插件 可视化WGSL语法",slug:"vscode插件-可视化wgsl语法",normalizedTitle:"vscode插件 可视化wgsl语法",charIndex:1310},{level:3,title:"location关键字",slug:"location关键字",normalizedTitle:"location关键字",charIndex:1574},{level:3,title:"顶点变量的数据类型",slug:"顶点变量的数据类型",normalizedTitle:"顶点变量的数据类型",charIndex:1858},{level:3,title:"vec3顶点坐标转vec4齐次坐标",slug:"vec3顶点坐标转vec4齐次坐标",normalizedTitle:"vec3顶点坐标转vec4齐次坐标",charIndex:2200},{level:3,title:"顶点计算后，return返回顶点数据",slug:"顶点计算后-return返回顶点数据",normalizedTitle:"顶点计算后，return返回顶点数据",charIndex:2431},{level:3,title:"函数返回值数据类型",slug:"函数返回值数据类型",normalizedTitle:"函数返回值数据类型",charIndex:2975},{level:3,title:"内置变量position和@builtin关键字",slug:"内置变量position和-builtin关键字",normalizedTitle:"内置变量position和@builtin关键字",charIndex:3181},{level:3,title:"本节课完成的一个最简单顶点着色器代码",slug:"本节课完成的一个最简单顶点着色器代码",normalizedTitle:"本节课完成的一个最简单顶点着色器代码",charIndex:3644},{level:3,title:"7小节代码体验测试",slug:"_7小节代码体验测试",normalizedTitle:"7小节代码体验测试",charIndex:3864},{level:3,title:"着色器代码块方法.createShaderModule()",slug:"着色器代码块方法-createshadermodule",normalizedTitle:"着色器代码块方法.createshadermodule()",charIndex:3945},{level:3,title:"渲染管线参数vertex.module属性",slug:"渲染管线参数vertex-module属性",normalizedTitle:"渲染管线参数vertex.module属性",charIndex:4356},{level:3,title:"entryPoint属性",slug:"entrypoint属性",normalizedTitle:"entrypoint属性",charIndex:4727}],headersStr:"顶点着色器代码 WGSL着色器代码形式 反引号里面写顶点着色器代码 @vertex fn关键字声明一个函数 vscode插件 可视化WGSL语法 location关键字 顶点变量的数据类型 vec3顶点坐标转vec4齐次坐标 顶点计算后，return返回顶点数据 函数返回值数据类型 内置变量position和@builtin关键字 本节课完成的一个最简单顶点着色器代码 7小节代码体验测试 着色器代码块方法.createShaderModule() 渲染管线参数vertex.module属性 entryPoint属性",content:"# 顶点着色器\n\n你把渲染管线想象为工厂的一条流水线，顶点着色器想象为流水线上一个的工位。\n\n\n\nGPU渲染管线上提供的顶点着色器单元的功能就是计算顶点，所谓计算顶点，简单点说，就是对顶点坐标x、y、z的值进行平移、旋转、缩放等等各种操作。\n\n\n\n\n# 顶点着色器代码\n\nGPU渲染管线上的顶点着色器功能单元，可以执行WGSL着色器语言编写的代码。\n\n所有顶点数据经过顶点着色器这个工位时候，都会执行顶点着色器代码中顶点计算的函数，比如平移顶点坐标，比如放大顶点坐标，具体怎么改变顶点数据，看你怎么写的顶点着色器代码。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    var pos2 = vec4<f32>(pos,1.0);//pos转齐次坐标\n    pos2.x -= 0.2;//偏移所有顶点的x坐标\n    return pos2;\n}\n\n\n\n# WGSL着色器代码形式\n\n在JavaScript或Typescript写的WebGPU代码时候，按照语法要求，WGSL着色器的代码，要以字符串的形式存在。\n\n如果你直接在单引号或双引号表示的字符串里面写WGSL代码，实现字符串的多行书写，需要用+号码连接，不是很方便的。\n\nconst str = '@vetex'\n    + 'fn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {'\n    + '    return vec4<f32>(pos,1.0);'\n    + '}'\n\n\n使用ES6的语法模板字符串``(反引号)，实现字符串的多行书写很方便。\n\n// 顶点着色器代码\nconst vertex = `\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n`\n\n\n\n# 反引号里面写顶点着色器代码\n\nTab键上面的一个按键输入反引号,实现JavaScript模板字符串``语法\n\nconst vertex = `以字符串形式写WGSL代码`\n\n\n\n# @vertex\n\n@vertex表示字符串vertex里面的代码是顶点着色器代码，在GPU渲染管线的顶点着色器单元上执行。\n\nconst vertex = `\n@vertex\n`\n\n\n为了方便单独管理WGSL着色器代码，你可以创建一个shader.js文件，在里面写着色器代码。\n\nconst vertex = `\n@vertex\n`\nexport { vertex }\n\n\n\n# fn关键字声明一个函数\n\nfn关键字声明一个函数，命名为main，作为顶点着色器代码的入口函数。fn关键字类似JavaScript语言的function关键字，用来声明一个函数\n\n@vertex\nfn main(){\n}\n\n\n\n# vscode插件 可视化WGSL语法\n\n搜索关键词WGSL，安装插件WGSL和WGSL Literal。\n\n着色器代码之前设置/* wgsl */，可以使用不同颜色来显示WGSL不能的部分，更方便预览学习。\n\n// 顶点着色器代码\nconst vertex = /* wgsl */`\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n`\n\n\n\n\n\n# location关键字\n\nlocation是WGSL语言的一个关键字，通用用来指定顶点缓冲区相关的顶点数据，使用location的时候需要加上@符号前缀，@location()小括号里面设置参数。\n\nmain函数的参数@location(0)表示你GPU显存中标记为0的顶点缓冲区中顶点数据。\n\n@vertex\nfn main(@location(0)){\n}\n\n\n执行@location(0) pos给main函数参数@location(0)表示的顶点数据设置一个变量名pos。\n\n@vertex\nfn main(@location(0) pos){\n}\n\n\n\n# 顶点变量的数据类型\n\n可以用三维向量vec3的三个分量表示顶点的x、y、z坐标。\n\n执行@location(0) pos: vec3<f32>给main函数参数pos设置数据类型，vec3表示pos变量的数据类型是三维向量vec3，<f32>表示三维向量x、y、z四个属性的值都是32位浮点数。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n}\n\n\n注意@location(0)对应WebGPU传过来的顶点是三个为一组，所以顶点着色器代码中pos变量的数据类型，用三维向量表示，如果WebGPU中传过来的顶点数据，两个为一组，比如只有x和y坐标，没有z坐标，书写形式就是@location(0) pos: vec2<f32>。\n\n\n# vec3顶点坐标转vec4齐次坐标\n\n在WGSL顶点着色器代码中，很多时候会用四维向量vec4表示顶点的位置坐标，vec4第四个分量默认值一般是1.0，vec4相比vec3多了一个分量，你可以把vec4形式的坐标称为齐次坐标，是WGSL内部一个常用语法形式格式。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n    var pos2 = vec4<f32>(pos,1.0);//pos转齐次坐标\n}\n\n\n\n# 顶点计算后，return返回顶点数据\n\n实际开发，一般会在main函数中，进行顶点计算，具体说就是，对顶点的坐标进行几何变换，比如平移、缩放、旋转等操作。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n    var pos2 = vec4<f32>(pos,1.0);\n    pos2.x -= 0.2;//偏移所有顶点的x坐标\n}\n\n\n渲染管线是一条流水线，顶点着色器处理好的顶点数据，最后需要通过关键字return返回，这样渲染管线的下个环节，就可以使用了。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n    var pos2 = vec4<f32>(pos,1.0);\n    pos2.x -= 0.2;\n    return pos2;//返回顶点数据，渲染管线下个环节使用\n}\n\n\n如果你不需要在GPU顶点着色器中对顶点坐标进行变换，可以直接return返回即可\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n    return vec4<f32>(pos,1.0);//返回顶点数据，渲染管线下个环节使用\n}\n\n\n\n# 函数返回值数据类型\n\nmain函数return返回的变量，需要通过->符号设置函数返回值的数类类型,-> vec4<f32>表示函数返回的变量是浮点数构成的四维向量vec4。\n\n@vertex\nfn main(@location(0) pos: vec43<f32>) -> vec4<f32>{\n    return vec4<f32>(pos,1.0);//返回顶点数据，渲染管线下个环节使用\n}\n\n\n\n# 内置变量position和@builtin关键字\n\nposition是WGSL语言的一个内置变量，所谓内置变量，就是说WGSL默认提供的变量，你不通过关键字var声明就可以使用。WGSL有很多内置变量，不同的内置变量有不同的含义，内置变量position表示顶点数据。\n\nbuiltin是WGSL语言的一个关键字，使用location的时候需要加上@符号前缀，@location()小括号里面设置参数，参数一般是WGSL的某个内置变量，换句话就是当你使用内置变量的时候，一般需要通过@location()标记。\n\nmain函数的返回是顶点数据，这时候除了设置返回值数据类型，还需要设置@builtin(position),表明返回值是顶点位置数据。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32>{\n    return vec4<f32>(pos,1.0);//返回顶点数据，渲染管线下个环节使用\n}\n\n\n\n\n\n# 本节课完成的一个最简单顶点着色器代码\n\n后面课程讲解，会经常在此代码基础上增删代码，第一次学习，没有记住顶点着色器全部代码也没关系，初学者会在本代码基础增删代码即可。\n\nconst vertex = `\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32>{\n    return vec4<f32>(pos,1.0);\n}\n`\n\n\n\n# 7小节代码体验测试\n\n通过上面学习，你对顶点着色器代码的功能也有了一定了解，你可以在7小节完整代码基础上，改变顶点位置坐标，体验测试，这样印象更加深刻。\n\n\n# 着色器代码块方法.createShaderModule()\n\nshader.js文件中顶点着色器代码。\n\n// 顶点着色器代码\nconst vertex = `\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n`\nexport { vertex }\n\n\n通过GPU设备对象的.createShaderModule()方法，把顶点着色器代码转化为GPU着色器代码块对象。\n\n// 引入顶点着色器vertex代码对应字符串\nimport { vertex } from './shader.js'\n// 字符串形式的顶点着色器代码作为code属性的值\ndevice.createShaderModule({ code: vertex })\n\n\n\n# 渲染管线参数vertex.module属性\n\n把顶点着色器代码块对象device.createShaderModule({ code: vertex })作为渲染管线参数vertex.module属性的值，这样就可以配置好渲染管线上顶点着色器功能单元，要执行的顶点着色器代码。\n\nimport { vertex } from './shader.js'\nconst pipeline = device.createRenderPipeline({\n    vertex: {\n        // 设置渲染管线要执行的顶点着色器代码\n        module: device.createShaderModule({ code: vertex }),\n        entryPoint: \"main\"\n    },\n});\n\n\n\n# entryPoint属性\n\n实际开发中，一般需要通过entryPoint属性指定顶点着色器代码的入口函数，入口函数名字你可以自定义,课程中习惯性设置为main。\n\nconst pipeline = device.createRenderPipeline({\n    vertex: {\n        module: device.createShaderModule({ code: vertex }),\n        entryPoint: \"main\"//指定入口函数\n    },\n});\n\n\nconst vertex =  /* wgsl */`\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n`\n",normalizedContent:"# 顶点着色器\n\n你把渲染管线想象为工厂的一条流水线，顶点着色器想象为流水线上一个的工位。\n\n\n\ngpu渲染管线上提供的顶点着色器单元的功能就是计算顶点，所谓计算顶点，简单点说，就是对顶点坐标x、y、z的值进行平移、旋转、缩放等等各种操作。\n\n\n\n\n# 顶点着色器代码\n\ngpu渲染管线上的顶点着色器功能单元，可以执行wgsl着色器语言编写的代码。\n\n所有顶点数据经过顶点着色器这个工位时候，都会执行顶点着色器代码中顶点计算的函数，比如平移顶点坐标，比如放大顶点坐标，具体怎么改变顶点数据，看你怎么写的顶点着色器代码。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    var pos2 = vec4<f32>(pos,1.0);//pos转齐次坐标\n    pos2.x -= 0.2;//偏移所有顶点的x坐标\n    return pos2;\n}\n\n\n\n# wgsl着色器代码形式\n\n在javascript或typescript写的webgpu代码时候，按照语法要求，wgsl着色器的代码，要以字符串的形式存在。\n\n如果你直接在单引号或双引号表示的字符串里面写wgsl代码，实现字符串的多行书写，需要用+号码连接，不是很方便的。\n\nconst str = '@vetex'\n    + 'fn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {'\n    + '    return vec4<f32>(pos,1.0);'\n    + '}'\n\n\n使用es6的语法模板字符串``(反引号)，实现字符串的多行书写很方便。\n\n// 顶点着色器代码\nconst vertex = `\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n`\n\n\n\n# 反引号里面写顶点着色器代码\n\ntab键上面的一个按键输入反引号,实现javascript模板字符串``语法\n\nconst vertex = `以字符串形式写wgsl代码`\n\n\n\n# @vertex\n\n@vertex表示字符串vertex里面的代码是顶点着色器代码，在gpu渲染管线的顶点着色器单元上执行。\n\nconst vertex = `\n@vertex\n`\n\n\n为了方便单独管理wgsl着色器代码，你可以创建一个shader.js文件，在里面写着色器代码。\n\nconst vertex = `\n@vertex\n`\nexport { vertex }\n\n\n\n# fn关键字声明一个函数\n\nfn关键字声明一个函数，命名为main，作为顶点着色器代码的入口函数。fn关键字类似javascript语言的function关键字，用来声明一个函数\n\n@vertex\nfn main(){\n}\n\n\n\n# vscode插件 可视化wgsl语法\n\n搜索关键词wgsl，安装插件wgsl和wgsl literal。\n\n着色器代码之前设置/* wgsl */，可以使用不同颜色来显示wgsl不能的部分，更方便预览学习。\n\n// 顶点着色器代码\nconst vertex = /* wgsl */`\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n`\n\n\n\n\n\n# location关键字\n\nlocation是wgsl语言的一个关键字，通用用来指定顶点缓冲区相关的顶点数据，使用location的时候需要加上@符号前缀，@location()小括号里面设置参数。\n\nmain函数的参数@location(0)表示你gpu显存中标记为0的顶点缓冲区中顶点数据。\n\n@vertex\nfn main(@location(0)){\n}\n\n\n执行@location(0) pos给main函数参数@location(0)表示的顶点数据设置一个变量名pos。\n\n@vertex\nfn main(@location(0) pos){\n}\n\n\n\n# 顶点变量的数据类型\n\n可以用三维向量vec3的三个分量表示顶点的x、y、z坐标。\n\n执行@location(0) pos: vec3<f32>给main函数参数pos设置数据类型，vec3表示pos变量的数据类型是三维向量vec3，<f32>表示三维向量x、y、z四个属性的值都是32位浮点数。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n}\n\n\n注意@location(0)对应webgpu传过来的顶点是三个为一组，所以顶点着色器代码中pos变量的数据类型，用三维向量表示，如果webgpu中传过来的顶点数据，两个为一组，比如只有x和y坐标，没有z坐标，书写形式就是@location(0) pos: vec2<f32>。\n\n\n# vec3顶点坐标转vec4齐次坐标\n\n在wgsl顶点着色器代码中，很多时候会用四维向量vec4表示顶点的位置坐标，vec4第四个分量默认值一般是1.0，vec4相比vec3多了一个分量，你可以把vec4形式的坐标称为齐次坐标，是wgsl内部一个常用语法形式格式。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n    var pos2 = vec4<f32>(pos,1.0);//pos转齐次坐标\n}\n\n\n\n# 顶点计算后，return返回顶点数据\n\n实际开发，一般会在main函数中，进行顶点计算，具体说就是，对顶点的坐标进行几何变换，比如平移、缩放、旋转等操作。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n    var pos2 = vec4<f32>(pos,1.0);\n    pos2.x -= 0.2;//偏移所有顶点的x坐标\n}\n\n\n渲染管线是一条流水线，顶点着色器处理好的顶点数据，最后需要通过关键字return返回，这样渲染管线的下个环节，就可以使用了。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n    var pos2 = vec4<f32>(pos,1.0);\n    pos2.x -= 0.2;\n    return pos2;//返回顶点数据，渲染管线下个环节使用\n}\n\n\n如果你不需要在gpu顶点着色器中对顶点坐标进行变换，可以直接return返回即可\n\n@vertex\nfn main(@location(0) pos: vec3<f32>){\n    return vec4<f32>(pos,1.0);//返回顶点数据，渲染管线下个环节使用\n}\n\n\n\n# 函数返回值数据类型\n\nmain函数return返回的变量，需要通过->符号设置函数返回值的数类类型,-> vec4<f32>表示函数返回的变量是浮点数构成的四维向量vec4。\n\n@vertex\nfn main(@location(0) pos: vec43<f32>) -> vec4<f32>{\n    return vec4<f32>(pos,1.0);//返回顶点数据，渲染管线下个环节使用\n}\n\n\n\n# 内置变量position和@builtin关键字\n\nposition是wgsl语言的一个内置变量，所谓内置变量，就是说wgsl默认提供的变量，你不通过关键字var声明就可以使用。wgsl有很多内置变量，不同的内置变量有不同的含义，内置变量position表示顶点数据。\n\nbuiltin是wgsl语言的一个关键字，使用location的时候需要加上@符号前缀，@location()小括号里面设置参数，参数一般是wgsl的某个内置变量，换句话就是当你使用内置变量的时候，一般需要通过@location()标记。\n\nmain函数的返回是顶点数据，这时候除了设置返回值数据类型，还需要设置@builtin(position),表明返回值是顶点位置数据。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32>{\n    return vec4<f32>(pos,1.0);//返回顶点数据，渲染管线下个环节使用\n}\n\n\n\n\n\n# 本节课完成的一个最简单顶点着色器代码\n\n后面课程讲解，会经常在此代码基础上增删代码，第一次学习，没有记住顶点着色器全部代码也没关系，初学者会在本代码基础增删代码即可。\n\nconst vertex = `\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32>{\n    return vec4<f32>(pos,1.0);\n}\n`\n\n\n\n# 7小节代码体验测试\n\n通过上面学习，你对顶点着色器代码的功能也有了一定了解，你可以在7小节完整代码基础上，改变顶点位置坐标，体验测试，这样印象更加深刻。\n\n\n# 着色器代码块方法.createshadermodule()\n\nshader.js文件中顶点着色器代码。\n\n// 顶点着色器代码\nconst vertex = `\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n`\nexport { vertex }\n\n\n通过gpu设备对象的.createshadermodule()方法，把顶点着色器代码转化为gpu着色器代码块对象。\n\n// 引入顶点着色器vertex代码对应字符串\nimport { vertex } from './shader.js'\n// 字符串形式的顶点着色器代码作为code属性的值\ndevice.createshadermodule({ code: vertex })\n\n\n\n# 渲染管线参数vertex.module属性\n\n把顶点着色器代码块对象device.createshadermodule({ code: vertex })作为渲染管线参数vertex.module属性的值，这样就可以配置好渲染管线上顶点着色器功能单元，要执行的顶点着色器代码。\n\nimport { vertex } from './shader.js'\nconst pipeline = device.createrenderpipeline({\n    vertex: {\n        // 设置渲染管线要执行的顶点着色器代码\n        module: device.createshadermodule({ code: vertex }),\n        entrypoint: \"main\"\n    },\n});\n\n\n\n# entrypoint属性\n\n实际开发中，一般需要通过entrypoint属性指定顶点着色器代码的入口函数，入口函数名字你可以自定义,课程中习惯性设置为main。\n\nconst pipeline = device.createrenderpipeline({\n    vertex: {\n        module: device.createshadermodule({ code: vertex }),\n        entrypoint: \"main\"//指定入口函数\n    },\n});\n\n\nconst vertex =  /* wgsl */`\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n`\n",charsets:{cjk:!0}},{title:"6. 片元着色器、图元装配",frontmatter:{title:"6. 片元着色器、图元装配",date:"2023-04-22T11:50:47.000Z",permalink:"/pages/7be6ce/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/01.1.WebGPU%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/06.%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E3%80%81%E5%9B%BE%E5%85%83%E8%A3%85%E9%85%8D.html",relativePath:"WebGPU教程/01.1.WebGPU快速入门/06.片元着色器、图元装配.md",key:"v-2f525902",path:"/pages/7be6ce/",headers:[{level:3,title:"primitive.topology(图元装配)",slug:"primitive-topology-图元装配",normalizedTitle:"primitive.topology(图元装配)",charIndex:90},{level:3,title:"WebGPU光栅化、片元着色器",slug:"webgpu光栅化、片元着色器",normalizedTitle:"webgpu光栅化、片元着色器",charIndex:705},{level:3,title:"片元着色器WGSL操作片元(像素)",slug:"片元着色器wgsl操作片元-像素",normalizedTitle:"片元着色器wgsl操作片元(像素)",charIndex:899},{level:3,title:"@fragment",slug:"fragment",normalizedTitle:"@fragment",charIndex:1013},{level:3,title:"fn关键字声明一个函数",slug:"fn关键字声明一个函数",normalizedTitle:"fn关键字声明一个函数",charIndex:1407},{level:3,title:"处理片元像素值",slug:"处理片元像素值",normalizedTitle:"处理片元像素值",charIndex:1485},{level:3,title:"片元着色器函数返回值设置@location(0) vec4<f32>",slug:"片元着色器函数返回值设置-location-0-vec4-f32",normalizedTitle:"片元着色器函数返回值设置@location(0) vec4<f32>",charIndex:1741},{level:3,title:"渲染管线参数fragment.module属性",slug:"渲染管线参数fragment-module属性",normalizedTitle:"渲染管线参数fragment.module属性",charIndex:2223},{level:3,title:"entryPoint属性",slug:"entrypoint属性",normalizedTitle:"entrypoint属性",charIndex:2602},{level:3,title:"fragment.targets的元素的format属性",slug:"fragment-targets的元素的format属性",normalizedTitle:"fragment.targets的元素的format属性",charIndex:2975},{level:3,title:"layout属性",slug:"layout属性",normalizedTitle:"layout属性",charIndex:3399}],headersStr:"primitive.topology(图元装配) WebGPU光栅化、片元着色器 片元着色器WGSL操作片元(像素) @fragment fn关键字声明一个函数 处理片元像素值 片元着色器函数返回值设置@location(0) vec4<f32> 渲染管线参数fragment.module属性 entryPoint属性 fragment.targets的元素的format属性 layout属性",content:'# 片元着色器、图元装配\n\n上节课给大家讲解了WebGPU渲染管线上的顶点着色器功能单元，下面给大家讲解WebGPU渲染管线其他功能单元(图元装配、光栅化、片元着色器)。\n\n\n# primitive.topology(图元装配)\n\n经过顶点着色器处理过的顶点数据，会进入图元装配环节，简单说就是如何通过顶点数据生成几何图形，比如三个点绘制一个三角形，两点可以绘制一条线段...\n\n\n\n通过渲染管线参数的primitive.topology属性可以设置WebGPU如何绘制顶点数据，下面随便列举即可。\n\ntriangle-list表示三个点为一组绘制一个三角形。\n\nconst pipeline = device.createRenderPipeline({\n    primitive: {\n        topology: "triangle-list",//绘制三角形\n    }\n});\n\n\nline-strip表示把多个顶点首位相接连接(不闭合)，三个坐标点可以绘制两条直线段。\n\nconst pipeline = device.createRenderPipeline({\n    primitive: {\n        topology: "line-strip",//多个定点依次连线\n    }\n});\n\n\npoint-list表示每个顶点坐标对应位置渲染一个小点\n\nconst pipeline = device.createRenderPipeline({\n    primitive: {\n        topology: "point-list",\n    }\n});\n\n\n\n# WebGPU光栅化、片元着色器\n\n\n\n光栅化，就是生成几何图形对应的片元，你可以把片元类比为图像上一个个像素理解，比如绘制绘制一个三角形，光栅化，相当于在三角形返回内，生成一个一个密集排列的片元(像素)。\n\n经过光栅化处理得到的片元，你可以认为是一个没有任何颜色的片元(像素)，需要通过渲染管线上片元着色器上色，片元着色器单元就像流水线上一个喷漆的工位一样，给物体设置外观颜色。\n\n\n# 片元着色器WGSL操作片元(像素)\n\n片元着色器和的顶点着色器类似，都是渲染管线上的一个着色器功能单元，可以执行WGSL语言编写的着色器代码。\n\n// 片元着色器代码\nconst fragment = /* wgsl */ `\n@fragment\nfn main() -> @location(0) vec4<f32> {\n    return vec4<f32>(1.0, 0.0, 0.0, 1.0);//片元设置为红色\n}\n`\n\n\n\n# @fragment\n\n@fragment表示字符串fragment里面的代码是片元着色器代码，在GPU渲染管线的片元着色器单元上执行。\n\nconst fragment = `\n@fragment\n`\n\n\n为了方便单独管理WGSL着色器代码，你可以创建一个shader.js文件，在里面写着色器代码。\n\n// 顶点着色器代码\nconst vertex = /* wgsl */ `\n@vertex\n`\n// 片元着色器代码\nconst fragment = /* wgsl */ `\n@fragment\n`\nexport { vertex, fragment }\n\n\n\n# fn关键字声明一个函数\n\nfn关键字声明一个函数，命名为main，作为片元着色器代码的入口函数。\n\n@fragment\nfn main(){\n}\n\n\n\n# 处理片元像素值\n\n顶点着色器代码用来计算顶点的坐标，片元着色器代码用来设置片元像素值。\n\n可以用四维向量四个分量表示像素的RGBA四个分量，比如vec4<f32>(1.0, 0.0, 0.0, 1.0)表示把片元的元素像素值设置为红色，透明度为1.0。\n\n和顶点着色器类似，片元着色器需要通过关键字return,把设置了颜色的片元像素数据传递到渲染管线下一个功能环节。\n\n@fragment\nfn main(){\n    return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}\n\n\n\n# 片元着色器函数返回值设置@location(0) vec4<f32>\n\nmain函数return返回的变量，需要通过->符号设置函数返回值的数类类型,-> vec4<f32>表示函数返回的变量是浮点数构成的四维向量vec4。\n\n@fragment\nfn main() -> vec4<f32> {\n    return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}\n\n\n片元着色器中的@location(0)和前面顶点着色器中@location(0)，虽然符号一样，但不是一回事，片元着色器中的@location(0)和顶点缓冲区中顶点数据也没关系。\n\n通常渲染管线片元着色器输出的片元像素数据，会存储在显卡内存上，@location(0)含义你就简单理解为输出的片元数据存储到显卡内存上，并把存储位置标记为0，用于渲染管线的后续操作和处理。\n\n@fragment\nfn main() -> @location(0) vec4<f32> {\n    return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}\n\n\n\n\n\n# 渲染管线参数fragment.module属性\n\n把顶点着色器代码块对象device.createShaderModule({ code: fragment })作为渲染管线参数fragment.module属性的值，这样就可以配置好渲染管线上片元着色器功能单元，要执行的片元着色器代码。\n\nimport { vertex, fragment } from \'./shader.js\'\nconst pipeline = device.createRenderPipeline({\n    fragment: {//片元相关配置\n        // module:设置渲染管线要执行的片元着色器代码\n        module: device.createShaderModule({ code: fragment }),\n    },\n});\n\n\n\n# entryPoint属性\n\n顶点着色器或片元着色器一般需要通过entryPoint属性指定入口函数，入口函数名字你可以自定义,课程中习惯性设置为main。\n\nconst pipeline = device.createRenderPipeline({\n    vertex: {\n        module: device.createShaderModule({ code: vertex }),\n        entryPoint: "main"//指定入口函数\n    },\n    fragment: {\n        module: device.createShaderModule({ code: fragment }),\n        entryPoint: "main",//指定入口函数\n    }\n});\n\n\n\n# fragment.targets的元素的format属性\n\n//获取浏览器默认的颜色格式\nconst format = navigator.gpu.getPreferredCanvasFormat();\ncontext.configure({\n    device: device,\n    format: format,//颜色格式\n});\n\n\nconst pipeline = device.createRenderPipeline({\n    fragment: {\n        module: device.createShaderModule({ code: fragment }),\n        entryPoint: "main",\n        targets: [{\n            format: format//和WebGPU上下文配置的颜色格式保持一致\n        }]\n    }\n});\n\n\n\n# layout属性\n\n在旧版本WebGPU中，如果你用不到layout特定功能，可以不用设置，不过在新版本WebGPU，是必须设置的，否则报错。入门案例中，咱们不需要对layout属性进行特殊设置，先使用默认值layout: \'auto\'就行。\n\nconst pipeline = device.createRenderPipeline({\n    layout: \'auto\',\n});\n',normalizedContent:'# 片元着色器、图元装配\n\n上节课给大家讲解了webgpu渲染管线上的顶点着色器功能单元，下面给大家讲解webgpu渲染管线其他功能单元(图元装配、光栅化、片元着色器)。\n\n\n# primitive.topology(图元装配)\n\n经过顶点着色器处理过的顶点数据，会进入图元装配环节，简单说就是如何通过顶点数据生成几何图形，比如三个点绘制一个三角形，两点可以绘制一条线段...\n\n\n\n通过渲染管线参数的primitive.topology属性可以设置webgpu如何绘制顶点数据，下面随便列举即可。\n\ntriangle-list表示三个点为一组绘制一个三角形。\n\nconst pipeline = device.createrenderpipeline({\n    primitive: {\n        topology: "triangle-list",//绘制三角形\n    }\n});\n\n\nline-strip表示把多个顶点首位相接连接(不闭合)，三个坐标点可以绘制两条直线段。\n\nconst pipeline = device.createrenderpipeline({\n    primitive: {\n        topology: "line-strip",//多个定点依次连线\n    }\n});\n\n\npoint-list表示每个顶点坐标对应位置渲染一个小点\n\nconst pipeline = device.createrenderpipeline({\n    primitive: {\n        topology: "point-list",\n    }\n});\n\n\n\n# webgpu光栅化、片元着色器\n\n\n\n光栅化，就是生成几何图形对应的片元，你可以把片元类比为图像上一个个像素理解，比如绘制绘制一个三角形，光栅化，相当于在三角形返回内，生成一个一个密集排列的片元(像素)。\n\n经过光栅化处理得到的片元，你可以认为是一个没有任何颜色的片元(像素)，需要通过渲染管线上片元着色器上色，片元着色器单元就像流水线上一个喷漆的工位一样，给物体设置外观颜色。\n\n\n# 片元着色器wgsl操作片元(像素)\n\n片元着色器和的顶点着色器类似，都是渲染管线上的一个着色器功能单元，可以执行wgsl语言编写的着色器代码。\n\n// 片元着色器代码\nconst fragment = /* wgsl */ `\n@fragment\nfn main() -> @location(0) vec4<f32> {\n    return vec4<f32>(1.0, 0.0, 0.0, 1.0);//片元设置为红色\n}\n`\n\n\n\n# @fragment\n\n@fragment表示字符串fragment里面的代码是片元着色器代码，在gpu渲染管线的片元着色器单元上执行。\n\nconst fragment = `\n@fragment\n`\n\n\n为了方便单独管理wgsl着色器代码，你可以创建一个shader.js文件，在里面写着色器代码。\n\n// 顶点着色器代码\nconst vertex = /* wgsl */ `\n@vertex\n`\n// 片元着色器代码\nconst fragment = /* wgsl */ `\n@fragment\n`\nexport { vertex, fragment }\n\n\n\n# fn关键字声明一个函数\n\nfn关键字声明一个函数，命名为main，作为片元着色器代码的入口函数。\n\n@fragment\nfn main(){\n}\n\n\n\n# 处理片元像素值\n\n顶点着色器代码用来计算顶点的坐标，片元着色器代码用来设置片元像素值。\n\n可以用四维向量四个分量表示像素的rgba四个分量，比如vec4<f32>(1.0, 0.0, 0.0, 1.0)表示把片元的元素像素值设置为红色，透明度为1.0。\n\n和顶点着色器类似，片元着色器需要通过关键字return,把设置了颜色的片元像素数据传递到渲染管线下一个功能环节。\n\n@fragment\nfn main(){\n    return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}\n\n\n\n# 片元着色器函数返回值设置@location(0) vec4<f32>\n\nmain函数return返回的变量，需要通过->符号设置函数返回值的数类类型,-> vec4<f32>表示函数返回的变量是浮点数构成的四维向量vec4。\n\n@fragment\nfn main() -> vec4<f32> {\n    return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}\n\n\n片元着色器中的@location(0)和前面顶点着色器中@location(0)，虽然符号一样，但不是一回事，片元着色器中的@location(0)和顶点缓冲区中顶点数据也没关系。\n\n通常渲染管线片元着色器输出的片元像素数据，会存储在显卡内存上，@location(0)含义你就简单理解为输出的片元数据存储到显卡内存上，并把存储位置标记为0，用于渲染管线的后续操作和处理。\n\n@fragment\nfn main() -> @location(0) vec4<f32> {\n    return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n}\n\n\n\n\n\n# 渲染管线参数fragment.module属性\n\n把顶点着色器代码块对象device.createshadermodule({ code: fragment })作为渲染管线参数fragment.module属性的值，这样就可以配置好渲染管线上片元着色器功能单元，要执行的片元着色器代码。\n\nimport { vertex, fragment } from \'./shader.js\'\nconst pipeline = device.createrenderpipeline({\n    fragment: {//片元相关配置\n        // module:设置渲染管线要执行的片元着色器代码\n        module: device.createshadermodule({ code: fragment }),\n    },\n});\n\n\n\n# entrypoint属性\n\n顶点着色器或片元着色器一般需要通过entrypoint属性指定入口函数，入口函数名字你可以自定义,课程中习惯性设置为main。\n\nconst pipeline = device.createrenderpipeline({\n    vertex: {\n        module: device.createshadermodule({ code: vertex }),\n        entrypoint: "main"//指定入口函数\n    },\n    fragment: {\n        module: device.createshadermodule({ code: fragment }),\n        entrypoint: "main",//指定入口函数\n    }\n});\n\n\n\n# fragment.targets的元素的format属性\n\n//获取浏览器默认的颜色格式\nconst format = navigator.gpu.getpreferredcanvasformat();\ncontext.configure({\n    device: device,\n    format: format,//颜色格式\n});\n\n\nconst pipeline = device.createrenderpipeline({\n    fragment: {\n        module: device.createshadermodule({ code: fragment }),\n        entrypoint: "main",\n        targets: [{\n            format: format//和webgpu上下文配置的颜色格式保持一致\n        }]\n    }\n});\n\n\n\n# layout属性\n\n在旧版本webgpu中，如果你用不到layout特定功能，可以不用设置，不过在新版本webgpu，是必须设置的，否则报错。入门案例中，咱们不需要对layout属性进行特殊设置，先使用默认值layout: \'auto\'就行。\n\nconst pipeline = device.createrenderpipeline({\n    layout: \'auto\',\n});\n',charsets:{cjk:!0}},{title:"8. WebGPU 3D坐标系(投影)",frontmatter:{title:"8. WebGPU 3D坐标系(投影)",date:"2023-04-22T11:51:22.000Z",permalink:"/pages/ff1bbf/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/01.1.WebGPU%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/08.WebGPU%203D%E5%9D%90%E6%A0%87%E7%B3%BB(%E6%8A%95%E5%BD%B1).html",relativePath:"WebGPU教程/01.1.WebGPU快速入门/08.WebGPU 3D坐标系(投影).md",key:"v-650e89cc",path:"/pages/ff1bbf/",headers:[{level:3,title:"WebGPU标准设备坐标系",slug:"webgpu标准设备坐标系",normalizedTitle:"webgpu标准设备坐标系",charIndex:89},{level:3,title:"WebGPU渲染规则(投影)",slug:"webgpu渲染规则-投影",normalizedTitle:"webgpu渲染规则(投影)",charIndex:389},{level:3,title:"测试WebGPU 渲染范围",slug:"测试webgpu-渲染范围",normalizedTitle:"测试webgpu 渲染范围",charIndex:918}],headersStr:"WebGPU标准设备坐标系 WebGPU渲染规则(投影) 测试WebGPU 渲染范围",content:"# WebGPU 3D坐标系(投影)\n\n经过前面7节课的讲解，完成一个最简单的WebGPU三角形小案例，本节课就在前面基础上，给大家讲解WebGPU的3D坐标系和投影。\n\n\n# WebGPU标准设备坐标系\n\n在1.3小节，创建顶点缓冲区的时候，简单介绍过WebGPU坐标系知识，咱们先回顾下。\n\nWebGPU坐标系在Canvas画布上的坐标原点是Canvas画布的中间位置，x轴水平向右，y轴竖直向上，x和y的坐标范围都是[-1,1]，\n\n\n\nWebGPU坐标系z轴与Canvas画布垂直，朝向屏幕，z坐标的范围是[0,1]。\n\n\n\n对于这种WebGPU坐标系，在图形学中，有个专门的名，就是标准化设备坐标系，对应英文名Normalized Device Coordinates，简称NDC，因为坐标范围是-1~1或0~1的相对值，你把NDC称为归一化设备坐标系也行。\n\n\n# WebGPU渲染规则(投影)\n\n在x、y、z轴上各取一个点创建一个等边三角形。\n\n\n\nconst vertexArray = new Float32Array([\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0,\n]);\n\n\n那么默认情况下，WebGPU会如何渲染上面顶点坐标定义的三角形？\n\n为了大家更好理解，我们假设在WebGPU的3D空间中，存在一束平行光线，沿着z轴照射到XOY平面上，这时候3D空间中的三角形会在XOY平面上产生投影，就像生活中，人在太阳光下，会地面上产生投影。\n\n这时候，z轴上的任何顶点，投影后，其实都在坐标原点，这样上面一个等边三角形，三个点投影后，就是两个点在x和y轴，z轴上的点投影到坐标原点，这样三个点连接起来，渲染的投影结果就是一个直接三角形。\n\n\n\n上面等边三角形顶点坐标和下面三餐性顶点坐标，在WebGPU默认情况下，投影效果其实一样的\n\nconst vertexArray = new Float32Array([\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0,\n]);\n\n\n\n# 测试WebGPU 渲染范围\n\nWebGPU坐标系x和y的坐标范围是[-1,1]，z坐标的范围是[0,1]。\n\nWebGPU默认的渲染规律是，如果你的几何图形，超出xyz长方体空间范围的部分会被剪裁掉，不显示。\n\n三个顶点坐标都没有超出范围，可以看到完整三角形，点1的x为z刚好和右侧canvas画布边缘重合，点2y为1，刚好和canvas画布的顶部边缘重合。\n\nconst vertexArray = new Float32Array([\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0,\n]);\n\n\n下面三角形z坐标都是2.0，渲染的时候，在canvas画布上，你可以看不到三角形。\n\nconst vertexArray = new Float32Array([\n    1.0, 0.0, 2.0,\n    0.0, 1.0, 2.0,\n    0.0, 0.0, 2.0,\n]);\n\n\n顶点1的x坐标超出范围，三角形超出WebGPU渲染范围部分不显示，三角形渲染不完整\n\nconst vertexArray = new Float32Array([\n    2.0, 0.0, 0.2,\n    0.0, 1.0, 0.2,\n    0.0, 0.0, 0.2,\n]);\n\n\n",normalizedContent:"# webgpu 3d坐标系(投影)\n\n经过前面7节课的讲解，完成一个最简单的webgpu三角形小案例，本节课就在前面基础上，给大家讲解webgpu的3d坐标系和投影。\n\n\n# webgpu标准设备坐标系\n\n在1.3小节，创建顶点缓冲区的时候，简单介绍过webgpu坐标系知识，咱们先回顾下。\n\nwebgpu坐标系在canvas画布上的坐标原点是canvas画布的中间位置，x轴水平向右，y轴竖直向上，x和y的坐标范围都是[-1,1]，\n\n\n\nwebgpu坐标系z轴与canvas画布垂直，朝向屏幕，z坐标的范围是[0,1]。\n\n\n\n对于这种webgpu坐标系，在图形学中，有个专门的名，就是标准化设备坐标系，对应英文名normalized device coordinates，简称ndc，因为坐标范围是-1~1或0~1的相对值，你把ndc称为归一化设备坐标系也行。\n\n\n# webgpu渲染规则(投影)\n\n在x、y、z轴上各取一个点创建一个等边三角形。\n\n\n\nconst vertexarray = new float32array([\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 1.0,\n]);\n\n\n那么默认情况下，webgpu会如何渲染上面顶点坐标定义的三角形？\n\n为了大家更好理解，我们假设在webgpu的3d空间中，存在一束平行光线，沿着z轴照射到xoy平面上，这时候3d空间中的三角形会在xoy平面上产生投影，就像生活中，人在太阳光下，会地面上产生投影。\n\n这时候，z轴上的任何顶点，投影后，其实都在坐标原点，这样上面一个等边三角形，三个点投影后，就是两个点在x和y轴，z轴上的点投影到坐标原点，这样三个点连接起来，渲染的投影结果就是一个直接三角形。\n\n\n\n上面等边三角形顶点坐标和下面三餐性顶点坐标，在webgpu默认情况下，投影效果其实一样的\n\nconst vertexarray = new float32array([\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0,\n]);\n\n\n\n# 测试webgpu 渲染范围\n\nwebgpu坐标系x和y的坐标范围是[-1,1]，z坐标的范围是[0,1]。\n\nwebgpu默认的渲染规律是，如果你的几何图形，超出xyz长方体空间范围的部分会被剪裁掉，不显示。\n\n三个顶点坐标都没有超出范围，可以看到完整三角形，点1的x为z刚好和右侧canvas画布边缘重合，点2y为1，刚好和canvas画布的顶部边缘重合。\n\nconst vertexarray = new float32array([\n    1.0, 0.0, 0.0,\n    0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0,\n]);\n\n\n下面三角形z坐标都是2.0，渲染的时候，在canvas画布上，你可以看不到三角形。\n\nconst vertexarray = new float32array([\n    1.0, 0.0, 2.0,\n    0.0, 1.0, 2.0,\n    0.0, 0.0, 2.0,\n]);\n\n\n顶点1的x坐标超出范围，三角形超出webgpu渲染范围部分不显示，三角形渲染不完整\n\nconst vertexarray = new float32array([\n    2.0, 0.0, 0.2,\n    0.0, 1.0, 0.2,\n    0.0, 0.0, 0.2,\n]);\n\n\n",charsets:{cjk:!0}},{title:"7. 渲染命令(至此完成第一个案例)",frontmatter:{title:"7. 渲染命令(至此完成第一个案例)",date:"2023-04-22T11:51:06.000Z",permalink:"/pages/6d5d59/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/01.1.WebGPU%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/07.%E6%B8%B2%E6%9F%93%E5%91%BD%E4%BB%A4(%E8%87%B3%E6%AD%A4%E5%AE%8C%E6%88%90%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B).html",relativePath:"WebGPU教程/01.1.WebGPU快速入门/07.渲染命令(至此完成第一个案例).md",key:"v-13085dfb",path:"/pages/6d5d59/",headers:[{level:3,title:"创建命令编码器和渲染通道",slug:"创建命令编码器和渲染通道",normalizedTitle:"创建命令编码器和渲染通道",charIndex:160},{level:3,title:"颜色缓冲区的概念",slug:"颜色缓冲区的概念",normalizedTitle:"颜色缓冲区的概念",charIndex:555},{level:3,title:".beginRenderPass的参数对象",slug:"beginrenderpass的参数对象",normalizedTitle:".beginrenderpass的参数对象",charIndex:815},{level:3,title:"设置渲染通道的渲染管线",slug:"设置渲染通道的渲染管线",normalizedTitle:"设置渲染通道的渲染管线",charIndex:1722},{level:3,title:"关联顶点缓冲区数据和渲染管线shaderLocation: 0",slug:"关联顶点缓冲区数据和渲染管线shaderlocation-0",normalizedTitle:"关联顶点缓冲区数据和渲染管线shaderlocation: 0",charIndex:2014},{level:3,title:"绘制命令.draw()",slug:"绘制命令-draw",normalizedTitle:"绘制命令.draw()",charIndex:2264},{level:3,title:"渲染通道结束命令.end()",slug:"渲染通道结束命令-end",normalizedTitle:"渲染通道结束命令.end()",charIndex:2508},{level:3,title:"命令编码器方法.finish()",slug:"命令编码器方法-finish",normalizedTitle:"命令编码器方法.finish()",charIndex:2695},{level:3,title:"GPU设备命令队列.queue属性",slug:"gpu设备命令队列-queue属性",normalizedTitle:"gpu设备命令队列.queue属性",charIndex:3133}],headersStr:"创建命令编码器和渲染通道 颜色缓冲区的概念 .beginRenderPass的参数对象 设置渲染通道的渲染管线 关联顶点缓冲区数据和渲染管线shaderLocation: 0 绘制命令.draw() 渲染通道结束命令.end() 命令编码器方法.finish() GPU设备命令队列.queue属性",content:"# 渲染命令(完成第一个案例的渲染)\n\n在前面几节课基础上，本节课通过设置一些渲染命令，最终完成第一个WebGPU小案例。本案例虽然非常简单，但是麻雀虽小，五脏俱全，后面的课程都可以在本节课的基础上给大家讲解。\n\n你可以把本节课的小案例，当做一个学习模板，再次基础上增删代码，学习体验WebGPU的各种知识点。\n\n\n# 创建命令编码器和渲染通道\n\n首先通过GPU设备对象的方法.createCommandEncoder()创建一个命令编码器对象。\n\n// 创建GPU命令编码器对象\nconst commandEncoder = device.createCommandEncoder();\n\n\n通过命令对象的方法.beginRenderPass()可以创建一个渲染通道对象renderPass。\n\nconst renderPass = commandEncoder.beginRenderPass({\n    // 需要配置一些参数\n});\n\n\n通过GPU命令编码器对象commandEncoder可以控制渲染管线pipeline渲染输出像素数据。\n\n前面讲过的一些控制webgpu API，默认不会直接执行，如果想在GPU上执行，还需要配置GPU命令编码器对象commandEncoder实现。\n\n\n\n\n# 颜色缓冲区的概念\n\n通过WebGPU渲染管线各个功能处理后，会得到图形的片元数据，或者说像素数据，这些像素数据，会存储到显卡内存颜色缓冲区中。\n\n你可以类比顶点缓冲区和理解颜色缓冲区，顶点缓冲区的功能是存储顶点数据，颜色缓冲区的功能是存储渲染管线输出的像素数据。\n\n颜色缓冲区和顶点缓冲区类似，可以创建，不过有一个比较特殊，就是canvas画布对应一个默认的颜色缓冲区，可以直接使用。\n\n如果你希望webgpu绘制的图形，呈现在canvas画布上，就要把绘制的结果输出到canvas画布对应的颜色缓冲区中。\n\n\n\n\n# .beginRenderPass的参数对象\n\n.beginRenderPass的参数对象具有多个属性，比如常用的colorAttachments(颜色附件)、depthStencilAttachment(深度/模板附件)...本节课先给大家介绍其中一个颜色附近属性colorAttachments。\n\n首先大家要知道渲染通道renderPass可以控制渲染管线pipeline渲染输出像素数据，输出的像素数据会存储到GPU设备的颜色缓冲区中。\n\ncolorAttachments属性就和颜色缓冲区有关，colorAttachments属性的值是数组，数组里面的元素是对象,可以包含多个对象，每个对象的都和一个颜色缓冲区相关，每个对象具有view、loadOp、storeOp、clearValue等属性。\n\n当我们需要把渲染管线的像素数据存储到多个颜色缓冲区时，colorAttachments的属性值才需要设置多个元素对象，一般情况下，colorAttachments的数组元素只需要设置一个即可，这样的话，渲染通道控制渲染管线输出的像素最终就会存储到该数组元素对应颜色缓冲区。\n\nconst renderPass = commandEncoder.beginRenderPass({\n    // 给渲染通道指定颜色缓冲区，配置指定的缓冲区\n    colorAttachments:[{\n        // 指向用于Canvas画布的纹理视图对象(Canvas对应的颜色缓冲区)\n        // 该渲染通道renderPass输出的像素数据会存储到Canvas画布对应的颜色缓冲区(纹理视图对象)\n        view: context.getCurrentTexture().createView(),  \n        storeOp: 'store',//像素数据写入颜色缓冲区\n        loadOp: 'clear',\n        clearValue: { r: 0.5, g: 0.5, b: 0.5, a: 1.0 }, //背景颜色\n    }]\n});\n\n\n\n# 设置渲染通道的渲染管线\n\n实际开发，可能有一个渲染管线，也可能有多个，你可以根据需要，通过渲染通道renderPass的方法.setPipeline()设置你要控制的渲染管线。\n\n// const pipeline = device.createRenderPipeline()\n// 设置该渲染通道控制渲染管线\nrenderPass.setPipeline(pipeline);\n\n\n通过GPU命令编码器对象commandEncoder可以根据需要创建多个渲染通道，每个通道都可以控制自己对应的的渲染管线输出图像。不过咱们入门部分案例，比较简单，只是创建一个渲染通道而已。\n\n\n# 关联顶点缓冲区数据和渲染管线shaderLocation: 0\n\n顶点缓冲区数据和渲染管线shaderLocation: 0表示存储位置关联起来\n\nrenderPass.setVertexBuffer(0, vertexBuffer);\n\n\n\n\n补充(后面会讲解)：实际开发，可以通过device.createBuffer创建多个顶点缓冲区，第一个案例，只有一个顶点缓冲区.setVertexBuffer()的参数1设置为0即可，如果有多个，可以设置为0、1、2、3等，后面遇到再具体讲解。\n\n\n# 绘制命令.draw()\n\n渲染通道对象renderPass提供了一个方法.draw()，英文字面意思就是绘制，你也可以把绘制方法.draw()称为绘制命令。通过绘制命令.draw()，你可以命令渲染通道对应的WebGPU的渲染管线如何绘制你定义的顶点数据。\n\n// renderPass.setPipeline(pipeline);\n// 绘制命令.draw()绘制顶点数据\nrenderPass.draw(3);\n\n\n注意顺序：调用.draw()之前要设置渲染管线，否则报错。\n\n\n# 渲染通道结束命令.end()\n\n渲染通道对象renderPass的.end()方法比较简单，就是字面意思结束，不用设置参数，一般你设置好绘制等命令后，需要设置renderPass.end()。\n\n// 渲染通道结束命令.end()\nrenderPass.end();\n\n\n执行renderPass.end(),系统内部会标记前渲染通道renderPass已经结束。\n\n\n# 命令编码器方法.finish()\n\n在前面代码调用的WebGPU API或者说方法，大部分都是用来控制GPU如何运行的，比如device.createRenderPipeline()就是控制GPU创建一个渲染管线，比如.draw方法，控制GPU如何绘制顶点数据，不过这些WebGPU API或方法不能直接控制GPU的运行，需要转化(编码)为GPU指令(命令)，才能控制GPU运转。\n\n命令编码器对象commandEncoder执行.finish()方法返回一个命令缓冲区对象，同时会把该编码器相关的WebGL API或方法，编码为GPU指令，存入到返回的命令缓冲区对象中。\n\n// const commandEncoder = device.createCommandEncoder();\n// 命令编码器.finish()创建命令缓冲区(生成GPU指令存入缓冲区)\nconst commandBuffer = commandEncoder.finish();\n\n\n\n\n\n# GPU设备命令队列.queue属性\n\nGPU设备命令队列.queue的功能是用来存放控制GPU运转的指令(命令)，简单说就是你命令编码器和渲染通道定义的一系列控制GPU运行的命令方法。\n\n.submit()是GPU设备对象device队列属性.queue的一个提交方法。\n\n提交方法.submit()的参数是一个数组，数组的元素是命令编码器执行.finish()生成的GPU命令缓冲区对象commandBuffer，数组元素可以包含多个命令缓冲区对象，入门案例比较简单，只添加了一个。\n\n// const commandEncoder = device.createCommandEncoder();\nconst commandBuffer = commandEncoder.finish();\n// 命令编码器缓冲区中命令传入GPU设备对象的命令队列.queue\ndevice.queue.submit([commandBuffer]);\n\n\n\n\n在执行.queue.submit([])方法之前，WebGPU相关命令方法，还不会被GPU硬件执行。",normalizedContent:"# 渲染命令(完成第一个案例的渲染)\n\n在前面几节课基础上，本节课通过设置一些渲染命令，最终完成第一个webgpu小案例。本案例虽然非常简单，但是麻雀虽小，五脏俱全，后面的课程都可以在本节课的基础上给大家讲解。\n\n你可以把本节课的小案例，当做一个学习模板，再次基础上增删代码，学习体验webgpu的各种知识点。\n\n\n# 创建命令编码器和渲染通道\n\n首先通过gpu设备对象的方法.createcommandencoder()创建一个命令编码器对象。\n\n// 创建gpu命令编码器对象\nconst commandencoder = device.createcommandencoder();\n\n\n通过命令对象的方法.beginrenderpass()可以创建一个渲染通道对象renderpass。\n\nconst renderpass = commandencoder.beginrenderpass({\n    // 需要配置一些参数\n});\n\n\n通过gpu命令编码器对象commandencoder可以控制渲染管线pipeline渲染输出像素数据。\n\n前面讲过的一些控制webgpu api，默认不会直接执行，如果想在gpu上执行，还需要配置gpu命令编码器对象commandencoder实现。\n\n\n\n\n# 颜色缓冲区的概念\n\n通过webgpu渲染管线各个功能处理后，会得到图形的片元数据，或者说像素数据，这些像素数据，会存储到显卡内存颜色缓冲区中。\n\n你可以类比顶点缓冲区和理解颜色缓冲区，顶点缓冲区的功能是存储顶点数据，颜色缓冲区的功能是存储渲染管线输出的像素数据。\n\n颜色缓冲区和顶点缓冲区类似，可以创建，不过有一个比较特殊，就是canvas画布对应一个默认的颜色缓冲区，可以直接使用。\n\n如果你希望webgpu绘制的图形，呈现在canvas画布上，就要把绘制的结果输出到canvas画布对应的颜色缓冲区中。\n\n\n\n\n# .beginrenderpass的参数对象\n\n.beginrenderpass的参数对象具有多个属性，比如常用的colorattachments(颜色附件)、depthstencilattachment(深度/模板附件)...本节课先给大家介绍其中一个颜色附近属性colorattachments。\n\n首先大家要知道渲染通道renderpass可以控制渲染管线pipeline渲染输出像素数据，输出的像素数据会存储到gpu设备的颜色缓冲区中。\n\ncolorattachments属性就和颜色缓冲区有关，colorattachments属性的值是数组，数组里面的元素是对象,可以包含多个对象，每个对象的都和一个颜色缓冲区相关，每个对象具有view、loadop、storeop、clearvalue等属性。\n\n当我们需要把渲染管线的像素数据存储到多个颜色缓冲区时，colorattachments的属性值才需要设置多个元素对象，一般情况下，colorattachments的数组元素只需要设置一个即可，这样的话，渲染通道控制渲染管线输出的像素最终就会存储到该数组元素对应颜色缓冲区。\n\nconst renderpass = commandencoder.beginrenderpass({\n    // 给渲染通道指定颜色缓冲区，配置指定的缓冲区\n    colorattachments:[{\n        // 指向用于canvas画布的纹理视图对象(canvas对应的颜色缓冲区)\n        // 该渲染通道renderpass输出的像素数据会存储到canvas画布对应的颜色缓冲区(纹理视图对象)\n        view: context.getcurrenttexture().createview(),  \n        storeop: 'store',//像素数据写入颜色缓冲区\n        loadop: 'clear',\n        clearvalue: { r: 0.5, g: 0.5, b: 0.5, a: 1.0 }, //背景颜色\n    }]\n});\n\n\n\n# 设置渲染通道的渲染管线\n\n实际开发，可能有一个渲染管线，也可能有多个，你可以根据需要，通过渲染通道renderpass的方法.setpipeline()设置你要控制的渲染管线。\n\n// const pipeline = device.createrenderpipeline()\n// 设置该渲染通道控制渲染管线\nrenderpass.setpipeline(pipeline);\n\n\n通过gpu命令编码器对象commandencoder可以根据需要创建多个渲染通道，每个通道都可以控制自己对应的的渲染管线输出图像。不过咱们入门部分案例，比较简单，只是创建一个渲染通道而已。\n\n\n# 关联顶点缓冲区数据和渲染管线shaderlocation: 0\n\n顶点缓冲区数据和渲染管线shaderlocation: 0表示存储位置关联起来\n\nrenderpass.setvertexbuffer(0, vertexbuffer);\n\n\n\n\n补充(后面会讲解)：实际开发，可以通过device.createbuffer创建多个顶点缓冲区，第一个案例，只有一个顶点缓冲区.setvertexbuffer()的参数1设置为0即可，如果有多个，可以设置为0、1、2、3等，后面遇到再具体讲解。\n\n\n# 绘制命令.draw()\n\n渲染通道对象renderpass提供了一个方法.draw()，英文字面意思就是绘制，你也可以把绘制方法.draw()称为绘制命令。通过绘制命令.draw()，你可以命令渲染通道对应的webgpu的渲染管线如何绘制你定义的顶点数据。\n\n// renderpass.setpipeline(pipeline);\n// 绘制命令.draw()绘制顶点数据\nrenderpass.draw(3);\n\n\n注意顺序：调用.draw()之前要设置渲染管线，否则报错。\n\n\n# 渲染通道结束命令.end()\n\n渲染通道对象renderpass的.end()方法比较简单，就是字面意思结束，不用设置参数，一般你设置好绘制等命令后，需要设置renderpass.end()。\n\n// 渲染通道结束命令.end()\nrenderpass.end();\n\n\n执行renderpass.end(),系统内部会标记前渲染通道renderpass已经结束。\n\n\n# 命令编码器方法.finish()\n\n在前面代码调用的webgpu api或者说方法，大部分都是用来控制gpu如何运行的，比如device.createrenderpipeline()就是控制gpu创建一个渲染管线，比如.draw方法，控制gpu如何绘制顶点数据，不过这些webgpu api或方法不能直接控制gpu的运行，需要转化(编码)为gpu指令(命令)，才能控制gpu运转。\n\n命令编码器对象commandencoder执行.finish()方法返回一个命令缓冲区对象，同时会把该编码器相关的webgl api或方法，编码为gpu指令，存入到返回的命令缓冲区对象中。\n\n// const commandencoder = device.createcommandencoder();\n// 命令编码器.finish()创建命令缓冲区(生成gpu指令存入缓冲区)\nconst commandbuffer = commandencoder.finish();\n\n\n\n\n\n# gpu设备命令队列.queue属性\n\ngpu设备命令队列.queue的功能是用来存放控制gpu运转的指令(命令)，简单说就是你命令编码器和渲染通道定义的一系列控制gpu运行的命令方法。\n\n.submit()是gpu设备对象device队列属性.queue的一个提交方法。\n\n提交方法.submit()的参数是一个数组，数组的元素是命令编码器执行.finish()生成的gpu命令缓冲区对象commandbuffer，数组元素可以包含多个命令缓冲区对象，入门案例比较简单，只添加了一个。\n\n// const commandencoder = device.createcommandencoder();\nconst commandbuffer = commandencoder.finish();\n// 命令编码器缓冲区中命令传入gpu设备对象的命令队列.queue\ndevice.queue.submit([commandbuffer]);\n\n\n\n\n在执行.queue.submit([])方法之前，webgpu相关命令方法，还不会被gpu硬件执行。",charsets:{cjk:!0}},{title:"9. 三角形拼接矩形",frontmatter:{title:"9. 三角形拼接矩形",date:"2023-04-24T22:08:49.000Z",permalink:"/pages/c033a7/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/01.1.WebGPU%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/09.%E4%B8%89%E8%A7%92%E5%BD%A2%E6%8B%BC%E6%8E%A5%E7%9F%A9%E5%BD%A2.html",relativePath:"WebGPU教程/01.1.WebGPU快速入门/09.三角形拼接矩形.md",key:"v-2dac77a6",path:"/pages/c033a7/",headers:[{level:3,title:"绘制两个三角形",slug:"绘制两个三角形",normalizedTitle:"绘制两个三角形",charIndex:98},{level:3,title:"三角形拼接一个矩形",slug:"三角形拼接一个矩形",normalizedTitle:"三角形拼接一个矩形",charIndex:81}],headersStr:"绘制两个三角形 三角形拼接一个矩形",content:'# 三角形拼接矩形\n\n实际上在WebGPU中，表达一个复杂的3D几何形状，一般都是通过一个一个三角形拼接出来的。\n\n\n\n本节课就给大家讲解一个最简单的案例，用2个三角形拼接一个矩形。\n\n\n\n\n# 绘制两个三角形\n\n前面说过，primitive属性的值设置为triangle-list，当执行draw绘制命令的时候，会以三角形的方式绘制顶点数据，简单说就是每3个顶点绘制一个三角形，6个顶点就是绘制两个三角形。\n\nconst pipeline = device.createRenderPipeline({\n    primitive: {\n        topology: "triangle-list",//绘制三角形\n    }\n});\n\n\n前面讲解过的，绘制一个三角形，三个顶点，draw绘制命令第一个参数是3。\n\nconst vertexArray = new Float32Array([\n    // 三角形三个顶点坐标的x、y、z值\n    0.0, 0.0, 0.0,//顶点1坐标\n    1.0, 0.0, 0.0,//顶点2坐标\n    0.0, 1.0, 0.0,//顶点3坐标\n]);\nrenderPass.draw(3);// 绘制顶点数据\n\n\n下面通过6个顶点绘制两个三角形。\n\n\n\n//创建顶点数据\nconst vertexArray = new Float32Array([\n    // 三角形1三个顶点坐标的x、y、z值\n    0.0, 0.0, 0.0,//顶点1坐标\n    1.0, 0.0, 0.0,//顶点2坐标\n    0.0, 1.0, 0.0,//顶点3坐标\n    // 三角形2三个顶点坐标的x、y、z值\n    -0.5, -0.5, 0.0,//顶点4坐标\n    -1.0, -0.5, 0.0,//顶点5坐标\n    -0.5, -1.0, 0.0,//顶点6坐标\n]);\nrenderPass.draw(6);// 绘制顶点数据\n\n\n\n# 三角形拼接一个矩形\n\n一个矩形至少需要两个三角形拼接表示，和上面两个三角形绘制代码逻辑一样，区别不过是，这两个三角形有个两顶点重合罢了。\n\n\n\n注意一个面的多个三角形，正反面要保持一致，就是说沿着某个方向看过去，矩形的两个三角形，要么都是正面，要么都是反面，或者说要么都是顺时装，要么都是逆时针。\n\nconst vertexArray = new Float32Array([\n    // 三角形1三个顶点顺时针(沿着z轴负半轴方向观察，如果正半轴方向观察就是逆时针)\n    -0.3, -0.5, 0.0,//顶点1坐标\n    0.3, -0.5, 0.0,//顶点2坐标\n    0.3, 0.5, 0.0,//顶点3坐标\n    // 三角形2三个顶点顺时针(沿着z轴负半轴方向观察，如果正半轴方向观察就是逆时针)\n    -0.3, -0.5, 0.0,//顶点4坐标 与顶点1重合\n    0.3, 0.5, 0.0,//顶点5坐标 与顶点3重合\n    -0.3, 0.5, 0.0,//顶点6坐标\n]);\n',normalizedContent:'# 三角形拼接矩形\n\n实际上在webgpu中，表达一个复杂的3d几何形状，一般都是通过一个一个三角形拼接出来的。\n\n\n\n本节课就给大家讲解一个最简单的案例，用2个三角形拼接一个矩形。\n\n\n\n\n# 绘制两个三角形\n\n前面说过，primitive属性的值设置为triangle-list，当执行draw绘制命令的时候，会以三角形的方式绘制顶点数据，简单说就是每3个顶点绘制一个三角形，6个顶点就是绘制两个三角形。\n\nconst pipeline = device.createrenderpipeline({\n    primitive: {\n        topology: "triangle-list",//绘制三角形\n    }\n});\n\n\n前面讲解过的，绘制一个三角形，三个顶点，draw绘制命令第一个参数是3。\n\nconst vertexarray = new float32array([\n    // 三角形三个顶点坐标的x、y、z值\n    0.0, 0.0, 0.0,//顶点1坐标\n    1.0, 0.0, 0.0,//顶点2坐标\n    0.0, 1.0, 0.0,//顶点3坐标\n]);\nrenderpass.draw(3);// 绘制顶点数据\n\n\n下面通过6个顶点绘制两个三角形。\n\n\n\n//创建顶点数据\nconst vertexarray = new float32array([\n    // 三角形1三个顶点坐标的x、y、z值\n    0.0, 0.0, 0.0,//顶点1坐标\n    1.0, 0.0, 0.0,//顶点2坐标\n    0.0, 1.0, 0.0,//顶点3坐标\n    // 三角形2三个顶点坐标的x、y、z值\n    -0.5, -0.5, 0.0,//顶点4坐标\n    -1.0, -0.5, 0.0,//顶点5坐标\n    -0.5, -1.0, 0.0,//顶点6坐标\n]);\nrenderpass.draw(6);// 绘制顶点数据\n\n\n\n# 三角形拼接一个矩形\n\n一个矩形至少需要两个三角形拼接表示，和上面两个三角形绘制代码逻辑一样，区别不过是，这两个三角形有个两顶点重合罢了。\n\n\n\n注意一个面的多个三角形，正反面要保持一致，就是说沿着某个方向看过去，矩形的两个三角形，要么都是正面，要么都是反面，或者说要么都是顺时装，要么都是逆时针。\n\nconst vertexarray = new float32array([\n    // 三角形1三个顶点顺时针(沿着z轴负半轴方向观察，如果正半轴方向观察就是逆时针)\n    -0.3, -0.5, 0.0,//顶点1坐标\n    0.3, -0.5, 0.0,//顶点2坐标\n    0.3, 0.5, 0.0,//顶点3坐标\n    // 三角形2三个顶点顺时针(沿着z轴负半轴方向观察，如果正半轴方向观察就是逆时针)\n    -0.3, -0.5, 0.0,//顶点4坐标 与顶点1重合\n    0.3, 0.5, 0.0,//顶点5坐标 与顶点3重合\n    -0.3, 0.5, 0.0,//顶点6坐标\n]);\n',charsets:{cjk:!0}},{title:"4. 顶点着色器矩阵变换",frontmatter:{title:"4. 顶点着色器矩阵变换",date:"2023-05-19T09:39:04.000Z",permalink:"/pages/17d42c/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/04.%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/04.顶点着色器矩阵变换.md",key:"v-3f3ba29a",path:"/pages/17d42c/",headers:[{level:3,title:"WGSL矩阵语法：矩阵",slug:"wgsl矩阵语法-矩阵",normalizedTitle:"wgsl矩阵语法：矩阵",charIndex:95},{level:3,title:"WGSLmat4x4()表示缩放矩阵",slug:"wgslmat4x4-f32-表示缩放矩阵",normalizedTitle:"wgslmat4x4()表示缩放矩阵",charIndex:null},{level:3,title:"顶点着色器缩放矩阵缩放顶点坐标",slug:"顶点着色器缩放矩阵缩放顶点坐标",normalizedTitle:"顶点着色器缩放矩阵缩放顶点坐标",charIndex:718},{level:3,title:"平移矩阵平移顶点坐标",slug:"平移矩阵平移顶点坐标",normalizedTitle:"平移矩阵平移顶点坐标",charIndex:1540},{level:3,title:"平移和缩放复合变换",slug:"平移和缩放复合变换",normalizedTitle:"平移和缩放复合变换",charIndex:1934}],headersStr:"WGSL矩阵语法：矩阵 WGSLmat4x4()表示缩放矩阵 顶点着色器缩放矩阵缩放顶点坐标 平移矩阵平移顶点坐标 平移和缩放复合变换",content:"# 顶点着色器矩阵变换\n\n先回顾下1.5节关于WebGPU渲染管线顶点着色器功能单元的讲解。\n\n\n\n\n\n下面就给大家演示一个案例，通过顶点着色器对所有的顶点位置坐标，进行缩放变换。\n\n\n# WGSL矩阵语法：矩阵\n\n写WebGPU案例之前，先来熟悉一个WGSL相关的语法，就是特殊数据类型矩阵，矩阵的语法可以参考，前面1.4.WGSL语法关于向量vec3或vec4的讲解，基本相似。\n\n2x2矩阵：mat2x2\n\n3x3矩阵：mat3x3\n\n4x4矩阵：mat4x4\n\n// 一个2乘2矩阵\n//a  b  \n//c  d\n// 矩阵元素一列一列输入mat2x2<f32>()\nmat2x2<f32>(a,c,b,d)\n\n\n\n# WGSLmat4x4<f32>()表示缩放矩阵\n\nmat4x4<f32>()创建一个4x4缩放矩阵(沿着x、y分别缩放0.5倍)。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n    //0.5  0    0    0\n    //0    0.5  0    0\n    //0    0    1    0\n    //0    0    0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var S = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n}\n\n\n\n# 顶点着色器缩放矩阵缩放顶点坐标\n\nWGSL顶点着色器中，4x4缩放矩阵mat4x4对顶点坐标缩放变换。\n\n在WebGPU渲染管线上，所有的顶点坐标，都会被缩放矩阵改变。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n    //0.5  0    0    0\n    //0    0.5  0    0\n    //0    0    1    0\n    //0    0    0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var S = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n    var pos2 = vec4<f32>(pos,1.0);//pos转齐次坐标\n    pos2 = S * pos2;//缩放矩阵对顶点缩放变换\n    return pos2;\n}\n\n\n不声明变量pos2，直接执行return S * vec4<f32>(pos,1.0);\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n    var S = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n    return S * vec4<f32>(pos,1.0);//缩放矩阵对顶点缩放变换\n}\n\n\n\n# 平移矩阵平移顶点坐标\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个平移矩阵(沿着x、y轴分别平移-1、-1)\n    //1   0   0    -1\n    //0   1   0    -1\n    //0   0   1    0\n    //0   0   0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var T = mat4x4<f32>(1.0,0.0,0.0,0.0,  0.0,1.0,0.0,0.0,  0.0,0.0,1.0,0.0,  -1.0,-1.0,0.0,1.0);\n    return T * vec4<f32>(pos,1.0);//平移矩阵对顶点平移变换\n}\n\n\n\n# 平移和缩放复合变换\n\n写下面代码之前，先回顾下2.2小节模型矩阵中，关于几何变换顺序对结果的影响。\n\n先平移、后缩放\n\n// 先平移、后缩放(矩阵顺序从右往左)\nreturn S * T * vec4<f32>(pos,1.0);\n\n\n先缩放、后平移\n\n// 先缩放、后平移(矩阵顺序从右往左)\nreturn T * S * vec4<f32>(pos,1.0);\n\n\n注意矩阵顺序，影响实际变换结果，你可以通过WebGPU的案例代码测试对比。",normalizedContent:"# 顶点着色器矩阵变换\n\n先回顾下1.5节关于webgpu渲染管线顶点着色器功能单元的讲解。\n\n\n\n\n\n下面就给大家演示一个案例，通过顶点着色器对所有的顶点位置坐标，进行缩放变换。\n\n\n# wgsl矩阵语法：矩阵\n\n写webgpu案例之前，先来熟悉一个wgsl相关的语法，就是特殊数据类型矩阵，矩阵的语法可以参考，前面1.4.wgsl语法关于向量vec3或vec4的讲解，基本相似。\n\n2x2矩阵：mat2x2\n\n3x3矩阵：mat3x3\n\n4x4矩阵：mat4x4\n\n// 一个2乘2矩阵\n//a  b  \n//c  d\n// 矩阵元素一列一列输入mat2x2<f32>()\nmat2x2<f32>(a,c,b,d)\n\n\n\n# wgslmat4x4<f32>()表示缩放矩阵\n\nmat4x4<f32>()创建一个4x4缩放矩阵(沿着x、y分别缩放0.5倍)。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n    //0.5  0    0    0\n    //0    0.5  0    0\n    //0    0    1    0\n    //0    0    0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var s = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n}\n\n\n\n# 顶点着色器缩放矩阵缩放顶点坐标\n\nwgsl顶点着色器中，4x4缩放矩阵mat4x4对顶点坐标缩放变换。\n\n在webgpu渲染管线上，所有的顶点坐标，都会被缩放矩阵改变。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n    //0.5  0    0    0\n    //0    0.5  0    0\n    //0    0    1    0\n    //0    0    0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var s = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n    var pos2 = vec4<f32>(pos,1.0);//pos转齐次坐标\n    pos2 = s * pos2;//缩放矩阵对顶点缩放变换\n    return pos2;\n}\n\n\n不声明变量pos2，直接执行return s * vec4<f32>(pos,1.0);\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n    var s = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n    return s * vec4<f32>(pos,1.0);//缩放矩阵对顶点缩放变换\n}\n\n\n\n# 平移矩阵平移顶点坐标\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个平移矩阵(沿着x、y轴分别平移-1、-1)\n    //1   0   0    -1\n    //0   1   0    -1\n    //0   0   1    0\n    //0   0   0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var t = mat4x4<f32>(1.0,0.0,0.0,0.0,  0.0,1.0,0.0,0.0,  0.0,0.0,1.0,0.0,  -1.0,-1.0,0.0,1.0);\n    return t * vec4<f32>(pos,1.0);//平移矩阵对顶点平移变换\n}\n\n\n\n# 平移和缩放复合变换\n\n写下面代码之前，先回顾下2.2小节模型矩阵中，关于几何变换顺序对结果的影响。\n\n先平移、后缩放\n\n// 先平移、后缩放(矩阵顺序从右往左)\nreturn s * t * vec4<f32>(pos,1.0);\n\n\n先缩放、后平移\n\n// 先缩放、后平移(矩阵顺序从右往左)\nreturn t * s * vec4<f32>(pos,1.0);\n\n\n注意矩阵顺序，影响实际变换结果，你可以通过webgpu的案例代码测试对比。",charsets:{cjk:!0}},{title:"3. gl-matrix数学计算库",frontmatter:{title:"3. gl-matrix数学计算库",date:"2023-04-25T11:56:52.000Z",permalink:"/pages/473326/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/03.gl-matrix%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%BA%93.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/03.gl-matrix数学计算库.md",key:"v-42bac2c6",path:"/pages/473326/",headers:[{level:3,title:"引入gl-matrix.js库",slug:"引入gl-matrix-js库",normalizedTitle:"引入gl-matrix.js库",charIndex:270},{level:3,title:"glMatrix.mat4.fromValues()创建4x4矩阵",slug:"glmatrix-mat4-fromvalues-创建4x4矩阵",normalizedTitle:"glmatrix.mat4.fromvalues()创建4x4矩阵",charIndex:880},{level:3,title:"glMatrix.mat4.create()创建单位矩阵",slug:"glmatrix-mat4-create-创建单位矩阵",normalizedTitle:"glmatrix.mat4.create()创建单位矩阵",charIndex:1536},{level:3,title:"代码生成平移矩阵",slug:"代码生成平移矩阵",normalizedTitle:"代码生成平移矩阵",charIndex:1678},{level:3,title:"代码生成缩放矩阵",slug:"代码生成缩放矩阵",normalizedTitle:"代码生成缩放矩阵",charIndex:2041},{level:3,title:"代码生成旋转矩阵",slug:"代码生成旋转矩阵",normalizedTitle:"代码生成旋转矩阵",charIndex:2220},{level:3,title:"矩阵乘法运算.multiply(),生成模型矩阵",slug:"矩阵乘法运算-multiply-生成模型矩阵",normalizedTitle:"矩阵乘法运算.multiply(),生成模型矩阵",charIndex:2751},{level:3,title:"简化写法生成模型矩阵",slug:"简化写法生成模型矩阵",normalizedTitle:"简化写法生成模型矩阵",charIndex:3218},{level:3,title:"三维向量vec3",slug:"三维向量vec3",normalizedTitle:"三维向量vec3",charIndex:3496},{level:3,title:"vec3进行进行矩阵变换.transformMat4()",slug:"vec3进行进行矩阵变换-transformmat4",normalizedTitle:"vec3进行进行矩阵变换.transformmat4()",charIndex:3679}],headersStr:"引入gl-matrix.js库 glMatrix.mat4.fromValues()创建4x4矩阵 glMatrix.mat4.create()创建单位矩阵 代码生成平移矩阵 代码生成缩放矩阵 代码生成旋转矩阵 矩阵乘法运算.multiply(),生成模型矩阵 简化写法生成模型矩阵 三维向量vec3 vec3进行进行矩阵变换.transformMat4()",content:"# gl-matrix数学计算库\n\n通过前面两节课学习，咱们了解了一些矩阵的概念，不过学习WebGPU课程过程中，没必要自己写这些数学算法，可以借助一个开源库gl-matrix,gl-matrix提供了矩阵、向量、四元数等等与图形学相关的数学计算函数，你直接调用即可。\n\n\n\ngl-matrix github地址：https://github.com/toji/gl-matrix\n\ngl-matrix官网：http://glmatrix.net/\n\ngl-matrix官网文档：http://glmatrix.net/docs/\n\n\n# 引入gl-matrix.js库\n\nnpm install gl-matrix -S\nimport * as glMatix from 'gl-matrix'\n\n\ngithub下载gl-matrix文件，可以在dist目录下看到gl-matrix.js和gl-matrix.min.js两个文件，两个文件内容一样，区在别于matrix.min.js是matrix.js的压缩文件，文件体积更小。\n\n\x3c!-- 引入gl-matrix.js库 --\x3e\n<script  src=\"./gl-matrix-master/dist/gl-matrix.js\"><\/script>\n\n\nes6语法import方式引入\n\n<script type=\"module\">\n    import * as glMatrix from './gl-matrix-master/dist/esm/index.js'\n    console.log('glMatrix.mat4', glMatrix.mat4);   \n <\/script>\n\n\n只引入mat4矩阵API\n\n<script type=\"module\">\n    import { mat4 } from './gl-matrix-master/dist/esm/index.js'\n    console.log('mat4', mat4); \n <\/script>\n\n\n\n# glMatrix.mat4.fromValues()创建4x4矩阵\n\n通过.fromValues()方法创建矩阵的时候，输入矩阵参数的顺序是按照矩阵列的顺序，一列一列输入到.fromValues()方法的参数。\n\n// 创建一个平移矩阵(沿着x、y、z轴分别平移1、2、3)\n//1   0   0    1\n//0   1   0    2\n//0   0   1    3\n//0   0   0    1\n//把矩阵按照列依次写入作为参数\nconst mat4T = glMatrix.mat4.fromValues(1,0,0,0,  0,1,0,0,  0,0,1,0,  1,2,3,1);\n\n\n//创建一个缩放矩阵(x、y、z分别缩放1、2、3) \n//1   0   0    0\n//0   2   0    0\n//0   0   3    0\n//0   0   0    1\n//把矩阵按照列依次写入作为参数\nconst mat4S = glMatrix.mat4.fromValues(1,0,0,0,  0,2,0,0,  0,0,3,0,  0,0,0,1);\n\n\n通过浏览器控制台打印结果可以判断，glMatrix对象的相关方法创建的矩阵是通过类型化数据对象Float32Array表示。\n\n// 创建的矩阵其实就是用JavaScript的类型化数组表示的\nconsole.log('mat4T',mat4T);\nconsole.log('mat4S',mat4S);\n\n\n\n# glMatrix.mat4.create()创建单位矩阵\n\nglMatrix.mat4.create()创建的是4x4单位矩阵。\n\n\n\nconst mat4 = glMatrix.mat4.create();//单位矩阵\nconsole.log('mat4',mat4);\n\n\n\n# 代码生成平移矩阵\n\n执行mat4.translate(mat4T,mat4,[2,0,0])表示根据参数3([2,0,0])创建一个沿着x轴平移2的平移矩阵，然后参数2(mat4)乘平移矩阵，计算结果赋值给参数1(mat4T)，mat4是单位矩阵不会改变平移矩阵。\n\n参数2(mat4)是单位矩阵，不会影响参数3([2,0,0])生成的平移矩阵。\n\nconst mat4 = glMatrix.mat4.create();//单位矩阵，辅助创建平移矩阵\n// 创建一个平移矩阵(沿着x平移2)\nconst mat4T = glMatrix.mat4.create();\nglMatrix.mat4.translate(mat4T,mat4,[2,0,0]);\nconsole.log('mat4T',mat4T);\n\n\n\n# 代码生成缩放矩阵\n\nconst mat4 = glMatrix.mat4.create();\n// 创建一个缩放矩阵(x缩放10) \nconst mat4S = glMatrix.mat4.create();\nglMatrix.mat4.scale(mat4S,mat4,[10,1,1]);\nconsole.log('mat4S',mat4S)\n\n\n\n# 代码生成旋转矩阵\n\nconst mat4 = glMatrix.mat4.create();\n// 生成一个旋转矩阵(绕z轴旋转45度) \nconst mat4X = glMatrix.mat4.create();\nglMatrix.mat4.rotateX(mat4X,mat4,Math.PI/4);\nconsole.log('mat4X',mat4X);\n\n\nconst mat4 = glMatrix.mat4.create();\n// 生成一个旋转矩阵(绕z轴旋转45度) \nconst mat4Y = glMatrix.mat4.create();\nglMatrix.mat4.rotateY(mat4Y,mat4,Math.PI/4);\nconsole.log('mat4Y',mat4Y);\n\n\nconst mat4 = glMatrix.mat4.create();\n// 生成一个旋转矩阵(绕z轴旋转45度) \nconst mat4Z = glMatrix.mat4.create();\nglMatrix.mat4.rotateZ(mat4Z,mat4,Math.PI/4);\nconsole.log('mat4Z',mat4Z)\n\n\n\n# 矩阵乘法运算.multiply(),生成模型矩阵\n\n// 创建一个平移矩阵(沿着x平移2)\nconst mat4T = glMatrix.mat4.create();\nglMatrix.mat4.translate(mat4T,mat4,[2,0,0]);\n// 创建一个缩放矩阵(x缩放10) \nconst mat4S = glMatrix.mat4.create();\nglMatrix.mat4.scale(mat4S,mat4,[10,1,1]);\n\n\n// 矩阵乘法运算.multiply()\nconst modelMatrix = glMatrix.mat4.create();//模型矩阵\nglMatrix.mat4.multiply(modelMatrix,modelMatrix,mat4S);//后缩放\nglMatrix.mat4.multiply(modelMatrix,modelMatrix,mat4T);//先平移\nconsole.log('modelMatrix',modelMatrix);\n\n\n\n# 简化写法生成模型矩阵\n\n顶点先平移、后缩放\n\n沿着x平移2\n\nx方向缩放10倍\n\nconst modelMatrix = glMatrix.mat4.create();\n//后发生缩放变换，先乘\nglMatrix.mat4.scale(modelMatrix, modelMatrix, [10, 1, 1]);\n//先发生平移变换，后乘\nglMatrix.mat4.translate(modelMatrix, modelMatrix, [2, 0, 0]);\nconsole.log('modelMatrix', modelMatrix);\n\n\n\n# 三维向量vec3\n\n三维向量vec3有三个分量，可以表示多种值，下面用vec3表示顶点xyz坐标\n\n//p1表示一个顶点的坐标\nconst p1 = glMatrix.vec3.fromValues(2, 0, 0);\nconst p2 = glMatrix.vec3.create();//默认(0,0,0)\nconsole.log('p2',p2);\n\n\n\n# vec3进行进行矩阵变换.transformMat4()\n\n通过.transformMat4()方法可以实现对表示点坐标的三维向量vec3进行矩阵变换。\n\n// 顶点先平移、后缩放\nconst modelMatrix = glMatrix.mat4.create();\nglMatrix.mat4.scale(modelMatrix, modelMatrix, [10, 1, 1]);\nglMatrix.mat4.translate(modelMatrix, modelMatrix, [2, 0, 0])\n\n\n//p1表示一个顶点的坐标\nconst p1 = glMatrix.vec3.fromValues(2, 0, 0);\nconst p2 = glMatrix.vec3.create();//默认(0,0,0)\nconsole.log('p2',p2);\n//p1矩阵变换，变换后结果存储在p2\nglMatrix.vec3.transformMat4(p2, p1, modelMatrix);\nconsole.log('p2', p2);//Float32Array(3) [40, 0, 0]\n",normalizedContent:"# gl-matrix数学计算库\n\n通过前面两节课学习，咱们了解了一些矩阵的概念，不过学习webgpu课程过程中，没必要自己写这些数学算法，可以借助一个开源库gl-matrix,gl-matrix提供了矩阵、向量、四元数等等与图形学相关的数学计算函数，你直接调用即可。\n\n\n\ngl-matrix github地址：https://github.com/toji/gl-matrix\n\ngl-matrix官网：http://glmatrix.net/\n\ngl-matrix官网文档：http://glmatrix.net/docs/\n\n\n# 引入gl-matrix.js库\n\nnpm install gl-matrix -s\nimport * as glmatix from 'gl-matrix'\n\n\ngithub下载gl-matrix文件，可以在dist目录下看到gl-matrix.js和gl-matrix.min.js两个文件，两个文件内容一样，区在别于matrix.min.js是matrix.js的压缩文件，文件体积更小。\n\n\x3c!-- 引入gl-matrix.js库 --\x3e\n<script  src=\"./gl-matrix-master/dist/gl-matrix.js\"><\/script>\n\n\nes6语法import方式引入\n\n<script type=\"module\">\n    import * as glmatrix from './gl-matrix-master/dist/esm/index.js'\n    console.log('glmatrix.mat4', glmatrix.mat4);   \n <\/script>\n\n\n只引入mat4矩阵api\n\n<script type=\"module\">\n    import { mat4 } from './gl-matrix-master/dist/esm/index.js'\n    console.log('mat4', mat4); \n <\/script>\n\n\n\n# glmatrix.mat4.fromvalues()创建4x4矩阵\n\n通过.fromvalues()方法创建矩阵的时候，输入矩阵参数的顺序是按照矩阵列的顺序，一列一列输入到.fromvalues()方法的参数。\n\n// 创建一个平移矩阵(沿着x、y、z轴分别平移1、2、3)\n//1   0   0    1\n//0   1   0    2\n//0   0   1    3\n//0   0   0    1\n//把矩阵按照列依次写入作为参数\nconst mat4t = glmatrix.mat4.fromvalues(1,0,0,0,  0,1,0,0,  0,0,1,0,  1,2,3,1);\n\n\n//创建一个缩放矩阵(x、y、z分别缩放1、2、3) \n//1   0   0    0\n//0   2   0    0\n//0   0   3    0\n//0   0   0    1\n//把矩阵按照列依次写入作为参数\nconst mat4s = glmatrix.mat4.fromvalues(1,0,0,0,  0,2,0,0,  0,0,3,0,  0,0,0,1);\n\n\n通过浏览器控制台打印结果可以判断，glmatrix对象的相关方法创建的矩阵是通过类型化数据对象float32array表示。\n\n// 创建的矩阵其实就是用javascript的类型化数组表示的\nconsole.log('mat4t',mat4t);\nconsole.log('mat4s',mat4s);\n\n\n\n# glmatrix.mat4.create()创建单位矩阵\n\nglmatrix.mat4.create()创建的是4x4单位矩阵。\n\n\n\nconst mat4 = glmatrix.mat4.create();//单位矩阵\nconsole.log('mat4',mat4);\n\n\n\n# 代码生成平移矩阵\n\n执行mat4.translate(mat4t,mat4,[2,0,0])表示根据参数3([2,0,0])创建一个沿着x轴平移2的平移矩阵，然后参数2(mat4)乘平移矩阵，计算结果赋值给参数1(mat4t)，mat4是单位矩阵不会改变平移矩阵。\n\n参数2(mat4)是单位矩阵，不会影响参数3([2,0,0])生成的平移矩阵。\n\nconst mat4 = glmatrix.mat4.create();//单位矩阵，辅助创建平移矩阵\n// 创建一个平移矩阵(沿着x平移2)\nconst mat4t = glmatrix.mat4.create();\nglmatrix.mat4.translate(mat4t,mat4,[2,0,0]);\nconsole.log('mat4t',mat4t);\n\n\n\n# 代码生成缩放矩阵\n\nconst mat4 = glmatrix.mat4.create();\n// 创建一个缩放矩阵(x缩放10) \nconst mat4s = glmatrix.mat4.create();\nglmatrix.mat4.scale(mat4s,mat4,[10,1,1]);\nconsole.log('mat4s',mat4s)\n\n\n\n# 代码生成旋转矩阵\n\nconst mat4 = glmatrix.mat4.create();\n// 生成一个旋转矩阵(绕z轴旋转45度) \nconst mat4x = glmatrix.mat4.create();\nglmatrix.mat4.rotatex(mat4x,mat4,math.pi/4);\nconsole.log('mat4x',mat4x);\n\n\nconst mat4 = glmatrix.mat4.create();\n// 生成一个旋转矩阵(绕z轴旋转45度) \nconst mat4y = glmatrix.mat4.create();\nglmatrix.mat4.rotatey(mat4y,mat4,math.pi/4);\nconsole.log('mat4y',mat4y);\n\n\nconst mat4 = glmatrix.mat4.create();\n// 生成一个旋转矩阵(绕z轴旋转45度) \nconst mat4z = glmatrix.mat4.create();\nglmatrix.mat4.rotatez(mat4z,mat4,math.pi/4);\nconsole.log('mat4z',mat4z)\n\n\n\n# 矩阵乘法运算.multiply(),生成模型矩阵\n\n// 创建一个平移矩阵(沿着x平移2)\nconst mat4t = glmatrix.mat4.create();\nglmatrix.mat4.translate(mat4t,mat4,[2,0,0]);\n// 创建一个缩放矩阵(x缩放10) \nconst mat4s = glmatrix.mat4.create();\nglmatrix.mat4.scale(mat4s,mat4,[10,1,1]);\n\n\n// 矩阵乘法运算.multiply()\nconst modelmatrix = glmatrix.mat4.create();//模型矩阵\nglmatrix.mat4.multiply(modelmatrix,modelmatrix,mat4s);//后缩放\nglmatrix.mat4.multiply(modelmatrix,modelmatrix,mat4t);//先平移\nconsole.log('modelmatrix',modelmatrix);\n\n\n\n# 简化写法生成模型矩阵\n\n顶点先平移、后缩放\n\n沿着x平移2\n\nx方向缩放10倍\n\nconst modelmatrix = glmatrix.mat4.create();\n//后发生缩放变换，先乘\nglmatrix.mat4.scale(modelmatrix, modelmatrix, [10, 1, 1]);\n//先发生平移变换，后乘\nglmatrix.mat4.translate(modelmatrix, modelmatrix, [2, 0, 0]);\nconsole.log('modelmatrix', modelmatrix);\n\n\n\n# 三维向量vec3\n\n三维向量vec3有三个分量，可以表示多种值，下面用vec3表示顶点xyz坐标\n\n//p1表示一个顶点的坐标\nconst p1 = glmatrix.vec3.fromvalues(2, 0, 0);\nconst p2 = glmatrix.vec3.create();//默认(0,0,0)\nconsole.log('p2',p2);\n\n\n\n# vec3进行进行矩阵变换.transformmat4()\n\n通过.transformmat4()方法可以实现对表示点坐标的三维向量vec3进行矩阵变换。\n\n// 顶点先平移、后缩放\nconst modelmatrix = glmatrix.mat4.create();\nglmatrix.mat4.scale(modelmatrix, modelmatrix, [10, 1, 1]);\nglmatrix.mat4.translate(modelmatrix, modelmatrix, [2, 0, 0])\n\n\n//p1表示一个顶点的坐标\nconst p1 = glmatrix.vec3.fromvalues(2, 0, 0);\nconst p2 = glmatrix.vec3.create();//默认(0,0,0)\nconsole.log('p2',p2);\n//p1矩阵变换，变换后结果存储在p2\nglmatrix.vec3.transformmat4(p2, p1, modelmatrix);\nconsole.log('p2', p2);//float32array(3) [40, 0, 0]\n",charsets:{cjk:!0}},{title:"5. WebGPU传递uniform数据",frontmatter:{title:"5. WebGPU传递uniform数据",date:"2023-05-19T09:40:12.000Z",permalink:"/pages/a1aa0e/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/05.WebGPU%E4%BC%A0%E9%80%92uniform%E6%95%B0%E6%8D%AE.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/05.WebGPU传递uniform数据.md",key:"v-4e577efe",path:"/pages/a1aa0e/",headers:[{level:3,title:"顶点缓冲区知识点回顾",slug:"顶点缓冲区知识点回顾",normalizedTitle:"顶点缓冲区知识点回顾",charIndex:196},{level:3,title:"类型化数组表示缩放矩阵数据",slug:"类型化数组表示缩放矩阵数据",normalizedTitle:"类型化数组表示缩放矩阵数据",charIndex:686},{level:3,title:"创建uniform数据的缓冲区",slug:"创建uniform数据的缓冲区",normalizedTitle:"创建uniform数据的缓冲区",charIndex:1426},{level:3,title:"uniform数据写入到uniform缓冲区中",slug:"uniform数据写入到uniform缓冲区中",normalizedTitle:"uniform数据写入到uniform缓冲区中",charIndex:1988},{level:3,title:"设置uniform数据的绑定组",slug:"设置uniform数据的绑定组",normalizedTitle:"设置uniform数据的绑定组",charIndex:2189},{level:3,title:"WGSL着色器代码声明uniform变量",slug:"wgsl着色器代码声明uniform变量",normalizedTitle:"wgsl着色器代码声明uniform变量",charIndex:2600},{level:3,title:".setBindGroup()传递uniform数据",slug:"setbindgroup-传递uniform数据",normalizedTitle:".setbindgroup()传递uniform数据",charIndex:3605},{level:3,title:"传递一个uniform浮点数数据",slug:"传递一个uniform浮点数数据",normalizedTitle:"传递一个uniform浮点数数据",charIndex:3906},{level:3,title:"练习题：给片元着色器传递颜色数据",slug:"练习题-给片元着色器传递颜色数据",normalizedTitle:"练习题：给片元着色器传递颜色数据",charIndex:4722},{level:3,title:"练习题：传递两个矩阵数据",slug:"练习题-传递两个矩阵数据",normalizedTitle:"练习题：传递两个矩阵数据",charIndex:5970}],headersStr:"顶点缓冲区知识点回顾 类型化数组表示缩放矩阵数据 创建uniform数据的缓冲区 uniform数据写入到uniform缓冲区中 设置uniform数据的绑定组 WGSL着色器代码声明uniform变量 .setBindGroup()传递uniform数据 传递一个uniform浮点数数据 练习题：给片元着色器传递颜色数据 练习题：传递两个矩阵数据",content:"# WebGPU传递uniform数据\n\n前面给大家讲解过，通过JavaScript类型化数组创建顶点数据，然后把顶点数据传递给顶点着色器，本节课给大家讲解如何把uniform数据传递给顶点着色器或者片元着色器。\n\n比如上节课介绍的顶点着色器的缩放矩阵，是写在顶点着色器代码中的，你可以把shader代码中的缩放矩阵数据，放在JavaScript代码中，然后再传入到顶点着色器。\n\n\n\n\n# 顶点缓冲区知识点回顾\n\n把顶点数据在JavaScript代码中创建传入到顶点着色器中。\n\n//类型化数组表示顶点数据\nconst vertexArray = new Float32Array([0.0, 0.0, 0.0,1.0, 0.0, 0.0,0.0, 1.0, 0.0,]);\n// 创建存储顶点数据的顶点缓冲区\nconst vertexBuffer = device.createBuffer({\n    size: vertexArray.byteLength,//顶点数据的字节长度\n    //usage设置该缓冲区的用途\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n});\n//把vertexArray里面的顶点数据写入到vertexBuffer对应的GPU显存缓冲区中\ndevice.queue.writeBuffer(vertexBuffer, 0, vertexArray);\n\n\n你参考前面入门案例关于顶点数据传递的讲解，来理解本节课uniform传递矩阵数据的传递。\n\n\n# 类型化数组表示缩放矩阵数据\n\n上节课讲解的，在顶点着色器中创建了一个缩放矩阵。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n    //0.5  0    0    0\n    //0    0.5  0    0\n    //0    0    1    0\n    //0    0    0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var S = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n}\n\n\n缩放矩阵数据，从顶点着色器删除，写在JavaScript代码中。\n\n // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n //0.5  0    0    0\n //0    0.5  0    0\n //0    0    1    0\n //0    0    0    1\n const mat4Array = new Float32Array([\n     // 矩阵元素一列一列输入作为类型化数组的参数\n     0.5, 0.0, 0.0, 0.0, \n     0.0, 0.5, 0.0, 0.0, \n     0.0, 0.0, 1.0, 0.0, \n     0.0, 0.0, 0.0, 1.0\n])\n\n\n对于这样一个需要传入到着色器中的矩阵数据(非顶点数据)，你可以把他称为uniform数据。\n\n\n# 创建uniform数据的缓冲区\n\n创建uniform数据的缓冲区，和创建顶点缓冲区类似，都是使用.createBuffer(),其它的代码形式基本一样，注意参数属性usage的值,如果设置为GPUBufferUsage.VERTEX表示缓冲区用于存放顶点数据，GPUBufferUsage.UNIFORM表示缓冲区用于存放uniform数据(非顶点数据)。\n\n// 创建存储顶点数据的顶点缓冲区\nconst vertexBuffer = device.createBuffer({\n    size: vertexArray.byteLength,//顶点数据的字节长度\n    //GPUBufferUsage.VERTEX表示缓冲区用于顶点数据\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n});\n\n\n// 在GPU显存上创建一个uniform数据缓冲区\nconst mat4Buffer = device.createBuffer({\n    size: mat4Array.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\n\n\n\n\n\n# uniform数据写入到uniform缓冲区中\n\nniform数据写入到uniform缓冲区中，和前面顶点数据传入到顶点缓冲区中，使用的方法一样，都是device.queue.writeBuffer()。\n\n// mat4Array里面矩阵数据写入uniform缓冲区mat4Buffer\ndevice.queue.writeBuffer(mat4Buffer, 0, mat4Array)\n\n\n\n# 设置uniform数据的绑定组\n\n学习device.createBindGroup()的参数，可以类比渲染管线中.shaderLocation学习\n\nbinding的属性值，可以设置为0、1、2、3等值进行标记。\n\n// 设置uniform数据的绑定组\nconst bindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),//绑定组，标记为0\n    // 一个组里面可以包含多个uniform数据\n    entries: [//每个元素可以用来设置一个uniform数据\n        {\n            binding: 0,//标记组里面的uniform数据\n            resource: { buffer: mat4Buffer }\n        }\n    ]\n});\n\n\n\n# WGSL着色器代码声明uniform变量\n\n上节课缩放矩阵直接写在顶点着色器中，本节课案例，缩放矩阵写是JavaScript代码中，顶点着色器中只要在顶点着色器代码关键字@vertex之前，声明一个uniform变量表示缩放矩阵，不用赋值，注意使用<uniform>标记该变量，系统才会识别为uniform数据，这样才能通过WebGPU API把js代码中顶点数据传入顶点着色器代码中对应的uniform变量。\n\nvar<uniform> S:mat4x4<f32>;\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 上节课的缩放矩阵S\n    // var S = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n    return S * vec4<f32>(pos,1.0);//缩放矩阵对顶点缩放变换\n}\n\n\n与JavaScript代码中uniform缓冲区中uniform数据关联。\n\n//@group(0)的参数0对应webgpu代码.getBindGroupLayout(0)参数0\n//@binding(0)的参数对应webgpu代码.binding的值，保持一致，比如都是0\n@group(0) @binding(0) var<uniform> S:mat4<f32>;\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return S * vec4<f32>(pos,1.0);//缩放矩阵对顶点缩放变换\n}\n\n\nconst bindGroup = device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n        {\n            binding: 0,\n            resource: { buffer: mat4Buffer }\n        }\n    ]\n});\n\n\n\n# .setBindGroup()传递uniform数据\n\n// 顶点缓冲区数据和渲染管线shaderLocation: 0表示存储位置关联起来\nrenderPass.setVertexBuffer(0, vertexBuffer);\n\n\n.setBindGroup()传递uniform数据和.setVertexBuffer()传递顶点数据的使用方法类似。\n\n// 把绑定组里面的uniform数据传递给着色器中uniform变量\n// 参数1的0和.getBindGroupLayout(0)参数一致，都是0\nrenderPass.setBindGroup( 0, bindGroup );\n\n\n\n# 传递一个uniform浮点数数据\n\n声明一个uniform变量，表示三角形顶点坐标x和y方向缩放倍数\n\n\n@group(0) @binding(0) var<uniform> t:f32;\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放t倍)\n    //t    0    0    0\n    //0    t    0    0\n    //0    0    1    0\n    //0    0    0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var S = mat4x4<f32>(t,0.0,0.0,0.0,  0.0,t,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n    return S * vec4<f32>(pos,1.0);//缩放矩阵对顶点缩放变换\n}\n\n\n在JavaScript代码中创建，着色器代码中的uniform变量t对应的数据，就是一个浮点数\n\n// 创建uniform浮点数对应的缓冲区\nconst t = 0.5;//一个浮点数，表示三角形x和y两个方向的缩放倍数\nconst mat4Array = new Float32Array([t]);\nconst mat4Buffer = device.createBuffer({\n    size: mat4Array.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\ndevice.queue.writeBuffer(mat4Buffer, 0, mat4Array);\n\n\n\n# 练习题：给片元着色器传递颜色数据\n\n// 给片元着色器传递一个颜色数据\nconst colorArray = new Float32Array([0.0,1.0,0.0]);//绿色\n// 在GPU显存上创建一个uniform数据缓冲区\nconst colorBuffer = device.createBuffer({\n    size: colorArray.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\n// colorArray里面颜色数据写入uniform缓冲区colorBuffer\ndevice.queue.writeBuffer(colorBuffer, 0, colorArray);\n\n\n// 设置uniform数据的绑定组\n// 学习createBindGroup的参数，可以类比渲染管线中shaderLocation学习\nconst bindGroup = device.createBindGroup({\n    // .getBindGroupLayout(0)参数0对应shader中@group(0)代码的参数0\n    layout: pipeline.getBindGroupLayout(0),//绑定组，标记为0\n    // 一个组里面可以包含多个uniform数据\n    entries: [//每个元素可以用来设置一个uniform数据\n        {\n            //binding的值对应@binding(0)的参数，保持一致，比如都是0\n            binding: 0,//标记组里面的uniform数据\n            resource: { buffer: mat4Buffer }\n        },\n        {\n            //binding的值对应@binding(1)的参数，保持一致，比如都是1\n            binding: 1,//标记组里面的uniform数据\n            resource: { buffer: colorBuffer }\n        }\n    ]\n});\n\n\n// uniform关键字辅助var声明一个三维向量变量color表示片元颜色\n//@binding(1)的参数对应webgpu代码.binding的值，保持一致，比如都是1\n@group(0) @binding(1) var<uniform> color:vec3<f32>;\n@fragment\nfn main() -> @location(0) vec4<f32> {\n    // return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    return vec4<f32>(color, 1.0);\n}\n\n\n\n# 练习题：传递两个矩阵数据\n\n参考课件案例源码4",normalizedContent:"# webgpu传递uniform数据\n\n前面给大家讲解过，通过javascript类型化数组创建顶点数据，然后把顶点数据传递给顶点着色器，本节课给大家讲解如何把uniform数据传递给顶点着色器或者片元着色器。\n\n比如上节课介绍的顶点着色器的缩放矩阵，是写在顶点着色器代码中的，你可以把shader代码中的缩放矩阵数据，放在javascript代码中，然后再传入到顶点着色器。\n\n\n\n\n# 顶点缓冲区知识点回顾\n\n把顶点数据在javascript代码中创建传入到顶点着色器中。\n\n//类型化数组表示顶点数据\nconst vertexarray = new float32array([0.0, 0.0, 0.0,1.0, 0.0, 0.0,0.0, 1.0, 0.0,]);\n// 创建存储顶点数据的顶点缓冲区\nconst vertexbuffer = device.createbuffer({\n    size: vertexarray.bytelength,//顶点数据的字节长度\n    //usage设置该缓冲区的用途\n    usage: gpubufferusage.vertex | gpubufferusage.copy_dst,\n});\n//把vertexarray里面的顶点数据写入到vertexbuffer对应的gpu显存缓冲区中\ndevice.queue.writebuffer(vertexbuffer, 0, vertexarray);\n\n\n你参考前面入门案例关于顶点数据传递的讲解，来理解本节课uniform传递矩阵数据的传递。\n\n\n# 类型化数组表示缩放矩阵数据\n\n上节课讲解的，在顶点着色器中创建了一个缩放矩阵。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n    //0.5  0    0    0\n    //0    0.5  0    0\n    //0    0    1    0\n    //0    0    0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var s = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n}\n\n\n缩放矩阵数据，从顶点着色器删除，写在javascript代码中。\n\n // 创建一个缩放矩阵(沿着x、y分别缩放0.5倍)\n //0.5  0    0    0\n //0    0.5  0    0\n //0    0    1    0\n //0    0    0    1\n const mat4array = new float32array([\n     // 矩阵元素一列一列输入作为类型化数组的参数\n     0.5, 0.0, 0.0, 0.0, \n     0.0, 0.5, 0.0, 0.0, \n     0.0, 0.0, 1.0, 0.0, \n     0.0, 0.0, 0.0, 1.0\n])\n\n\n对于这样一个需要传入到着色器中的矩阵数据(非顶点数据)，你可以把他称为uniform数据。\n\n\n# 创建uniform数据的缓冲区\n\n创建uniform数据的缓冲区，和创建顶点缓冲区类似，都是使用.createbuffer(),其它的代码形式基本一样，注意参数属性usage的值,如果设置为gpubufferusage.vertex表示缓冲区用于存放顶点数据，gpubufferusage.uniform表示缓冲区用于存放uniform数据(非顶点数据)。\n\n// 创建存储顶点数据的顶点缓冲区\nconst vertexbuffer = device.createbuffer({\n    size: vertexarray.bytelength,//顶点数据的字节长度\n    //gpubufferusage.vertex表示缓冲区用于顶点数据\n    usage: gpubufferusage.vertex | gpubufferusage.copy_dst,\n});\n\n\n// 在gpu显存上创建一个uniform数据缓冲区\nconst mat4buffer = device.createbuffer({\n    size: mat4array.bytelength,\n    usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\n\n\n\n\n\n# uniform数据写入到uniform缓冲区中\n\nniform数据写入到uniform缓冲区中，和前面顶点数据传入到顶点缓冲区中，使用的方法一样，都是device.queue.writebuffer()。\n\n// mat4array里面矩阵数据写入uniform缓冲区mat4buffer\ndevice.queue.writebuffer(mat4buffer, 0, mat4array)\n\n\n\n# 设置uniform数据的绑定组\n\n学习device.createbindgroup()的参数，可以类比渲染管线中.shaderlocation学习\n\nbinding的属性值，可以设置为0、1、2、3等值进行标记。\n\n// 设置uniform数据的绑定组\nconst bindgroup = device.createbindgroup({\n    layout: pipeline.getbindgrouplayout(0),//绑定组，标记为0\n    // 一个组里面可以包含多个uniform数据\n    entries: [//每个元素可以用来设置一个uniform数据\n        {\n            binding: 0,//标记组里面的uniform数据\n            resource: { buffer: mat4buffer }\n        }\n    ]\n});\n\n\n\n# wgsl着色器代码声明uniform变量\n\n上节课缩放矩阵直接写在顶点着色器中，本节课案例，缩放矩阵写是javascript代码中，顶点着色器中只要在顶点着色器代码关键字@vertex之前，声明一个uniform变量表示缩放矩阵，不用赋值，注意使用<uniform>标记该变量，系统才会识别为uniform数据，这样才能通过webgpu api把js代码中顶点数据传入顶点着色器代码中对应的uniform变量。\n\nvar<uniform> s:mat4x4<f32>;\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 上节课的缩放矩阵s\n    // var s = mat4x4<f32>(0.5,0.0,0.0,0.0,  0.0,0.5,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n    return s * vec4<f32>(pos,1.0);//缩放矩阵对顶点缩放变换\n}\n\n\n与javascript代码中uniform缓冲区中uniform数据关联。\n\n//@group(0)的参数0对应webgpu代码.getbindgrouplayout(0)参数0\n//@binding(0)的参数对应webgpu代码.binding的值，保持一致，比如都是0\n@group(0) @binding(0) var<uniform> s:mat4<f32>;\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return s * vec4<f32>(pos,1.0);//缩放矩阵对顶点缩放变换\n}\n\n\nconst bindgroup = device.createbindgroup({\n    layout: pipeline.getbindgrouplayout(0),\n    entries: [\n        {\n            binding: 0,\n            resource: { buffer: mat4buffer }\n        }\n    ]\n});\n\n\n\n# .setbindgroup()传递uniform数据\n\n// 顶点缓冲区数据和渲染管线shaderlocation: 0表示存储位置关联起来\nrenderpass.setvertexbuffer(0, vertexbuffer);\n\n\n.setbindgroup()传递uniform数据和.setvertexbuffer()传递顶点数据的使用方法类似。\n\n// 把绑定组里面的uniform数据传递给着色器中uniform变量\n// 参数1的0和.getbindgrouplayout(0)参数一致，都是0\nrenderpass.setbindgroup( 0, bindgroup );\n\n\n\n# 传递一个uniform浮点数数据\n\n声明一个uniform变量，表示三角形顶点坐标x和y方向缩放倍数\n\n\n@group(0) @binding(0) var<uniform> t:f32;\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    // 创建一个缩放矩阵(沿着x、y分别缩放t倍)\n    //t    0    0    0\n    //0    t    0    0\n    //0    0    1    0\n    //0    0    0    1\n    // 矩阵元素一列一列输入mat4x4<f32>()\n    var s = mat4x4<f32>(t,0.0,0.0,0.0,  0.0,t,0.0,0.0,  0.0,0.0,1.0,0.0,  0.0,0.0,0.0,1.0);\n    return s * vec4<f32>(pos,1.0);//缩放矩阵对顶点缩放变换\n}\n\n\n在javascript代码中创建，着色器代码中的uniform变量t对应的数据，就是一个浮点数\n\n// 创建uniform浮点数对应的缓冲区\nconst t = 0.5;//一个浮点数，表示三角形x和y两个方向的缩放倍数\nconst mat4array = new float32array([t]);\nconst mat4buffer = device.createbuffer({\n    size: mat4array.bytelength,\n    usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\ndevice.queue.writebuffer(mat4buffer, 0, mat4array);\n\n\n\n# 练习题：给片元着色器传递颜色数据\n\n// 给片元着色器传递一个颜色数据\nconst colorarray = new float32array([0.0,1.0,0.0]);//绿色\n// 在gpu显存上创建一个uniform数据缓冲区\nconst colorbuffer = device.createbuffer({\n    size: colorarray.bytelength,\n    usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\n// colorarray里面颜色数据写入uniform缓冲区colorbuffer\ndevice.queue.writebuffer(colorbuffer, 0, colorarray);\n\n\n// 设置uniform数据的绑定组\n// 学习createbindgroup的参数，可以类比渲染管线中shaderlocation学习\nconst bindgroup = device.createbindgroup({\n    // .getbindgrouplayout(0)参数0对应shader中@group(0)代码的参数0\n    layout: pipeline.getbindgrouplayout(0),//绑定组，标记为0\n    // 一个组里面可以包含多个uniform数据\n    entries: [//每个元素可以用来设置一个uniform数据\n        {\n            //binding的值对应@binding(0)的参数，保持一致，比如都是0\n            binding: 0,//标记组里面的uniform数据\n            resource: { buffer: mat4buffer }\n        },\n        {\n            //binding的值对应@binding(1)的参数，保持一致，比如都是1\n            binding: 1,//标记组里面的uniform数据\n            resource: { buffer: colorbuffer }\n        }\n    ]\n});\n\n\n// uniform关键字辅助var声明一个三维向量变量color表示片元颜色\n//@binding(1)的参数对应webgpu代码.binding的值，保持一致，比如都是1\n@group(0) @binding(1) var<uniform> color:vec3<f32>;\n@fragment\nfn main() -> @location(0) vec4<f32> {\n    // return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    return vec4<f32>(color, 1.0);\n}\n\n\n\n# 练习题：传递两个矩阵数据\n\n参考课件案例源码4",charsets:{cjk:!0}},{title:"2. 模型矩阵",frontmatter:{title:"2. 模型矩阵",date:"2023-04-24T23:56:14.000Z",permalink:"/pages/47d092/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/02.%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/02.模型矩阵.md",key:"v-50c7990a",path:"/pages/47d092/",headers:[{level:3,title:"几何变换顺序对结果的影响",slug:"几何变换顺序对结果的影响",normalizedTitle:"几何变换顺序对结果的影响",charIndex:93},{level:3,title:"矩阵表示(先平移、后缩放)",slug:"矩阵表示-先平移、后缩放",normalizedTitle:"矩阵表示(先平移、后缩放)",charIndex:285},{level:3,title:"单位矩阵",slug:"单位矩阵",normalizedTitle:"单位矩阵",charIndex:668}],headersStr:"几何变换顺序对结果的影响 矩阵表示(先平移、后缩放) 单位矩阵",content:"# 模型矩阵\n\n在图形学中经常会提到模型矩阵的概念，其实模型矩阵就是咱们上节课介绍的平移矩阵、旋转矩阵、缩放矩阵的统称，或者说模型矩阵是平移、缩放、旋转矩阵相乘得到的复合矩阵。\n\n\n# 几何变换顺序对结果的影响\n\n假设一个顶点原始坐标(2,0,0)。\n\n先平移2、后缩放10：如果先沿着x轴平移2，变为(4,0,0)，再x轴方向缩放10倍，最终坐标是(40,0,0)。\n\n先缩放10、后平移2：如果先x轴方向缩放10倍，变为(20,0,0)，再沿着x轴平移2，最终坐标是(22,0,0)。\n\n你可以发现上面同样的平移和缩放，顺序不同，变换后的顶点坐标也不相同。\n\n\n# 矩阵表示(先平移、后缩放)\n\n假设一个顶点原始坐标(2,0,0),先沿着x轴平移2，变为(4,0,0)，再x轴方向缩放10倍，最终坐标是(40,0,0)。这个过程可以用上节课介绍的矩阵乘法运算去表示。\n\n\n\n模型矩阵：先计算所有几何变换对应矩阵的乘积，得到一个模型矩阵，再对顶点坐标进行变换。\n\n先把顶点几何变换对应的所有矩阵进行乘法运算，得到一个新的复合矩阵(模型矩阵)，这个模型矩阵可以用来表示顶点坐标所有的几何变换。\n\n\n\n把上面缩放矩阵和平移矩阵的顺序调换，重新计算结果，你会发现，和上面计算的模型矩阵不同，变换后坐标也不是(40,0,0),而是(22,0,0)。\n\n\n\n这就是告诉大家，矩阵的乘法运算，不满足交换律，矩阵顺序，不能随意设置，先发生的平移矩阵，放在后面，后发生的缩放矩阵放在前面，或者说，先发生的平移矩阵，更靠近顶点的齐次坐标。\n\n\n\n\n# 单位矩阵\n\n单位矩阵就是对角线上都为1，其它为0的矩阵。\n\n\n\n单位矩阵乘其它矩阵，或者其它矩阵成单位矩阵，新矩阵都和其它矩阵一样，不受范围矩阵影响，单位矩阵有点类似自然数加减乘除的1。\n\n",normalizedContent:"# 模型矩阵\n\n在图形学中经常会提到模型矩阵的概念，其实模型矩阵就是咱们上节课介绍的平移矩阵、旋转矩阵、缩放矩阵的统称，或者说模型矩阵是平移、缩放、旋转矩阵相乘得到的复合矩阵。\n\n\n# 几何变换顺序对结果的影响\n\n假设一个顶点原始坐标(2,0,0)。\n\n先平移2、后缩放10：如果先沿着x轴平移2，变为(4,0,0)，再x轴方向缩放10倍，最终坐标是(40,0,0)。\n\n先缩放10、后平移2：如果先x轴方向缩放10倍，变为(20,0,0)，再沿着x轴平移2，最终坐标是(22,0,0)。\n\n你可以发现上面同样的平移和缩放，顺序不同，变换后的顶点坐标也不相同。\n\n\n# 矩阵表示(先平移、后缩放)\n\n假设一个顶点原始坐标(2,0,0),先沿着x轴平移2，变为(4,0,0)，再x轴方向缩放10倍，最终坐标是(40,0,0)。这个过程可以用上节课介绍的矩阵乘法运算去表示。\n\n\n\n模型矩阵：先计算所有几何变换对应矩阵的乘积，得到一个模型矩阵，再对顶点坐标进行变换。\n\n先把顶点几何变换对应的所有矩阵进行乘法运算，得到一个新的复合矩阵(模型矩阵)，这个模型矩阵可以用来表示顶点坐标所有的几何变换。\n\n\n\n把上面缩放矩阵和平移矩阵的顺序调换，重新计算结果，你会发现，和上面计算的模型矩阵不同，变换后坐标也不是(40,0,0),而是(22,0,0)。\n\n\n\n这就是告诉大家，矩阵的乘法运算，不满足交换律，矩阵顺序，不能随意设置，先发生的平移矩阵，放在后面，后发生的缩放矩阵放在前面，或者说，先发生的平移矩阵，更靠近顶点的齐次坐标。\n\n\n\n\n# 单位矩阵\n\n单位矩阵就是对角线上都为1，其它为0的矩阵。\n\n\n\n单位矩阵乘其它矩阵，或者其它矩阵成单位矩阵，新矩阵都和其它矩阵一样，不受范围矩阵影响，单位矩阵有点类似自然数加减乘除的1。\n\n",charsets:{cjk:!0}},{title:"6. gl-matrix生成顶点着色器的矩阵",frontmatter:{title:"6. gl-matrix生成顶点着色器的矩阵",date:"2023-05-19T09:40:24.000Z",permalink:"/pages/d69ed5/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/06.gl-matrix%E7%94%9F%E6%88%90%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E7%9A%84%E7%9F%A9%E9%98%B5.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/06.gl-matrix生成顶点着色器的矩阵.md",key:"v-07a4d46e",path:"/pages/d69ed5/",headers:[{level:3,title:"引入gl-matrix库",slug:"引入gl-matrix库",normalizedTitle:"引入gl-matrix库",charIndex:122},{level:3,title:"glMatrix生成顶点着色器缩放矩阵",slug:"glmatrix生成顶点着色器缩放矩阵",normalizedTitle:"glmatrix生成顶点着色器缩放矩阵",charIndex:267},{level:3,title:"glMatrix生成顶点着色器平移矩阵",slug:"glmatrix生成顶点着色器平移矩阵",normalizedTitle:"glmatrix生成顶点着色器平移矩阵",charIndex:677},{level:3,title:"模型矩阵(先平移、后缩放)",slug:"模型矩阵-先平移、后缩放",normalizedTitle:"模型矩阵(先平移、后缩放)",charIndex:1093},{level:3,title:"模型矩阵(先缩放、后平移)",slug:"模型矩阵-先缩放、后平移",normalizedTitle:"模型矩阵(先缩放、后平移)",charIndex:1561}],headersStr:"引入gl-matrix库 glMatrix生成顶点着色器缩放矩阵 glMatrix生成顶点着色器平移矩阵 模型矩阵(先平移、后缩放) 模型矩阵(先缩放、后平移)",content:"# gl-matrix生成顶点着色器的矩阵\n\n你可以把本节课内容作为前面三小节的练习题，尝试先自己写下，再看视频。\n\n * gl-matrix生成缩放、平移等模型矩阵\n * uniform传递矩阵数据\n * 顶点着色器使用矩阵变换顶点\n\n\n# 引入gl-matrix库\n\n根据你自己文件gl-matrix库的地址设置路径。\n\ngl-matrix库使用的基本语法，可以参考2.3小节。\n\n// 引入gl-matrix库\nimport * as glMatrix from '../../gl-matrix/index.js'\n\n\n\n# glMatrix生成顶点着色器缩放矩阵\n\n// 传递着色器对应uniform数据\nconst mat4Array = glMatrix.mat4.create();\n//缩放变换\nglMatrix.mat4.scale(mat4Array, mat4Array, [0.5, 0.5, 1]);\n// 在GPU显存上创建一个uniform数据缓冲区\nconst mat4Buffer = device.createBuffer({\n    size: mat4Array.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\n// mat4Array里面矩阵数据写入uniform缓冲区mat4Buffer\ndevice.queue.writeBuffer(mat4Buffer, 0, mat4Array);\n\n\n\n# glMatrix生成顶点着色器平移矩阵\n\n// 传递着色器对应uniform数据\nconst mat4Array = glMatrix.mat4.create();\n//生成平移变换矩阵\nglMatrix.mat4.translate(mat4Array, mat4Array, [-1, -1, 0]);\n// 在GPU显存上创建一个uniform数据缓冲区\nconst mat4Buffer = device.createBuffer({\n    size: mat4Array.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\n// mat4Array里面矩阵数据写入uniform缓冲区mat4Buffer\ndevice.queue.writeBuffer(mat4Buffer, 0, mat4Array);\n\n\n\n# 模型矩阵(先平移、后缩放)\n\n// 传递着色器对应uniform数据\nconst modelMatrix = glMatrix.mat4.create();\n//后发生缩放变换，先乘\nglMatrix.mat4.scale(modelMatrix, modelMatrix, [0.5, 0.5, 1]);\n//先发生平移变换，后乘\nglMatrix.mat4.translate(modelMatrix, modelMatrix, [-1, -1, 0]);\n// 在GPU显存上创建一个uniform数据缓冲区\nconst modelMatrixBuffer = device.createBuffer({\n   size: modelMatrix.byteLength,\n   usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\ndevice.queue.writeBuffer(modelMatrixBuffer, 0, modelMatrix);\n\n\n\n# 模型矩阵(先缩放、后平移)\n\n// 传递着色器对应uniform数据\nconst modelMatrix = glMatrix.mat4.create();\n//后发生平移变换，先乘\nglMatrix.mat4.translate(modelMatrix, modelMatrix, [-1, -1, 0]);\n//先发生缩放变换，后乘\nglMatrix.mat4.scale(modelMatrix, modelMatrix, [0.5, 0.5, 1])\n// 在GPU显存上创建一个uniform数据缓冲区\nconst modelMatrixBuffer = device.createBuffer({\n   size: modelMatrix.byteLength,\n   usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\ndevice.queue.writeBuffer(modelMatrixBuffer, 0, modelMatrix);\n",normalizedContent:"# gl-matrix生成顶点着色器的矩阵\n\n你可以把本节课内容作为前面三小节的练习题，尝试先自己写下，再看视频。\n\n * gl-matrix生成缩放、平移等模型矩阵\n * uniform传递矩阵数据\n * 顶点着色器使用矩阵变换顶点\n\n\n# 引入gl-matrix库\n\n根据你自己文件gl-matrix库的地址设置路径。\n\ngl-matrix库使用的基本语法，可以参考2.3小节。\n\n// 引入gl-matrix库\nimport * as glmatrix from '../../gl-matrix/index.js'\n\n\n\n# glmatrix生成顶点着色器缩放矩阵\n\n// 传递着色器对应uniform数据\nconst mat4array = glmatrix.mat4.create();\n//缩放变换\nglmatrix.mat4.scale(mat4array, mat4array, [0.5, 0.5, 1]);\n// 在gpu显存上创建一个uniform数据缓冲区\nconst mat4buffer = device.createbuffer({\n    size: mat4array.bytelength,\n    usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\n// mat4array里面矩阵数据写入uniform缓冲区mat4buffer\ndevice.queue.writebuffer(mat4buffer, 0, mat4array);\n\n\n\n# glmatrix生成顶点着色器平移矩阵\n\n// 传递着色器对应uniform数据\nconst mat4array = glmatrix.mat4.create();\n//生成平移变换矩阵\nglmatrix.mat4.translate(mat4array, mat4array, [-1, -1, 0]);\n// 在gpu显存上创建一个uniform数据缓冲区\nconst mat4buffer = device.createbuffer({\n    size: mat4array.bytelength,\n    usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\n// mat4array里面矩阵数据写入uniform缓冲区mat4buffer\ndevice.queue.writebuffer(mat4buffer, 0, mat4array);\n\n\n\n# 模型矩阵(先平移、后缩放)\n\n// 传递着色器对应uniform数据\nconst modelmatrix = glmatrix.mat4.create();\n//后发生缩放变换，先乘\nglmatrix.mat4.scale(modelmatrix, modelmatrix, [0.5, 0.5, 1]);\n//先发生平移变换，后乘\nglmatrix.mat4.translate(modelmatrix, modelmatrix, [-1, -1, 0]);\n// 在gpu显存上创建一个uniform数据缓冲区\nconst modelmatrixbuffer = device.createbuffer({\n   size: modelmatrix.bytelength,\n   usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\ndevice.queue.writebuffer(modelmatrixbuffer, 0, modelmatrix);\n\n\n\n# 模型矩阵(先缩放、后平移)\n\n// 传递着色器对应uniform数据\nconst modelmatrix = glmatrix.mat4.create();\n//后发生平移变换，先乘\nglmatrix.mat4.translate(modelmatrix, modelmatrix, [-1, -1, 0]);\n//先发生缩放变换，后乘\nglmatrix.mat4.scale(modelmatrix, modelmatrix, [0.5, 0.5, 1])\n// 在gpu显存上创建一个uniform数据缓冲区\nconst modelmatrixbuffer = device.createbuffer({\n   size: modelmatrix.bytelength,\n   usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\ndevice.queue.writebuffer(modelmatrixbuffer, 0, modelmatrix);\n",charsets:{cjk:!0}},{title:"7. WebGPU动画(uniform旋转矩阵)",frontmatter:{title:"7. WebGPU动画(uniform旋转矩阵)",date:"2023-05-20T23:28:54.000Z",permalink:"/pages/e69b13/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/07.WebGPU%E5%8A%A8%E7%94%BB(uniform%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5).html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/07.WebGPU动画(uniform旋转矩阵).md",key:"v-79c7025f",path:"/pages/e69b13/",headers:[{level:3,title:"requestAnimationFrame()请求动画帧函数",slug:"requestanimationframe-请求动画帧函数",normalizedTitle:"requestanimationframe()请求动画帧函数",charIndex:54},{level:3,title:"gl-matrix生成旋转矩阵",slug:"gl-matrix生成旋转矩阵",normalizedTitle:"gl-matrix生成旋转矩阵",charIndex:354},{level:3,title:"命令编码器对象和绘制命令.draw()",slug:"命令编码器对象和绘制命令-draw",normalizedTitle:"命令编码器对象和绘制命令.draw()",charIndex:1098},{level:3,title:"动画循环render()重复渲染",slug:"动画循环render-重复渲染",normalizedTitle:"动画循环render()重复渲染",charIndex:1853},{level:3,title:"WebGPU渲染循环更新uniform矩阵",slug:"webgpu渲染循环更新uniform矩阵",normalizedTitle:"webgpu渲染循环更新uniform矩阵",charIndex:2703}],headersStr:"requestAnimationFrame()请求动画帧函数 gl-matrix生成旋转矩阵 命令编码器对象和绘制命令.draw() 动画循环render()重复渲染 WebGPU渲染循环更新uniform矩阵",content:"# WebGPU动画(uniform旋转矩阵)\n\n本节课给大家讲解如何实现WebGPU的动画效果。\n\n\n# requestAnimationFrame()请求动画帧函数\n\n通过HTML5的请求动画帧函数window.requestAnimationFrame(),辅助实现WebGPU的动画效果。\n\nrequestAnimationFrame(render)实现render函数的周期性执行，默认每秒钟执行60次，也可能低于60次。\n\nlet i = 0;\n// 循环动画render()\nfunction render() {\n    i+=1;\n    requestAnimationFrame(render);\n    console.log('执行次数'+i);\n}\nrender();\n\n\n\n# gl-matrix生成旋转矩阵\n\n在上节课2.6小节基础上，更改代码，通过gl-matrix生成一个旋转矩阵，旋转几何图形，其它代码不变。\n\n需要旋转的矩形对应顶点数据\n\n const vertexArray = new Float32Array([\n     // 三角形1\n     -0.3, -0.5, 0.0,\n     0.3, -0.5, 0.0,\n     0.3, 0.5, 0.0,\n     // 三角形2\n     -0.3, -0.5, 0.0,\n     0.3, 0.5, 0.0,\n     -0.3, 0.5, 0.0,\n ]);\n\n\ngl-matrix生成旋转矩阵,传入uniform数据缓冲区\n\nconst modelMatrix = glMatrix.mat4.create();\n// 绕z旋转30度\nglMatrix.mat4.rotateZ(modelMatrix, modelMatrix, Math.PI/6);\n// 绕z旋转90度\n// glMatrix.mat4.rotateZ(modelMatrix, modelMatrix, Math.PI/2)\n// 在GPU显存上创建一个uniform数据缓冲区\nconst modelMatrixBuffer = device.createBuffer({\n    size: modelMatrix.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\ndevice.queue.writeBuffer(modelMatrixBuffer, 0, modelMatrix);\n\n\n\n# 命令编码器对象和绘制命令.draw()\n\n回顾下1.7节讲解的内容：命令编码器对象。\n\n前面给大家讲解过，通过命令编码器对象commandEncoder调用绘制命令.draw(),可以把顶点数据对应几何图形绘制出来，简单点说就是调用WebGPU API，解析顶点数据生成一张图像，显示在Cavnas画布上。\n\n// 命令编码器\nconst commandEncoder = device.createCommandEncoder();\n// 渲染通道\nconst renderPass = commandEncoder.beginRenderPass({\n    colorAttachments: [{\n        view: context.getCurrentTexture().createView(),\n        storeOp: 'store',\n        loadOp: 'clear',\n    }]\n});\nrenderPass.setPipeline(pipeline);\n// 顶点缓冲区数据和渲染管线shaderLocation: 0表示存储位置关联起来\nrenderPass.setVertexBuffer(0, vertexBuffer);\n// 把绑定组里面的uniform数据传递给着色器中uniform变量\nrenderPass.setBindGroup(0, bindGroup);\nrenderPass.draw(6);// 绘制顶点数据\nrenderPass.end();\nconst commandBuffer = commandEncoder.finish();\ndevice.queue.submit([commandBuffer]);\n\n\n\n# 动画循环render()重复渲染\n\n通过命令编码器对象，完成一次绘制draw，可以生成一张图像，如果重复执行，就可以不停的生成新的图像，每次执行生成的图像可以称为一帧图像。\n\n//渲染循环\nfunction render() {\n    // 命令编码器\n    const commandEncoder = device.createCommandEncoder();\n    // 渲染通道\n    const renderPass = commandEncoder.beginRenderPass({\n        colorAttachments: [{\n            view: context.getCurrentTexture().createView(),\n            storeOp: 'store',\n            \n            loadOp: 'clear',\n        }]\n    });\n    renderPass.setPipeline(pipeline);\n    // 顶点缓冲区数据和渲染管线shaderLocation: 0表示存储位置关联起来\n    renderPass.setVertexBuffer(0, vertexBuffer);\n    // 把绑定组里面的uniform数据传递给着色器中uniform变量\n    renderPass.setBindGroup(0, bindGroup);\n    renderPass.draw(6);// 绘制顶点数据\n    renderPass.end();\n    const commandBuffer = commandEncoder.finish();\n    device.queue.submit([commandBuffer]);\n    requestAnimationFrame(render);\n}\nrender()\n\n\n\n# WebGPU渲染循环更新uniform矩阵\n\n动画循环render()中更新uniform矩阵、重新执行draw绘制，每次执行draw的时候，都是使用新的旋转矩阵，生成一张新的图像，把不同旋转矩阵对应的一帧帧图像连起来，这样就可以产生旋转动画的视觉效果。\n\n//渲染循环\nlet angle = 0.0;//初始旋转角度\nfunction render() {\n    angle += 0.05;//每次渲染角度增加\n    const modelMatrix = glMatrix.mat4.create();\n    // 每次渲染，生成新的旋转矩阵\n    glMatrix.mat4.rotateZ(modelMatrix, modelMatrix,angle);\n    //模型矩阵modelMatrix重新写入uniform数据的缓冲区中\n    device.queue.writeBuffer(modelMatrixBuffer, 0, modelMatrix)\n\n    // 命令编码器\n    const commandEncoder = device.createCommandEncoder();\n    // 渲染通道\n    const renderPass = commandEncoder.beginRenderPass({\n        colorAttachments: [{\n            view: context.getCurrentTexture().createView(),\n            storeOp: 'store',\n            loadOp: 'clear',\n        }]\n    });\n    renderPass.setPipeline(pipeline);\n    // 顶点缓冲区数据和渲染管线shaderLocation: 0表示存储位置关联起来\n    renderPass.setVertexBuffer(0, vertexBuffer);\n    // 把绑定组里面的uniform数据传递给着色器中uniform变量\n    renderPass.setBindGroup(0, bindGroup);\n    renderPass.draw(6);// 绘制顶点数据\n    renderPass.end();\n    const commandBuffer = commandEncoder.finish();\n    device.queue.submit([commandBuffer]);\n\n    requestAnimationFrame(render);\n}\nrender()\n\n",normalizedContent:"# webgpu动画(uniform旋转矩阵)\n\n本节课给大家讲解如何实现webgpu的动画效果。\n\n\n# requestanimationframe()请求动画帧函数\n\n通过html5的请求动画帧函数window.requestanimationframe(),辅助实现webgpu的动画效果。\n\nrequestanimationframe(render)实现render函数的周期性执行，默认每秒钟执行60次，也可能低于60次。\n\nlet i = 0;\n// 循环动画render()\nfunction render() {\n    i+=1;\n    requestanimationframe(render);\n    console.log('执行次数'+i);\n}\nrender();\n\n\n\n# gl-matrix生成旋转矩阵\n\n在上节课2.6小节基础上，更改代码，通过gl-matrix生成一个旋转矩阵，旋转几何图形，其它代码不变。\n\n需要旋转的矩形对应顶点数据\n\n const vertexarray = new float32array([\n     // 三角形1\n     -0.3, -0.5, 0.0,\n     0.3, -0.5, 0.0,\n     0.3, 0.5, 0.0,\n     // 三角形2\n     -0.3, -0.5, 0.0,\n     0.3, 0.5, 0.0,\n     -0.3, 0.5, 0.0,\n ]);\n\n\ngl-matrix生成旋转矩阵,传入uniform数据缓冲区\n\nconst modelmatrix = glmatrix.mat4.create();\n// 绕z旋转30度\nglmatrix.mat4.rotatez(modelmatrix, modelmatrix, math.pi/6);\n// 绕z旋转90度\n// glmatrix.mat4.rotatez(modelmatrix, modelmatrix, math.pi/2)\n// 在gpu显存上创建一个uniform数据缓冲区\nconst modelmatrixbuffer = device.createbuffer({\n    size: modelmatrix.bytelength,\n    usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\ndevice.queue.writebuffer(modelmatrixbuffer, 0, modelmatrix);\n\n\n\n# 命令编码器对象和绘制命令.draw()\n\n回顾下1.7节讲解的内容：命令编码器对象。\n\n前面给大家讲解过，通过命令编码器对象commandencoder调用绘制命令.draw(),可以把顶点数据对应几何图形绘制出来，简单点说就是调用webgpu api，解析顶点数据生成一张图像，显示在cavnas画布上。\n\n// 命令编码器\nconst commandencoder = device.createcommandencoder();\n// 渲染通道\nconst renderpass = commandencoder.beginrenderpass({\n    colorattachments: [{\n        view: context.getcurrenttexture().createview(),\n        storeop: 'store',\n        loadop: 'clear',\n    }]\n});\nrenderpass.setpipeline(pipeline);\n// 顶点缓冲区数据和渲染管线shaderlocation: 0表示存储位置关联起来\nrenderpass.setvertexbuffer(0, vertexbuffer);\n// 把绑定组里面的uniform数据传递给着色器中uniform变量\nrenderpass.setbindgroup(0, bindgroup);\nrenderpass.draw(6);// 绘制顶点数据\nrenderpass.end();\nconst commandbuffer = commandencoder.finish();\ndevice.queue.submit([commandbuffer]);\n\n\n\n# 动画循环render()重复渲染\n\n通过命令编码器对象，完成一次绘制draw，可以生成一张图像，如果重复执行，就可以不停的生成新的图像，每次执行生成的图像可以称为一帧图像。\n\n//渲染循环\nfunction render() {\n    // 命令编码器\n    const commandencoder = device.createcommandencoder();\n    // 渲染通道\n    const renderpass = commandencoder.beginrenderpass({\n        colorattachments: [{\n            view: context.getcurrenttexture().createview(),\n            storeop: 'store',\n            \n            loadop: 'clear',\n        }]\n    });\n    renderpass.setpipeline(pipeline);\n    // 顶点缓冲区数据和渲染管线shaderlocation: 0表示存储位置关联起来\n    renderpass.setvertexbuffer(0, vertexbuffer);\n    // 把绑定组里面的uniform数据传递给着色器中uniform变量\n    renderpass.setbindgroup(0, bindgroup);\n    renderpass.draw(6);// 绘制顶点数据\n    renderpass.end();\n    const commandbuffer = commandencoder.finish();\n    device.queue.submit([commandbuffer]);\n    requestanimationframe(render);\n}\nrender()\n\n\n\n# webgpu渲染循环更新uniform矩阵\n\n动画循环render()中更新uniform矩阵、重新执行draw绘制，每次执行draw的时候，都是使用新的旋转矩阵，生成一张新的图像，把不同旋转矩阵对应的一帧帧图像连起来，这样就可以产生旋转动画的视觉效果。\n\n//渲染循环\nlet angle = 0.0;//初始旋转角度\nfunction render() {\n    angle += 0.05;//每次渲染角度增加\n    const modelmatrix = glmatrix.mat4.create();\n    // 每次渲染，生成新的旋转矩阵\n    glmatrix.mat4.rotatez(modelmatrix, modelmatrix,angle);\n    //模型矩阵modelmatrix重新写入uniform数据的缓冲区中\n    device.queue.writebuffer(modelmatrixbuffer, 0, modelmatrix)\n\n    // 命令编码器\n    const commandencoder = device.createcommandencoder();\n    // 渲染通道\n    const renderpass = commandencoder.beginrenderpass({\n        colorattachments: [{\n            view: context.getcurrenttexture().createview(),\n            storeop: 'store',\n            loadop: 'clear',\n        }]\n    });\n    renderpass.setpipeline(pipeline);\n    // 顶点缓冲区数据和渲染管线shaderlocation: 0表示存储位置关联起来\n    renderpass.setvertexbuffer(0, vertexbuffer);\n    // 把绑定组里面的uniform数据传递给着色器中uniform变量\n    renderpass.setbindgroup(0, bindgroup);\n    renderpass.draw(6);// 绘制顶点数据\n    renderpass.end();\n    const commandbuffer = commandencoder.finish();\n    device.queue.submit([commandbuffer]);\n\n    requestanimationframe(render);\n}\nrender()\n\n",charsets:{cjk:!0}},{title:"8. 绕y轴旋转动画",frontmatter:{title:"8. 绕y轴旋转动画",date:"2023-05-20T23:29:33.000Z",permalink:"/pages/df319e/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/08.%E7%BB%95y%E8%BD%B4%E6%97%8B%E8%BD%AC%E5%8A%A8%E7%94%BB.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/08.绕y轴旋转动画.md",key:"v-09c2f018",path:"/pages/df319e/",headers:[{level:3,title:"绕y轴旋转",slug:"绕y轴旋转",normalizedTitle:"绕y轴旋转",charIndex:2},{level:3,title:"绕y旋转矩形平面显示不完整",slug:"绕y旋转矩形平面显示不完整",normalizedTitle:"绕y旋转矩形平面显示不完整",charIndex:1008}],headersStr:"绕y轴旋转 绕y旋转矩形平面显示不完整",content:"# 绕y轴旋转动画\n\n上节课给大家演示了矩形平面绕z轴旋转，本节课给大家展示一个绕y轴旋转的案例。\n\n\n# 绕y轴旋转\n\n在上节课代码基础上给大家讲解。\n\n在渲染循环render函数外面，创建一个uniform的缓冲区用来存储矩阵数据，然后在render里面更新缓冲区中的矩阵数据，没必要重新创建，毕竟每个缓冲区都会占用GPU显存空间。\n\nconst modelMatrixBuffer = device.createBuffer({\n    size: 16*4,//旋转矩阵16个元素，每个元素占4个字节\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\n\n\n// .create()创建一个单位矩阵\nconst modelMatrix = glMatrix.mat4.create();\n// 在GPU显存上创建一个uniform数据缓冲区\nconst modelMatrixBuffer = device.createBuffer({\n    size: modelMatrix.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n});\n\n\n渲染循环函数render每次执行，重新生成对应的绕y轴旋转的矩阵，更新原来uniform缓冲区中的矩阵数据。\n\n//渲染循环\nlet angle = 0.0;\nfunction render() {\n    angle += 0.05;\n    const modelMatrix = glMatrix.mat4.create();\n    glMatrix.mat4.rotateY(modelMatrix, modelMatrix,angle);\n    device.queue.writeBuffer(modelMatrixBuffer, 0, modelMatrix)\n    ...\n    const commandEncoder = device.createCommandEncoder();\n    ...\n    renderPass.draw(6);\n    ...\n    requestAnimationFrame(render);\n}\nrender()\n\n\n\n# 绕y旋转矩形平面显示不完整\n\n你会发现上面绕y旋转矩形平面显示不完整，原因很简单，你回顾1.8.WebGPU 3D坐标系(投影)讲解的知识点就会明白。\n\n具体说就是当矩形平面旋转的时候，矩形z的值不在0~1范围的部分被剪裁了。\n\n\n\n\n\n如果你想看到完整的\n\n//渲染循环\nlet angle = 0.0;\nfunction render() {\n    angle += 0.05;\n    const modelMatrix = glMatrix.mat4.create();\n    // 每次操作(旋转后，再平移)\n    glMatrix.mat4.translate(modelMatrix, modelMatrix,[0,0,0.5]);//后平移，不平移矩形平面会被剪裁掉一半\n    glMatrix.mat4.rotateY(modelMatrix, modelMatrix,angle);//先旋转\n    device.queue.writeBuffer(modelMatrixBuffer, 0, modelMatrix)\n    ...\n    const commandEncoder = device.createCommandEncoder();\n    ...\n    renderPass.draw(6);\n    ...\n    requestAnimationFrame(render);\n}\nrender()\n",normalizedContent:"# 绕y轴旋转动画\n\n上节课给大家演示了矩形平面绕z轴旋转，本节课给大家展示一个绕y轴旋转的案例。\n\n\n# 绕y轴旋转\n\n在上节课代码基础上给大家讲解。\n\n在渲染循环render函数外面，创建一个uniform的缓冲区用来存储矩阵数据，然后在render里面更新缓冲区中的矩阵数据，没必要重新创建，毕竟每个缓冲区都会占用gpu显存空间。\n\nconst modelmatrixbuffer = device.createbuffer({\n    size: 16*4,//旋转矩阵16个元素，每个元素占4个字节\n    usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\n\n\n// .create()创建一个单位矩阵\nconst modelmatrix = glmatrix.mat4.create();\n// 在gpu显存上创建一个uniform数据缓冲区\nconst modelmatrixbuffer = device.createbuffer({\n    size: modelmatrix.bytelength,\n    usage: gpubufferusage.uniform | gpubufferusage.copy_dst\n});\n\n\n渲染循环函数render每次执行，重新生成对应的绕y轴旋转的矩阵，更新原来uniform缓冲区中的矩阵数据。\n\n//渲染循环\nlet angle = 0.0;\nfunction render() {\n    angle += 0.05;\n    const modelmatrix = glmatrix.mat4.create();\n    glmatrix.mat4.rotatey(modelmatrix, modelmatrix,angle);\n    device.queue.writebuffer(modelmatrixbuffer, 0, modelmatrix)\n    ...\n    const commandencoder = device.createcommandencoder();\n    ...\n    renderpass.draw(6);\n    ...\n    requestanimationframe(render);\n}\nrender()\n\n\n\n# 绕y旋转矩形平面显示不完整\n\n你会发现上面绕y旋转矩形平面显示不完整，原因很简单，你回顾1.8.webgpu 3d坐标系(投影)讲解的知识点就会明白。\n\n具体说就是当矩形平面旋转的时候，矩形z的值不在0~1范围的部分被剪裁了。\n\n\n\n\n\n如果你想看到完整的\n\n//渲染循环\nlet angle = 0.0;\nfunction render() {\n    angle += 0.05;\n    const modelmatrix = glmatrix.mat4.create();\n    // 每次操作(旋转后，再平移)\n    glmatrix.mat4.translate(modelmatrix, modelmatrix,[0,0,0.5]);//后平移，不平移矩形平面会被剪裁掉一半\n    glmatrix.mat4.rotatey(modelmatrix, modelmatrix,angle);//先旋转\n    device.queue.writebuffer(modelmatrixbuffer, 0, modelmatrix)\n    ...\n    const commandencoder = device.createcommandencoder();\n    ...\n    renderpass.draw(6);\n    ...\n    requestanimationframe(render);\n}\nrender()\n",charsets:{cjk:!0}},{title:"10. 片元深度值、深度缓冲区",frontmatter:{title:"10. 片元深度值、深度缓冲区",date:"2023-05-20T23:30:34.000Z",permalink:"/pages/aac7f7/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/10.%E7%89%87%E5%85%83%E6%B7%B1%E5%BA%A6%E5%80%BC%E3%80%81%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E5%8C%BA.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/10.片元深度值、深度缓冲区.md",key:"v-b352d932",path:"/pages/aac7f7/",headers:[{level:3,title:"片元深度值(z坐标)",slug:"片元深度值-z坐标",normalizedTitle:"片元深度值(z坐标)",charIndex:65},{level:3,title:"帧缓冲区简介",slug:"帧缓冲区简介",normalizedTitle:"帧缓冲区简介",charIndex:264},{level:3,title:"片元着色器获取片元深度值",slug:"片元着色器获取片元深度值",normalizedTitle:"片元着色器获取片元深度值",charIndex:362},{level:3,title:"根据片元深度值控制片元颜色",slug:"根据片元深度值控制片元颜色",normalizedTitle:"根据片元深度值控制片元颜色",charIndex:882},{level:3,title:"片元深度可视化",slug:"片元深度可视化",normalizedTitle:"片元深度可视化",charIndex:1217}],headersStr:"片元深度值(z坐标) 帧缓冲区简介 片元着色器获取片元深度值 根据片元深度值控制片元颜色 片元深度可视化",content:"# 片元深度值、深度缓冲区\n\n接着上节课片元屏幕坐标，给大家介绍下，WebGPU片元深度值(Z坐标)和深度缓冲区的概念。\n\n\n# 片元深度值(z坐标)\n\n在xyz轴上分别取一个点构成构成一个三角形，然后以该三角形为例给大家讲解片元的深度值。\n\n// 三角形顶点坐标\n1.0, 0.0, 0.0,\n0.0, 1.0, 0.0,\n0.0, 0.0, 1.0,\n\n\n\n\n经过渲染管线处理后生成片元数据\n\n\n\n三角形里面的每个片元数据都有一个自己的对应xyz坐标数据,本节课主要给大家讨论下Z坐标，你也可以称为片元深度值。\n\n\n\n\n# 帧缓冲区简介\n\n经过渲染管线处理，会生成一些片元相关的数据，片元的颜色(像素)数据存储在颜色缓冲区，片元的深度值Z存储在深度缓冲区中，颜色缓冲区、深度缓冲区都是帧缓冲区的一部分。\n\n\n\n\n\n\n# 片元着色器获取片元深度值\n\n获取片元的屏幕坐标xy\n\n@fragment\nfn main(@builtin(position) fragCoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragCoord.x;//片元屏幕坐标x\n    var y = fragCoord.y;//片元屏幕坐标y\n}\n\n\n获取片元深度值方式和屏幕坐标一样，也是通过@builtin(position)声明的变量获取。\n\n@fragment\nfn main(@builtin(position) fragCoord : vec4<f32>) -> @location(0) vec4<f32> {\n    //片元深度值，也就是z坐标\n    var z = fragCoord.z;\n}\n\n\n通过内置变量@builtin(position)可以获取片元的坐标，fragCoord.x、fragCoord.y是屏幕坐标,不过fragCoord.z是并不是屏幕坐标，在该案例中，三角形三个顶点位置对应的片元z，还是你在顶点缓冲区中三个顶点的z坐标，其余的片元z值在这三个点的z之间。\n\n\n# 根据片元深度值控制片元颜色\n\n@fragment\nfn main(@builtin(position) fragCoord : vec4<f32>) -> @location(0) vec4<f32> {\n    // 片元深度值\n    var z = fragCoord.z;\n    if(z < 0.5){\n        // 片元深度值小于0.5，片元设置为红色\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    }else{\n        // 片元深度值不小于250，片元设置为绿色\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n    }\n}\n\n\n\n# 片元深度可视化\n\nz的范围0~1，颜色范围绿色(0, 1, 0)到黄色(1, 1, 0)之间变化\n\n@fragment\nfn main(@builtin(position) fragCoord : vec4<f32>) -> @location(0) vec4<f32> {\n    // 片元深度值\n    var z = fragCoord.z;\n    // 可视化片元深度\n    return vec4<f32>(z, 1.0, 0.0, 1.0);\n}\n\n\nz的范围0~1，颜色范围蓝色(0, 0, 1)到红色(1, 0, 0)之间变化\n\n@fragment\nfn main(@builtin(position) fragCoord : vec4<f32>) -> @location(0) vec4<f32> {\n    // 片元深度值\n    var z = fragCoord.z;\n    // 可视化片元深度\n    return vec4<f32>(z,0.0, 1.0-z, 1.0);\n}\n",normalizedContent:"# 片元深度值、深度缓冲区\n\n接着上节课片元屏幕坐标，给大家介绍下，webgpu片元深度值(z坐标)和深度缓冲区的概念。\n\n\n# 片元深度值(z坐标)\n\n在xyz轴上分别取一个点构成构成一个三角形，然后以该三角形为例给大家讲解片元的深度值。\n\n// 三角形顶点坐标\n1.0, 0.0, 0.0,\n0.0, 1.0, 0.0,\n0.0, 0.0, 1.0,\n\n\n\n\n经过渲染管线处理后生成片元数据\n\n\n\n三角形里面的每个片元数据都有一个自己的对应xyz坐标数据,本节课主要给大家讨论下z坐标，你也可以称为片元深度值。\n\n\n\n\n# 帧缓冲区简介\n\n经过渲染管线处理，会生成一些片元相关的数据，片元的颜色(像素)数据存储在颜色缓冲区，片元的深度值z存储在深度缓冲区中，颜色缓冲区、深度缓冲区都是帧缓冲区的一部分。\n\n\n\n\n\n\n# 片元着色器获取片元深度值\n\n获取片元的屏幕坐标xy\n\n@fragment\nfn main(@builtin(position) fragcoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragcoord.x;//片元屏幕坐标x\n    var y = fragcoord.y;//片元屏幕坐标y\n}\n\n\n获取片元深度值方式和屏幕坐标一样，也是通过@builtin(position)声明的变量获取。\n\n@fragment\nfn main(@builtin(position) fragcoord : vec4<f32>) -> @location(0) vec4<f32> {\n    //片元深度值，也就是z坐标\n    var z = fragcoord.z;\n}\n\n\n通过内置变量@builtin(position)可以获取片元的坐标，fragcoord.x、fragcoord.y是屏幕坐标,不过fragcoord.z是并不是屏幕坐标，在该案例中，三角形三个顶点位置对应的片元z，还是你在顶点缓冲区中三个顶点的z坐标，其余的片元z值在这三个点的z之间。\n\n\n# 根据片元深度值控制片元颜色\n\n@fragment\nfn main(@builtin(position) fragcoord : vec4<f32>) -> @location(0) vec4<f32> {\n    // 片元深度值\n    var z = fragcoord.z;\n    if(z < 0.5){\n        // 片元深度值小于0.5，片元设置为红色\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    }else{\n        // 片元深度值不小于250，片元设置为绿色\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n    }\n}\n\n\n\n# 片元深度可视化\n\nz的范围0~1，颜色范围绿色(0, 1, 0)到黄色(1, 1, 0)之间变化\n\n@fragment\nfn main(@builtin(position) fragcoord : vec4<f32>) -> @location(0) vec4<f32> {\n    // 片元深度值\n    var z = fragcoord.z;\n    // 可视化片元深度\n    return vec4<f32>(z, 1.0, 0.0, 1.0);\n}\n\n\nz的范围0~1，颜色范围蓝色(0, 0, 1)到红色(1, 0, 0)之间变化\n\n@fragment\nfn main(@builtin(position) fragcoord : vec4<f32>) -> @location(0) vec4<f32> {\n    // 片元深度值\n    var z = fragcoord.z;\n    // 可视化片元深度\n    return vec4<f32>(z,0.0, 1.0-z, 1.0);\n}\n",charsets:{cjk:!0}},{title:"9. 片元的屏幕坐标",frontmatter:{title:"9. 片元的屏幕坐标",date:"2023-05-20T23:29:48.000Z",permalink:"/pages/e2c95a/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/09.%E7%89%87%E5%85%83%E7%9A%84%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/09.片元的屏幕坐标.md",key:"v-42ec0e6e",path:"/pages/e2c95a/",headers:[{level:3,title:"标准设备坐标和屏幕坐标",slug:"标准设备坐标和屏幕坐标",normalizedTitle:"标准设备坐标和屏幕坐标",charIndex:121},{level:3,title:"片元着色器获取片元屏幕坐标xy",slug:"片元着色器获取片元屏幕坐标xy",normalizedTitle:"片元着色器获取片元屏幕坐标xy",charIndex:370},{level:3,title:"根据屏幕坐标控制片元颜色",slug:"根据屏幕坐标控制片元颜色",normalizedTitle:"根据屏幕坐标控制片元颜色",charIndex:731},{level:3,title:"练习题:设置颜色渐变",slug:"练习题-设置颜色渐变",normalizedTitle:"练习题:设置颜色渐变",charIndex:1474}],headersStr:"标准设备坐标和屏幕坐标 片元着色器获取片元屏幕坐标xy 根据屏幕坐标控制片元颜色 练习题:设置颜色渐变",content:"# WebGPU片元的屏幕坐标\n\n先回顾下前面关于片元着色器的讲解。\n\n\n\n通过WebGPU渲染管线上功能单元光栅化处理，获得几何图形的片元数据。\n\n比如一个三角形，经过光栅化，会获取到一个一个片元(像素)填充出来一个三角形的轮廓。\n\n\n# 标准设备坐标和屏幕坐标\n\n先回顾下前面讲解的标准设备坐标系\n\n\n\n三角形里面的每个片元数据都有一个自己的对应xyz坐标数据，可以使用WebGPU标准设备坐标系去描述片元的3D位置。\n\n\n\n在1.8节，讲解过WebGPU投影的知识点，三角形投影到Canvas画布上，片元在canvas画布上的位置，可以使用屏幕坐标系描述。\n\n屏幕坐标系，坐标原点是Canvas画布的左上角，x轴水平向右，y轴竖直向下，x最大值是canvas画布宽度，y最大值是canvas画布的高度，单位是像素值px。\n\n\n\n\n# 片元着色器获取片元屏幕坐标xy\n\n片元着色器中可以通过片元着色器主函数main()的参数获取光栅化后得到的片元坐标数据。\n\n命名一个变量fragCoord表示片元坐标，当然你也可以用其它的名字，然后通过内置变量position指定fragCoord变量表示片元位置数据，具体写法是添加前缀@builtin(position)，最后注明数据类型fragCoord : vec4<f32> 然后。\n\n@fragment\nfn main(@builtin(position) fragCoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragCoord.x;//片元屏幕坐标x\n    var y = fragCoord.y;//片元屏幕坐标y\n}\n\n\n\n# 根据屏幕坐标控制片元颜色\n\ncanvas画布的宽度是500px，x方向中间屏幕坐标是250，下面代码以250为分界线，设置片元颜色，左边红色，右边绿色。\n\nfn main(@builtin(position) fragCoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragCoord.x;//片元屏幕坐标x\n    if(x < 250.0){\n        // 片元x屏幕坐标小于250，片元设置为红色\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    }else{\n        // 片元x屏幕坐标不小于250，片元设置为绿色\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n    }\n}\n\n\n把中心位置(250,250)左上角设置为红色，其他区域绿色。\n\n@fragment\nfn main(@builtin(position) fragCoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragCoord.x;//片元屏幕坐标x\n    var y = fragCoord.y;//片元屏幕坐标y\n    // 左上角红色，其他区域绿色\n    if(x < 250.0 && y < 250.0){\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    }else{\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n    }\n}\n\n\n\n# 练习题:设置颜色渐变\n\n给下面一个三角形设置一个渐变色，左边蓝色，右边红色，中间是两种颜色的过渡色。\n\n// 三角形顶点坐标\n1.0, 0.0, 0.0,\n0.0, 1.0, 0.0,\n0.0, 0.0, 0.0,\n\n\n下面代码是根据片元屏幕坐标x设置渐变色，你可以根据需要自由编写渐变公式。\n\n@fragment\nfn main(@builtin(position) fragCoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragCoord.x;//片元屏幕坐标x\n    // 渐变色\n    var per: f32 = (x-250.0)/250.0;\n    return vec4<f32>(per, 0.0, 1.0-per, 1.0);\n}\n\n\n",normalizedContent:"# webgpu片元的屏幕坐标\n\n先回顾下前面关于片元着色器的讲解。\n\n\n\n通过webgpu渲染管线上功能单元光栅化处理，获得几何图形的片元数据。\n\n比如一个三角形，经过光栅化，会获取到一个一个片元(像素)填充出来一个三角形的轮廓。\n\n\n# 标准设备坐标和屏幕坐标\n\n先回顾下前面讲解的标准设备坐标系\n\n\n\n三角形里面的每个片元数据都有一个自己的对应xyz坐标数据，可以使用webgpu标准设备坐标系去描述片元的3d位置。\n\n\n\n在1.8节，讲解过webgpu投影的知识点，三角形投影到canvas画布上，片元在canvas画布上的位置，可以使用屏幕坐标系描述。\n\n屏幕坐标系，坐标原点是canvas画布的左上角，x轴水平向右，y轴竖直向下，x最大值是canvas画布宽度，y最大值是canvas画布的高度，单位是像素值px。\n\n\n\n\n# 片元着色器获取片元屏幕坐标xy\n\n片元着色器中可以通过片元着色器主函数main()的参数获取光栅化后得到的片元坐标数据。\n\n命名一个变量fragcoord表示片元坐标，当然你也可以用其它的名字，然后通过内置变量position指定fragcoord变量表示片元位置数据，具体写法是添加前缀@builtin(position)，最后注明数据类型fragcoord : vec4<f32> 然后。\n\n@fragment\nfn main(@builtin(position) fragcoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragcoord.x;//片元屏幕坐标x\n    var y = fragcoord.y;//片元屏幕坐标y\n}\n\n\n\n# 根据屏幕坐标控制片元颜色\n\ncanvas画布的宽度是500px，x方向中间屏幕坐标是250，下面代码以250为分界线，设置片元颜色，左边红色，右边绿色。\n\nfn main(@builtin(position) fragcoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragcoord.x;//片元屏幕坐标x\n    if(x < 250.0){\n        // 片元x屏幕坐标小于250，片元设置为红色\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    }else{\n        // 片元x屏幕坐标不小于250，片元设置为绿色\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n    }\n}\n\n\n把中心位置(250,250)左上角设置为红色，其他区域绿色。\n\n@fragment\nfn main(@builtin(position) fragcoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragcoord.x;//片元屏幕坐标x\n    var y = fragcoord.y;//片元屏幕坐标y\n    // 左上角红色，其他区域绿色\n    if(x < 250.0 && y < 250.0){\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    }else{\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n    }\n}\n\n\n\n# 练习题:设置颜色渐变\n\n给下面一个三角形设置一个渐变色，左边蓝色，右边红色，中间是两种颜色的过渡色。\n\n// 三角形顶点坐标\n1.0, 0.0, 0.0,\n0.0, 1.0, 0.0,\n0.0, 0.0, 0.0,\n\n\n下面代码是根据片元屏幕坐标x设置渐变色，你可以根据需要自由编写渐变公式。\n\n@fragment\nfn main(@builtin(position) fragcoord : vec4<f32>) -> @location(0) vec4<f32> {\n    var x = fragcoord.x;//片元屏幕坐标x\n    // 渐变色\n    var per: f32 = (x-250.0)/250.0;\n    return vec4<f32>(per, 0.0, 1.0-per, 1.0);\n}\n\n\n",charsets:{cjk:!0}},{title:"1. 数学基础(平移、旋转、缩放矩阵)",frontmatter:{title:"1. 数学基础(平移、旋转、缩放矩阵)",date:"2023-04-24T22:09:26.000Z",permalink:"/pages/38777d/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80(%E5%B9%B3%E7%A7%BB%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5).html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/01.数学基础(平移、旋转、缩放矩阵).md",key:"v-0d1e30f7",path:"/pages/38777d/",headers:[{level:3,title:"线性代数、图形学",slug:"线性代数、图形学",normalizedTitle:"线性代数、图形学",charIndex:100},{level:3,title:"本节课针对学员",slug:"本节课针对学员",normalizedTitle:"本节课针对学员",charIndex:322},{level:3,title:"矩阵、矩阵运算规则",slug:"矩阵、矩阵运算规则",normalizedTitle:"矩阵、矩阵运算规则",charIndex:391},{level:3,title:"平移矩阵",slug:"平移矩阵",normalizedTitle:"平移矩阵",charIndex:50},{level:3,title:"缩放矩阵",slug:"缩放矩阵",normalizedTitle:"缩放矩阵",charIndex:13},{level:3,title:"旋转矩阵",slug:"旋转矩阵",normalizedTitle:"旋转矩阵",charIndex:60}],headersStr:"线性代数、图形学 本节课针对学员 矩阵、矩阵运算规则 平移矩阵 缩放矩阵 旋转矩阵",content:"# 数学基础(平移、旋转、缩放矩阵)\n\n本下节课给大家介绍下矩阵的概念，以及用于几何变换的矩阵，比如平移矩阵、缩放矩阵、旋转矩阵。\n\n如果你对这些几何变换的矩阵概念比较熟悉，可以跳过本节课。\n\n\n# 线性代数、图形学\n\n如果你有《线性代数》、《计算机图形学》基础，更有利于WebGPU的学习。当然了，你没有这些基础，也没关系，咱们课程的特色就是尽量弱化对数学和图形学基础的要求，尽量带你从零入门。\n\n如果你时间比较充足，也有兴趣，可以去翻翻《线性代数》、《计算机图形学》相关的书籍，当然你不去翻，咱们的课程你也能学习。\n\n如果你数学基础不好，工作也不用封装3D引擎或数学库，可以不用学习《线性代数》，直接用下节课介绍的一个数学库即可。\n\n\n# 本节课针对学员\n\n * 大学学过线性代数的矩阵，但是并不了解用于平移、旋转、缩放的矩阵\n * 没学过线性代数，数学停留在高中水平\n\n\n# 矩阵、矩阵运算规则\n\n矩阵是图形学中一个比较重要的数学工具。\n\nm×n矩阵表示m行n列的矩阵。\n\n\n\n矩阵乘法运算规则\n\n\n\n\n# 平移矩阵\n\n下面咱们不会严格逻辑推导数学公式，用不严谨的小白方式，给大家介绍下平移矩阵。\n\n一个点的坐标是(x,y,z),假设沿着X、Y、Z轴分别平移Tx、Ty、Tz，毫无疑问平移后的坐标是(x+Tx,y+Ty,z+Tz)。\n\n坐标是(x,y,z)转化为齐次坐标坐标是(x,y,z,1),可以用4x1矩阵表示，这种特殊形式，也可以称为列向量，在webgpu顶点着色器代码中也可以用四维向量vec4表示。\n\n请用矩阵的乘法运算法则验证下面矩阵的等式是否成立?\n\n\n\n\n# 缩放矩阵\n\n通过缩放矩阵可以对顶点的齐次坐标进行缩放。\n\n\n\n\n# 旋转矩阵\n\n假设一个点的坐标是(x,y,z),经过旋转变换后的坐标为(X,Y,Z)\n\n绕Z轴旋转γ角度,z的坐标不变不变，x、y的坐标发生变化，如果你有兴趣，可以用你高中的三角函数知识推理，可以知道旋转后的坐标：X=xcosγ-ysinγ,Y=xsinγ+ycosγ\n\n\n\n三角函数计算推理过程\n\n// 假设旋转前角度A，对应x和y的值\nx = R * cos(A)\ny = R * sin(A)\n\n// 假设旋转了γ度，对应X和Y的值\nX = R * cos(γ+A)\n  = R * (cos(γ)cos(A)-sin(γ)sin(A))\n  = R*cos(A)cos(γ) - R*sin(A)sin(γ)\n  = xcosγ-ysinγ\n\nY = R * sin(γ+A)\n  = R * (sin(γ)cos(A)+cos(γ)sin(A))\n  = R*cos(A)sin(γ) + R*sin(A)cos(γ)\n  = xsinγ+ycosγ\n\n\n\n\n旋转后的坐标：X=xcosγ-ysinγ,Y=xsinγ+ycosγ\n\n绕X轴旋转α角度\n\nx的坐标不变，y、z的坐标发生变化，Y=ycosα-zsinα,Z=ysinα+zcosα\n\n\n\n绕Y轴旋转β角度\n\ny的坐标不变，z、x的坐标发生变化，Z=zsinβ+xcosβ,X=zcosβ-xsinβ\n\n",normalizedContent:"# 数学基础(平移、旋转、缩放矩阵)\n\n本下节课给大家介绍下矩阵的概念，以及用于几何变换的矩阵，比如平移矩阵、缩放矩阵、旋转矩阵。\n\n如果你对这些几何变换的矩阵概念比较熟悉，可以跳过本节课。\n\n\n# 线性代数、图形学\n\n如果你有《线性代数》、《计算机图形学》基础，更有利于webgpu的学习。当然了，你没有这些基础，也没关系，咱们课程的特色就是尽量弱化对数学和图形学基础的要求，尽量带你从零入门。\n\n如果你时间比较充足，也有兴趣，可以去翻翻《线性代数》、《计算机图形学》相关的书籍，当然你不去翻，咱们的课程你也能学习。\n\n如果你数学基础不好，工作也不用封装3d引擎或数学库，可以不用学习《线性代数》，直接用下节课介绍的一个数学库即可。\n\n\n# 本节课针对学员\n\n * 大学学过线性代数的矩阵，但是并不了解用于平移、旋转、缩放的矩阵\n * 没学过线性代数，数学停留在高中水平\n\n\n# 矩阵、矩阵运算规则\n\n矩阵是图形学中一个比较重要的数学工具。\n\nm×n矩阵表示m行n列的矩阵。\n\n\n\n矩阵乘法运算规则\n\n\n\n\n# 平移矩阵\n\n下面咱们不会严格逻辑推导数学公式，用不严谨的小白方式，给大家介绍下平移矩阵。\n\n一个点的坐标是(x,y,z),假设沿着x、y、z轴分别平移tx、ty、tz，毫无疑问平移后的坐标是(x+tx,y+ty,z+tz)。\n\n坐标是(x,y,z)转化为齐次坐标坐标是(x,y,z,1),可以用4x1矩阵表示，这种特殊形式，也可以称为列向量，在webgpu顶点着色器代码中也可以用四维向量vec4表示。\n\n请用矩阵的乘法运算法则验证下面矩阵的等式是否成立?\n\n\n\n\n# 缩放矩阵\n\n通过缩放矩阵可以对顶点的齐次坐标进行缩放。\n\n\n\n\n# 旋转矩阵\n\n假设一个点的坐标是(x,y,z),经过旋转变换后的坐标为(x,y,z)\n\n绕z轴旋转γ角度,z的坐标不变不变，x、y的坐标发生变化，如果你有兴趣，可以用你高中的三角函数知识推理，可以知道旋转后的坐标：x=xcosγ-ysinγ,y=xsinγ+ycosγ\n\n\n\n三角函数计算推理过程\n\n// 假设旋转前角度a，对应x和y的值\nx = r * cos(a)\ny = r * sin(a)\n\n// 假设旋转了γ度，对应x和y的值\nx = r * cos(γ+a)\n  = r * (cos(γ)cos(a)-sin(γ)sin(a))\n  = r*cos(a)cos(γ) - r*sin(a)sin(γ)\n  = xcosγ-ysinγ\n\ny = r * sin(γ+a)\n  = r * (sin(γ)cos(a)+cos(γ)sin(a))\n  = r*cos(a)sin(γ) + r*sin(a)cos(γ)\n  = xsinγ+ycosγ\n\n\n\n\n旋转后的坐标：x=xcosγ-ysinγ,y=xsinγ+ycosγ\n\n绕x轴旋转α角度\n\nx的坐标不变，y、z的坐标发生变化，y=ycosα-zsinα,z=ysinα+zcosα\n\n\n\n绕y轴旋转β角度\n\ny的坐标不变，z、x的坐标发生变化，z=zsinβ+xcosβ,x=zcosβ-xsinβ\n\n",charsets:{cjk:!0}},{title:"11. WebGPU顶点数据插值计算",frontmatter:{title:"11. WebGPU顶点数据插值计算",date:"2023-05-20T23:30:48.000Z",permalink:"/pages/0149ac/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/11.WebGPU%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/11.WebGPU顶点数据插值计算.md",key:"v-18ffc03d",path:"/pages/0149ac/",headers:[{level:3,title:"结构体方式设置顶点着色器main()返回值",slug:"结构体方式设置顶点着色器main-返回值",normalizedTitle:"结构体方式设置顶点着色器main()返回值",charIndex:63},{level:3,title:"顶点位置数据插值计算",slug:"顶点位置数据插值计算",normalizedTitle:"顶点位置数据插值计算",charIndex:637},{level:3,title:"1. 声明一个变量表示片元xyz坐标",slug:"_1-声明一个变量表示片元xyz坐标",normalizedTitle:"1. 声明一个变量表示片元xyz坐标",charIndex:828},{level:3,title:"2. 片元着色器获取插值后的片元坐标xyz",slug:"_2-片元着色器获取插值后的片元坐标xyz",normalizedTitle:"2. 片元着色器获取插值后的片元坐标xyz",charIndex:1617}],headersStr:"结构体方式设置顶点着色器main()返回值 顶点位置数据插值计算 1. 声明一个变量表示片元xyz坐标 2. 片元着色器获取插值后的片元坐标xyz",content:"# WebGPU顶点数据插值计算\n\n本节课给大家介绍下，在WebGPU比较常用的一个知识点，就是顶点数据的插值计算。\n\n\n# 结构体方式设置顶点着色器main()返回值\n\n先学习一个与顶点着色器返回值相关的新语法。\n\n前面课程常用的顶点着色器代码，返回值设置方式@builtin(position) vec4<f32>。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n\n\n顶点着色器main函数返回值用结构体的方式设置。\n\n执行var out:Out;通过结构体Out定义一个变量out，类似JavaScript语言中的类，通过new实例化一个对象。\n\nfn main(@location(0) pos: vec3<f32>) -> Out {\n    var out:Out;//通过结构体生成一个变量\n}\n\n\nstruct Out{\n    @builtin(position) position:vec4<f32>,\n}\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> Out {\n    var out:Out;\n    out.position = vec4<f32>(pos,1.0);\n    return out;\n}\n\n\n\n# 顶点位置数据插值计算\n\n为了方便理解顶点数据的插值计算，以片元的坐标计算为例说明，具体就是获取WebGPU 3D标准设备坐标系下，每个片元对应的xyz坐标。\n\n// 在xyz轴上分别取一个点构成构成一个三角形\n1.0, 0.0, 0.0,\n0.0, 1.0, 0.0,\n0.0, 0.0, 1.0,\n\n\n在WebGPU 3D坐标系下，每个片元都有一个xyz坐标值。\n\n\n\n\n\n\n# 1. 声明一个变量表示片元xyz坐标\n\n顶点着色器返回的数据结构Out中，声明一个变量vPosition:vec3<f32>表示顶点的xyz坐标，然后使用@location(0)标记，注意这里的@location(0)与main函数参数中的@location(0)不是一回事，也不冲突。一般需要顶点着色器输出的变量，需要使用@location()标记，location的参数可以是0、1、2等，本节课比较简单，只有一个变量，标记为0即可。\n\nstruct Out{\n    @builtin(position) position:vec4<f32>,\n    // 位置变量vPosition表示顶点位置坐标插值后的坐标\n    // 通过location标记改变量，location的参数可以是0、1、2等\n    // vPosition可以用来表示每个片元的坐标xyz\n    @location(0) vPosition:vec3<f32>\n}\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> Out {\n    ...\n}\n\n\n表示顶点位置数据的变量pos赋值给out.vPosition，这样顶点着色器功能单元默认就会对顶点进行插值计算，所谓插值计算，就是给pos对应的顶点数据，插入更多的顶点坐标，与片元一一对应，表示每个片元的xyz坐标值。\n\nfn main(@location(0) pos: vec3<f32>) -> Out {\n    var out:Out;//通过结构体生成一个变量\n    out.position = vec4<f32>(pos,1.0);\n    out.vPosition = pos;//插值计算，生成的每个片元对应的xyz坐标\n    return out;\n}\n\n\n\n# 2. 片元着色器获取插值后的片元坐标xyz\n\nmain参数通过@location(0)声明一个变量，和顶点着色器中vPosition变量关联起来。关联起来的原因就是，两个变量都是通过@location(0)标记的，@location()的参数都是0。\n\nvPosition.x表示片元的x坐标，通过课程代码中三角形三个顶点的坐标可以判断vPosition.x的范围是0~1之间。\n\n@fragment\nfn main(@location(0) vPosition:vec3<f32>) -> @location(0) vec4<f32> {\n    // 根据x坐标设置片元颜色\n    if(vPosition.x<0.5){\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    }else{\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n    }\n}\n",normalizedContent:"# webgpu顶点数据插值计算\n\n本节课给大家介绍下，在webgpu比较常用的一个知识点，就是顶点数据的插值计算。\n\n\n# 结构体方式设置顶点着色器main()返回值\n\n先学习一个与顶点着色器返回值相关的新语法。\n\n前面课程常用的顶点着色器代码，返回值设置方式@builtin(position) vec4<f32>。\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return vec4<f32>(pos,1.0);\n}\n\n\n顶点着色器main函数返回值用结构体的方式设置。\n\n执行var out:out;通过结构体out定义一个变量out，类似javascript语言中的类，通过new实例化一个对象。\n\nfn main(@location(0) pos: vec3<f32>) -> out {\n    var out:out;//通过结构体生成一个变量\n}\n\n\nstruct out{\n    @builtin(position) position:vec4<f32>,\n}\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> out {\n    var out:out;\n    out.position = vec4<f32>(pos,1.0);\n    return out;\n}\n\n\n\n# 顶点位置数据插值计算\n\n为了方便理解顶点数据的插值计算，以片元的坐标计算为例说明，具体就是获取webgpu 3d标准设备坐标系下，每个片元对应的xyz坐标。\n\n// 在xyz轴上分别取一个点构成构成一个三角形\n1.0, 0.0, 0.0,\n0.0, 1.0, 0.0,\n0.0, 0.0, 1.0,\n\n\n在webgpu 3d坐标系下，每个片元都有一个xyz坐标值。\n\n\n\n\n\n\n# 1. 声明一个变量表示片元xyz坐标\n\n顶点着色器返回的数据结构out中，声明一个变量vposition:vec3<f32>表示顶点的xyz坐标，然后使用@location(0)标记，注意这里的@location(0)与main函数参数中的@location(0)不是一回事，也不冲突。一般需要顶点着色器输出的变量，需要使用@location()标记，location的参数可以是0、1、2等，本节课比较简单，只有一个变量，标记为0即可。\n\nstruct out{\n    @builtin(position) position:vec4<f32>,\n    // 位置变量vposition表示顶点位置坐标插值后的坐标\n    // 通过location标记改变量，location的参数可以是0、1、2等\n    // vposition可以用来表示每个片元的坐标xyz\n    @location(0) vposition:vec3<f32>\n}\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> out {\n    ...\n}\n\n\n表示顶点位置数据的变量pos赋值给out.vposition，这样顶点着色器功能单元默认就会对顶点进行插值计算，所谓插值计算，就是给pos对应的顶点数据，插入更多的顶点坐标，与片元一一对应，表示每个片元的xyz坐标值。\n\nfn main(@location(0) pos: vec3<f32>) -> out {\n    var out:out;//通过结构体生成一个变量\n    out.position = vec4<f32>(pos,1.0);\n    out.vposition = pos;//插值计算，生成的每个片元对应的xyz坐标\n    return out;\n}\n\n\n\n# 2. 片元着色器获取插值后的片元坐标xyz\n\nmain参数通过@location(0)声明一个变量，和顶点着色器中vposition变量关联起来。关联起来的原因就是，两个变量都是通过@location(0)标记的，@location()的参数都是0。\n\nvposition.x表示片元的x坐标，通过课程代码中三角形三个顶点的坐标可以判断vposition.x的范围是0~1之间。\n\n@fragment\nfn main(@location(0) vposition:vec3<f32>) -> @location(0) vec4<f32> {\n    // 根据x坐标设置片元颜色\n    if(vposition.x<0.5){\n        return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n    }else{\n        return vec4<f32>(0.0, 1.0, 0.0, 1.0);\n    }\n}\n",charsets:{cjk:!0}},{title:"12. 练习—顶点位置插值",frontmatter:{title:"12. 练习—顶点位置插值",date:"2023-06-02T18:49:14.000Z",permalink:"/pages/0c6955/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/12.%E7%BB%83%E4%B9%A0%E2%80%94%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%80%BC.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/12.练习—顶点位置插值.md",key:"v-63e0f928",path:"/pages/0c6955/",headers:[{level:3,title:"WGSL顶点着色器代码(考虑旋转影响)",slug:"wgsl顶点着色器代码-考虑旋转影响",normalizedTitle:"wgsl顶点着色器代码(考虑旋转影响)",charIndex:81},{level:3,title:"WGSL片元着色器代码",slug:"wgsl片元着色器代码",normalizedTitle:"wgsl片元着色器代码",charIndex:783},{level:3,title:"不考虑模型矩阵对顶点置坐标的影响",slug:"不考虑模型矩阵对顶点置坐标的影响",normalizedTitle:"不考虑模型矩阵对顶点置坐标的影响",charIndex:1164},{level:3,title:"WGLSL语法练习——vPosition设置为vec4类型",slug:"wglsl语法练习-vposition设置为vec4类型",normalizedTitle:"wglsl语法练习——vposition设置为vec4类型",charIndex:1551},{level:3,title:"WGLSL语法练习",slug:"wglsl语法练习",normalizedTitle:"wglsl语法练习",charIndex:1551}],headersStr:"WGSL顶点着色器代码(考虑旋转影响) WGSL片元着色器代码 不考虑模型矩阵对顶点置坐标的影响 WGLSL语法练习——vPosition设置为vec4类型 WGLSL语法练习",content:"# 练习—顶点位置插值\n\n本节课内容算是一个练习题，并不讲解新的WebGPU知识点，用到的WebGPU知识点是上节课讲解的WebGPU顶点数据插值计算。\n\n\n# WGSL顶点着色器代码(考虑旋转影响)\n\n参考上节课内容，给2.8小节矩形旋转案例源码增加顶点插值计算shader。\n\n原来顶点着色器代码\n\n@group(0) @binding(0) var<uniform> modelMatrix:mat4x4<f32>;\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return modelMatrix * vec4<f32>(pos,1.0);\n}\n\n\n顶点着色器代码增加顶点插值计算功能\n\n@group(0) @binding(0) var<uniform> modelMatrix:mat4x4<f32>;\nstruct Out{\n    @builtin(position) position:vec4<f32>,\n    @location(0) vPosition:vec3<f32>,\n}\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> Out{\n    var out:Out;\n    out.position = modelMatrix * vec4<f32>(pos,1.0);\n    // 顶点插值的时候考虑模型矩阵的影响\n    // 注意vPosition数据类型是三维向量，计算结果执行.xyz\n    out.vPosition = (modelMatrix * vec4<f32>(pos,1.0)).xyz;\n    return out;\n}\n\n\n\n# WGSL片元着色器代码\n\n原来的WGSL顶点着色器代码\n\n@fragment\nfn main(@location(0) vPosition:vec3<f32>) -> @location(0) vec4<f32> {\n    return vec4<f32>(vPosition.x, 0.0, 1.0-vPosition.x, 1.0);\n}\n\n\n根据旋转后的顶点插值坐标,设置每个片元的颜色值。\n\n@fragment\nfn main(@location(0) vPosition:vec3<f32>) -> @location(0) vec4<f32> {\n    // 根据旋转后的顶点插值坐标,设置每个片元的颜色值\n    return vec4<f32>(vPosition.z, 0.0, 1.0-vPosition.z, 1.0);\n}\n\n\n\n# 不考虑模型矩阵对顶点置坐标的影响\n\n不考虑模型矩阵对顶点位置坐标的影响，插值计算的时候，直接设置out.vPosition = pos;即可。\n\nfn main(@location(0) pos: vec3<f32>) -> Out{\n    var out:Out;\n    out.position = modelMatrix * vec4<f32>(pos,1.0);\n    // 顶点插值的时候考虑模型矩阵的影响\n    // 注意vPosition数据类型是三维向量，计算结果执行.xyz\n    // out.vPosition = (modelMatrix * vec4<f32>(pos,1.0)).xyz;\n    // 顶点插值的时候不考虑模型矩阵的影响\n    out.vPosition = pos;\n    return out;\n}\n\n\n\n# WGLSL语法练习——vPosition设置为vec4类型\n\n@group(0) @binding(0) var<uniform> modelMatrix:mat4x4<f32>;\nstruct Out{\n    @builtin(position) position:vec4<f32>,\n    @location(0) vPosition:vec4<f32>,\n}\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> Out{\n    var out:Out;\n    out.position = modelMatrix * vec4<f32>(pos,1.0);\n    // 顶点插值的时候考虑模型矩阵的影响\n    // 注意vPosition数据类型是三维向量，计算结果执行.xyz\n    out.vPosition = modelMatrix * vec4<f32>(pos,1.0);\n    return out;\n}\n\n\n@fragment\nfn main(@location(0) vPosition:vec4<f32>) -> @location(0) vec4<f32> {\n    return vec4<f32>(vPosition.x, 0.0, 1.0-vPosition.x, 1.0);\n}\n\n\n\n# WGLSL语法练习\n\nout.vPosition和out.position计算方式相同，可以直接把out.position赋值给out.vPosition\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> Out{\n    var out:Out;\n    out.position = modelMatrix * vec4<f32>(pos,1.0);\n    // out.vPosition = modelMatrix * vec4<f32>(pos,1.0);\n    // .vPosition和.position计算方式相同，可以直接把.position赋值给.vPosition\n    out.vPosition = out.position;\n    return out;\n}\n",normalizedContent:"# 练习—顶点位置插值\n\n本节课内容算是一个练习题，并不讲解新的webgpu知识点，用到的webgpu知识点是上节课讲解的webgpu顶点数据插值计算。\n\n\n# wgsl顶点着色器代码(考虑旋转影响)\n\n参考上节课内容，给2.8小节矩形旋转案例源码增加顶点插值计算shader。\n\n原来顶点着色器代码\n\n@group(0) @binding(0) var<uniform> modelmatrix:mat4x4<f32>;\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> @builtin(position) vec4<f32> {\n    return modelmatrix * vec4<f32>(pos,1.0);\n}\n\n\n顶点着色器代码增加顶点插值计算功能\n\n@group(0) @binding(0) var<uniform> modelmatrix:mat4x4<f32>;\nstruct out{\n    @builtin(position) position:vec4<f32>,\n    @location(0) vposition:vec3<f32>,\n}\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> out{\n    var out:out;\n    out.position = modelmatrix * vec4<f32>(pos,1.0);\n    // 顶点插值的时候考虑模型矩阵的影响\n    // 注意vposition数据类型是三维向量，计算结果执行.xyz\n    out.vposition = (modelmatrix * vec4<f32>(pos,1.0)).xyz;\n    return out;\n}\n\n\n\n# wgsl片元着色器代码\n\n原来的wgsl顶点着色器代码\n\n@fragment\nfn main(@location(0) vposition:vec3<f32>) -> @location(0) vec4<f32> {\n    return vec4<f32>(vposition.x, 0.0, 1.0-vposition.x, 1.0);\n}\n\n\n根据旋转后的顶点插值坐标,设置每个片元的颜色值。\n\n@fragment\nfn main(@location(0) vposition:vec3<f32>) -> @location(0) vec4<f32> {\n    // 根据旋转后的顶点插值坐标,设置每个片元的颜色值\n    return vec4<f32>(vposition.z, 0.0, 1.0-vposition.z, 1.0);\n}\n\n\n\n# 不考虑模型矩阵对顶点置坐标的影响\n\n不考虑模型矩阵对顶点位置坐标的影响，插值计算的时候，直接设置out.vposition = pos;即可。\n\nfn main(@location(0) pos: vec3<f32>) -> out{\n    var out:out;\n    out.position = modelmatrix * vec4<f32>(pos,1.0);\n    // 顶点插值的时候考虑模型矩阵的影响\n    // 注意vposition数据类型是三维向量，计算结果执行.xyz\n    // out.vposition = (modelmatrix * vec4<f32>(pos,1.0)).xyz;\n    // 顶点插值的时候不考虑模型矩阵的影响\n    out.vposition = pos;\n    return out;\n}\n\n\n\n# wglsl语法练习——vposition设置为vec4类型\n\n@group(0) @binding(0) var<uniform> modelmatrix:mat4x4<f32>;\nstruct out{\n    @builtin(position) position:vec4<f32>,\n    @location(0) vposition:vec4<f32>,\n}\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> out{\n    var out:out;\n    out.position = modelmatrix * vec4<f32>(pos,1.0);\n    // 顶点插值的时候考虑模型矩阵的影响\n    // 注意vposition数据类型是三维向量，计算结果执行.xyz\n    out.vposition = modelmatrix * vec4<f32>(pos,1.0);\n    return out;\n}\n\n\n@fragment\nfn main(@location(0) vposition:vec4<f32>) -> @location(0) vec4<f32> {\n    return vec4<f32>(vposition.x, 0.0, 1.0-vposition.x, 1.0);\n}\n\n\n\n# wglsl语法练习\n\nout.vposition和out.position计算方式相同，可以直接把out.position赋值给out.vposition\n\n@vertex\nfn main(@location(0) pos: vec3<f32>) -> out{\n    var out:out;\n    out.position = modelmatrix * vec4<f32>(pos,1.0);\n    // out.vposition = modelmatrix * vec4<f32>(pos,1.0);\n    // .vposition和.position计算方式相同，可以直接把.position赋值给.vposition\n    out.vposition = out.position;\n    return out;\n}\n",charsets:{cjk:!0}},{title:"13. 顶点颜色数据插值计算",frontmatter:{title:"13. 顶点颜色数据插值计算",date:"2023-06-02T18:49:23.000Z",permalink:"/pages/3d0f41/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/13.%E9%A1%B6%E7%82%B9%E9%A2%9C%E8%89%B2%E6%95%B0%E6%8D%AE%E6%8F%92%E5%80%BC%E8%AE%A1%E7%AE%97.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/13.顶点颜色数据插值计算.md",key:"v-d9f794c4",path:"/pages/3d0f41/",headers:[{level:3,title:"创建顶点颜色数据",slug:"创建顶点颜色数据",normalizedTitle:"创建顶点颜色数据",charIndex:68},{level:3,title:"渲染管线配置顶点颜色数据获取方式",slug:"渲染管线配置顶点颜色数据获取方式",normalizedTitle:"渲染管线配置顶点颜色数据获取方式",charIndex:878},{level:3,title:"渲染通道.setVertexBuffer()设置顶点颜色数据",slug:"渲染通道-setvertexbuffer-设置顶点颜色数据",normalizedTitle:"渲染通道.setvertexbuffer()设置顶点颜色数据",charIndex:1667},{level:3,title:"颜色插值介绍",slug:"颜色插值介绍",normalizedTitle:"颜色插值介绍",charIndex:1922},{level:3,title:"WGSL顶点着色器代码",slug:"wgsl顶点着色器代码",normalizedTitle:"wgsl顶点着色器代码",charIndex:2018},{level:3,title:"WGSL片元着色器代码",slug:"wgsl片元着色器代码",normalizedTitle:"wgsl片元着色器代码",charIndex:2417}],headersStr:"创建顶点颜色数据 渲染管线配置顶点颜色数据获取方式 渲染通道.setVertexBuffer()设置顶点颜色数据 颜色插值介绍 WGSL顶点着色器代码 WGSL片元着色器代码",content:'# WebGPU顶点颜色数据插值计算\n\n前面给大家介绍过顶点位置坐标数据，本节课给大家介绍一种新的顶点数据，就是顶点颜色数据。\n\n\n# 创建顶点颜色数据\n\n顶点位置数据和顶点位置数据的缓冲区。\n\n//创建顶点位置坐标数据\nconst vertexArray = new Float32Array([\n    0.0, 0.0, 0.0,//顶点1 位置坐标\n    1.0, 0.0, 0.0,//顶点2 位置坐标\n    0.0, 1.0, 0.0,//顶点3 位置坐标\n]);\n// 创建顶点位置数据的缓冲区\nconst vertexBuffer = device.createBuffer({\n    size: vertexArray.byteLength,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n});\n// 顶点位置数据写入缓冲区\ndevice.queue.writeBuffer(vertexBuffer, 0, vertexArray);\n\n\n类比顶点位置数据，创建顶点颜色数据和顶点颜色数据对应的缓冲区。\n\n//创建顶点颜色数据\nconst colorArray = new Float32Array([\n    1.0, 0.0, 0.0,//顶点1颜色数据 红色\n    0.0, 1.0, 0.0,//顶点2颜色数据 绿色\n    0.0, 0.0, 1.0,//顶点3颜色数据 蓝色\n]);\nconst colorBuffer = device.createBuffer({// 创建顶点颜色数据的缓冲区\n    size: colorArray.byteLength,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n});\n// 顶点颜色数据写入缓冲区\ndevice.queue.writeBuffer(colorBuffer, 0, colorArray);\n\n\n\n# 渲染管线配置顶点颜色数据获取方式\n\n渲染管线关于顶点颜色数据相关的参数设置，可以参考顶点位置数据配置参数。\n\nbuffers属性的数组元素是对象构成的，一个对象对应一个顶点缓冲区。\n\n// 渲染管线\nconst pipeline = device.createRenderPipeline({\n    vertex: {//顶点相关配置\n        ...\n        buffers: [//顶点缓冲区相关设置\n            {\n                arrayStride: 3 * 4,\n                attributes: [{\n                   //顶点位置缓冲区存储位置标记\n                   shaderLocation: 1,\n                   format: "float32x3",\n                   offset: 0\n                }]\n            }, {\n                //一个顶点的颜色包含rgb三个分量,每个分量4字节\n                arrayStride: 3 * 4,\n                attributes: [{\n                   //顶点颜色缓冲区存储位置标记\n                   shaderLocation: 1,\n                   format: "float32x3",\n                   offset: 0\n                }]\n            }\n        ]\n    },\n    ...\n});\n\n\n\n# 渲染通道.setVertexBuffer()设置顶点颜色数据\n\n// 渲染通道设置顶点位置数据对应顶点缓冲区   参数一：0表示第1个顶点缓冲区\nrenderPass.setVertexBuffer(0, vertexBuffer);\n// 渲染通道设置顶点颜色数据对应顶点缓冲区   参数一：1表示第2个顶点缓冲区\nrenderPass.setVertexBuffer(1, colorBuffer);\n\n\n如果有多个顶点缓冲区，把device.createBuffer()的参数一，依次增加即可。\n\n\n# 颜色插值介绍\n\n所谓顶点颜色插值，简单说就是WebGPU会自动根据三角形三个顶点的颜色值，插值计算出来所有片元对应的颜色值，如果三个顶点颜色不同，可以看到一种颜色的渐变效果。\n\n\n\n\n\n\n# WGSL顶点着色器代码\n\n顶点颜色数据需要插值计算，类比前面顶点位置数据的插值计算编写。\n\nstruct Out {\n    @builtin(position) position : vec4<f32>,\n    // vColor表示顶点颜色插值后，每个片元对应的颜色数据\n    @location(0) vColor: vec3<f32>\n}\n@vertex\n// main函数输入顶点位置数据和顶点颜色数据\nfn main(@location(0) pos: vec3<f32>,@location(1) color: vec3<f32>) -> Out {\n    var out: Out;\n    out.position = vec4<f32>(pos,1.0);\n    out.vColor = color;//顶点颜色插值计算\n    return out;\n}\n\n\n\n# WGSL片元着色器代码\n\n@fragment\n// 插值后顶点颜色数据，作为函数参数\nfn main( @location(0) vColor: vec3<f32>) -> @location(0) vec4<f32> {\n    // 插值后顶点颜色数据作为赋值给每个片元\n    return vec4<f32>(vColor, 1.0);\n}\n',normalizedContent:'# webgpu顶点颜色数据插值计算\n\n前面给大家介绍过顶点位置坐标数据，本节课给大家介绍一种新的顶点数据，就是顶点颜色数据。\n\n\n# 创建顶点颜色数据\n\n顶点位置数据和顶点位置数据的缓冲区。\n\n//创建顶点位置坐标数据\nconst vertexarray = new float32array([\n    0.0, 0.0, 0.0,//顶点1 位置坐标\n    1.0, 0.0, 0.0,//顶点2 位置坐标\n    0.0, 1.0, 0.0,//顶点3 位置坐标\n]);\n// 创建顶点位置数据的缓冲区\nconst vertexbuffer = device.createbuffer({\n    size: vertexarray.bytelength,\n    usage: gpubufferusage.vertex | gpubufferusage.copy_dst,\n});\n// 顶点位置数据写入缓冲区\ndevice.queue.writebuffer(vertexbuffer, 0, vertexarray);\n\n\n类比顶点位置数据，创建顶点颜色数据和顶点颜色数据对应的缓冲区。\n\n//创建顶点颜色数据\nconst colorarray = new float32array([\n    1.0, 0.0, 0.0,//顶点1颜色数据 红色\n    0.0, 1.0, 0.0,//顶点2颜色数据 绿色\n    0.0, 0.0, 1.0,//顶点3颜色数据 蓝色\n]);\nconst colorbuffer = device.createbuffer({// 创建顶点颜色数据的缓冲区\n    size: colorarray.bytelength,\n    usage: gpubufferusage.vertex | gpubufferusage.copy_dst,\n});\n// 顶点颜色数据写入缓冲区\ndevice.queue.writebuffer(colorbuffer, 0, colorarray);\n\n\n\n# 渲染管线配置顶点颜色数据获取方式\n\n渲染管线关于顶点颜色数据相关的参数设置，可以参考顶点位置数据配置参数。\n\nbuffers属性的数组元素是对象构成的，一个对象对应一个顶点缓冲区。\n\n// 渲染管线\nconst pipeline = device.createrenderpipeline({\n    vertex: {//顶点相关配置\n        ...\n        buffers: [//顶点缓冲区相关设置\n            {\n                arraystride: 3 * 4,\n                attributes: [{\n                   //顶点位置缓冲区存储位置标记\n                   shaderlocation: 1,\n                   format: "float32x3",\n                   offset: 0\n                }]\n            }, {\n                //一个顶点的颜色包含rgb三个分量,每个分量4字节\n                arraystride: 3 * 4,\n                attributes: [{\n                   //顶点颜色缓冲区存储位置标记\n                   shaderlocation: 1,\n                   format: "float32x3",\n                   offset: 0\n                }]\n            }\n        ]\n    },\n    ...\n});\n\n\n\n# 渲染通道.setvertexbuffer()设置顶点颜色数据\n\n// 渲染通道设置顶点位置数据对应顶点缓冲区   参数一：0表示第1个顶点缓冲区\nrenderpass.setvertexbuffer(0, vertexbuffer);\n// 渲染通道设置顶点颜色数据对应顶点缓冲区   参数一：1表示第2个顶点缓冲区\nrenderpass.setvertexbuffer(1, colorbuffer);\n\n\n如果有多个顶点缓冲区，把device.createbuffer()的参数一，依次增加即可。\n\n\n# 颜色插值介绍\n\n所谓顶点颜色插值，简单说就是webgpu会自动根据三角形三个顶点的颜色值，插值计算出来所有片元对应的颜色值，如果三个顶点颜色不同，可以看到一种颜色的渐变效果。\n\n\n\n\n\n\n# wgsl顶点着色器代码\n\n顶点颜色数据需要插值计算，类比前面顶点位置数据的插值计算编写。\n\nstruct out {\n    @builtin(position) position : vec4<f32>,\n    // vcolor表示顶点颜色插值后，每个片元对应的颜色数据\n    @location(0) vcolor: vec3<f32>\n}\n@vertex\n// main函数输入顶点位置数据和顶点颜色数据\nfn main(@location(0) pos: vec3<f32>,@location(1) color: vec3<f32>) -> out {\n    var out: out;\n    out.position = vec4<f32>(pos,1.0);\n    out.vcolor = color;//顶点颜色插值计算\n    return out;\n}\n\n\n\n# wgsl片元着色器代码\n\n@fragment\n// 插值后顶点颜色数据，作为函数参数\nfn main( @location(0) vcolor: vec3<f32>) -> @location(0) vec4<f32> {\n    // 插值后顶点颜色数据作为赋值给每个片元\n    return vec4<f32>(vcolor, 1.0);\n}\n',charsets:{cjk:!0}},{title:"14. 顶点位置、颜色数据共享缓冲区",frontmatter:{title:"14. 顶点位置、颜色数据共享缓冲区",date:"2023-06-02T18:49:29.000Z",permalink:"/pages/3a2ff2/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/14.%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%BD%AE%E3%80%81%E9%A2%9C%E8%89%B2%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E7%BC%93%E5%86%B2%E5%8C%BA.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/14.顶点位置、颜色数据共享缓冲区.md",key:"v-53fb374d",path:"/pages/3a2ff2/",headers:[{level:3,title:"知识回顾",slug:"知识回顾",normalizedTitle:"知识回顾",charIndex:108},{level:3,title:"顶点位置、顶点颜色数据共享顶点缓冲区",slug:"顶点位置、顶点颜色数据共享顶点缓冲区",normalizedTitle:"顶点位置、顶点颜色数据共享顶点缓冲区",charIndex:668},{level:3,title:"渲染管线配置",slug:"渲染管线配置",normalizedTitle:"渲染管线配置",charIndex:1203},{level:3,title:"渲染通道方法.setVertexBuffer()详解",slug:"渲染通道方法-setvertexbuffer-详解",normalizedTitle:"渲染通道方法.setvertexbuffer()详解",charIndex:2770}],headersStr:"知识回顾 顶点位置、顶点颜色数据共享顶点缓冲区 渲染管线配置 渲染通道方法.setVertexBuffer()详解",content:'# 顶点位置、颜色数据共享缓冲区\n\n继续上节课顶点颜色数据的讲解，在上节课三角形案例中，顶点位置和顶点颜色数据分别占用一个顶点缓冲区，下面给大家讲解一个新的例子，就是顶点位置和颜色数据共享同一个顶点缓冲区。\n\n\n# 知识回顾\n\n一个三角形的顶点位置、顶点颜色数据分别创建一个顶点缓冲区。\n\nconst vertexArray = new Float32Array([\n    0.0, 0.0, 0.0,//顶点1 位置坐标\n    1.0, 0.0, 0.0,//顶点2 位置坐标\n    0.0, 1.0, 0.0,//顶点3 位置坐标\n]);\n// 创建顶点位置数据的缓冲区\nconst vertexBuffer = device.createBuffer({...});\ndevice.queue.writeBuffer(vertexBuffer, 0, vertexArray);\n\n//创建顶点颜色数据\nconst colorArray = new Float32Array([\n    1.0, 0.0, 0.0,//顶点1颜色数据 红色\n    0.0, 1.0, 0.0,//顶点2颜色数据 绿色\n    0.0, 0.0, 1.0,//顶点3颜色数据 蓝色\n]);\n// 创建顶点颜色数据的缓冲区\nconst colorBuffer = device.createBuffer({...});\ndevice.queue.writeBuffer(vertexBuffer, 0, vertexArray);\n\n\n\n# 顶点位置、顶点颜色数据共享顶点缓冲区\n\nWebGPU中顶点位置、顶点颜色数据共享顶点缓冲区\n\n//创建顶点数据(顶点位置、顶点颜色)\nconst vertexArray = new Float32Array([\n    // 顶点1位置    顶点1颜色(红色)\n    0.0, 0.0, 0.0, 1.0, 0.0, 0.0,\n    // 顶点2位置    顶点2颜色(绿色)\n    1.0, 0.0, 0.0, 0.0, 1.0, 0.0,\n    // 顶点3位置    顶点3颜色(蓝色)\n    0.0, 1.0, 0.0, 0.0, 0.0, 1.0,\n]);\n// 创建顶点数据的缓冲区(顶点位置、顶点颜色)\nconst vertexBuffer = device.createBuffer({\n    size: vertexArray.byteLength,\n    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n});\n// 顶点位置、颜色数据写入缓冲区\ndevice.queue.writeBuffer(vertexBuffer, 0, vertexArray);\n\n\n\n# 渲染管线配置\n\n顶点位置和顶点颜色数据分别占用一个顶点缓冲区，对应的渲染管线配置。\n\n// 渲染管线\nconst pipeline = device.createRenderPipeline({\n    vertex: {//顶点相关配置\n        ...\n        buffers: [//顶点缓冲区相关设置\n            {\n                arrayStride: 3 * 4,\n                attributes: [{\n                   //顶点位置缓冲区存储位置标记\n                   shaderLocation: 0,\n                   format: "float32x3",\n                   offset: 0\n                }]\n            }, {\n                //一个顶点的颜色包含rgb三个分量,每个分量4字节\n                arrayStride: 3 * 4,\n                attributes: [{\n                   //顶点颜色缓冲区存储位置标记\n                   shaderLocation: 1,\n                   format: "float32x3",\n                   offset: 0\n                }]\n            }\n        ]\n    },\n    ...\n});\n\n\nbuffers属性的数组元素是对象构成的，一个对象对应一个顶点缓冲区，既然顶点位置和顶点颜色数据共享缓冲区，就不用给buffers数组新建一个对象子元素了。\n\n// 渲染管线\nconst pipeline = device.createRenderPipeline({\n    vertex: {//顶点相关配置\n        ...\n        buffers: [//顶点缓冲区相关设置\n            {\n                arrayStride: 6 * 4,\n                attributes: [{\n                   //顶点位置缓冲区存储位置标记\n                   shaderLocation: 0,\n                   format: "float32x3",\n                   offset: 0\n                },{\n                   //顶点颜色缓冲区存储位置标记\n                   shaderLocation: 1,\n                   format: "float32x3",\n                   //一个顶点可能包含多种类型顶点数据，间隔顶点位置的3个数字，才能获取颜色数据\n                   offset: 3 * 4\n                }]\n            }\n        ]\n    },\n    ...\n});\n\n\n一个顶点包含位置数据3个分量、颜色数据3个分量，共计6个数字,每个数字4字节\n\narrayStride: 6 * 4\n\n\n一个顶点可能包含多种类型顶点数据，间隔顶点位置的3个数字，才能获取颜色数据\n\noffset: 3 * 4\n\n\n\n# 渲染通道方法.setVertexBuffer()详解\n\n前面关于.setVertexBuffer()的参数1解释比较模糊，下面具体解释下，.setVertexBuffer()的第一个参数准确来说，对应的是渲染管线buffers数组里面元素的索引值。\n\n\n\n// 渲染通道设置顶点位置数据对应顶点缓冲区   参数一：0表示第1个顶点缓冲区\nrenderPass.setVertexBuffer(0, vertexBuffer);\n// 渲染通道设置顶点颜色数据对应顶点缓冲区   参数一：1表示第2个顶点缓冲区\nrenderPass.setVertexBuffer(1, colorBuffer);\n\n\n如果有多个顶点缓冲区，把device.createBuffer()的参数一，依次增加即可。\n\n前面课程代码会给大家解释，.setVertexBuffer()的参数1和buffers数组中第一个元素对象shaderLocation的值0对应，是因为把buffers数组第一个对象的shaderLocation设置为0,而0刚好是该对象在buffers数组中的索引值，其实你也可以把shaderLocation设置为1、2等其他值，不一定要和.setVertexBuffer()的参数1一致，shaderLocation的值只要和WGSL顶点着色器代码对应即可。',normalizedContent:'# 顶点位置、颜色数据共享缓冲区\n\n继续上节课顶点颜色数据的讲解，在上节课三角形案例中，顶点位置和顶点颜色数据分别占用一个顶点缓冲区，下面给大家讲解一个新的例子，就是顶点位置和颜色数据共享同一个顶点缓冲区。\n\n\n# 知识回顾\n\n一个三角形的顶点位置、顶点颜色数据分别创建一个顶点缓冲区。\n\nconst vertexarray = new float32array([\n    0.0, 0.0, 0.0,//顶点1 位置坐标\n    1.0, 0.0, 0.0,//顶点2 位置坐标\n    0.0, 1.0, 0.0,//顶点3 位置坐标\n]);\n// 创建顶点位置数据的缓冲区\nconst vertexbuffer = device.createbuffer({...});\ndevice.queue.writebuffer(vertexbuffer, 0, vertexarray);\n\n//创建顶点颜色数据\nconst colorarray = new float32array([\n    1.0, 0.0, 0.0,//顶点1颜色数据 红色\n    0.0, 1.0, 0.0,//顶点2颜色数据 绿色\n    0.0, 0.0, 1.0,//顶点3颜色数据 蓝色\n]);\n// 创建顶点颜色数据的缓冲区\nconst colorbuffer = device.createbuffer({...});\ndevice.queue.writebuffer(vertexbuffer, 0, vertexarray);\n\n\n\n# 顶点位置、顶点颜色数据共享顶点缓冲区\n\nwebgpu中顶点位置、顶点颜色数据共享顶点缓冲区\n\n//创建顶点数据(顶点位置、顶点颜色)\nconst vertexarray = new float32array([\n    // 顶点1位置    顶点1颜色(红色)\n    0.0, 0.0, 0.0, 1.0, 0.0, 0.0,\n    // 顶点2位置    顶点2颜色(绿色)\n    1.0, 0.0, 0.0, 0.0, 1.0, 0.0,\n    // 顶点3位置    顶点3颜色(蓝色)\n    0.0, 1.0, 0.0, 0.0, 0.0, 1.0,\n]);\n// 创建顶点数据的缓冲区(顶点位置、顶点颜色)\nconst vertexbuffer = device.createbuffer({\n    size: vertexarray.bytelength,\n    usage: gpubufferusage.vertex | gpubufferusage.copy_dst,\n});\n// 顶点位置、颜色数据写入缓冲区\ndevice.queue.writebuffer(vertexbuffer, 0, vertexarray);\n\n\n\n# 渲染管线配置\n\n顶点位置和顶点颜色数据分别占用一个顶点缓冲区，对应的渲染管线配置。\n\n// 渲染管线\nconst pipeline = device.createrenderpipeline({\n    vertex: {//顶点相关配置\n        ...\n        buffers: [//顶点缓冲区相关设置\n            {\n                arraystride: 3 * 4,\n                attributes: [{\n                   //顶点位置缓冲区存储位置标记\n                   shaderlocation: 0,\n                   format: "float32x3",\n                   offset: 0\n                }]\n            }, {\n                //一个顶点的颜色包含rgb三个分量,每个分量4字节\n                arraystride: 3 * 4,\n                attributes: [{\n                   //顶点颜色缓冲区存储位置标记\n                   shaderlocation: 1,\n                   format: "float32x3",\n                   offset: 0\n                }]\n            }\n        ]\n    },\n    ...\n});\n\n\nbuffers属性的数组元素是对象构成的，一个对象对应一个顶点缓冲区，既然顶点位置和顶点颜色数据共享缓冲区，就不用给buffers数组新建一个对象子元素了。\n\n// 渲染管线\nconst pipeline = device.createrenderpipeline({\n    vertex: {//顶点相关配置\n        ...\n        buffers: [//顶点缓冲区相关设置\n            {\n                arraystride: 6 * 4,\n                attributes: [{\n                   //顶点位置缓冲区存储位置标记\n                   shaderlocation: 0,\n                   format: "float32x3",\n                   offset: 0\n                },{\n                   //顶点颜色缓冲区存储位置标记\n                   shaderlocation: 1,\n                   format: "float32x3",\n                   //一个顶点可能包含多种类型顶点数据，间隔顶点位置的3个数字，才能获取颜色数据\n                   offset: 3 * 4\n                }]\n            }\n        ]\n    },\n    ...\n});\n\n\n一个顶点包含位置数据3个分量、颜色数据3个分量，共计6个数字,每个数字4字节\n\narraystride: 6 * 4\n\n\n一个顶点可能包含多种类型顶点数据，间隔顶点位置的3个数字，才能获取颜色数据\n\noffset: 3 * 4\n\n\n\n# 渲染通道方法.setvertexbuffer()详解\n\n前面关于.setvertexbuffer()的参数1解释比较模糊，下面具体解释下，.setvertexbuffer()的第一个参数准确来说，对应的是渲染管线buffers数组里面元素的索引值。\n\n\n\n// 渲染通道设置顶点位置数据对应顶点缓冲区   参数一：0表示第1个顶点缓冲区\nrenderpass.setvertexbuffer(0, vertexbuffer);\n// 渲染通道设置顶点颜色数据对应顶点缓冲区   参数一：1表示第2个顶点缓冲区\nrenderpass.setvertexbuffer(1, colorbuffer);\n\n\n如果有多个顶点缓冲区，把device.createbuffer()的参数一，依次增加即可。\n\n前面课程代码会给大家解释，.setvertexbuffer()的参数1和buffers数组中第一个元素对象shaderlocation的值0对应，是因为把buffers数组第一个对象的shaderlocation设置为0,而0刚好是该对象在buffers数组中的索引值，其实你也可以把shaderlocation设置为1、2等其他值，不一定要和.setvertexbuffer()的参数1一致，shaderlocation的值只要和wgsl顶点着色器代码对应即可。',charsets:{cjk:!0}},{title:"15. 练习-顶点颜色",frontmatter:{title:"15. 练习-顶点颜色",date:"2023-06-02T18:49:41.000Z",permalink:"/pages/299242/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/15.%E7%BB%83%E4%B9%A0-%E9%A1%B6%E7%82%B9%E9%A2%9C%E8%89%B2.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/15.练习-顶点颜色.md",key:"v-b35f1826",path:"/pages/299242/",headers:[{level:3,title:"设置顶点颜色",slug:"设置顶点颜色",normalizedTitle:"设置顶点颜色",charIndex:101}],headersStr:"设置顶点颜色",content:"# 练习-顶点颜色\n\n本节课做一个顶点颜色相关的练习题，你可以打开1.9小节的案例，能看到两个红色的三角形，下面你可以先参考上节课知识点，借助顶点颜色，把两个红色三角形改为一个红色、一个绿色。\n\n\n# 设置顶点颜色\n\n思路非常简单，三角形三个顶点的颜色不同，会产生颜色渐变的效果，如果三个顶点颜色相同，三角形看到的颜色就是你设置的顶点颜色。\n\n//创建顶点数据(顶点位置、顶点颜色)\nconst vertexArray = new Float32Array([\n    // 三角形1\n    // 顶点1位置    顶点1颜色(红色)\n    0.0, 0.0, 0.0, 1.0, 0.0, 0.0,\n    // 顶点2位置    顶点2颜色(红色)\n    1.0, 0.0, 0.0, 1.0, 0.0, 0.0,\n    // 顶点3位置    顶点3颜色(红色)\n    0.0, 1.0, 0.0, 1.0, 0.0, 0.0,\n\n    // 三角形2\n    -0.5, -0.5, 0.0,  0.0, 1.0, 0.0,\n    -1.0, -0.5, 0.0,  0.0, 1.0, 0.0,\n    -0.5, -1.0, 0.0,  0.0, 1.0, 0.0, \n]);\n",normalizedContent:"# 练习-顶点颜色\n\n本节课做一个顶点颜色相关的练习题，你可以打开1.9小节的案例，能看到两个红色的三角形，下面你可以先参考上节课知识点，借助顶点颜色，把两个红色三角形改为一个红色、一个绿色。\n\n\n# 设置顶点颜色\n\n思路非常简单，三角形三个顶点的颜色不同，会产生颜色渐变的效果，如果三个顶点颜色相同，三角形看到的颜色就是你设置的顶点颜色。\n\n//创建顶点数据(顶点位置、顶点颜色)\nconst vertexarray = new float32array([\n    // 三角形1\n    // 顶点1位置    顶点1颜色(红色)\n    0.0, 0.0, 0.0, 1.0, 0.0, 0.0,\n    // 顶点2位置    顶点2颜色(红色)\n    1.0, 0.0, 0.0, 1.0, 0.0, 0.0,\n    // 顶点3位置    顶点3颜色(红色)\n    0.0, 1.0, 0.0, 1.0, 0.0, 0.0,\n\n    // 三角形2\n    -0.5, -0.5, 0.0,  0.0, 1.0, 0.0,\n    -1.0, -0.5, 0.0,  0.0, 1.0, 0.0,\n    -0.5, -1.0, 0.0,  0.0, 1.0, 0.0, \n]);\n",charsets:{cjk:!0}},{title:"16. 结构体作为WGLSL函数参数",frontmatter:{title:"16. 结构体作为WGLSL函数参数",date:"2023-06-02T18:49:48.000Z",permalink:"/pages/8918c1/"},regularPath:"/WebGPU%E6%95%99%E7%A8%8B/02.2.%203D%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/16.%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BAWGLSL%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0.html",relativePath:"WebGPU教程/02.2. 3D几何变换数学基础/16.结构体作为WGLSL函数参数.md",key:"v-25fafc76",path:"/pages/8918c1/",headers:[{level:3,title:"结构体作为顶点着色器main函数参数",slug:"结构体作为顶点着色器main函数参数",normalizedTitle:"结构体作为顶点着色器main函数参数",charIndex:97},{level:3,title:"结构体作为片元着色器main函数参数",slug:"结构体作为片元着色器main函数参数",normalizedTitle:"结构体作为片元着色器main函数参数",charIndex:975}],headersStr:"结构体作为顶点着色器main函数参数 结构体作为片元着色器main函数参数",content:"# 结构体作为WGSL函数参数\n\n本节课给大家讲解，在WebGPU案例中，把结构体作为WGSL顶点着色器和片元着色器主函数main的参数。\n\n下面直接在2.14节代码基础上给大家演示。\n\n\n# 结构体作为顶点着色器main函数参数\n\n下面两端代码的功能是相同的。\n\n顶点位置数据、顶点颜色数据对应的变量作为WGSL顶点着色器main函数的参数，输入给顶点着色器使用。\n\nstruct Out {\n    @builtin(position) position : vec4<f32>,\n    // vColor表示顶点颜色插值后，每个片元对应的颜色数据\n    @location(0) vColor: vec3<f32>\n}\n@vertex\n// main函数输入顶点位置数据和顶点颜色数据\nfn main(@location(0) pos: vec3<f32>,@location(1) color: vec3<f32>) -> Out {\n    var out: Out;\n    out.position = vec4<f32>(pos,1.0);\n    out.vColor = color;\n    return out;\n}\n\n\n声明一个结构体Input，包含顶点位置数据和顶点颜色数据，然后结构体作为main函数参数。\n\nstruct Out {\n    @builtin(position) position : vec4<f32>,\n    // vColor表示顶点颜色插值后，每个片元对应的颜色数据\n    @location(0) vColor: vec3<f32>\n}\nstruct Input{\n    @location(0) pos: vec3<f32>,\n    @location(1) color: vec3<f32>\n}\n@vertex\n// 结构体作为main函数参数：结构体包含顶点位置数据和顶点颜色数据\nfn main(input:Input) -> Out {\n    var out: Out;\n    out.position = vec4<f32>(input.pos,1.0);\n    out.vColor = input.color;\n    return out;\n}\n\n\n\n# 结构体作为片元着色器main函数参数\n\n插值后的顶点颜色数据对应变量vColor作为片元着色器main函数的参数。\n\n@fragment\n// 插值后顶点颜色数据，作为函数参数\nfn main( @location(0) vColor: vec3<f32>) -> @location(0) vec4<f32> {\n    // 插值后顶点颜色数据作为赋值给每个片元\n    return vec4<f32>(vColor, 1.0);\n}\n\n\n结构体作为片元着色器main函数的参数。\n\nstruct Input{\n    @location(0) vColor: vec3<f32>\n}\n@fragment\n// 插值后顶点颜色数据，作为函数参数\nfn main( input:Input) -> @location(0) vec4<f32> {\n    // 插值后顶点颜色数据作为赋值给每个片元\n    return vec4<f32>(input.vColor, 1.0);\n}\n",normalizedContent:"# 结构体作为wgsl函数参数\n\n本节课给大家讲解，在webgpu案例中，把结构体作为wgsl顶点着色器和片元着色器主函数main的参数。\n\n下面直接在2.14节代码基础上给大家演示。\n\n\n# 结构体作为顶点着色器main函数参数\n\n下面两端代码的功能是相同的。\n\n顶点位置数据、顶点颜色数据对应的变量作为wgsl顶点着色器main函数的参数，输入给顶点着色器使用。\n\nstruct out {\n    @builtin(position) position : vec4<f32>,\n    // vcolor表示顶点颜色插值后，每个片元对应的颜色数据\n    @location(0) vcolor: vec3<f32>\n}\n@vertex\n// main函数输入顶点位置数据和顶点颜色数据\nfn main(@location(0) pos: vec3<f32>,@location(1) color: vec3<f32>) -> out {\n    var out: out;\n    out.position = vec4<f32>(pos,1.0);\n    out.vcolor = color;\n    return out;\n}\n\n\n声明一个结构体input，包含顶点位置数据和顶点颜色数据，然后结构体作为main函数参数。\n\nstruct out {\n    @builtin(position) position : vec4<f32>,\n    // vcolor表示顶点颜色插值后，每个片元对应的颜色数据\n    @location(0) vcolor: vec3<f32>\n}\nstruct input{\n    @location(0) pos: vec3<f32>,\n    @location(1) color: vec3<f32>\n}\n@vertex\n// 结构体作为main函数参数：结构体包含顶点位置数据和顶点颜色数据\nfn main(input:input) -> out {\n    var out: out;\n    out.position = vec4<f32>(input.pos,1.0);\n    out.vcolor = input.color;\n    return out;\n}\n\n\n\n# 结构体作为片元着色器main函数参数\n\n插值后的顶点颜色数据对应变量vcolor作为片元着色器main函数的参数。\n\n@fragment\n// 插值后顶点颜色数据，作为函数参数\nfn main( @location(0) vcolor: vec3<f32>) -> @location(0) vec4<f32> {\n    // 插值后顶点颜色数据作为赋值给每个片元\n    return vec4<f32>(vcolor, 1.0);\n}\n\n\n结构体作为片元着色器main函数的参数。\n\nstruct input{\n    @location(0) vcolor: vec3<f32>\n}\n@fragment\n// 插值后顶点颜色数据，作为函数参数\nfn main( input:input) -> @location(0) vec4<f32> {\n    // 插值后顶点颜色数据作为赋值给每个片元\n    return vec4<f32>(input.vcolor, 1.0);\n}\n",charsets:{cjk:!0}},{title:"Web3D人才推荐",frontmatter:{title:"Web3D人才推荐",date:"2023-10-07T23:08:47.000Z",permalink:"/pages/0d3229/",sidebar:"auto"},regularPath:"/_posts/Web3D%E4%BA%BA%E6%89%8D%E6%8E%A8%E8%8D%90.html",relativePath:"_posts/Web3D人才推荐.md",key:"v-37e75448",path:"/pages/0d3229/",headersStr:null,content:"# Web3D可视化人才推荐\n\n如果你是公司的HR或技术负责人，需要招聘WebGL/Three.js方向3D可视化程序员，可以联系我，告诉我你们的招聘要求即可。\n\n如果你们公司刚接触Web3D项目，不知道找什么样的人才，可以告诉我你们的项目需求，我会根据你们项目需求推荐匹配合适的人才。\n\n邮箱：guolongbang@163.com",normalizedContent:"# web3d可视化人才推荐\n\n如果你是公司的hr或技术负责人，需要招聘webgl/three.js方向3d可视化程序员，可以联系我，告诉我你们的招聘要求即可。\n\n如果你们公司刚接触web3d项目，不知道找什么样的人才，可以告诉我你们的项目需求，我会根据你们项目需求推荐匹配合适的人才。\n\n邮箱：guolongbang@163.com",charsets:{cjk:!0}},{title:"Web3D可视化面试题和模板(WebGL/Three.js)",frontmatter:{title:"Web3D可视化面试题和模板(WebGL/Three.js)",date:"2023-08-28T18:25:44.000Z",permalink:"/pages/88e5dc/",sidebar:"auto"},regularPath:"/_posts/Web3D%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9D%A2%E8%AF%95(WebGL%E3%80%81Three.js).html",relativePath:"_posts/Web3D可视化面试(WebGL、Three.js).md",key:"v-5e46ee5e",path:"/pages/88e5dc/",headers:[{level:2,title:"面试大方向指导",slug:"面试大方向指导",normalizedTitle:"面试大方向指导",charIndex:246},{level:2,title:"作品问题",slug:"作品问题",normalizedTitle:"作品问题",charIndex:497},{level:2,title:"前端问题面试",slug:"前端问题面试",normalizedTitle:"前端问题面试",charIndex:709},{level:2,title:"threejs基础问题",slug:"threejs基础问题",normalizedTitle:"threejs基础问题",charIndex:899},{level:3,title:"你都了解什么建模软件",slug:"你都了解什么建模软件",normalizedTitle:"你都了解什么建模软件",charIndex:961},{level:3,title:"介绍下模型几何体的position、uv、index、normal等属性",slug:"介绍下模型几何体的position、uv、index、normal等属性",normalizedTitle:"介绍下模型几何体的position、uv、index、normal等属性",charIndex:1132},{level:3,title:"渲染循环问题",slug:"渲染循环问题",normalizedTitle:"渲染循环问题",charIndex:1311},{level:3,title:"Group和Object3D区别",slug:"group和object3d区别",normalizedTitle:"group和object3d区别",charIndex:1505},{level:3,title:"你了解threejs哪些材质",slug:"你了解threejs哪些材质",normalizedTitle:"你了解threejs哪些材质",charIndex:1625},{level:3,title:"你了解tween.js库吗",slug:"你了解tween-js库吗",normalizedTitle:"你了解tween.js库吗",charIndex:1992},{level:3,title:"怎么获取本地坐标和世界坐标",slug:"怎么获取本地坐标和世界坐标",normalizedTitle:"怎么获取本地坐标和世界坐标",charIndex:2085},{level:3,title:"了解gltf文件格式吗",slug:"了解gltf文件格式吗",normalizedTitle:"了解gltf文件格式吗",charIndex:2193},{level:3,title:"threejs后处理你都了解什么内容",slug:"threejs后处理你都了解什么内容",normalizedTitle:"threejs后处理你都了解什么内容",charIndex:2402},{level:3,title:"一个三维场景有哪些标注标签方式",slug:"一个三维场景有哪些标注标签方式",normalizedTitle:"一个三维场景有哪些标注标签方式",charIndex:2540},{level:3,title:"怎么通过threejs代码设置三维场景的阴影",slug:"怎么通过threejs代码设置三维场景的阴影",normalizedTitle:"怎么通过threejs代码设置三维场景的阴影",charIndex:2665},{level:3,title:"你知道怎么鼠标单击拾取选中模型吗？",slug:"你知道怎么鼠标单击拾取选中模型吗",normalizedTitle:"你知道怎么鼠标单击拾取选中模型吗？",charIndex:2989},{level:3,title:"你大概知道threejs什么光源",slug:"你大概知道threejs什么光源",normalizedTitle:"你大概知道threejs什么光源",charIndex:3215},{level:3,title:"threejs怎么调节光圈明暗程度",slug:"threejs怎么调节光圈明暗程度",normalizedTitle:"threejs怎么调节光圈明暗程度",charIndex:3266},{level:2,title:"数学几何计算问题",slug:"数学几何计算问题",normalizedTitle:"数学几何计算问题",charIndex:3322},{level:3,title:"图形学方面，你了解哪些常用几何变换的矩阵",slug:"图形学方面-你了解哪些常用几何变换的矩阵",normalizedTitle:"图形学方面，你了解哪些常用几何变换的矩阵",charIndex:3392},{level:3,title:"threejs控制模型姿态的方式有哪些，简单说说",slug:"threejs控制模型姿态的方式有哪些-简单说说",normalizedTitle:"threejs控制模型姿态的方式有哪些，简单说说",charIndex:3454},{level:3,title:"四元数和欧拉角有什么区别",slug:"四元数和欧拉角有什么区别",normalizedTitle:"四元数和欧拉角有什么区别",charIndex:3588},{level:3,title:"向量点乘几何含义",slug:"向量点乘几何含义",normalizedTitle:"向量点乘几何含义",charIndex:3653},{level:3,title:"怎么计算两个向量的夹角",slug:"怎么计算两个向量的夹角",normalizedTitle:"怎么计算两个向量的夹角",charIndex:3729},{level:3,title:"向量叉乘几何含义",slug:"向量叉乘几何含义",normalizedTitle:"向量叉乘几何含义",charIndex:3764},{level:3,title:"怎么计算一个三角形平面的法线",slug:"怎么计算一个三角形平面的法线",normalizedTitle:"怎么计算一个三角形平面的法线",charIndex:3875},{level:3,title:"判断点是否在扇形区域内",slug:"判断点是否在扇形区域内",normalizedTitle:"判断点是否在扇形区域内",charIndex:3954},{level:2,title:"底层webgl或threejs shader问题",slug:"底层webgl或threejs-shader问题",normalizedTitle:"底层webgl或threejs shader问题",charIndex:4102},{level:3,title:"介绍下渲染管线的原理",slug:"介绍下渲染管线的原理",normalizedTitle:"介绍下渲染管线的原理",charIndex:4230},{level:3,title:"原生WebGL你怎么创建一个矩形",slug:"原生webgl你怎么创建一个矩形",normalizedTitle:"原生webgl你怎么创建一个矩形",charIndex:4473},{level:3,title:"了解webgpu吗",slug:"了解webgpu吗",normalizedTitle:"了解webgpu吗",charIndex:4662},{level:3,title:"你写过webgl或threejs的shader吗",slug:"你写过webgl或threejs的shader吗",normalizedTitle:"你写过webgl或threejs的shader吗",charIndex:4808},{level:3,title:"通过threejs材质那个方法可以修改已有材质的shader",slug:"通过threejs材质那个方法可以修改已有材质的shader",normalizedTitle:"通过threejs材质那个方法可以修改已有材质的shader",charIndex:4935},{level:3,title:"threejs shader实现飞线动画",slug:"threejs-shader实现飞线动画",normalizedTitle:"threejs shader实现飞线动画",charIndex:5147},{level:3,title:"threejs shader设置模型颜色渐变",slug:"threejs-shader设置模型颜色渐变",normalizedTitle:"threejs shader设置模型颜色渐变",charIndex:5282},{level:3,title:"threejs shader实现直线扫光效果",slug:"threejs-shader实现直线扫光效果",normalizedTitle:"threejs shader实现直线扫光效果",charIndex:5558},{level:3,title:"threejs shader实现直线波动光圈扫光效果",slug:"threejs-shader实现直线波动光圈扫光效果",normalizedTitle:"threejs shader实现直线波动光圈扫光效果",charIndex:5731},{level:3,title:"更多补充中",slug:"更多补充中",normalizedTitle:"更多补充中",charIndex:5895}],headersStr:"面试大方向指导 作品问题 前端问题面试 threejs基础问题 你都了解什么建模软件 介绍下模型几何体的position、uv、index、normal等属性 渲染循环问题 Group和Object3D区别 你了解threejs哪些材质 你了解tween.js库吗 怎么获取本地坐标和世界坐标 了解gltf文件格式吗 threejs后处理你都了解什么内容 一个三维场景有哪些标注标签方式 怎么通过threejs代码设置三维场景的阴影 你知道怎么鼠标单击拾取选中模型吗？ 你大概知道threejs什么光源 threejs怎么调节光圈明暗程度 数学几何计算问题 图形学方面，你了解哪些常用几何变换的矩阵 threejs控制模型姿态的方式有哪些，简单说说 四元数和欧拉角有什么区别 向量点乘几何含义 怎么计算两个向量的夹角 向量叉乘几何含义 怎么计算一个三角形平面的法线 判断点是否在扇形区域内 底层webgl或threejs shader问题 介绍下渲染管线的原理 原生WebGL你怎么创建一个矩形 了解webgpu吗 你写过webgl或threejs的shader吗 通过threejs材质那个方法可以修改已有材质的shader threejs shader实现飞线动画 threejs shader设置模型颜色渐变 threejs shader实现直线扫光效果 threejs shader实现直线波动光圈扫光效果 更多补充中",content:"# Web3D可视化面试题和模板(WebGL/Three.js)\n\n下面给大家简单介绍下Web3D可视化面试(WebGL、Three.js)中可能会遇到的问题。\n\n不过有一点要提前声明下，Web3D可视化起步发展中，并不像普通前端有那么多固定的面试模板或留言，面试形式五花八门，也不一定就是面试具体知识点。大家不用刻意去记忆下面的面试题，面试时根据自己掌握的知识，结合项目，随机应变回答即可。\n\n大家要做的是，根据我写的面试题，判断下，你自身的水平，查漏补缺，慢慢提升自身水平即可。\n\n\n# 面试大方向指导\n\n不同公司面试方式五花八门，不过大体上分为两大类。\n\n如果中小公司，刚刚接触这块，公司没人了解，一般倾向于让你展示作品或履历，而不是具体问题，毕竟他们也不会。\n\n如果对方公司有完整WebGL程序员团队，一般会问具体threejs、webgl、Cesium等具体知识点，如果是实习生，一般要求低点，如果是中高级程序员，除了简单threejs知识点，还会问数学几何计算、shader、WebGL等底层知识点。\n\n还有一些公司会给你一个模型场景，让你回去，自由发挥实现一个特定效果。\n\n\n# 作品问题\n\n你可以在我系统课程中一些案例基础上，丰富下，自己实现一些效果，或者放在个人博客上。(有一点，如果你的面试官刚好接触过我课程，你需要想好怎么回复，比如直接说明学过我课程，自己增加了点功能即可)。\n\n去模型网等任何网站购买一些原创模型，然后自己写代码，这样就省去建模时间，然后直接套用课程用功能代码就行，模型虽然不同，但是代码没什么区别。\n\n当然了如果你有公司履历就用不着这样了，直接展示公司做的案例即可。\n\n\n# 前端问题面试\n\n一般前端问题面试，相比普通前端，会问的少点，毕竟主要还是面试3d这块。\n\n如果你原来就是前端，那么和以前面试一样就行。\n\n如果你是非前端转过来的，那么对你普通前端技术栈可能没有那么熟悉，但是也尽量去了解熟悉下。如果问到某块知识点你熟悉吗，如果不熟悉，直接回答否就行或者说知道点，但是很少用，这样面试官也不会深入问了。这样面试官就会重点面试web3d这块。\n\n\n# threejs基础问题\n\n一般会问提一些web3d可视化开发常见的基础问题，比如three.js、模型软件之类的。\n\n\n# 你都了解什么建模软件\n\n下面我写的非常多，但是你不用去记忆，其实能知道常用的Blender就行了，或者多说点美术常用的3dmax、c4d之类的\n\n美术相关：blender、3dmax、c4d、maya 机械相关：SolidWorks、CATIA、AutoCAD、UG 建筑相关：Revit、SketchUp 工业设计相关：Rhino\n\n\n# 介绍下模型几何体的position、uv、index、normal等属性\n\n 1. position：顶点位置坐标，描述模型的几何形状\n 2. uv：顶点UV纹理坐标，与顶点位置一一对应，用来表示贴图与模型的映射关系\n 3. index：几何体顶点索引\n 4. normal：几何体顶点法线\n\n更具体学习参考threejs中文网电子书章节2和章节5\n\n\n# 渲染循环问题\n\n具体问题：three.js动画渲染循环中，一般需要执行WebGL渲染器那个方法\n\n答案：一般需要执行WebGL渲染器WebGLRenderer的.render()渲染方法\n\nfunction render() {\n    renderer.render(scene, camera); \n    requestAnimationFrame(render);\n}\n\n\n\n# Group和Object3D区别\n\n在threejs的语法中Object3D是的Group父类,但是具体使用，都差不多，Group更语义化一些，可以用来表示一个组对象，可以包含mesh、group、line等子对象，构成层级模型。\n\n\n# 你了解threejs哪些材质\n\n整体来说，有点材质、精灵材质、线材质、网格材质等等，这些材质分别和点模型Points、精灵模型Sprite、线模型Line、网格模型Mesh相对应。\n\n其中网格材质比较丰富，比较常用，比如不受光照影响的基础网格模型MeshBasicMaterial，受到光照影响的漫反射网格材质MeshLambertMaterial、高光网格材质MeshPhongMaterial、PBR相关材质MeshStandardMaterial和MeshPhysicalMaterial\n\n相关链接： http://www.webgl3d.cn/pages/2da02c/ http://www.webgl3d.cn/pages/24c407/ http://www.webgl3d.cn/pages/56b66b/\n\n\n# 你了解tween.js库吗\n\ntween.js是JavaScript动画库，主要用于补间动画。在threejs项目中，也可以借助tween.js辅助threejs实现动画效果。\n\n\n# 怎么获取本地坐标和世界坐标\n\n模型本地坐标：.position属性\n\n模型世界坐标：.getWorldPosition()方法\n\n参考：http://www.webgl3d.cn/pages/00ddfa/\n\n\n# 了解gltf文件格式吗\n\ngltf是Web3D可视化开发中，非常常用的一种三维模型文件格式，就像图像常用的jpg或png格式一样。\n\n一般实际开发，通过Blender构建三维模型，然后导出gltf文件，threejs在通过代码加载gltf模型。\n\n.glb文件是gltf格式的二进制文件。\n\n相关内容参考threejs中文网电子书章节6：http://www.webgl3d.cn/pages/f24993/\n\n\n# threejs后处理你都了解什么内容\n\n具体参考：http://www.webgl3d.cn/pages/e1e75d/\n\n实际回复，你可以把你大概熟悉的说下，比如outline高亮发光描边，比如bloom发光、比如抗锯齿的相关后处理、比如gama矫正的相关后处理。\n\n\n# 一个三维场景有哪些标注标签方式\n\n 1. threejs自身的模型对象，比如精灵模型Sprite\n 2. CSS2和CSS3渲染器，渲染HTML标签标注三维场景\n\n参考：http://www.webgl3d.cn/pages/428714/\n\n\n# 怎么通过threejs代码设置三维场景的阴影\n\n记不太清，可以大概描述即可，一般就是递归遍历整个三维场景，设置所有模型可以产生阴影和接收阴影效果。\n\n然后通过阴影属性.shadow.camera，设置好阴影渲染范围。\n\n最后不要忘了，渲染器允许阴影渲染、光源允许阴影计算。\n\n具体参考：http://www.webgl3d.cn/pages/1dbe9d/\n\n1..castShadow设置产生阴影的模型对象 2..castShadow设置产生阴影的光源对象 3..receiveShadow设置接收阴影效果的模型 4..shadowMap.enabledWebGl渲染器允许阴影渲染 5..shadow.camera设置光源阴影渲染范围\n\n\n# 你知道怎么鼠标单击拾取选中模型吗？\n\n一般就是借助射线拾取API Raycaster实现。\n\n 1. 根据鼠标点击事件对象，获得鼠标在canvas画布上的屏幕坐标(单位像素px)\n 2. 把屏幕坐标转化为WebGL标准设备坐标\n 3. .setFromCamera()根据标准设备坐标和相机参数计算射线\n 4. 最后通过Raycaster实现射线拾取模型计算\n\n具体流程：http://www.webgl3d.cn/pages/f96af1/\n\n\n# 你大概知道threejs什么光源\n\n点光源、聚光源、平行光、环境光...，根据你了解说下就行\n\n\n# threejs怎么调节光圈明暗程度\n\nthreejs光源对象具有光照强度属性，可以调节光源的明暗程度。\n\n\n# 数学几何计算问题\n\n一般长期做这块，一些基本的数学几何计算还是要了解，更多内容，可以查看threejs中文网电子书或系统课程介绍。\n\n\n# 图形学方面，你了解哪些常用几何变换的矩阵\n\n模型矩阵：旋转矩阵、缩放矩阵、平移矩阵\n\n相机相关的视图矩阵、投影矩阵\n\n\n# threejs控制模型姿态的方式有哪些，简单说说\n\n 1. 角度属性.rotation(欧拉角)\n 2. 四元数属性.quaternion\n 3. rotateX、rotateY、rotateZ等旋转方法，可以改变角度属性.rotation\n 4. 旋转矩阵\n\n\n# 四元数和欧拉角有什么区别\n\n四元数和欧拉角，都可以控制物体的姿态角度变化。\n\n欧拉角存在自锁现象，四元数不存在自锁现象。\n\n\n# 向量点乘几何含义\n\n简单回复就是两个向量长度乘以夹角余弦值，更具体参考：http://www.webgl3d.cn/pages/44b0ba/\n\n\n# 怎么计算两个向量的夹角\n\n两个向量归一化，然后dot点乘即可\n\n\n# 向量叉乘几何含义\n\n 1. 两个向量叉乘，得到的新向量垂直于两个向量\n 2. 相乘结果向量长度是：两个向量长度乘以夹角正弦值\n\n更多代码参考：http://www.webgl3d.cn/pages/4558d6/\n\n\n# 怎么计算一个三角形平面的法线\n\n三角形随便选择两条边，生成两个向量。\n\n两个向量叉乘，得到一个垂直于三角形向量，结果向量归一化，就是三角形法线方向。\n\n\n# 判断点是否在扇形区域内\n\n一般一些游戏相关功能，可能会问到。\n\n简单回复就是，利用向量点乘，判断点是否在扇形区域内。利用向量点乘计算夹角，与扇形角度比较，然后计算点与扇形圆形距离与扇形半径比较即可。\n\n更多代码参考：http://www.webgl3d.cn/pages/feb38e/\n\n\n# 底层webgl或threejs shader问题\n\n一般有webgl专门团队公司，在北上广深一线城市，20k朝上webgl程序员，一般还是要求shader这块的，除非特殊情况，对方公司没人懂，招聘前端，懂threjs优先，可能不要求shader。\n\n\n# 介绍下渲染管线的原理\n\n形象点说，WebGL渲染管线就像工厂的流水线一样，提供了不同的功能单元，比如顶点着色器、图元装配、光栅器、片元着色器、深度测试、模板测试等不同功能单元，渲染管线通过这些功能单元，可以处理三维场景的顶点、光源、纹理图像等数据，渲染三维场景，在Canvas画布上输出渲染结果。\n\n 1. 顶点着色器：执行顶点着色器代码\n 2. 片元着色器：执行片元着色器代码\n\n\n\n更多关于webgl渲染管线详细的介绍，可以参考threejs中文网WebGL入门讲解即可。\n\n\n# 原生WebGL你怎么创建一个矩形\n\n可以用两个三角形拼接出来一个矩形，三个顶点表示一个三角形，两个三角形需要6个顶点坐标。\n\n两个三角形有个两个顶点坐标是共享的，也可以借助顶点索引，这样创建一个顶点坐标，然后利用索引重复利用其中两个顶点即可。\n\n参考：http://www.webgl3d.cn/WebGL/\n\nhttp://www.webgl3d.cn/WebGL/\n\n\n# 了解webgpu吗\n\n根据自身情况具体说明就行\n\nwebgpu类似webgl的一种新一代图形技术，谷歌浏览器2023年刚刚开始支持。如果你学习过系统课程里面入门webpgu，就说只是入门即可，如果没学习过WebGPU，直接回复不熟悉也没什么，公司只是考察下，你对这个行业的了解情况。\n\n\n# 你写过webgl或threejs的shader吗\n\n根据自身情况回复，如果写过具体的说明，如果没写过的复杂案例，可以回复大概入门，能写一些简单。\n\n学习的话，参考系统课程里面threejs shader或原生webgl或原生webpgu的讲解。\n\n\n# 通过threejs材质那个方法可以修改已有材质的shader\n\n所有threejs材质有一个父类Material，Material具有.onBeforeCompile()方法，通过.onBeforeCompile()方法可以修改、增删threejs材质默认的shader，比如你可以修改Lambert网格材质的着色器代码，可以修改PBR材质的着色器代码。\n\n具体参考系统课程中threejs shader部分的讲解\n\n\n# threejs shader实现飞线动画\n\n飞线轨迹是通过线条几何体的顶点坐标构成，可以使用点模型Points渲染飞线轨迹，然后通过顶点着色器gl_PointSize控制飞线点的像素大小，按照飞线顶点顺序，控制点像素大小渐变即可。\n\n具体在地球飞线案例中有讲解\n\n\n# threejs shader设置模型颜色渐变\n\n在片元着色器GLSL代码中，通过片元坐标vPosition控制颜色值，比如让片元的颜色值gl_FragColor与vPosition的z坐标相关。\n\nvec3 gradient = mix(vec3(0.0,0.1,0.1), vec3(0.0,1.0,1.0), vPosition.z/550.0);\noutgoingLight = outgoingLight*gradient;\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\n\n# threejs shader实现直线扫光效果\n\n.onBeforeCompile()批量修改场景中所有模型的材质shader。\n\n比如通过vPosition的x坐标分量，在x1~x2范围内，控制顶点颜色值，实现直线扫光效果。如果希望扫光运动起来，可以加入一个uniform时间变量t，控制x1~x2范围随时间变化，实现直线扫光动画效果。\n\n\n# threejs shader实现直线波动光圈扫光效果\n\n比如通过vPosition的x、y坐标分量控制，计算三角函数计算x、y坐标与某个圆心的半径长度，设置半径r1~r2范围，控制顶点颜色值，比如设置白色。如果希望扫光运动起来，可以加入一个uniform时间变量t，控制r1~r2范围随时间变化，实现直线光圈动画效果。\n\n\n# 更多补充中\n\n如果你遇到面试问题，可以也可以私信我留言，我会整理好统一，分享大家\n\n交流群在threejs中文网的首页。",normalizedContent:"# web3d可视化面试题和模板(webgl/three.js)\n\n下面给大家简单介绍下web3d可视化面试(webgl、three.js)中可能会遇到的问题。\n\n不过有一点要提前声明下，web3d可视化起步发展中，并不像普通前端有那么多固定的面试模板或留言，面试形式五花八门，也不一定就是面试具体知识点。大家不用刻意去记忆下面的面试题，面试时根据自己掌握的知识，结合项目，随机应变回答即可。\n\n大家要做的是，根据我写的面试题，判断下，你自身的水平，查漏补缺，慢慢提升自身水平即可。\n\n\n# 面试大方向指导\n\n不同公司面试方式五花八门，不过大体上分为两大类。\n\n如果中小公司，刚刚接触这块，公司没人了解，一般倾向于让你展示作品或履历，而不是具体问题，毕竟他们也不会。\n\n如果对方公司有完整webgl程序员团队，一般会问具体threejs、webgl、cesium等具体知识点，如果是实习生，一般要求低点，如果是中高级程序员，除了简单threejs知识点，还会问数学几何计算、shader、webgl等底层知识点。\n\n还有一些公司会给你一个模型场景，让你回去，自由发挥实现一个特定效果。\n\n\n# 作品问题\n\n你可以在我系统课程中一些案例基础上，丰富下，自己实现一些效果，或者放在个人博客上。(有一点，如果你的面试官刚好接触过我课程，你需要想好怎么回复，比如直接说明学过我课程，自己增加了点功能即可)。\n\n去模型网等任何网站购买一些原创模型，然后自己写代码，这样就省去建模时间，然后直接套用课程用功能代码就行，模型虽然不同，但是代码没什么区别。\n\n当然了如果你有公司履历就用不着这样了，直接展示公司做的案例即可。\n\n\n# 前端问题面试\n\n一般前端问题面试，相比普通前端，会问的少点，毕竟主要还是面试3d这块。\n\n如果你原来就是前端，那么和以前面试一样就行。\n\n如果你是非前端转过来的，那么对你普通前端技术栈可能没有那么熟悉，但是也尽量去了解熟悉下。如果问到某块知识点你熟悉吗，如果不熟悉，直接回答否就行或者说知道点，但是很少用，这样面试官也不会深入问了。这样面试官就会重点面试web3d这块。\n\n\n# threejs基础问题\n\n一般会问提一些web3d可视化开发常见的基础问题，比如three.js、模型软件之类的。\n\n\n# 你都了解什么建模软件\n\n下面我写的非常多，但是你不用去记忆，其实能知道常用的blender就行了，或者多说点美术常用的3dmax、c4d之类的\n\n美术相关：blender、3dmax、c4d、maya 机械相关：solidworks、catia、autocad、ug 建筑相关：revit、sketchup 工业设计相关：rhino\n\n\n# 介绍下模型几何体的position、uv、index、normal等属性\n\n 1. position：顶点位置坐标，描述模型的几何形状\n 2. uv：顶点uv纹理坐标，与顶点位置一一对应，用来表示贴图与模型的映射关系\n 3. index：几何体顶点索引\n 4. normal：几何体顶点法线\n\n更具体学习参考threejs中文网电子书章节2和章节5\n\n\n# 渲染循环问题\n\n具体问题：three.js动画渲染循环中，一般需要执行webgl渲染器那个方法\n\n答案：一般需要执行webgl渲染器webglrenderer的.render()渲染方法\n\nfunction render() {\n    renderer.render(scene, camera); \n    requestanimationframe(render);\n}\n\n\n\n# group和object3d区别\n\n在threejs的语法中object3d是的group父类,但是具体使用，都差不多，group更语义化一些，可以用来表示一个组对象，可以包含mesh、group、line等子对象，构成层级模型。\n\n\n# 你了解threejs哪些材质\n\n整体来说，有点材质、精灵材质、线材质、网格材质等等，这些材质分别和点模型points、精灵模型sprite、线模型line、网格模型mesh相对应。\n\n其中网格材质比较丰富，比较常用，比如不受光照影响的基础网格模型meshbasicmaterial，受到光照影响的漫反射网格材质meshlambertmaterial、高光网格材质meshphongmaterial、pbr相关材质meshstandardmaterial和meshphysicalmaterial\n\n相关链接： http://www.webgl3d.cn/pages/2da02c/ http://www.webgl3d.cn/pages/24c407/ http://www.webgl3d.cn/pages/56b66b/\n\n\n# 你了解tween.js库吗\n\ntween.js是javascript动画库，主要用于补间动画。在threejs项目中，也可以借助tween.js辅助threejs实现动画效果。\n\n\n# 怎么获取本地坐标和世界坐标\n\n模型本地坐标：.position属性\n\n模型世界坐标：.getworldposition()方法\n\n参考：http://www.webgl3d.cn/pages/00ddfa/\n\n\n# 了解gltf文件格式吗\n\ngltf是web3d可视化开发中，非常常用的一种三维模型文件格式，就像图像常用的jpg或png格式一样。\n\n一般实际开发，通过blender构建三维模型，然后导出gltf文件，threejs在通过代码加载gltf模型。\n\n.glb文件是gltf格式的二进制文件。\n\n相关内容参考threejs中文网电子书章节6：http://www.webgl3d.cn/pages/f24993/\n\n\n# threejs后处理你都了解什么内容\n\n具体参考：http://www.webgl3d.cn/pages/e1e75d/\n\n实际回复，你可以把你大概熟悉的说下，比如outline高亮发光描边，比如bloom发光、比如抗锯齿的相关后处理、比如gama矫正的相关后处理。\n\n\n# 一个三维场景有哪些标注标签方式\n\n 1. threejs自身的模型对象，比如精灵模型sprite\n 2. css2和css3渲染器，渲染html标签标注三维场景\n\n参考：http://www.webgl3d.cn/pages/428714/\n\n\n# 怎么通过threejs代码设置三维场景的阴影\n\n记不太清，可以大概描述即可，一般就是递归遍历整个三维场景，设置所有模型可以产生阴影和接收阴影效果。\n\n然后通过阴影属性.shadow.camera，设置好阴影渲染范围。\n\n最后不要忘了，渲染器允许阴影渲染、光源允许阴影计算。\n\n具体参考：http://www.webgl3d.cn/pages/1dbe9d/\n\n1..castshadow设置产生阴影的模型对象 2..castshadow设置产生阴影的光源对象 3..receiveshadow设置接收阴影效果的模型 4..shadowmap.enabledwebgl渲染器允许阴影渲染 5..shadow.camera设置光源阴影渲染范围\n\n\n# 你知道怎么鼠标单击拾取选中模型吗？\n\n一般就是借助射线拾取api raycaster实现。\n\n 1. 根据鼠标点击事件对象，获得鼠标在canvas画布上的屏幕坐标(单位像素px)\n 2. 把屏幕坐标转化为webgl标准设备坐标\n 3. .setfromcamera()根据标准设备坐标和相机参数计算射线\n 4. 最后通过raycaster实现射线拾取模型计算\n\n具体流程：http://www.webgl3d.cn/pages/f96af1/\n\n\n# 你大概知道threejs什么光源\n\n点光源、聚光源、平行光、环境光...，根据你了解说下就行\n\n\n# threejs怎么调节光圈明暗程度\n\nthreejs光源对象具有光照强度属性，可以调节光源的明暗程度。\n\n\n# 数学几何计算问题\n\n一般长期做这块，一些基本的数学几何计算还是要了解，更多内容，可以查看threejs中文网电子书或系统课程介绍。\n\n\n# 图形学方面，你了解哪些常用几何变换的矩阵\n\n模型矩阵：旋转矩阵、缩放矩阵、平移矩阵\n\n相机相关的视图矩阵、投影矩阵\n\n\n# threejs控制模型姿态的方式有哪些，简单说说\n\n 1. 角度属性.rotation(欧拉角)\n 2. 四元数属性.quaternion\n 3. rotatex、rotatey、rotatez等旋转方法，可以改变角度属性.rotation\n 4. 旋转矩阵\n\n\n# 四元数和欧拉角有什么区别\n\n四元数和欧拉角，都可以控制物体的姿态角度变化。\n\n欧拉角存在自锁现象，四元数不存在自锁现象。\n\n\n# 向量点乘几何含义\n\n简单回复就是两个向量长度乘以夹角余弦值，更具体参考：http://www.webgl3d.cn/pages/44b0ba/\n\n\n# 怎么计算两个向量的夹角\n\n两个向量归一化，然后dot点乘即可\n\n\n# 向量叉乘几何含义\n\n 1. 两个向量叉乘，得到的新向量垂直于两个向量\n 2. 相乘结果向量长度是：两个向量长度乘以夹角正弦值\n\n更多代码参考：http://www.webgl3d.cn/pages/4558d6/\n\n\n# 怎么计算一个三角形平面的法线\n\n三角形随便选择两条边，生成两个向量。\n\n两个向量叉乘，得到一个垂直于三角形向量，结果向量归一化，就是三角形法线方向。\n\n\n# 判断点是否在扇形区域内\n\n一般一些游戏相关功能，可能会问到。\n\n简单回复就是，利用向量点乘，判断点是否在扇形区域内。利用向量点乘计算夹角，与扇形角度比较，然后计算点与扇形圆形距离与扇形半径比较即可。\n\n更多代码参考：http://www.webgl3d.cn/pages/feb38e/\n\n\n# 底层webgl或threejs shader问题\n\n一般有webgl专门团队公司，在北上广深一线城市，20k朝上webgl程序员，一般还是要求shader这块的，除非特殊情况，对方公司没人懂，招聘前端，懂threjs优先，可能不要求shader。\n\n\n# 介绍下渲染管线的原理\n\n形象点说，webgl渲染管线就像工厂的流水线一样，提供了不同的功能单元，比如顶点着色器、图元装配、光栅器、片元着色器、深度测试、模板测试等不同功能单元，渲染管线通过这些功能单元，可以处理三维场景的顶点、光源、纹理图像等数据，渲染三维场景，在canvas画布上输出渲染结果。\n\n 1. 顶点着色器：执行顶点着色器代码\n 2. 片元着色器：执行片元着色器代码\n\n\n\n更多关于webgl渲染管线详细的介绍，可以参考threejs中文网webgl入门讲解即可。\n\n\n# 原生webgl你怎么创建一个矩形\n\n可以用两个三角形拼接出来一个矩形，三个顶点表示一个三角形，两个三角形需要6个顶点坐标。\n\n两个三角形有个两个顶点坐标是共享的，也可以借助顶点索引，这样创建一个顶点坐标，然后利用索引重复利用其中两个顶点即可。\n\n参考：http://www.webgl3d.cn/webgl/\n\nhttp://www.webgl3d.cn/webgl/\n\n\n# 了解webgpu吗\n\n根据自身情况具体说明就行\n\nwebgpu类似webgl的一种新一代图形技术，谷歌浏览器2023年刚刚开始支持。如果你学习过系统课程里面入门webpgu，就说只是入门即可，如果没学习过webgpu，直接回复不熟悉也没什么，公司只是考察下，你对这个行业的了解情况。\n\n\n# 你写过webgl或threejs的shader吗\n\n根据自身情况回复，如果写过具体的说明，如果没写过的复杂案例，可以回复大概入门，能写一些简单。\n\n学习的话，参考系统课程里面threejs shader或原生webgl或原生webpgu的讲解。\n\n\n# 通过threejs材质那个方法可以修改已有材质的shader\n\n所有threejs材质有一个父类material，material具有.onbeforecompile()方法，通过.onbeforecompile()方法可以修改、增删threejs材质默认的shader，比如你可以修改lambert网格材质的着色器代码，可以修改pbr材质的着色器代码。\n\n具体参考系统课程中threejs shader部分的讲解\n\n\n# threejs shader实现飞线动画\n\n飞线轨迹是通过线条几何体的顶点坐标构成，可以使用点模型points渲染飞线轨迹，然后通过顶点着色器gl_pointsize控制飞线点的像素大小，按照飞线顶点顺序，控制点像素大小渐变即可。\n\n具体在地球飞线案例中有讲解\n\n\n# threejs shader设置模型颜色渐变\n\n在片元着色器glsl代码中，通过片元坐标vposition控制颜色值，比如让片元的颜色值gl_fragcolor与vposition的z坐标相关。\n\nvec3 gradient = mix(vec3(0.0,0.1,0.1), vec3(0.0,1.0,1.0), vposition.z/550.0);\noutgoinglight = outgoinglight*gradient;\ngl_fragcolor = vec4( outgoinglight, diffusecolor.a );\n\n\n\n# threejs shader实现直线扫光效果\n\n.onbeforecompile()批量修改场景中所有模型的材质shader。\n\n比如通过vposition的x坐标分量，在x1~x2范围内，控制顶点颜色值，实现直线扫光效果。如果希望扫光运动起来，可以加入一个uniform时间变量t，控制x1~x2范围随时间变化，实现直线扫光动画效果。\n\n\n# threejs shader实现直线波动光圈扫光效果\n\n比如通过vposition的x、y坐标分量控制，计算三角函数计算x、y坐标与某个圆心的半径长度，设置半径r1~r2范围，控制顶点颜色值，比如设置白色。如果希望扫光运动起来，可以加入一个uniform时间变量t，控制r1~r2范围随时间变化，实现直线光圈动画效果。\n\n\n# 更多补充中\n\n如果你遇到面试问题，可以也可以私信我留言，我会整理好统一，分享大家\n\n交流群在threejs中文网的首页。",charsets:{cjk:!0}},{title:"Web3D案例",frontmatter:{title:"Web3D案例",date:"2023-12-12T21:38:09.000Z",permalink:"/pages/8c57cd/",sidebar:"auto"},regularPath:"/_posts/Web3D%E6%A1%88%E4%BE%8B.html",relativePath:"_posts/Web3D案例.md",key:"v-720cbfa2",path:"/pages/8c57cd/",headers:[{level:3,title:"物联网、数字孪生相关",slug:"物联网、数字孪生相关",normalizedTitle:"物联网、数字孪生相关",charIndex:84},{level:3,title:"游戏、元宇宙、展厅(第一、三人称漫游)",slug:"游戏、元宇宙、展厅-第一、三人称漫游",normalizedTitle:"游戏、元宇宙、展厅(第一、三人称漫游)",charIndex:1021},{level:3,title:"地图、地图数据Web3D可视化",slug:"地图、地图数据web3d可视化",normalizedTitle:"地图、地图数据web3d可视化",charIndex:1052},{level:3,title:"3D Banner",slug:"_3d-banner",normalizedTitle:"3d banner",charIndex:1513},{level:3,title:"全景图相关",slug:"全景图相关",normalizedTitle:"全景图相关",charIndex:2059},{level:3,title:"机械、BIM：专业领域在线预览",slug:"机械、bim-专业领域在线预览",normalizedTitle:"机械、bim：专业领域在线预览",charIndex:2192}],headersStr:"物联网、数字孪生相关 游戏、元宇宙、展厅(第一、三人称漫游) 地图、地图数据Web3D可视化 3D Banner 全景图相关 机械、BIM：专业领域在线预览",content:"# Web3D案例\n\n你可以PC端点击下面链接，在线体验Web3D可视化案例。\n\n如果你掌握Threejs可视化系统课程，实现下面的效果，易如反掌，轻轻松松。\n\n\n# 物联网、数字孪生相关\n\n智慧工厂3D可视化\n\n智慧园区楼宇物业管理\n\n物联网数字孪生——收费站\n\n智慧社区3D可视化\n\n\n- img: /img3D/工厂.jpg\n  # link: http://www.webgl3d.cn/3D/gongchang/index.html\n  link: http://www.yanhuangxueyuan.com/3D/gongchang/index.html\n  name: 智慧工厂3D可视化\n\n- img: /img3D/build.jpg\n  # link: http://www.webgl3d.cn/3D/build/index.html\n  link: http://www.yanhuangxueyuan.com/3D/build/index.html\n  name: 智慧园区楼宇物业管理\n\n- img: /img3D/收费站.jpg\n  # link: http://www.webgl3d.cn/3D/shoufeizhan/index.html\n  link: http://www.yanhuangxueyuan.com/3D/shoufeizhan/index.html\n  name: 物联网数字孪生——收费站\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦 兔子老师\n  # avatar: /img/logo.png\n\n# - img: /img3D/小区.jpg\n#   link: http://www.webgl3d.cn/3D/xiaoqu/index.html\n#   name: 智慧社区3D可视化  \n- img: /img3D/智慧城市.jpg\n  link: https://study.163.com/course/courseLearn.htm?courseId=1212760820&share=2&shareId=400000000594054#/learn/video?lessonId=1284262084&courseId=1212760820\n  name: 智慧社区3D可视化  \n\n\n\n\n# 游戏、元宇宙、展厅(第一、三人称漫游)\n\n展厅待上传\n\n\n# 地图、地图数据Web3D可视化\n\n地球飞线Web3D数据可视化\n\n地图Web3D数据可视化\n\n- img: /img3D/地球飞线.jpg\n  link: https://study.163.com/course/courseLearn.htm?courseId=1212760820&share=2&shareId=400000000594054#/learn/video?lessonId=1284259191&courseId=1212760820\n  name: 地球飞线Web3D数据可视化\n- img: /img3D/中国地图飞线.jpg\n  link: https://study.163.com/course/courseLearn.htm?courseId=1212760820&share=2&shareId=400000000594054#/learn/video?lessonId=1284428496&courseId=1212760820\n  name: 地图Web3D数据可视化\n\n\n\n\n# 3D Banner\n\n3D Banner\n\n3D Banner——太极\n\n- img: /img3D/banner1.jpg\n  # link: http://www.webgl3d.cn/3D/banner1/index.html\n  link: http://www.yanhuangxueyuan.com/3D/banner1/index.html\n  name: 3D Banner\n#   desc: 零基础入门Three.js # 描述，可选\n#   author: 郭隆邦 # 作者，可选\n  # avatar: /img/logo.png # 头像，可选\n- img: /img3D/banner太极.jpg\n  # link: http://www.webgl3d.cn/3D/banner3/index.html\n  link: http://www.yanhuangxueyuan.com/3D/banner3/index.html\n  name: 3D Banner——太极\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦 兔子老师\n  # avatar: /img/logo.png\n\n\n\n\n# 全景图相关\n\n室内设计720在线预览\n\n- img: /img3D/室内设计.jpg\n  link: http://www.yanhuangxueyuan.com/3D/houseDesign/index.html\n  name: 室内设计720在线预览\n\n\n\n# 机械、BIM：专业领域在线预览\n\n机械模型在线预览\n\n机械零件预览\n\n- img: /img3D/装配体.jpg\n  link: http://www.yanhuangxueyuan.com/3D/jixiezhuangpei/index.html\n  name: 机械模型在线预览\n- img: /img3D/涡喷.jpg\n  link: http://www.yanhuangxueyuan.com/3D/wopen/index.html\n  name: 机械零件预览\n#   desc: 零基础入门Three.js # 描述，可选\n#   author: 郭隆邦 # 作者，可选\n  # avatar: /img/logo.png # 头像，可选\n# - img: /img3D/banner太极.jpg\n#   link: http://www.webgl3d.cn/3D/banner3/index.html\n#   name: 3D Banner——太极\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦 兔子老师\n  # avatar: /img/logo.png\n# 建筑的先随机搞一个上传上去，这一点非常重要\n",normalizedContent:"# web3d案例\n\n你可以pc端点击下面链接，在线体验web3d可视化案例。\n\n如果你掌握threejs可视化系统课程，实现下面的效果，易如反掌，轻轻松松。\n\n\n# 物联网、数字孪生相关\n\n智慧工厂3d可视化\n\n智慧园区楼宇物业管理\n\n物联网数字孪生——收费站\n\n智慧社区3d可视化\n\n\n- img: /img3d/工厂.jpg\n  # link: http://www.webgl3d.cn/3d/gongchang/index.html\n  link: http://www.yanhuangxueyuan.com/3d/gongchang/index.html\n  name: 智慧工厂3d可视化\n\n- img: /img3d/build.jpg\n  # link: http://www.webgl3d.cn/3d/build/index.html\n  link: http://www.yanhuangxueyuan.com/3d/build/index.html\n  name: 智慧园区楼宇物业管理\n\n- img: /img3d/收费站.jpg\n  # link: http://www.webgl3d.cn/3d/shoufeizhan/index.html\n  link: http://www.yanhuangxueyuan.com/3d/shoufeizhan/index.html\n  name: 物联网数字孪生——收费站\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦 兔子老师\n  # avatar: /img/logo.png\n\n# - img: /img3d/小区.jpg\n#   link: http://www.webgl3d.cn/3d/xiaoqu/index.html\n#   name: 智慧社区3d可视化  \n- img: /img3d/智慧城市.jpg\n  link: https://study.163.com/course/courselearn.htm?courseid=1212760820&share=2&shareid=400000000594054#/learn/video?lessonid=1284262084&courseid=1212760820\n  name: 智慧社区3d可视化  \n\n\n\n\n# 游戏、元宇宙、展厅(第一、三人称漫游)\n\n展厅待上传\n\n\n# 地图、地图数据web3d可视化\n\n地球飞线web3d数据可视化\n\n地图web3d数据可视化\n\n- img: /img3d/地球飞线.jpg\n  link: https://study.163.com/course/courselearn.htm?courseid=1212760820&share=2&shareid=400000000594054#/learn/video?lessonid=1284259191&courseid=1212760820\n  name: 地球飞线web3d数据可视化\n- img: /img3d/中国地图飞线.jpg\n  link: https://study.163.com/course/courselearn.htm?courseid=1212760820&share=2&shareid=400000000594054#/learn/video?lessonid=1284428496&courseid=1212760820\n  name: 地图web3d数据可视化\n\n\n\n\n# 3d banner\n\n3d banner\n\n3d banner——太极\n\n- img: /img3d/banner1.jpg\n  # link: http://www.webgl3d.cn/3d/banner1/index.html\n  link: http://www.yanhuangxueyuan.com/3d/banner1/index.html\n  name: 3d banner\n#   desc: 零基础入门three.js # 描述，可选\n#   author: 郭隆邦 # 作者，可选\n  # avatar: /img/logo.png # 头像，可选\n- img: /img3d/banner太极.jpg\n  # link: http://www.webgl3d.cn/3d/banner3/index.html\n  link: http://www.yanhuangxueyuan.com/3d/banner3/index.html\n  name: 3d banner——太极\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦 兔子老师\n  # avatar: /img/logo.png\n\n\n\n\n# 全景图相关\n\n室内设计720在线预览\n\n- img: /img3d/室内设计.jpg\n  link: http://www.yanhuangxueyuan.com/3d/housedesign/index.html\n  name: 室内设计720在线预览\n\n\n\n# 机械、bim：专业领域在线预览\n\n机械模型在线预览\n\n机械零件预览\n\n- img: /img3d/装配体.jpg\n  link: http://www.yanhuangxueyuan.com/3d/jixiezhuangpei/index.html\n  name: 机械模型在线预览\n- img: /img3d/涡喷.jpg\n  link: http://www.yanhuangxueyuan.com/3d/wopen/index.html\n  name: 机械零件预览\n#   desc: 零基础入门three.js # 描述，可选\n#   author: 郭隆邦 # 作者，可选\n  # avatar: /img/logo.png # 头像，可选\n# - img: /img3d/banner太极.jpg\n#   link: http://www.webgl3d.cn/3d/banner3/index.html\n#   name: 3d banner——太极\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦 兔子老师\n  # avatar: /img/logo.png\n# 建筑的先随机搞一个上传上去，这一点非常重要\n",charsets:{cjk:!0}},{title:"免费入门课程",frontmatter:{title:"免费入门课程",date:"2023-08-01T11:19:00.000Z",permalink:"/pages/56bb7e/",sidebar:!0},regularPath:"/_posts/%E5%85%8D%E8%B4%B9%E8%AF%BE%E7%A8%8B.html",relativePath:"_posts/免费课程.md",key:"v-6e1e280a",path:"/pages/56bb7e/",headers:[{level:3,title:"Web前端基础",slug:"web前端基础",normalizedTitle:"web前端基础",charIndex:703},{level:3,title:"3D可视化建模",slug:"_3d可视化建模",normalizedTitle:"3d可视化建模",charIndex:2088}],headersStr:"Web前端基础 3D可视化建模",content:"# 免费入门课程\n\n为了更好的推广宣传Three.js，除了付费的就业级系统课程，也给大家提供了各种的免费入门小课甜点。如果你想节约学习时间，避免走弯路，有人答疑，可以选择付费系统课程，当然你只是想了解下，也可以学习本站免费电子书和b站入门视频。\n\nThree.js入门教程链接\n\nWebGPU入门教程链接\n\nThree.js入门视频教程\n\n郭隆邦\n\nWEBGPU入门视频教程\n\n郭隆邦\n\n- img: /imgAd/threejs2023.jpg\n  link: https://www.bilibili.com/video/BV14r4y1G7h4/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: Three.js入门视频教程\n#   desc: 零基础入门Three.js # 描述，可选\n  author: 郭隆邦 # 作者，可选\n  avatar: /img/logo.png # 头像，可选\n- img: /imgAd/WEBGPU.jpg\n  link: https://www.bilibili.com/video/BV11M41137UH/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: WEBGPU入门视频教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: 郭隆邦\n  avatar: /img/logo.png\n\n\n\n\n# Web前端基础\n\n学习Web3D可视化，需要一定Web前端基础，尤其是做项目，更离不开前端技术栈了。\n\n前端需要学习什么？\n\nWeb 3D可视化如何学习\n\nHTML入门教程\n\nCSS入门教程\n\nJavaScript入门教程\n\n- img: /imgAd/html.jpg\n  link: https://www.bilibili.com/video/BV1HY411P7T4/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: HTML入门教程\n#   desc: 零基础入门Three.js # 描述，可选\n#   author: 郭隆邦 # 作者，可选\n#   avatar: /img/logo.png # 头像，可选\n- img: /imgAd/css.jpg\n  link: https://www.bilibili.com/video/BV1xu411k7XX/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: CSS入门教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦\n#   avatar: /img/logo.png\n- img: /imgAd/JavaScript.jpg\n  link: https://www.bilibili.com/video/BV1Fr4y1n7ac/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: JavaScript入门教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦\n#   avatar: /img/logo.png\n\n\n\nES6入门教程\n\nTypeScript入门教程\n\n- img: /imgAd/es6.jpg\n  link: https://www.bilibili.com/video/BV1fB4y127tM/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af \n  name: ES6入门教程\n#   desc: 零基础入门Three.js # 描述，可选\n#   author: 郭隆邦 # 作者，可选\n#   avatar: /img/logo.png # 头像，可选\n- img: /imgAd/ts.jpg\n  link: https://www.bilibili.com/video/BV1fY411A7ZJ/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: TypeScript入门教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦\n#   avatar: /img/logo.png\n\n\n\n\n# 3D可视化建模\n\n兔子老师是我队友，所以我要请求兔子老师录制了一些3D可视化方向建模教程，提供给大家。\n\nBlender 3D可视化建模\n\n兔子老师\n\n3dmax入门视频教程\n\n兔子老师\n\n- img: /imgAd/blender.jpg\n  link: https://www.bilibili.com/video/BV15D4y147V7/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: Blender 3D可视化建模\n#   desc: 零基础入门Three.js # 描述，可选\n  author: 兔子老师 # 作者，可选\n  avatar: /imgAd/兔子老师.jpg # 头像，可选\n- img: /imgAd/3dmax.jpg\n  link: https://www.bilibili.com/video/BV17Z4y1c7Ra/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: 3dmax入门视频教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: 兔子老师\n  avatar: /imgAd/兔子老师.jpg\n\n",normalizedContent:"# 免费入门课程\n\n为了更好的推广宣传three.js，除了付费的就业级系统课程，也给大家提供了各种的免费入门小课甜点。如果你想节约学习时间，避免走弯路，有人答疑，可以选择付费系统课程，当然你只是想了解下，也可以学习本站免费电子书和b站入门视频。\n\nthree.js入门教程链接\n\nwebgpu入门教程链接\n\nthree.js入门视频教程\n\n郭隆邦\n\nwebgpu入门视频教程\n\n郭隆邦\n\n- img: /imgad/threejs2023.jpg\n  link: https://www.bilibili.com/video/bv14r4y1g7h4/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: three.js入门视频教程\n#   desc: 零基础入门three.js # 描述，可选\n  author: 郭隆邦 # 作者，可选\n  avatar: /img/logo.png # 头像，可选\n- img: /imgad/webgpu.jpg\n  link: https://www.bilibili.com/video/bv11m41137uh/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: webgpu入门视频教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: 郭隆邦\n  avatar: /img/logo.png\n\n\n\n\n# web前端基础\n\n学习web3d可视化，需要一定web前端基础，尤其是做项目，更离不开前端技术栈了。\n\n前端需要学习什么？\n\nweb 3d可视化如何学习\n\nhtml入门教程\n\ncss入门教程\n\njavascript入门教程\n\n- img: /imgad/html.jpg\n  link: https://www.bilibili.com/video/bv1hy411p7t4/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: html入门教程\n#   desc: 零基础入门three.js # 描述，可选\n#   author: 郭隆邦 # 作者，可选\n#   avatar: /img/logo.png # 头像，可选\n- img: /imgad/css.jpg\n  link: https://www.bilibili.com/video/bv1xu411k7xx/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: css入门教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦\n#   avatar: /img/logo.png\n- img: /imgad/javascript.jpg\n  link: https://www.bilibili.com/video/bv1fr4y1n7ac/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: javascript入门教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦\n#   avatar: /img/logo.png\n\n\n\nes6入门教程\n\ntypescript入门教程\n\n- img: /imgad/es6.jpg\n  link: https://www.bilibili.com/video/bv1fb4y127tm/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af \n  name: es6入门教程\n#   desc: 零基础入门three.js # 描述，可选\n#   author: 郭隆邦 # 作者，可选\n#   avatar: /img/logo.png # 头像，可选\n- img: /imgad/ts.jpg\n  link: https://www.bilibili.com/video/bv1fy411a7zj/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: typescript入门教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n#   author: 郭隆邦\n#   avatar: /img/logo.png\n\n\n\n\n# 3d可视化建模\n\n兔子老师是我队友，所以我要请求兔子老师录制了一些3d可视化方向建模教程，提供给大家。\n\nblender 3d可视化建模\n\n兔子老师\n\n3dmax入门视频教程\n\n兔子老师\n\n- img: /imgad/blender.jpg\n  link: https://www.bilibili.com/video/bv15d4y147v7/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: blender 3d可视化建模\n#   desc: 零基础入门three.js # 描述，可选\n  author: 兔子老师 # 作者，可选\n  avatar: /imgad/兔子老师.jpg # 头像，可选\n- img: /imgad/3dmax.jpg\n  link: https://www.bilibili.com/video/bv17z4y1c7ra/?share_source=copy_web&vd_source=87fd4ba12cc3bed7aed51c523b6749af\n  name: 3dmax入门视频教程\n#   desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: 兔子老师\n  avatar: /imgad/兔子老师.jpg\n\n",charsets:{cjk:!0}},{title:"外包项目",frontmatter:{title:"外包项目",date:"2023-10-07T23:18:28.000Z",permalink:"/pages/bab765/",sidebar:"auto"},regularPath:"/_posts/%E5%A4%96%E5%8C%85%E9%A1%B9%E7%9B%AE.html",relativePath:"_posts/外包项目.md",key:"v-0d65b539",path:"/pages/bab765/",headersStr:null,content:"# 外包项目\n\n如果你们公司有Web3D可视化项目外包的需求，可以联系邮件联系我。\n\n希望注明以下信息：\n\n 1. 有详细需要文档最好，没有的话，大概描述下做什么\n 2. 开发周期，比如洗完几周之内或者几个月之内完成\n 3. 基本预算，不用太具体，范围很大都所谓，比如2~6万，我目的是为了过滤n手外包\n\n我会根据你们预算范围，与项目复杂程度，决定是否详细了解，邮件可以备注微信号，合适的话，我会加你们。\n\n邮箱：guolongbang@163.com",normalizedContent:"# 外包项目\n\n如果你们公司有web3d可视化项目外包的需求，可以联系邮件联系我。\n\n希望注明以下信息：\n\n 1. 有详细需要文档最好，没有的话，大概描述下做什么\n 2. 开发周期，比如洗完几周之内或者几个月之内完成\n 3. 基本预算，不用太具体，范围很大都所谓，比如2~6万，我目的是为了过滤n手外包\n\n我会根据你们预算范围，与项目复杂程度，决定是否详细了解，邮件可以备注微信号，合适的话，我会加你们。\n\n邮箱：guolongbang@163.com",charsets:{cjk:!0}},{title:"本站内容转载和引用声明",frontmatter:{title:"本站内容转载和引用声明",date:"2023-08-01T11:00:08.000Z",permalink:"/pages/b563a7/",sidebar:"auto"},regularPath:"/_posts/%E6%9C%AC%E7%AB%99%E5%86%85%E5%AE%B9%E8%BD%AC%E8%BD%BD%E5%92%8C%E5%BC%95%E7%94%A8%E5%A3%B0%E6%98%8E.html",relativePath:"_posts/本站内容转载和引用声明.md",key:"v-1bed40a5",path:"/pages/b563a7/",headers:[{level:3,title:"不允许的情况",slug:"不允许的情况",normalizedTitle:"不允许的情况",charIndex:92}],headersStr:"不允许的情况",content:"# 本站内容转载和引用声明\n\n首先声明，本站内容，只要不是用于商业盈利用途(比如授课)，只是个人学习转载，引用都可以，但是必须注明来源，备注上Three.js中文网网址即可。\n\n\n# 不允许的情况\n\n 1. 可以引用某篇文章，但是不允许，网站整体复制镜像\n 2. 其他老师不允许复制复制粘贴我电子书课件内容，用于讲课盈利\n\n比如b站某up主，直接复制我旧版本Threejs电子书内容到自己的讲课笔记中，去b站讲课吸粉，本身带有盈利行为，不经过我的允许就算了，引用也不注明来源，说他复制抄袭，还不承认，非说是借鉴，后面道歉，又不诚心道歉。\n\nThree.js教程 打假 公告：https://www.bilibili.com/read/cv20549613\n\n评 老陈打码 虚假道歉公告https://www.bilibili.com/read/cv20570734",normalizedContent:"# 本站内容转载和引用声明\n\n首先声明，本站内容，只要不是用于商业盈利用途(比如授课)，只是个人学习转载，引用都可以，但是必须注明来源，备注上three.js中文网网址即可。\n\n\n# 不允许的情况\n\n 1. 可以引用某篇文章，但是不允许，网站整体复制镜像\n 2. 其他老师不允许复制复制粘贴我电子书课件内容，用于讲课盈利\n\n比如b站某up主，直接复制我旧版本threejs电子书内容到自己的讲课笔记中，去b站讲课吸粉，本身带有盈利行为，不经过我的允许就算了，引用也不注明来源，说他复制抄袭，还不承认，非说是借鉴，后面道歉，又不诚心道歉。\n\nthree.js教程 打假 公告：https://www.bilibili.com/read/cv20549613\n\n评 老陈打码 虚假道歉公告https://www.bilibili.com/read/cv20570734",charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,heroText:"Web3D可视化",tagline:"🚀提供图文、视频等学习资源",actionText:"Three.js教程 →",actionLink:"/pages/aac9ab/",bannerBg:"none",features:[{title:"图文文档",details:"辅助视频学习，学习后，也适合随时翻阅复习或当做手册使用用。"},{title:"视频",details:"提供了视频讲解，更容易入门，满足多样化需要。"},{title:"课件源码",details:"课件源码注释非常详细，除了可以配合视频学习，也可以当做功能手册参考"}],postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-0e429eca",path:"/",headers:[{level:2,title:"⚡ 反馈与交流",slug:"⚡-反馈与交流",normalizedTitle:"⚡ 反馈与交流",charIndex:57}],headersStr:"⚡ 反馈与交流",content:"Threejs系统课3D可视化 →\n\n3D案例体验 →\n\n人才推荐\n\nBlender可视化建模教程\n\n\n\n\n\n# ⚡ 反馈与交流\n\nthreejs QQ 群7: 814702116   threejs QQ 群8: 548574160\n                           \n加群备注，threejs中文网            加群备注，threejs中文网\n我个人微信号: webglthreejs\n\n加vx备注，threejs中文网",normalizedContent:"threejs系统课3d可视化 →\n\n3d案例体验 →\n\n人才推荐\n\nblender可视化建模教程\n\n\n\n\n\n# ⚡ 反馈与交流\n\nthreejs qq 群7: 814702116   threejs qq 群8: 548574160\n                           \n加群备注，threejs中文网            加群备注，threejs中文网\n我个人微信号: webglthreejs\n\n加vx备注，threejs中文网",charsets:{cjk:!0}}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"免费视频",link:"/pages/56bb7e/"},{text:"系统课",link:"https://study.163.com/course/courseMain.htm?courseId=1212760820&share=2&shareId=400000000594054"},{text:"Three.js电子书",link:"/pages/4a14ce/",items:[{text:"Three.js基础课程",link:"/pages/4a14ce/"},{text:"Threejs进阶课程",link:"/pages/001888/"},{text:"Threejs Shader",link:"/pages/d30795/"},{text:"Blender建模基础",link:"/pages/00cfc0/"},{text:"Three.js基础课程(旧版本)",link:"http://www.webgl3d.cn/Three.js/"},{text:"Threejs文章",link:"/pages/c3ecc9/"}]},{text:"WebGPU教程",link:"/pages/9bbfa9/"},{text:"WebGL教程",link:"/pages/9bc0db/",items:[{text:"WebGL教程",link:"/pages/9bc0db/"},{text:"WebGL教程(旧版本)",link:"http://www.webgl3d.cn/WebGL/"}]},{text:"3D案例",link:"/pages/8c57cd/"},{text:"threejs中文文档",items:[{text:"本站部署(打开快)",link:"http://www.yanhuangxueyuan.com/threejs/docs/index.html#manual/zh/"},{text:"原英文官网文档",link:"https://threejs.org/docs/index.html#manual/zh/"}]}],sidebarDepth:2,logo:"/img/logo.png",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/01.Three.js教程/":[{title:"0.学前说明",collapsable:!0,children:[["0.0.学前说明/01.课程部分案例3D效果速览.md","课程部分案例3D效果速览","/pages/4a14ce/"],["0.0.学前说明/02.课程特点.md","课程特点","/pages/a97995/"],["0.0.学前说明/03.学前基础、如何学习3D.md","学前基础、如何学习3D","/pages/2de1b9/"]]},{title:"1.Three.js快速入门",collapsable:!0,children:[["01.1.Three.js快速入门/01.threejs文件包下载和目录简介.md","1. threejs文件包下载和目录简介","/pages/aac9ab/"],["01.1.Three.js快速入门/02.学习环境-编辑器和本地静态服务.md","2. 学习环境-编辑器和静态服务器","/pages/336b66/"],["01.1.Three.js快速入门/03.开发和学习环境，引入threejs库.md","3. 开发和学习环境，引入threejs","/pages/cd35b2/"],["01.1.Three.js快速入门/04.第一个3D案例—创建3D场景.md","4. 第一个3D案例—创建3D场景","/pages/2e5d69/"],["01.1.Three.js快速入门/05.第一个3D案例—透视投影相机.md","5. 第一个3D案例—透视投影相机","/pages/c0b143/"],["01.1.Three.js快速入门/06.第一个3D案例—渲染器.md","6. 第一个3D案例—渲染器","/pages/b483f0/"],["01.1.Three.js快速入门/07.Threejs三维坐标系—加强三维空间认识.md","7. 三维坐标系-加强三维空间认识","/pages/6abb06/"],["01.1.Three.js快速入门/08.光源对物体表面影响.md","8. 光源对物体表面影响","/pages/b9504a/"],["01.1.Three.js快速入门/09.相机控件轨道控制器OrbitControls.md","9. 相机控件OrbitControls","/pages/837374/"],["01.1.Three.js快速入门/10.平行光与环境光.md","10. 平行光与环境光","/pages/343ae9/"],["01.1.Three.js快速入门/11.动画渲染循环.md","11. 动画渲染循环","/pages/ffe0f4/"],["01.1.Three.js快速入门/12.Canvas画布布局和全屏.md","12. Canvas画布布局和全屏","/pages/4e518f/"],["01.1.Three.js快速入门/13.stats查看threejs渲染帧率.md","13. stats查看threejs渲染帧率","/pages/3c9b94/"],["01.1.Three.js快速入门/14.阵列立方体和相机适配体验.md","14. 阵列立方体和相机适配体验","/pages/2a45ee/"],["01.1.Three.js快速入门/15.Threejs常见几何体简介.md","15. Threejs常见几何体简介","/pages/e04c44/"],["01.1.Three.js快速入门/16.高光网格材质MeshPhongMaterial.md","16. 高光网格材质Phong","/pages/2da02c/"],["01.1.Three.js快速入门/17.WebGL渲染器设置(锯齿模糊、背景颜色).md","17. WebGL渲染器设置(锯齿模糊)","/pages/f636b8/"],["01.1.Three.js快速入门/18.gui.js库(可视化改变三维场景).md","18. gui.js库(可视化改变三维场景)","/pages/5005d5/"],["01.1.Three.js快速入门/19.gui调试界面2—颜色、命名、步长、事件.md","19. gui调试界面2-颜色命名等","/pages/66ce2c/"],["01.1.Three.js快速入门/20.gui调试界面3-下拉菜单、单选框.md","20. gui调试3-下拉菜单、单选框","/pages/0569b5/"],["01.1.Three.js快速入门/21.gui.js库(分组).md","21. gui.js库(分组)","/pages/2e1b8c/"],["01.1.Three.js快速入门/22.查询examples和文档(辅助开发).md","22. examples和文档(辅助开发)","/pages/f1d3dd/"],["01.1.Three.js快速入门/23.threejs语法总结.md","23. threejs语法总结","/pages/63ce1e/"],["01.1.Three.js快速入门/24.【选修】Vue+Threejs开发环境.md","【选修】Vue+Threejs开发环境","/pages/637c91/"],["01.1.Three.js快速入门/25.【选修】React+Threejs开发环境.md","【选修】React+Three.js开发环境","/pages/d6ce1f/"]]},{title:"2.几何体BufferGeometry",collapsable:!0,children:[["02.2.几何体BufferGeometry/01.几何体顶点位置数据和点模型对象Points.md","1. 几何体顶点位置数据和点模型","/pages/f84ca8/"],["02.2.几何体BufferGeometry/02.线模型对象.md","2. 线模型对象","/pages/ed3be5/"],["02.2.几何体BufferGeometry/03.网格模型(三角形概念).md","3. 网格模型(三角形概念)","/pages/32785a/"],["02.2.几何体BufferGeometry/04.构建一个矩形平面几何体.md","4. 构建一个矩形平面几何体","/pages/6722b2/"],["02.2.几何体BufferGeometry/05.几何体顶点索引数据.md","5. 几何体顶点索引数据","/pages/05b687/"],["02.2.几何体BufferGeometry/06.顶点法线数据.md","6. 顶点法线数据","/pages/ff37d3/"],["02.2.几何体BufferGeometry/07.查看three.js自带几何体顶点结构.md","7. 查看threejs自带几何体顶点","/pages/d8b07b/"],["02.2.几何体BufferGeometry/08.BufferGeometry的旋转、缩放、平移方法.md","8. 旋转、缩放、平移几何体","/pages/1b0d6c/"]]},{title:"3.模型对象、材质",collapsable:!0,children:[["03.3.模型对象、材质/01.三维向量Vector3与模型位置、缩放属性.md","1. 三维向量Vector3与模型位置","/pages/440e51/"],["03.3.模型对象、材质/02.欧拉Euler与角度属性.rotation.md","2. 欧拉Euler与角度属性.rotation","/pages/cb4e2f/"],["03.3.模型对象、材质/03.模型材质颜色(Color对象).md","3. 模型材质颜色(Color对象)","/pages/ec1682/"],["03.3.模型对象、材质/04.模型材质父类Material.md","4. 模型材质父类Material","/pages/24c407/"],["03.3.模型对象、材质/05.模型材质和几何体属性.md","5. 模型材质和几何体属性","/pages/091565/"],["03.3.模型对象、材质/06.克隆.clone()和复制.copy().md","6. 克隆.clone()和复制.copy()","/pages/186303/"]]},{title:"4.层级模型",collapsable:!0,children:[["04.4.层级模型/01.三维向量Vector3与模型位置、缩放属性.md","1. Vector3与模型位置、缩放属性","/pages/c86096/"],["04.4.层级模型/02.递归遍历模型树结构、查询模型节点.md","2. 遍历模型树结构、查询模型节点","/pages/4da2c3/"],["04.4.层级模型/03.本地坐标和世界坐标.md","3. 本地坐标和世界坐标","/pages/00ddfa/"],["04.4.层级模型/04.改变模型相对局部坐标原点位置.md","4. 改变模型相对局部坐标原点位置","/pages/a2fae0/"],["04.4.层级模型/05.移除对象.remove().md","5. 移除对象.remove()","/pages/e66ea7/"],["04.4.层级模型/06.模型隐藏或显示.md","6. 模型隐藏或显示","/pages/eeb05a/"]]},{title:"5.顶点UV坐标、纹理贴图",collapsable:!0,children:[["05.5.顶点UV坐标、纹理贴图/01.创建纹理贴图.md","1. 创建纹理贴图","/pages/2220d2/"],["05.5.顶点UV坐标、纹理贴图/02.自定义顶点UV坐标.md","2. 自定义顶点UV坐标","/pages/71e307/"],["05.5.顶点UV坐标、纹理贴图/03.圆形平面CircleGeometry设置纹理贴图.md","3. 圆形平面设置纹理贴图","/pages/dcc03b/"],["05.5.顶点UV坐标、纹理贴图/04.纹理对象Texture阵列( 瓷砖地面案例 ).md","4. 纹理对象Texture阵列","/pages/e257c9/"],["05.5.顶点UV坐标、纹理贴图/05.矩形Mesh+背景透明png贴图(场景地面导航标注).md","5. 矩形Mesh+背景透明png贴图","/pages/bf71c4/"],["05.5.顶点UV坐标、纹理贴图/06.UV动画.md","6. UV动画","/pages/ed1694/"]]},{title:"6.加载外部三维模型(gltf)",collapsable:!0,children:[["06.6.加载外部三维模型(gltf)/01.建模软件绘制3D场景(比如Blender).md","1. 建模软件绘制3D场景(Blender)","/pages/f24993/"],["06.6.加载外部三维模型(gltf)/02. GLTF格式简介 (Web3D领域JPG).md","2. GLTF格式简介 (Web3D领域JPG)","/pages/2cdb29/"],["06.6.加载外部三维模型(gltf)/03.加载.gltf文件(模型加载全流程).md","3. 加载.gltf文件(模型加载全流程)","/pages/006fcb/"],["06.6.加载外部三维模型(gltf)/04.OrbitControls辅助设置相机参数.md","4. OrbitControls辅助设置相机参数","/pages/ed32ac/"],["06.6.加载外部三维模型(gltf)/05.gltf不同文件形式(.glb、贴图、.bin).md","5. gltf不同文件形式(.glb)","/pages/24ed9e/"],["06.6.加载外部三维模型(gltf)/06.模型命名(程序与美术协作)—层级模型节点选择.md","6. 模型命名(程序与美术协作)","/pages/a4813a/"],["06.6.加载外部三维模型(gltf)/07.递归遍历层级模型修改材质.md","7. 递归遍历层级模型修改材质","/pages/d78052/"],["06.6.加载外部三维模型(gltf)/08.外部模型材质是否共享的问题.md","8. 外部模型材质是否共享的问题","/pages/f3c6d0/"],["06.6.加载外部三维模型(gltf)/09.纹理.encoding和渲染器.outputEncoding.md","9. 纹理encoding和渲染器","/pages/c2fd5c/"],["06.6.加载外部三维模型(gltf)/10.gltf模型更换.map(纹理.flipY属性).md","10. gltf模型更换.map(纹理.flipY)","/pages/cbdb36/"]]},{title:"7.PBR材质与纹理贴图",collapsable:!0,children:[["07.7.PBR材质与纹理贴图/01.PBR材质简介.md","1. PBR材质简介","/pages/56b66b/"],["07.7.PBR材质与纹理贴图/02.PBR材质金属度和粗糙度(金属效果).md","2. PBR材质金属度和粗糙度","/pages/ca9079/"],["07.7.PBR材质与纹理贴图/03.环境贴图.envMap(金属效果).md","3. 环境贴图.envMap(金属效果)","/pages/780376/"],["07.7.PBR材质与纹理贴图/04.环境贴图2.md","4. 环境贴图2","/pages/3b2d91/"],["07.7.PBR材质与纹理贴图/05.MeshPhysicalMaterial清漆层Clearcoat.md","5. MeshPhysicalMaterial清漆层","/pages/121b10/"],["07.7.PBR材质与纹理贴图/06.物理材质透光率.transmission.md","6. 物理材质透光率.transmission","/pages/4f04e6/"],["07.7.PBR材质与纹理贴图/07.三维软件导出PBR材质属性.md","7. 三维软件导出PBR材质属性","/pages/41c918/"]]},{title:"8.渲染器和前端UI界面",collapsable:!0,children:[["08.8.渲染器和前端UI界面/01.three.js Canvas画布布局.md","1. three.js Canvas画布布局","/pages/12b014/"],["08.8.渲染器和前端UI界面/02.UI交互界面与Canvas画布叠加.md","2. UI交互界面与Canvas画布叠加","/pages/780ceb/"],["08.8.渲染器和前端UI界面/03.UI交互按钮与3D场景交互.md","3. UI交互按钮与3D场景交互","/pages/2a15e4/"],["08.8.渲染器和前端UI界面/04.Three.js背景透明度.md","4. Three.js背景透明度","/pages/a4febe/"],["08.8.渲染器和前端UI界面/05.Three.js渲染结果保存为图片.md","5. Three.js渲染结果保存为图片","/pages/a1304b/"],["08.8.渲染器和前端UI界面/06.深度冲突(模型闪烁).md","6. 深度冲突(模型闪烁)","/pages/e8f727/"],["08.8.渲染器和前端UI界面/07.模型加载进度条.md","7. 模型加载进度条","/pages/71ed82/"]]},{title:"9.生成曲线、几何体",collapsable:!0,children:[["09.9.生成曲线、几何体/01.生成圆弧顶点.md","1. 生成圆弧顶点","/pages/8868a1/"],["09.9.生成曲线、几何体/02.几何体方法.setFromPoints().md","2. 几何体方法.setFromPoints()","/pages/e28594/"],["09.9.生成曲线、几何体/03.曲线Curve简介.md","3. 曲线Curve简介","/pages/564039/"],["09.9.生成曲线、几何体/04.椭圆、圆.md","4. 椭圆、圆","/pages/c64602/"],["09.9.生成曲线、几何体/05.样条曲线.md","5. 样条曲线","/pages/717f0f/"],["09.9.生成曲线、几何体/06.贝塞尔曲线.md","6. 贝塞尔曲线","/pages/15ba8d/"],["09.9.生成曲线、几何体/07.样条、贝塞尔曲线应用.md","7. 样条、贝塞尔曲线应用","/pages/a8cc3a/"],["09.9.生成曲线、几何体/08.组合曲线CurvePath拼接不同曲线.md","8. 组合曲线CurvePath拼接曲线","/pages/e11f54/"],["09.9.生成曲线、几何体/09.曲线路径管道TubeGeometry.md","9. 曲线路径管道TubeGeometry","/pages/f36362/"],["09.9.生成曲线、几何体/10.旋转成型LatheGeometry.md","10. 旋转成型LatheGeometry","/pages/4f1012/"],["09.9.生成曲线、几何体/11.轮廓填充ShapeGeometry.md","11. 轮廓填充ShapeGeometry","/pages/29f885/"],["09.9.生成曲线、几何体/12.拉伸ExtrudeGeometry.md","12. 拉伸ExtrudeGeometry","/pages/4ac668/"],["09.9.生成曲线、几何体/13.扫描ExtrudeGeometry.md","13. 扫描ExtrudeGeometry","/pages/a06aed/"],["09.9.生成曲线、几何体/14.多边形轮廓Shape简介.md","14. 多边形轮廓Shape简介","/pages/4b70af/"],["09.9.生成曲线、几何体/15.多边形轮廓Shape(圆弧).md","15. 多边形轮廓Shape(圆弧)","/pages/ccc74f/"],["09.9.生成曲线、几何体/16.多边形Shape(内孔.holes).md","16. 多边形Shape(内孔.holes)","/pages/875c74/"],["09.9.生成曲线、几何体/17.模型边界线EdgesGeometry.md","17. 模型边界线EdgesGeometry","/pages/5fe984/"],["09.9.生成曲线、几何体/18.几何体顶点颜色数数据.md","18. 几何体顶点颜色数数据","/pages/92ea15/"],["09.9.生成曲线、几何体/19.一段曲线颜色渐变.md","19. 一段曲线颜色渐变","/pages/ace64e/"],["09.9.生成曲线、几何体/20.Color颜色渐变插值.md","20. Color颜色渐变插值","/pages/05ca12/"],["09.9.生成曲线、几何体/21.查看或设置gltf几何体顶点.md","21. 查看或设置gltf几何体顶点","/pages/fde9a0/"],["09.9.生成曲线、几何体/22.山脉地形高度可视化.md","22. 山脉地形高度可视化","/pages/dbd776/"]]},{title:"10.相机基础",collapsable:!0,children:[["10.10.相机基础/01.正投影相机.md","1. 正投影相机","/pages/1c3a1a/"],["10.10.相机基础/02.正投影相机-Canvas尺寸变化.md","2. 正投影相机-Canvas尺寸变化","/pages/6f9387/"],["10.10.相机基础/03.包围盒Box3.md","3. 包围盒Box3","/pages/13d359/"],["10.10.相机基础/04.地图案例(包围盒、正投影).md","4. 地图案例(包围盒、正投影)","/pages/747cf1/"],["10.10.相机基础/05.相机动画( .position 和 .lookAt() ).md","5. 相机动画(.position和.lookAt())","/pages/ca57bd/"],["10.10.相机基础/06.不同方向的投影视图.md","6. 不同方向的投影视图","/pages/3153bf/"],["10.10.相机基础/07.旋转渲染结果(.up相机上方向).md","7. 旋转渲染结果(.up相机上方向)","/pages/3bcff1/"],["10.10.相机基础/08.管道漫游案例.md","8. 管道漫游案例","/pages/188907/"],["10.10.相机基础/09.OrbitControls旋转缩放限制.md","9. OrbitControls旋转缩放限制","/pages/17b6dc/"],["10.10.相机基础/10.相机控件MapControls.md","10. 相机控件MapControls","/pages/76953b/"]]},{title:"11.光源和阴影",collapsable:!0,children:[["11.11.光源和阴影/01.聚光源SpotLight.md","1. 聚光源SpotLight","/pages/344c05/"],["11.11.光源和阴影/02.平行光阴影计算.md","2. 平行光阴影计算","/pages/1dbe9d/"],["11.11.光源和阴影/03.阴影范围.shadow.camera.md","3. 阴影范围.shadow.camera","/pages/68e9fd/"],["11.11.光源和阴影/04.阴影.mapSize和.radius.md","4. 阴影.mapSize和.radius","/pages/547403/"],["11.11.光源和阴影/05.工厂光源(环境贴图和环境光).md","5. 工厂光源(环境贴图和环境光)","/pages/3824bf/"],["11.11.光源和阴影/06.工厂光源(平行光模拟太阳光).md","6. 工厂光源(平行光模拟太阳光)","/pages/c418f4/"],["11.11.光源和阴影/07.工厂(模拟太阳光阴影).md","7. 工厂(模拟太阳光阴影)","/pages/96077e/"],["11.11.光源和阴影/08.gui辅助调节光源阴影.md","8. gui辅助调节光源阴影","/pages/3f1331/"]]},{title:"12.精灵模型Sprite",collapsable:!0,children:[["12.12.精灵模型Sprite/01.精灵模型Sprite.md","1. 精灵模型Sprite","/pages/75d790/"],["12.12.精灵模型Sprite/02.精灵模型标注场景(贴图).md","2. 精灵模型标注场景(贴图)","/pages/bd93e5/"],["12.12.精灵模型Sprite/03.Sprite模拟下雨、下雪.md","3. Sprite模拟下雨、下雪","/pages/477843/"]]},{title:"13.后处理EffectComposer",collapsable:!0,children:[["13.13.后处理EffectComposer/01.后处理(高亮发光描边OutlinePass).md","1. 后处理(发光描边OutlinePass)","/pages/e1e75d/"],["13.13.后处理EffectComposer/02.OutlinePass发光描边样式.md","2. OutlinePass描边样式","/pages/73bfc8/"],["13.13.后处理EffectComposer/03.Bloom发光通道.md","3. Bloom发光通道","/pages/4583d8/"],["13.13.后处理EffectComposer/04.多通道组合(GlitchPass和描边).md","4. 多通道组合(GlitchPass和描边)","/pages/9618d5/"],["13.13.后处理EffectComposer/05.gltf工厂模型设置发光描边.md","5. gltf工厂模型设置发光描边","/pages/c9b485/"],["13.13.后处理EffectComposer/06.gltf后处理颜色异常(伽马校正).md","6. gltf后处理颜色异常(伽马校正)","/pages/db8785/"],["13.13.后处理EffectComposer/07.抗锯齿后处理.md","7. 抗锯齿后处理","/pages/fe22af/"]]},{title:"14.射线拾取模型",collapsable:!0,children:[["14.14.射线拾取模型/01.射线Ray.md","1. 射线Ray","/pages/500511/"],["14.14.射线拾取模型/02.Raycaster(射线拾取模型).md","2. Raycaster(射线拾取模型)","/pages/a448b6/"],["14.14.射线拾取模型/03.屏幕坐标转标准设备坐标.md","3. 屏幕坐标转标准设备坐标","/pages/41d16d/"],["14.14.射线拾取模型/04.Raycaster(鼠标点击选中模型).md","4. Raycaster(鼠标点击选中模型)","/pages/f96af1/"],["14.14.射线拾取模型/05.Canvas尺寸变化(射线坐标计算).md","5. Canvas尺寸变化(射线坐标计算)","/pages/6065de/"],["14.14.射线拾取模型/06.射线拾取层级模型(选中模型发光描边).md","6. 射线拾取层级模型(模型描边)","/pages/dd2774/"],["14.14.射线拾取模型/07.射线拾取Sprite控制场景.md","7. 射线拾取Sprite控制场景","/pages/b73a83/"]]},{title:"15.场景标注标签信息",collapsable:!0,children:[["15.15.场景标注标签信息/01.CSS2DRenderer(HTM元素作为标签).md","1. CSS2DRenderer(HTML标签)","/pages/428714/"],["15.15.场景标注标签信息/02.HTML标签遮挡Canvas画布事件.md","2. HTML标签遮挡Canvas画布事件","/pages/63aef4/"],["15.15.场景标注标签信息/03.Canvas画布尺寸变化(HTML标签).md","3. Canvas尺寸变化(HTML标签)","/pages/0801b3/"],["15.15.场景标注标签信息/04.标签位置不同设置方式.md","4. 标签位置不同设置方式","/pages/9b6a56/"],["15.15.场景标注标签信息/05.标签位置(标注工厂设备).md","5. 标签位置(标注工厂设备)","/pages/6ec16d/"],["15.15.场景标注标签信息/06.标签指示线或箭头指向标注点.md","6. 标签指示线或箭头指向标注点","/pages/fb01c9/"],["15.15.场景标注标签信息/07.鼠标选中模型弹出标签(工厂案例).md","7. 鼠标选中模型弹出标签(工厂)","/pages/793f8d/"],["15.15.场景标注标签信息/08.单机按钮关闭HTML标签.md","8. 单击按钮关闭HTML标签","/pages/1fa97c/"],["15.15.场景标注标签信息/09.CSS3DRenderer渲染HTML标签.md","9. CSS3DRenderer渲染HTML标签","/pages/b23f11/"],["15.15.场景标注标签信息/10.CSS3批量标注多个标签.md","10. CSS3批量标注多个标签","/pages/b5f8e2/"],["15.15.场景标注标签信息/11.精灵模型Sprite作为标签.md","11. 精灵模型Sprite作为标签","/pages/76a18d/"],["15.15.场景标注标签信息/12.Sprite标签(Canvas作为贴图).md","12. Sprite标签(Canvas作为贴图)","/pages/c15dd2/"]]},{title:"16.关键帧动画",collapsable:!0,children:[["16.16.关键帧动画/01.关键帧动画.md","1. 关键帧动画","/pages/3aff37/"],["16.16.关键帧动画/02.动画播放(暂停、倍速、循环).md","2. 动画播放(暂停、倍速、循环)","/pages/c8f25d/"],["16.16.关键帧动画/03.动画播放(拖动任意时间状态).md","3. 动画播放(拖动任意时间状态)","/pages/c98f2f/"],["16.16.关键帧动画/04.解析外部模型关键帧动画.md","4. 解析外部模型关键帧动画","/pages/e5737c/"],["16.16.关键帧动画/05.机械虚拟装配案例(播放).md","5. 机械虚拟装配案例(播放)","/pages/478039/"],["16.16.关键帧动画/06.虚拟装配(任意时间定位).md","6. 虚拟装配(任意时间定位)","/pages/c9c18c/"],["16.16.关键帧动画/07.变形动画原理.md","7. 变形动画原理","/pages/d8c0b0/"],["16.16.关键帧动画/08.变形动画(定制人物胖瘦).md","8. 变形动画(定制人物胖瘦)","/pages/43c650/"],["16.16.关键帧动画/09.骨骼关节Bone.md","9. 骨骼关节Bone","/pages/870a19/"],["16.16.关键帧动画/10.查看外部模型骨骼动画.md","10. 查看外部模型骨骼动画","/pages/56644a/"],["16.16.关键帧动画/11.骨骼动画不同动作切换.md","11. 骨骼动画不同动作切换","/pages/f5175e/"]]},{title:"17.动画库tween.js",collapsable:!0,children:[["17.17.动画库tween.js/01.tweenjs创建threejs动画.md","1. tweenjs创建threejs动画","/pages/69bd16/"],["17.17.动画库tween.js/02.tweenjs相机运动动画.md","2. tweenjs相机运动动画","/pages/406def/"],["17.17.动画库tween.js/03.点按钮,相机飞行靠近观察设备.md","3. 点按钮,相机飞行靠近观察设备","/pages/c0b87e/"],["17.17.动画库tween.js/04.点击设备,相机靠近放大预览.md","4. 点击设备,相机靠近放大预览","/pages/f2273c/"],["17.17.动画库tween.js/05.缓动算法.easing(地球渐入相机动画).md","5. 缓动算法.easing(地球渐入相机动画)","/pages/51d9ae/"],["17.17.动画库tween.js/06.模型或标签淡入淡出.md","6. 模型或标签淡入淡出","/pages/5227e0/"]]}],catalogue:{},"/02.Three.js进阶教程/":[{title:"1. 数学几何计算基础",collapsable:!0,children:[["01.1. 数学几何计算基础/01.threejs坐标系与三角函数.md","1. threejs坐标系与三角函数","/pages/001888/"],["01.1. 数学几何计算基础/02.三维向量Vector3简介.md","2. 三维向量Vector3简介","/pages/b4b9bb/"],["01.1. 数学几何计算基础/03.向量大小(Vector3长度.length()).md","3. 向量大小(Vector3长度.length())","/pages/0a87db/"],["01.1. 数学几何计算基础/04.向量方向(归一化.normalize).md","4. 向量方向(归一化.normalize)","/pages/d69d76/"],["01.1. 数学几何计算基础/05.相机沿着视线方向运动.md","5. 相机沿着视线方向运动","/pages/a5e313/"],["01.1. 数学几何计算基础/06.箭头ArrowHelper.md","6. 箭头ArrowHelper","/pages/e24048/"]]},{title:"2.位移、速度、加速度(向量)",collapsable:!0,children:[["02.2.位移、速度、加速度(向量)/01.匀速动画(向量表示速度).md","1. 匀速动画(向量表示速度)","/pages/e3f92b/"],["02.2.位移、速度、加速度(向量)/02.物体下落动画(重力加速度).md","2. 物体下落动画(重力加速度)","/pages/27de57/"]]},{title:"3.向量点乘、叉乘",collapsable:!0,children:[["03.3.向量点乘、叉乘/01.向量点乘dot.md","1. 向量点乘dot","/pages/44b0ba/"],["03.3.向量点乘、叉乘/02.点乘练习-计算三角形夹角.md","2. 点乘练习-计算三角形夹角","/pages/acc4b8/"],["03.3.向量点乘、叉乘/03.点乘判断物体在人前或人后.md","3. 点乘判断物体在人前或人后","/pages/d32e58/"],["03.3.向量点乘、叉乘/04.点乘判断是否在扇形内.md","4. 点乘判断是否在扇形内","/pages/feb38e/"],["03.3.向量点乘、叉乘/05.向量叉乘cross.md","5. 向量叉乘cross","/pages/4558d6/"],["03.3.向量点乘、叉乘/06.叉乘判断人左右.md","6. 叉乘判断人左右","/pages/9babd7/"],["03.3.向量点乘、叉乘/07.点乘判断平行向量方向异同.md","7. 点乘判断平行向量方向异同","/pages/b03f77/"],["03.3.向量点乘、叉乘/08.判断两个点是否在线段同一侧.md","8. 判断两个点是否在线段同一侧","/pages/8da3bf/"],["03.3.向量点乘、叉乘/09.叉乘计算三角形法线.md","9. 叉乘计算三角形法线","/pages/d574b7/"],["03.3.向量点乘、叉乘/10.叉乘计算三角形面积.md","10. 叉乘计算三角形面积","/pages/03073e/"],["03.3.向量点乘、叉乘/11.练习—计算物体的表面积.md","11. 练习—计算物体的表面积","/pages/ab63ef/"],["03.3.向量点乘、叉乘/12.点到直线的距离.md","12. 点到直线的距离","/pages/1e8af7/"]]},{title:"4.四元数、欧拉角(角度姿态)",collapsable:!0,children:[["04.4.四元数、欧拉角(角度姿态)/01.欧拉角Euler.md","1. 欧拉角Euler","/pages/4b4a0b/"],["04.4.四元数、欧拉角(角度姿态)/02.四元数Quaternion.md","2. 四元数Quaternion","/pages/1fea5e/"],["04.4.四元数、欧拉角(角度姿态)/03.四元数表示物体姿态.md","3. 四元数表示物体姿态","/pages/44207d/"],["04.4.四元数、欧拉角(角度姿态)/04.四元数乘法运算.md","4. 四元数乘法运算","/pages/435568/"],["04.4.四元数、欧拉角(角度姿态)/05.四元数表示两个向量旋转.md","5. 四元数表示两个向量旋转","/pages/72cb3f/"]]},{title:"5.矩阵",collapsable:!0,children:[["05.5.矩阵/01.数学基础(平移、旋转、缩放矩阵).md","1. 数学基础(平移、旋转、缩放矩阵)","/pages/0be3f8/"],["05.5.矩阵/02.模型矩阵.md","2. 模型矩阵","/pages/f6ddf9/"],["05.5.矩阵/03.Three.js矩阵Matrix4.md","3. Three.js矩阵Matrix4","/pages/adcb9e/"],["05.5.矩阵/04.矩阵乘法multiply.md","4. 矩阵乘法multiply","/pages/6d4b1f/"],["05.5.矩阵/05.模型本地矩阵、世界矩阵.md","5. 模型本地矩阵、世界矩阵","/pages/c5b6bb/"],["05.5.矩阵/06.视图矩阵、投影矩阵.md","6. 视图矩阵、投影矩阵","/pages/bf26f8/"]]},{title:"6.射线",collapsable:!0,children:[["06.6.射线/01. 射线Ray(复习前面内容).md","1. 射线Ray(复习前面内容)","/pages/c1c0e7/"],["06.6.射线/02.射线拾取模型(复习前面).md","2. 射线拾取模型(复习前面)","/pages/bbc7ce/"]]},{title:"7.包围盒",collapsable:!0,children:[["07.7.包围盒/01.包围盒Box3(复习前面).md","1. 包围盒Box3(复习前面)","/pages/515d43/"]]},{title:"8.第一、三人称漫游",collapsable:!0,children:[["08.8.第一、三人称漫游/01.键盘WASD按键状态记录.md","1. 键盘WASD按键状态记录","/pages/bb25ee/"],["08.8.第一、三人称漫游/02.W键控制角色模型运动.md","2. W键控制角色模型运动","/pages/8d3d09/"],["08.8.第一、三人称漫游/03.加速度(按键给玩家加速).md","3. 加速度(按键给玩家加速)","/pages/e8e668/"],["08.8.第一、三人称漫游/04.阻尼(玩家角色逐渐减速停止).md","4. 阻尼(玩家角色逐渐减速停止)","/pages/24d3be/"],["08.8.第一、三人称漫游/05.按键S退后运动.md","5. 按键S退后运动","/pages/99cd6d/"],["08.8.第一、三人称漫游/06.相机跟着玩家走(第三人称漫游).md","6. 相机跟着玩家走(第三人称漫游)","/pages/7fe7e3/"],["08.8.第一、三人称漫游/07.鼠标左右拖动改变玩家视角.md","7. 鼠标左右拖动改变玩家视角","/pages/ef6fe2/"],["08.8.第一、三人称漫游/08.获取玩家(相机)正前方方向.md","8. 获取玩家(相机)正前方方向","/pages/c5d199/"],["08.8.第一、三人称漫游/09.鼠标上下移动只改变相机视角.md","9. 鼠标上下移动只改变相机视角","/pages/15d00d/"],["08.8.第一、三人称漫游/10.玩家角色左右运动(叉乘).md","10. 玩家角色左右运动(叉乘)","/pages/adb8cb/"],["08.8.第一、三人称漫游/11.鼠标滑动改变视角(指针锁定模式).md","11. 鼠标滑动改变视角(指针锁定模式)","/pages/920120/"],["08.8.第一、三人称漫游/12.快捷键切换第一、第三人称.md","12. 快捷键切换第一、第三人称","/pages/c9f808/"],["08.8.第一、三人称漫游/13.骨骼动画与运动状态关联.md","13. 骨骼动画与运动状态关联","/pages/dd3bfe/"]]},{title:"9.漫游-八叉树碰撞检测",collapsable:!0,children:[["09.9.漫游-八叉树碰撞检测/01.八叉树Octree扩展库介绍.md","1. 八叉树Octree扩展库介绍","/pages/db8906/"],["09.9.漫游-八叉树碰撞检测/02.八叉树与胶囊Capsule交叉计算.md","2. 八叉树与胶囊Capsule交叉计算","/pages/f92da6/"]]},{title:"10.CannonJS物理引擎",collapsable:!0,children:[["10.10.CannonJS物理引擎/01.物理引擎CannonJS简介和引入.md","1. 物理引擎CannonJS简介和引入","/pages/e48d3c/"],["10.10.CannonJS物理引擎/02.CannonJS自由落体计算.md","2. CannonJS自由落体计算","/pages/e80014/"],["10.10.CannonJS物理引擎/03.练习-threejs可视化cannon计算结果.md","3. 练习-threejs可视化cannon计算结果","/pages/eb4d49/"],["10.10.CannonJS物理引擎/04.CannonJS模拟乒乓球下落反弹.md","4. CannonJS模拟乒乓球下落反弹","/pages/ae695b/"],["10.10.CannonJS物理引擎/05.练习-修改小球参数.md","5. 练习-修改小球参数","/pages/ee7628/"],["10.10.CannonJS物理引擎/06.练习-点按钮重复下落.md","6. 练习-点按钮重复下落","/pages/a5ef46/"],["10.10.CannonJS物理引擎/07.CannonJS碰撞事件，碰撞声音.md","7. CannonJS碰撞事件，碰撞声音","/pages/4a6320/"],["10.10.CannonJS物理引擎/08.长方体Box碰撞体(箱子下落).md","8. 长方体Box碰撞体(箱子下落)","/pages/bcb959/"],["10.10.CannonJS物理引擎/09.练习题-外部gltf箱子模型.md","9. 练习题-外部gltf箱子模型","/pages/b646d4/"],["10.10.CannonJS物理引擎/10.凸多面体ConvexPolyhedron.md","10. 凸多面体ConvexPolyhedron","/pages/280f40/"]]}],"/03.Threejs Shader教程/":[{title:"1.threejs Shader基础语法",collapsable:!0,children:[["01.1.threejs Shader基础语法/01.学前说明.md","1. 学前说明","/pages/d30795/"],["01.1.threejs Shader基础语法/02.着色器GLSL ES语言(复习).md","2. 着色器GLSL ES语言(复习)","/pages/3b3f35/"],["01.1.threejs Shader基础语法/03.ShaderMaterial着色器材质.md","3. ShaderMaterial着色器材质","/pages/eb2fda/"],["01.1.threejs Shader基础语法/04.ShaderMaterial半透明、双面显示.md","4. ShaderMaterial半透明、双面显示","/pages/8142c3/"],["01.1.threejs Shader基础语法/05.uniform变量传值.md","5. uniform变量传值","/pages/2c9721/"],["01.1.threejs Shader基础语法/06.WebGL渲染管线.md","6. WebGL渲染管线","/pages/21c48e/"],["01.1.threejs Shader基础语法/07.片元屏幕坐标fragCoord.xy.md","7. 片元屏幕坐标fragCoord.xy","/pages/b109f4/"],["01.1.threejs Shader基础语法/08.顶点颜色varying插值计算.md","8. 顶点颜色varying插值计算","/pages/118412/"],["01.1.threejs Shader基础语法/09.顶点位置插值(实现渐变色).md","9. 顶点位置插值(实现渐变色)","/pages/64fa98/"],["01.1.threejs Shader基础语法/10.颜色贴图map(顶点UV坐标).md","10. 颜色贴图map(顶点UV坐标)","/pages/8db59b/"],["01.1.threejs Shader基础语法/11.shader模仿点材质效果.md","11. shader模仿点材质效果","/pages/964545/"],["01.1.threejs Shader基础语法/12.attribute自定义顶点变量.md","12. attribute自定义顶点变量","/pages/f74c6d/"]]},{title:"2.onBeforeCompile修改材质",collapsable:!0,children:[["02.2.onBeforeCompile修改材质/01.threejs材质的shader代码.md","1. threejs材质的shader代码","/pages/b7b8ff/"],["02.2.onBeforeCompile修改材质/02.onBeforeCompile修改材质shader.md","2. onBeforeCompile修改材质shader","/pages/4dd4b2/"],["02.2.onBeforeCompile修改材质/03.修改材质shader(彩色图变灰度图).md","3. 修改材质shader(彩色图变灰度图)","/pages/d163ed/"],["02.2.onBeforeCompile修改材质/04.顶点位置插值(设置片元颜色).md","4. 顶点位置插值(设置片元颜色)","/pages/a93f3a/"],["02.2.onBeforeCompile修改材质/05.顶点位置插值(设置片元颜色)2.md","5. 顶点位置插值(设置片元颜色)2","/pages/069520/"],["02.2.onBeforeCompile修改材质/06.模型扫光效果(顶点位置插值).md","6. 模型扫光效果(顶点位置插值)","/pages/e9f8fd/"],["02.2.onBeforeCompile修改材质/07.模型扫光效果(颜色渐变).md","7. 模型扫光效果(颜色渐变)","/pages/437645/"]]}],"/Blender教程/":[{title:"1.Blender入门基础",collapsable:!0,children:[["01.1.Blender入门基础/01.Blender入门基础.md","1. Blender入门基础","/pages/00cfc0/"],["01.1.Blender入门基础/02.Blender下载、安装、中文界面.md","2. Blender下载、安装、中文界面","/pages/1c4bb8/"],["01.1.Blender入门基础/03.基本操作：旋转、缩放、平移.md","3. 基本操作：旋转、缩放、平移","/pages/b66c23/"],["01.1.Blender入门基础/04.编辑、保存网格模型.md","4. 编辑、保存网格模型","/pages/73804e/"],["01.1.Blender入门基础/05.Blender导出gltf(与threejs协作).md","5. Blender导出gltf(与threejs协作)","/pages/a4ad16/"]]}],"/Threejs文章/":[["01.谈谈Three.js版本问题.md","谈谈Three.js版本问题","/pages/0fdf7b/"],["02.阅读Three.js源码.md","阅读Three.js源码","/pages/33b01c/"],["03.3D模型gltf下载网站(threejs开发).md","3D模型gltf下载网站(threejs开发)","/pages/c3ecc9/"],["04.three.js模拟显示屏模型播放视频.md","three.js模拟显示屏模型播放视频","/pages/6188ce/"]],"/Vue+Three.js 3D可视化/":[{title:"1.学前说明",collapsable:!0,children:[["01.1.学前说明/01.Vue+Three.js课程简介.md","1. Vue+Three.js课程简介","/pages/46aa7c/"]]},{title:"2.Vue+Three.js基础",collapsable:!0,children:[["02.2.Vue+Three.js基础/01.Vite搭建Vue 3D开发环境.md","1. Vite搭建Vue 3D开发环境","/pages/a837c2/"]]}],"/WebGL教程/":[{title:"1.WebGL快速入门",collapsable:!0,children:[["01.1.WebGL快速入门/01.WebGL学前说明.md","1. WebGL学前说明","/pages/9bc0db/"],["01.1.WebGL快速入门/02.着色器GLSL ES语言.md","2. 着色器GLSL ES语言","/pages/409d6c/"],["01.1.WebGL快速入门/03.第一个WebGL案例.md","3. 第一个WebGL案例","/pages/f66004/"]]},{title:"2.3D几何变换数学基础",collapsable:!0,children:[["02.2.3D几何变换数学基础/01.数学基础(平移、旋转、缩放矩阵).md","1. 数学基础(平移、旋转、缩放矩阵)","/pages/1dd7e1/"],["02.2.3D几何变换数学基础/02.模型矩阵.md","2. 模型矩阵","/pages/d6fb6c/"],["02.2.3D几何变换数学基础/03.gl-matrix数学计算库.md","3. gl-matrix数学计算库","/pages/7d74bf/"]]}],"/WebGPU教程/":[{title:"1.WebGPU快速入门",collapsable:!0,children:[["01.1.WebGPU快速入门/01.WebGPU学习开发环境配置.md","1. WebGPU学习开发环境配置","/pages/9bbfa9/"],["01.1.WebGPU快速入门/02.WebGPU API和Canvas画布.md","2. WebGPU API和Canvas画布","/pages/a4735b/"],["01.1.WebGPU快速入门/03.创建顶点缓冲区、渲染管线.md","3. 创建顶点缓冲区、渲染管线","/pages/359922/"],["01.1.WebGPU快速入门/04.着色器语言WGSL快速了解.md","4. 着色器语言WGSL快速了解","/pages/d5968c/"],["01.1.WebGPU快速入门/05.顶点着色器.md","5. 顶点着色器","/pages/55f573/"],["01.1.WebGPU快速入门/06.片元着色器、图元装配.md","6. 片元着色器、图元装配","/pages/7be6ce/"],["01.1.WebGPU快速入门/07.渲染命令(至此完成第一个案例).md","7. 渲染命令(至此完成第一个案例)","/pages/6d5d59/"],["01.1.WebGPU快速入门/08.WebGPU 3D坐标系(投影).md","8. WebGPU 3D坐标系(投影)","/pages/ff1bbf/"],["01.1.WebGPU快速入门/09.三角形拼接矩形.md","9. 三角形拼接矩形","/pages/c033a7/"]]},{title:"2. 3D几何变换数学基础",collapsable:!0,children:[["02.2. 3D几何变换数学基础/01.数学基础(平移、旋转、缩放矩阵).md","1. 数学基础(平移、旋转、缩放矩阵)","/pages/38777d/"],["02.2. 3D几何变换数学基础/02.模型矩阵.md","2. 模型矩阵","/pages/47d092/"],["02.2. 3D几何变换数学基础/03.gl-matrix数学计算库.md","3. gl-matrix数学计算库","/pages/473326/"],["02.2. 3D几何变换数学基础/04.顶点着色器矩阵变换.md","4. 顶点着色器矩阵变换","/pages/17d42c/"],["02.2. 3D几何变换数学基础/05.WebGPU传递uniform数据.md","5. WebGPU传递uniform数据","/pages/a1aa0e/"],["02.2. 3D几何变换数学基础/06.gl-matrix生成顶点着色器的矩阵.md","6. gl-matrix生成顶点着色器的矩阵","/pages/d69ed5/"],["02.2. 3D几何变换数学基础/07.WebGPU动画(uniform旋转矩阵).md","7. WebGPU动画(uniform旋转矩阵)","/pages/e69b13/"],["02.2. 3D几何变换数学基础/08.绕y轴旋转动画.md","8. 绕y轴旋转动画","/pages/df319e/"],["02.2. 3D几何变换数学基础/09.片元的屏幕坐标.md","9. 片元的屏幕坐标","/pages/e2c95a/"],["02.2. 3D几何变换数学基础/10.片元深度值、深度缓冲区.md","10. 片元深度值、深度缓冲区","/pages/aac7f7/"],["02.2. 3D几何变换数学基础/11.WebGPU顶点数据插值计算.md","11. WebGPU顶点数据插值计算","/pages/0149ac/"],["02.2. 3D几何变换数学基础/12.练习—顶点位置插值.md","12. 练习—顶点位置插值","/pages/0c6955/"],["02.2. 3D几何变换数学基础/13.顶点颜色数据插值计算.md","13. 顶点颜色数据插值计算","/pages/3d0f41/"],["02.2. 3D几何变换数学基础/14.顶点位置、颜色数据共享缓冲区.md","14. 顶点位置、颜色数据共享缓冲区","/pages/3a2ff2/"],["02.2. 3D几何变换数学基础/15.练习-顶点颜色.md","15. 练习-顶点颜色","/pages/299242/"],["02.2. 3D几何变换数学基础/16.结构体作为WGLSL函数参数.md","16. 结构体作为WGLSL函数参数","/pages/8918c1/"]]}]},updateBar:{showToArticle:!1},pageStyle:"line",category:!1,tag:!1,author:{name:"郭隆邦",href:"https://space.bilibili.com/47762042?spm_id_from=333.788.0.0"},social:{},footer:{createYear:2016,copyrightInfo:'<a href="https://beian.miit.gov.cn/">豫ICP备16004767号-2</a>'},htmlModules:{sidebarT:'<a style="font-size: 1.3rem;" href="https://study.163.com/course/courseMain.htm?courseId=1212760820&share=2&shareId=400000000594054" target="_blank">Web3D系统课程视频</a>'}}};var xl=t(94),wl=t(95),jl=t(11);var Tl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(jl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(jl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(jl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,a=n.length;r<a;r++){const{frontmatter:{categories:a,tags:o}}=n[r];"array"===Object(jl.n)(a)&&a.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(jl.n)(o)&&o.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Nt.component(xl.default),Nt.component(wl.default);function Bl(n){return n.toString().padStart(2,"0")}t(243);Nt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,625))),Nt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94))),Nt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95)));t(244);var Al=[({Vue:n,options:e,router:t,siteData:r,isServer:a})=>{a||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://fastly.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".page-wwads");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Bl(n.getUTCMonth()+1)}-${Bl(n.getUTCDate())} ${Bl(n.getUTCHours())}:${Bl(n.getUTCMinutes())}:${Bl(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(Tl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?01293bffa6c3962016c08ba685c79d78";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],Sl=[];class zl extends class{constructor(){this.store=new Nt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Nt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(zl.prototype,{getPageAsyncComponent:si,getLayoutAsyncComponent:ii,getAsyncComponent:li,getVueComponent:ci});var Cl={install(n){const e=new zl;n.$vuepress=e,n.prototype.$vuepress=e}};function Pl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var kl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return hi("pageKey",e),Nt.component(e)||Nt.component(e,si(e)),Nt.component(e)?n(e):n("")}},Il={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Ml={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Rl=(t(245),t(246),Object(vl.a)(Ml,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ll={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Nt.config.productionTip=!1,Nt.use(Vs),Nt.use(Cl),Nt.mixin(function(n,e,t=Nt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},yl)),Nt.component("Content",kl),Nt.component("ContentSlotsDistributor",Il),Nt.component("OutboundLink",Rl),Nt.component("ClientOnly",Ll),Nt.component("Layout",ii("Layout")),Nt.component("NotFound",ii("NotFound")),Nt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:""},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:yl.routerBase||yl.base,t=new Vs({base:e,mode:"history",fallback:!1,routes:El,scrollBehavior:(n,e,t)=>t||(n.hash?!Nt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Pl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Pl(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";Pl(n,a)?r(a):Pl(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Al.filter(n=>"function"==typeof n).map(e=>e({Vue:Nt,options:r,router:t,siteData:yl,isServer:n})))}catch(n){console.error(n)}return{app:new Nt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Sl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);